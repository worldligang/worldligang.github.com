
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
      <meta name="baidu-site-verification" content="X93tJz3pCq" />
  <title>刚刚在线</title>
  <meta name="author" content="李刚">
  <meta name="uyan_auth" content="d1112891bb" />
  <meta name="baidu-tc-verification" content="7acda2305fabbf1ddd9f83e385ddd899" />
      
  
  <meta name="description" content="2年iOS开发站长，优秀iOS开发博客之一。关注iOS开发、swift开发、iOSDevTip、移动互联网、自媒体、Cocoapods、Xcode、iOS，刚刚在线博客是一个值得收藏的网站！">
  <meta name="keywords" content="iOS,iOS开发,cocoapods,code,iOS代码, 源代码, 刚刚在线,iOS李刚, pointInside, 刚刚, hitTest, Objective-c,李刚博客">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.superqq.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="刚刚在线" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->


  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">刚刚在线</a></h1>
  
    <h2>关注iOS开发和移动互联网的自媒体博客</h2>
  
</hgroup>

<!--广告位-->
<dic class="flashnews">
    <script type="text/javascript">
        /*960*60 创建于 2015-06-13*/
        var cpro_id = "u2154036";
        </script>
    <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
    </div>
<!--广告链接结束--></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://zhannei.superqq.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.superqq.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">全部文章</a></li>
  <li><a href="/blog/categories/ioskai-fa/">iOS开发</a></li>
  <li><a href="/blog/categories/swiftkai-fa">swift开发</a></li>
  <li><a href="/blog/categories/cheng-xu-yuan/">程序员</a></li>
  <li><a href="/blog/categories/yuan-dai-ma/">源代码</a></li>
  <li><a href="/blog/categories/sdkfu-wu/">sdk服务</a></li>
  <li><a href="/blog/categories/tui-jian/">推荐</a></li>
  <li><a href="/about">赞助作者</a></li>
  <li><a href="http://www.90159.com/" target="_blank" title=头条>头条</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/31/aktabbarcontroller-similar-to-wechat-library/">AKTabBarController：类似微信的第三方库</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-31T00:28:53+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>12:28 am</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><p>自从有了评论之后，就可以很方便的和大家交流。以前都是我一个人默默的发文章，看不出大家对文章的看法。评论开通之后，就可以很快速的获取大家对文章的看法。</p>

<p>有人会指出文章里有错误的地方，真的很感激他们，非常的认真；有人会对文章说出自己的见解，加深自己的印象，同时，也能帮助到其他的朋友；有人也会在评论里，提出一些问题，但是鉴于评论的字数限制，只能简单的回答一下。</p>

<p>在昨天的文章评论里面，有一个朋友提出了一个问题，关于微信导航栏的。</p>

<h2>问题分析和解答</h2>

<p><strong>问：</strong></p>

<pre><code>自定义导航栏怎么写？就像微信那样，tabBar的四个界面切换导航栏都不变化
</code></pre>

<p><strong>答：</strong></p>

<pre><code>github上搜索AKTabBarController
</code></pre>

<p>其实，这位朋友的问题不是关于自定义导航栏，我觉得他可能是想问微信底部的<code>TabBar</code>和导航结合使用是如何实现的。</p>

<p>记得之前在github看到过有一个类似微信的框架（算不上框架，我们就这么简单的叫一下）。就是<a href="https://github.com/alikaragoz/AKTabBarController">AKTabBarController</a>。</p>

<p><code>AKTabBarController</code>是一个非常不错的第三方。在github上有663个<code>star</code>，使用方法也不是很复杂，下面我们简单的看一下。</p>

<h2>如何导入到项目中</h2>

<p><code>AKTabBarController</code>是支持<a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods</a>导入的。想理解CocoaPods的请点击：<a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods安装和使用教程</a>。在你的Podfile文件中加入：</p>

<pre><code>platform :ios

pod 'AKTabBarController'
</code></pre>

<p>添加成功之后，在终端执行：</p>

<pre><code>pod install 
</code></pre>

<h2>如何使用AKTabBarController</h2>

<p>安装成功之后，在你想用的地方导入头文件：</p>

<pre><code>#import "AKTabBarController.h"
</code></pre>

<p>然后，创建<code>tabBar</code></p>

<pre><code>// Create and initialize the height of the tab bar to 50px.
_tabBarController = [[AKTabBarController alloc] initWithTabBarHeight:50];

// Create and initialize with specific height and position atop the view controller
_tabBarController = [[AKTabBarController alloc] initWithTabBarHeight:50 position:AKTabBarPositionTop];

// Adding the view controllers to manage.
[_tabBarController setViewControllers:@[[[FirstViewController alloc] init], [[SecondViewController alloc] init], [[ThirdViewController alloc] init], [[FourthViewController alloc] init]]]];  
</code></pre>

<p>关于更多AKTabBarController的用法，请访问：**<a href="https://github.com/alikaragoz/AKTabBarController**">https://github.com/alikaragoz/AKTabBarController**</a></p>

<h2>功能简介</h2>

<pre><code>• 自适应竖屏和横屏模式，tab 上的图标会根据竖屏和横屏模式自动缩放大小以适应tab的高度。

• 自定义 tab bar 的高度；

• 当进入下个视图时，可以自动隐藏tab bar；

• 可以只显示图片，而不显示文字；并且当 tab bar 的高度太小时，可以自动缩放图片以及隐藏文字；

• 只需要一张图片来表示 tab 被选择和非选择模式。即tab 被选中时的高光是用CoreGraphics绘制的，不需要额外的图片。

• 选择不同 tab 时的动画切换效果用的是淡入淡出（cross fade）的效果. 

• 支持预渲染图像

• 支持设置tabBar字体。
</code></pre>

<h2>实际效果</h2>

<p>最终实现的效果如下所示：</p>

<p><img src="https://github.com/alikaragoz/AKTabBarController/raw/master/Screenshots/iphone-portrait.png" alt="1" /></p>

<p>这里只是简单的讲解一下。大家闲的时候，如果有兴趣的话，可以自己动手来熟练关于<code>AKTabBarController</code>更多的功能。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/30/six-tips-on-navigation-bar/">关于导航栏的六个小技巧</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-30T00:13:43+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:13 am</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><p><code>UINavigationBar</code>和<code>UINavigationItem</code>是iOS开发中常用的控件。今天给大家介绍一下六个关于导航栏的小技巧。</p>

<h2>1.设置导航栏标题</h2>

<pre><code>self.title = @"iOS开发：iOSDevTip";
</code></pre>

<h2>2.设置导航栏样式</h2>

<p>设置方法：</p>

<pre><code>[self.navigationController.navigationBar setBarStyle:UIBarStyleBlack];
</code></pre>

<p><code>UIBarStyle</code>的样式：</p>

<pre><code>typedef NS_ENUM(NSInteger, UIBarStyle) {
    UIBarStyleDefault          = 0,
    UIBarStyleBlack            = 1,

    UIBarStyleBlackOpaque      = 1, // Deprecated. Use UIBarStyleBlack
    UIBarStyleBlackTranslucent = 2, // Deprecated. Use UIBarStyleBlack and set the translucent property to YES
};
</code></pre>

<p><code>UIBarStyleDefault</code>是默认样式，<code>UIBarStyleBlack</code>是黑色不透明。<code>UIBarStyleBlackOpaque</code>和<code>UIBarStyleBlackTranslucent</code>这两个已经废弃了。</p>

<p>如果想设置导航栏透明，可以加上下面这句代码：</p>

<pre><code>self.navigationController.navigationBar.translucent = YES;
</code></pre>

<h2>3.修改返回按钮title</h2>

<pre><code>self.navigationItem.title = @"test";
</code></pre>

<h2>4.隐藏返回按钮title</h2>

<p>比较笨的方法是：</p>

<pre><code>self.navigationItem.title = @"";
</code></pre>

<p>还可以这样设置：</p>

<pre><code>[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60) forBarMetrics:UIBarMetricsDefault];
</code></pre>

<h2>5.设置leftBarButtonItem</h2>

<pre><code>self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"back" style:UIBarButtonItemStylePlain target:self action:@selector(back:)];

- (void)back:(id)sender
{
    [self.navigationController popViewControllerAnimated:YES];
}
</code></pre>

<h2>6.左滑返回手势失效了怎么办</h2>

<p>如果按上一步设置<code>leftBarButtonItem</code>之后，左滑返回手势就会失效。设置一下<code>UIGestureRecognizerDelegate</code>代理即可：</p>

<pre><code>self.navigationController.interactivePopGestureRecognizer.delegate = self;
</code></pre>

<p>以上是六个关于导航栏的小技巧。更多iOS开发相关的技术，请关注我的微信公众号iOS开发：<strong>iOSDevTip</strong></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/29/uiimage-geometric-zoom/">iOS开发之UIImage等比缩放</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-29T00:01:15+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:01 am</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><h2>评论功能真不错</h2>

<p>评论开通后，果然有很多人吐槽。谢谢大家的支持和关爱，如果有做的不到的地方，还请海涵。毕竟我一个人的力量是有限的，我会尽自己最大的努力大家准备一些干货。</p>

<p>有些内容可能都是比较基础的，记住：不积跬步无以至千里，不积小流无以成江海。我想这个道理大家都懂，在为大家准备文章的过程中，对我来说也是一次学习成长。</p>

<p>大家可以继续吐槽！微信的评论就是一个沟通的渠道，也是一篇文章的延续。你也可以在评论中写一些你对iOS开发的见解，说不定就会对他人有帮助。</p>

<p>很高兴，已经有好几位iOS开发的朋友答应以后会写文章投稿给我。在这里，我再强调一下：如果你有好的技术文章一定要投稿给我噢！投稿邮箱：</p>

<pre><code>worldligang@163.com
</code></pre>

<p>前面讲了<a href="http://www.superqq.com/blog/2015/07/26/jie-qu-uiimagezhi-ding-da-xiao-qu-yu/">截取UIImage指定大小区域</a>，很方便的截取<code>UIImage</code>。今天要和大家分享的是<code>UIImage</code>的缩放。</p>

<p>两种缩放:</p>

<ol>
<li>缩放到指定大小，也就是指定的<code>size</code>.</li>
<li>等比缩放。</li>
</ol>


<h2>缩放到指定大小</h2>

<pre><code>- (UIImage*)imageCompressWithSimple:(UIImage*)image scaledToSize:(CGSize)size
{
    UIGraphicsBeginImageContext(size);
    [image drawInRect:CGRectMake(0,0,size.width,size.height)];
    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
</code></pre>

<h2>等比缩放</h2>

<h3>通过缩放系数</h3>

<pre><code>- (UIImage*)imageCompressWithSimple:(UIImage*)image scale:(float)scale
{
    CGSize size = image.size;
    CGFloat width = size.width;
    CGFloat height = size.height;
    CGFloat scaledWidth = width * scale;
    CGFloat scaledHeight = height * scale;
    UIGraphicsBeginImageContext(size); // this will crop
    [image drawInRect:CGRectMake(0,0,scaledWidth,scaledHeight)];
    UIImage* newImage= UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
</code></pre>

<p><code>scale</code>是缩放系数  。</p>

<h3>通过计算得到缩放系数</h3>

<pre><code>- (UIImage*)imageByScalingAndCroppingForSize:(CGSize)targetSize
{

    UIImage *sourceImage = [UIImage imageNamed:@"test.jpg"];
    UIImage *newImage = nil;
    CGSize imageSize = sourceImage.size;
    CGFloat width = imageSize.width;
    CGFloat height = imageSize.height;
    CGFloat targetWidth = targetSize.width;
    CGFloat targetHeight = targetSize.height;
    CGFloat scaleFactor = 0.0;
    CGFloat scaledWidth = targetWidth;
    CGFloat scaledHeight = targetHeight;
    CGPoint thumbnailPoint = CGPointMake(0.0,0.0);

    if (CGSizeEqualToSize(imageSize, targetSize) == NO)
    {
        CGFloat widthFactor = targetWidth / width;
        CGFloat heightFactor = targetHeight / height;
        if (widthFactor &gt; heightFactor)
            scaleFactor = widthFactor; // scale to fit height
        else
            scaleFactor = heightFactor; // scale to fit width

        scaledWidth= width * scaleFactor;
        scaledHeight = height * scaleFactor;
        // center the image
        if (widthFactor &gt; heightFactor)
        {
            thumbnailPoint.y = (targetHeight - scaledHeight) * 0.5;
        }
        else if (widthFactor &lt; heightFactor)
        {
            thumbnailPoint.x = (targetWidth - scaledWidth) * 0.5;
        }
    }

    UIGraphicsBeginImageContext(targetSize); // this will crop
    CGRect thumbnailRect = CGRectZero;
    thumbnailRect.origin = thumbnailPoint;
    thumbnailRect.size.width= scaledWidth;
    thumbnailRect.size.height = scaledHeight;
    [sourceImage drawInRect:thumbnailRect];
    newImage = UIGraphicsGetImageFromCurrentImageContext();

    if(newImage == nil)
        NSLog(@"could not scale image");
    //pop the context to get back to the default
    UIGraphicsEndImageContext();

    return newImage;

}
</code></pre>

<p>很久之前写了一篇文章<a href="http://www.superqq.com/blog/2015/01/22/jie-jue-mwphotobrowserzhong-de-sdwebimagejia-zai-da-tu-dao-zhi-de-nei-cun-jing-gao-wen-ti/">解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题</a>。这个我记得当时从服务器拿到的照片大概有10几M的样子，加载出来会导致内存警告。所以我当时通过修改SDWebImage源码，就是把下载下来的照片进行缩放，内存就降下来了。一般情况下应该不会加载这么大的照片的，用户要是知道，早把你的APP给删掉了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/28/swift-alamofire/">著名的AFNetworking网络基础库Swift版Alamofire</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-28T20:42:52+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>8:42 pm</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://github.com/Alamofire/Alamofire" target="_blank" title=“源代码”>源代码</a></p>

<p><img src="http://swiftmi.qiniudn.com/codeimage/201409/13_1410874399080_89.gif" alt="swift-gif" /></p>

<h2>Swift Alamofire 简介</h2>

<p><img src="https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png" alt="Alamofire: Elegant Networking in Swift" /></p>

<p>Alamofire是 Swift 语言的 HTTP 网络开发工具包,相当于Swift实现<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">AFNetworking</a>版本。</p>

<p>当然,AFNetworking非常稳定,在Mac OSX与iOS中也能像其他Objective-C代码一样用Swift编写。不过Alamofire更适合Swift语言风格习惯(Alamofire与AFNetworking可以共存一个项目中,互不影响).</p>

<pre><code>Alamofire 取名来源于 [Alamo Fire flower](https://aggie-horticulture.tamu.edu/wildseed/alamofire.html)
</code></pre>

<h2>Alamofire安装使用方法</h2>

<p>使用CocoaPods安装，在podfile</p>

<pre><code>source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', '~&gt; 1.2'
</code></pre>

<p>submodule 方式安装</p>

<pre><code>$ git submodule add https://github.com/Alamofire/Alamofire.git
</code></pre>

<h2>环境要求</h2>

<p>Xcode 6</p>

<p>iOS 7.0+ / Mac OS X 10.9+</p>

<h2>Alamofire使用方法</h2>

<h3>GET 请求</h3>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get")
</code></pre>

<p>带参数</p>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
</code></pre>

<p>Response结果处理</p>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .response { (request, response, data, error) in
                     println(request)
                     println(response)
                     println(error)
                   }
</code></pre>

<p>Response结果字符串处理</p>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .responseString { (request, response, string, error) in
                  println(string)
         }
</code></pre>

<h2>HTTP 方法（Medthods）</h2>

<p>Alamofire.Method enum 列表出在RFC 2616中定义的HTTP方法 §9:</p>

<pre><code>public enum Method: String {
    case OPTIONS = "OPTIONS"
    case GET = "GET"
    case HEAD = "HEAD"
    case POST = "POST"
    case PUT = "PUT"
    case PATCH = "PATCH"
    case DELETE = "DELETE"
    case TRACE = "TRACE"
    case CONNECT = "CONNECT"
}
</code></pre>

<p>这些值可以作为Alamofire.request请求的第一个参数.</p>

<pre><code>Alamofire.request(.POST, "http://httpbin.org/post")

Alamofire.request(.PUT, "http://httpbin.org/put")

Alamofire.request(.DELETE, "http://httpbin.org/delete")
</code></pre>

<p>POST请求</p>

<pre><code>let parameters = [
    "foo": "bar",
    "baz": ["a", 1],
    "qux": [
        "x": 1,
        "y": 2,
        "z": 3
    ]
]

Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters)
</code></pre>

<p>发送以下HttpBody内容:</p>

<pre><code>foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3
</code></pre>

<p>Alamofire 使用Alamofire.ParameterEncoding可以支持URL query/URI form,JSON, PropertyList方式编码参数。</p>

<p>Parameter Encoding</p>

<pre><code>enum ParameterEncoding {
    case URL
    case JSON(options: NSJSONWritingOptions)
    case PropertyList(format: NSPropertyListFormat,
                      options: NSPropertyListWriteOptions)

    func encode(request: NSURLRequest,
                parameters: [String: AnyObject]?) -&gt;
                    (NSURLRequest, NSError?)
    { ... }
}
</code></pre>

<p>NSURLRequest方式编码参数</p>

<pre><code>let URL = NSURL(string: "http://httpbin.org/get")
var request = NSURLRequest(URL: URL)

let parameters = ["foo": "bar"]
let encoding = Alamofire.ParameterEncoding.URL
(request, _) = encoding.encode(request, parameters)
</code></pre>

<p>POST JSON格式数据</p>

<pre><code>Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters, encoding: .JSON(options: nil))
         .responseJSON {(request, response, JSON, error) in
            println(JSON)
     }
</code></pre>

<p>Response 方法</p>

<pre><code>response()
responseString(encoding: NSStringEncoding)
responseJSON(options: NSJSONReadingOptions)
responsePropertyList(options: NSPropertyListReadOptions)
</code></pre>

<h3>上传（Uploading）</h3>

<p>支持的类型</p>

<pre><code>File
Data
Stream
Multipart (Coming Soon)
</code></pre>

<p>上传文件</p>

<pre><code>let fileURL = NSBundle.mainBundle()
                  .URLForResource("Default",
                                  withExtension: "png")

Alamofire.upload(.POST, "http://httpbin.org/post", file: fileURL)
</code></pre>

<h3>上传进度</h3>

<pre><code>Alamofire.upload(.POST, "http://httpbin.org/post", file: fileURL)
    .progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in
        println(totalBytesWritten)
    }
    .responseJSON { (request, response, JSON, error) in
        println(JSON)
    }
</code></pre>

<h3>下载</h3>

<p>支持的类型</p>

<pre><code>Request
Resume Data
</code></pre>

<p>下载文件</p>

<pre><code>Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: { (temporaryURL, response) in
    if let directoryURL = NSFileManager.defaultManager()
                          .URLsForDirectory(.DocumentDirectory,
                                            inDomains: .UserDomainMask)[0]
                          as? NSURL {
        let pathComponent = response.suggestedFilename

        return directoryURL.URLByAppendingPathComponent(pathComponent)
    }

    return temporaryURL
})
</code></pre>

<p>下载到默认路径</p>

<pre><code>let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)

Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
</code></pre>

<p>下载进度</p>

<pre><code>Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
         .progress { (bytesRead, totalBytesRead, totalBytesExpectedToRead) in
             println(totalBytesRead)
         }
         .response { (request, response, _, error) in
             println(response)
         }
</code></pre>

<h3>认证（Authentication）</h3>

<p>支持以下几种认证</p>

<pre><code>HTTP Basic
HTTP Digest
Kerberos
NTLM
</code></pre>

<p>Http basic认证</p>

<pre><code>let user = "user"
let password = "password"

Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
    .authenticate(HTTPBasic: user, password: password)
    .response {(request, response, _, error) in
        println(response)
        }
</code></pre>

<p>采用NSURLCredential&amp;NSURLProtectionSpace方式认证</p>

<pre><code>let user = "user"
let password = "password"

let credential = NSURLCredential(user: user, password: password, persistence: .ForSession)
let protectionSpace = NSURLProtectionSpace(host: "httpbin.org", port: 0, `protocol`: "https", realm: nil, authenticationMethod: NSURLAuthenticationMethodHTTPBasic)



Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
    .authenticate(usingCredential: credential, forProtectionSpace: protectionSpace)
    .response {(request, response, _, error) in
        println(response)
}
</code></pre>

<h3>Printable</h3>

<pre><code>let request = Alamofire.request(.GET, "http://httpbin.org/ip")

println(request)
// GET http://httpbin.org/ip (200)
</code></pre>

<h3>调试</h3>

<pre><code>let request = Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])

debugPrintln(request)
</code></pre>

<h3>Output (cURL)</h3>

<pre><code>$ curl -i \
    -H "User-Agent: Alamofire" \
    -H "Accept-Encoding: Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
    -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
    "http://httpbin.org/get?foo=bar"
</code></pre>

<p>更多的用法将会在接口文档中一一列出,敬请期待。</p>

<p>Alamofire与AFNetworking是同一个作者</p>

<blockquote><p>作者李刚是刚刚在线（www.superqq.com）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://upload-images.jianshu.io/upload_images/624136-963198258f95cc10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOSDevTip" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/28/four-create-uiimage-method/">五种创建UIImage的类方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-28T01:08:30+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:08 am</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><h3>iOS开发已开通评论功能</h3>

<p>皇天不负有心人，iOS开发的评论功能已经被邀请开通啦。这几天一直想着，微信团队大概在月底的时候会邀请我开通评论功能。果然不出我所料。这是我收到的消息：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/weixincomment.png" alt="weixincomment.png" /></p>

<p>至此，iOS开发的原创、赞赏、评论三个功能都齐啦，这也是对我辛苦努力的一种肯定。前方的路依然很漫长，我们一起努力，让iOS开发变得更好。</p>

<p>既然评论功能已经开通，大家也别闲着啦！今天的文章大家一起尽情的吐槽吧！</p>

<p><code>UIImage</code>有五个类方法，用来创建<code>UIImage</code>的。下面介绍一下每个类方法的作用和创建实例。</p>

<h3>1.使用类方法<code>imageNamed:</code>创建</h3>

<pre><code>+ (UIImage *)imageNamed:(NSString *)name;      // load from main bundle      
</code></pre>

<p><code>name</code>是照片名称。创建UIImage对象，代码如下：</p>

<pre><code>UIImage *image = [UIImage imageNamed:@"ganggang"];   
</code></pre>

<p>使用<code>imageNamed:</code>初始化的时候，会先检查缓存中是否存在<code>ganggang</code>的照片，如不存在，图片首先会被缓存起来，然后才返回要加载的图片对象；如果存在，直接返回要加载的照片对象。</p>

<h3>2.使用类方法<code>imageWithContentsOfFile:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithContentsOfFile:(NSString *)path;
</code></pre>

<p><code>path</code>是需要加载照片的路径，如何获取照片的路径请点击<a href="http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing/">iOS开发之获取沙盒路径</a>。实现代码如下：</p>

<pre><code>UIImage *image = [UIImage imageWithContentsOfFile:path];   
</code></pre>

<p>使用<code>imageWithContentsOfFile:</code>创建<code>UIImage</code>的时候，是直接从磁盘上加载。当收到内存警告时，<code>UIImage</code>对象会被释放，下一次绘图的时候，需要重新加载。</p>

<h3>3.使用类方法<code>imageWithData:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithData:(NSData *)data;
</code></pre>

<p><code>data</code>是照片数据，一般是请求返回的，然后通过<code>imageWithData:</code>创建<code>UIImage</code>。实现代码如下所示：</p>

<pre><code>NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@"http://www.superqq.com/images/getqrcode.jpg"]];
UIImage *image =[UIImage imageWithData:data]; 
</code></pre>

<h3>4.使用类方法<code>imageWithCGImage:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage;
</code></pre>

<p><code>cgImage</code>是定义在QuartzCore框架中的一个结构体指针。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。</p>

<pre><code>UIImage *image = [UIImage imageWithCGImage:cgImage];   
</code></pre>

<h3>5.使用类方法<code>imageWithCIImage:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithCIImage:(CIImage *)ciImage NS_AVAILABLE_IOS(5_0);
</code></pre>

<p><code>CIImage</code>是<code>CoreImage</code>框架中最基本代表图像的对象，在<code>CIImage</code>被<code>CIContext</code>渲染出来之前，他是依赖于滤镜链的，滤镜是不会更改<code>CIImage</code>中的图像数据。</p>

<pre><code> UIImage *image = [UIImage imageWithCGImage:ciImage];   
</code></pre>

<p>以上四种方法都是<code>UIImage</code>的类方法，使用<code>UIImage</code>的初始化方法也是可以创建<code>UIImage</code>对象的大家可以进<code>UIImage</code>详细了解一下。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/27/ioskai-fa-zhi-layoutsubviewsde-zuo-yong-he-diao-yong-ji-zhi/">iOS开发之layoutSubviews的作用和调用机制</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-27T13:57:27+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:57 pm</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><p>在UIView里面有一个方法<code>layoutSubviews</code>，这个方法具体作用是什么呢？</p>

<pre><code>- (void)layoutSubviews;    // override point. called by layoutIfNeeded automatically. As of iOS 6.0, when constraints-based layout is used the base implementation applies the constraints-based layout, otherwise it does nothing.
</code></pre>

<h2>官方文档解释</h2>

<p>我们先来看看苹果官方文档的解释：</p>

<pre><code>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.

Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.

You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.
</code></pre>

<p>最后一段说，不要直接调用此方法。如果你想强制更新布局，你可以调用<code>setNeedsLayout</code>方法；如果你想立即数显你的<code>views</code>，你需要调用<code>layoutIfNeeded</code>方法。</p>

<h2>layoutSubviews作用</h2>

<p><code>layoutSubviews</code>是对<code>subviews</code>重新布局。比如，我们想更新子视图的位置的时候，可以通过调用<code>layoutSubviews</code>方法，既可以实现对子视图重新布局。</p>

<p><code>layoutSubviews</code>默认是不做任何事情的，用到的时候，需要在自雷进行重写。</p>

<h2>layoutSubviews以下情况会被调用</h2>

<p>苹果官方文档已经强调，不能直接调用<code>layoutSubviews</code>对子视图进行重新布局。那么，<code>layoutSubviews</code>什么情况下会被调用呢？通过百度搜索，发现以下几种情况<code>layoutSubviews</code>会被调用。</p>

<ol>
<li>直接调用<code>setLayoutSubviews</code>。（这个在上面苹果官方文档里有说明）</li>
<li><code>addSubview</code>的时候。</li>
<li>当<code>view</code>的<code>frame</code>发生改变的时候。</li>
<li>滑动<code>UIScrollView</code>的时候。</li>
<li>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>
<li>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>
</ol>


<p>我简单测试了一下，上面基本都会被调用。 注意：</p>

<pre><code>当view的fram的值为0的时候，`addSubview`也不会调用`layoutSubviews`的。
</code></pre>

<p><code>layoutSubviews</code>方法在对自雷视图进行布局的时候非常方便。可以自己动手，深入理解<code>layoutSubviews</code>的调用机制。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/26/jie-qu-uiimagezhi-ding-da-xiao-qu-yu/">截取UIImage指定大小区域</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-26T10:07:58+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:07 am</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><p>最近遇到这样的需求：从服务器获取到一张照片，只需要显示他的左半部分，或者中间部分等等。也就是截取UIImage指定大小区域。</p>

<h2>UIImage扩展</h2>

<p>我的解决方案是对<code>UIImage</code>进行扩展。通过<code>CGImageRef</code>和<code>CGImage</code>完成截取，调用的方法是：<code>CGImageCreateWithImageInRect</code>。扩展类叫<code>UIImage+Crop</code>，具体代码如下：</p>

<h3>UIImage+Crop.h</h3>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

typedef NS_ENUM(NSInteger, XYCropImageStyle){
    XYCropImageStyleRight               =0,      // 右半部分
    XYCropImageStyleCenter              =1,      // 中间部分
    XYCropImageStyleLeft                =2,      // 左半部分
    XYCropImageStyleRightOneOfThird     =3,      // 右侧三分之一部分
    XYCropImageStyleCenterOneOfThird    =4,      // 中间三分之一部分
    XYCropImageStyleLeftOneOfThird      =5,      // 左侧三分之一部分
    XYCropImageStyleRightQuarter        =6,      // 右侧四分之一部分
    XYCropImageStyleCenterRightQuarter  =7,      // 中间右侧四分之一部分
    XYCropImageStyleCenterLeftQuarter   =8,      // 中间左侧四分之一部分
    XYCropImageStyleLeftQuarter         =9,      // 左侧四分之一部分
};

@interface UIImage (Crop)
- (UIImage *)imageByCroppingWithStyle:(XYCropImageStyle)style;

@end
</code></pre>

<h3>UIImage+Crop.m</h3>

<pre><code>#import "UIImage+Crop.h"

@implementation UIImage (Crop)

- (UIImage *)imageByCroppingWithStyle:(XYCropImageStyle)style
{
    CGRect rect;
    switch (style) {
        case XYCropImageStyleLeft:
            rect = CGRectMake(0, 0, self.size.width/2, self.size.height);
            break;
        case XYCropImageStyleCenter:
            rect = CGRectMake(self.size.width/4, 0, self.size.width/2, self.size.height);
            break;
        case XYCropImageStyleRight:
            rect = CGRectMake(self.size.width/2, 0, self.size.width/2, self.size.height);
            break;
        case XYCropImageStyleLeftOneOfThird:
            rect = CGRectMake(0, 0, self.size.width/3, self.size.height);
            break;
        case XYCropImageStyleCenterOneOfThird:
            rect = CGRectMake(self.size.width/3, 0, self.size.width/3, self.size.height);
            break;
        case XYCropImageStyleRightOneOfThird:
            rect = CGRectMake(self.size.width/3*2, 0, self.size.width/3, self.size.height);
            break;
        case XYCropImageStyleLeftQuarter:
            rect = CGRectMake(0, 0, self.size.width/4, self.size.height);
            break;
        case XYCropImageStyleCenterLeftQuarter:
            rect = CGRectMake(self.size.width/4, 0, self.size.width/4, self.size.height);
            break;
        case XYCropImageStyleCenterRightQuarter:
            rect = CGRectMake(self.size.width/4*2, 0, self.size.width/4, self.size.height);
            break;
        case XYCropImageStyleRightQuarter:
            rect = CGRectMake(self.size.width/4*3, 0, self.size.width/4, self.size.height);
            break;
        default:
            break;
    }
    CGImageRef imageRef = self.CGImage;
    CGImageRef imagePartRef = CGImageCreateWithImageInRect(imageRef, rect);
    UIImage *cropImage = [UIImage imageWithCGImage:imagePartRef];
    CGImageRelease(imagePartRef);
    return cropImage;
}
</code></pre>

<h2>实际运用</h2>

<p>简单测试一下，看看有没有实现我们想要的效果。首先，先加载一个完整的UIImageView。这个应该不难。代码如下：</p>

<pre><code>UIImageView *imgView = [[UIImageView alloc] init];
imgView.frame = CGRectMake((SCREEN.width - 226) / 2, 100, 226, 106);
UIImage *image = [UIImage imageNamed:@"ganggang"];
imgView.image = image;
[self.view addSubview:imgView];
</code></pre>

<p>运行一下：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/jiequing.png" alt="jiequing" /></p>

<p>要对UIImage进行裁剪，首先导入头文件：</p>

<pre><code>#import "UIImage+Crop.h"
</code></pre>

<p>在上面<code>UIImage *image = [UIImage imageNamed:@"ganggang"];</code>这段代码之后加上下面这句：</p>

<pre><code>image = [image imageByCroppingWithStyle:XYCropImageStyleLeft];
</code></pre>

<p><code>XYCropImageStyleLeft</code>是截取照片的左半部分。效果如下：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/jiequed.png" alt="jiequed" /></p>

<p>截取成功，还可以截取其他区域的，只需要传入不同的<code>XYCropImageStyle</code>即可实现。以上代码依然在<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>里。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/25/cheng-xu-yuan-:zhe-ge-zhou-mo-bu-jia-ban/">程序员：这个周末不加班</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-25T09:01:33+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:01 am</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><p>时间依然没有停住它的脚步，新的周末如期而至。这应该是一件令人兴奋的时期，谁不想度过一个美好的周末呢？</p>

<p>作为程序员每天都在解决永远解不完的bug，做着永远做不完的需求，能有个周末好好休息休息，真的是一件非常奢侈的事情。</p>

<h2>我也是加班加过来的</h2>

<p>说到这个话题应该是程序员心中的痛啊，哪有程序员不加班的呢？我刚进公司的时候，公司刚成立不久。为了项目进度，拼命的加班，老板每天都在催进度。</p>

<p>那一段时间，公司的程序员们基本都是八九点下班。偶尔一次迎着夕阳下班，都高兴的不得了。不禁感叹一句，终于可以和太阳一起下班啦！</p>

<p>每个周六没有事情，大家也都乖乖的来加班。听着老板不断的画饼。不过好在，公司的发展很迅速，产品销售的也还不错。不过这好像跟我们程序员一点关系都没有。</p>

<h2>少加班或拒绝加班</h2>

<p>公司发展的好，对于程序员来说肯定是一件好事。无论老板有没有兑现当时画饼的承诺，我们都应该为公司的迅速发展而高兴。</p>

<p>随着公司的发展，越来越多的人才不断加入公司。我就喜欢和厉害的人一起工作，这样可以学到不少东西，这对我来说也是一种进步。</p>

<p>我想以后如果没有什么特别重要的事情，尽量选择少加班，或者直接拒绝加班。这应该是我们的权利。当然，说是这么说。如果真的需要加班，那还会义不容辞的，谁让我们选择这个苦逼的行业呢！</p>

<h2>这个周末如何度过</h2>

<p>这个周末我选择不加班。周六准备和高中同学一起聚会，就在上海。好几位同学都是做程序员的（笑），有的人今天还是请假出来聚会的。</p>

<p>自从高中毕业，相见的机会越来越少。所以这一次聚会大家都很珍惜。</p>

<p>周日大学同学来上海，他不是来找我的，他是来找他女朋友的。我呢，还是需要过去见上一面，一起聊聊各自的情况，毕竟来到上海啦。</p>

<p>这个周末你选择如何度过呢？·</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/25/ioskai-fa-zhi-sha-he-he-wen-jian-cao-zuo-(hui-zong-)/">iOS开发之沙盒和文件操作（汇总）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-25T00:15:17+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:15 am</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><p>关于沙盒和文件操作的文章写了几篇，在写的过程中加深了自己的记忆。今天来做一下汇总，算是对知识点的梳理。</p>

<h2>文章梳理</h2>

<p>1 <a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a></p>

<p>这是一篇关于沙盒的基础知识教程。简述沙盒的作用，对Documents、Library、tmp之间的区别做了介绍。通过两种方法打开沙盒，查看其中的内容。</p>

<p>2 <a href="http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing/">iOS开发之获取沙盒路径</a></p>

<p>沙盒里的文件夹包括Documents、Library、tmp。文章介绍了如何获取Documents、Library、Caches、tmp的路径。</p>

<p>3 <a href="http://www.superqq.com/blog/2015/07/23/ru-he-cha-kan-zhen-ji-de-sha-he-%28tu-wen-jiao-cheng-%29/">如何查看真机的沙盒（图文教程）</a></p>

<p>通过图文的方式详细讲解如何查看真机沙盒。</p>

<p>4 <a href="http://www.superqq.com/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng/">NSFileManager文件操作的十个小功能</a></p>

<p>NSFileManager是一个单列类，也是一个文件管理器。可以通过NSFileManager创建文件夹、创建文件、写文件、读文件内容等等基本功能。</p>

<h2>小记</h2>

<p>希望以上的知识梳理能帮助大家更好的掌握沙盒机制以及文件操作。我会持续分享更多关于iOS开发相关的技术文章。</p>

<p>swift推出这么久，不知道你有没有开始用swift写项目。推荐给你一个swift学习网站:<a href="http://www.iswifting.com/">swift开发</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng/">NSFileManager文件操作的十个小功能</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-24T00:14:03+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:14 am</span></time>
        
         
      </p>
    
  </header>


  <div class="entry-content"><p>NSFileManager是一个单列类，也是一个文件管理器。可以通过NSFileManager创建文件夹、创建文件、写文件、读文件内容等等基本功能。</p>

<p>下面将介绍NSFileManager文件操作的十个小功能。我们在Documents里面进行举例，首先是获取Documents的路径。这个在<a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a>已经详细讲解过了。获取Documents路径方法如下：</p>

<pre><code>- (NSString *)getDocumentsPath
{
    //获取Documents路径
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *path = [paths objectAtIndex:0];
    NSLog(@"path:%@", path);
    return path;
}
</code></pre>

<h3>创建文件夹</h3>

<pre><code>-(void)createDirectory{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSDirectory = [documentsPath stringByAppendingPathComponent:@"iOS"];
    BOOL isSuccess = [fileManager createDirectoryAtPath:iOSDirectory withIntermediateDirectories:YES attributes:nil error:nil];
    if (isSuccess) {
        NSLog(@"success");
    } else {
        NSLog(@"fail");
    }
}
</code></pre>

<h3>创建文件</h3>

<pre><code>-(void)createFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager createFileAtPath:iOSPath contents:nil attributes:nil];
    if (isSuccess) {
        NSLog(@"success");
    } else {
        NSLog(@"fail");
    }
}
</code></pre>

<h3>写文件</h3>

<pre><code>-(void)writeFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *content = @"我要写数据啦";
    BOOL isSuccess = [content writeToFile:iOSPath atomically:YES encoding:NSUTF8StringEncoding error:nil];
    if (isSuccess) {
        NSLog(@"write success");
    } else {
        NSLog(@"write fail");
    }
}
</code></pre>

<h3>读取文件内容</h3>

<pre><code>-(void)readFileContent{
    NSString *documentsPath =[self getDocumentsPath];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *content = [NSString stringWithContentsOfFile:iOSPath encoding:NSUTF8StringEncoding error:nil];
    NSLog(@"read success: %@",content);
}
</code></pre>

<h3>判断文件是否存在</h3>

<pre><code>- (BOOL)isSxistAtPath:(NSString *)filePath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:filePath];
    return isExist;
}
</code></pre>

<h3>计算文件大小</h3>

<pre><code>- (unsigned long long)fileSizeAtPath:(NSString *)filePath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:filePath];
    if (isExist){
        unsigned long long fileSize = [[fileManager attributesOfItemAtPath:filePath error:nil] fileSize];
        return fileSize;
    } else {
        NSLog(@"file is not exist");
        return 0;
    }
}
</code></pre>

<h3>计算整个文件夹中所有文件大小</h3>

<pre><code>- (unsigned long long)folderSizeAtPath:(NSString*)folderPath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:folderPath];
    if (isExist){
        NSEnumerator *childFileEnumerator = [[fileManager subpathsAtPath:folderPath] objectEnumerator];
        unsigned long long folderSize = 0;
        NSString *fileName = @"";
        while ((fileName = [childFileEnumerator nextObject]) != nil){
            NSString* fileAbsolutePath = [folderPath stringByAppendingPathComponent:fileName];
            folderSize += [self fileSizeAtPath:fileAbsolutePath];
        }
        return folderSize / (1024.0 * 1024.0);
    } else {
        NSLog(@"file is not exist");
        return 0;
    }
}
</code></pre>

<h3>删除文件</h3>

<pre><code>-(void)deleteFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager removeItemAtPath:iOSPath error:nil];
    if (isSuccess) {
        NSLog(@"delete success");
    }else{
        NSLog(@"delete fail");
    }
}
</code></pre>

<h3>移动文件</h3>

<pre><code>- (void)moveFileName
{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *filePath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *moveToPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager moveItemAtPath:filePath toPath:moveToPath error:nil];
    if (isSuccess) {
        NSLog(@"rename success");
    }else{
        NSLog(@"rename fail");
    }
}
</code></pre>

<h3>重命名</h3>

<pre><code>- (void)renameFileName
{
    //通过移动该文件对文件重命名
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *filePath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *moveToPath = [documentsPath stringByAppendingPathComponent:@"rename.txt"];
    BOOL isSuccess = [fileManager moveItemAtPath:filePath toPath:moveToPath error:nil];
    if (isSuccess) {
        NSLog(@"rename success");
    }else{
        NSLog(@"rename fail");
    }
}
</code></pre>

<p>以上文件操作代码都在<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>，可以直接通过git拉下来进行测试。关于NSFileManager的用法还有很多，一起接续探索吧！</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>微信扫一扫，代码写的好</h1>
        <br/>
        <br/><strong>东半球最好的iOS开发公众号</strong> 
        <br/>
        <br/><img width="220px" src="http://www.superqq.com/images/getqrcode.jpg" />
        <br/>
        <br/><strong>东半球最好的程序猿公众号</strong>
        <br/>
        <br/><img width="220px" src="http://www.superqq.com/images/CodePush.jpg" />
        </p>
<!--广告位-->
<script type="text/javascript">
    /*刚刚在线250*350 创建于 2015-07-31*/
    var cpro_id = "u2238366";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/07/31/aktabbarcontroller-similar-to-wechat-library/">AKTabBarController：类似微信的第三方库</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/30/six-tips-on-navigation-bar/">关于导航栏的六个小技巧</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/29/uiimage-geometric-zoom/">iOS开发之UIImage等比缩放</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/28/swift-alamofire/">著名的AFNetworking网络基础库Swift版Alamofire</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/28/four-create-uiimage-method/">五种创建UIImage的类方法</a>
      </li>
    
  </ul>
</section>
</section>
<section>
    <h1>About Me</h1>
    <br/>
    <p> 李刚：百度百家专栏作者，刚刚在线站长，iOS工程师非著名自媒体人，微信公众号iOS开发：iOSDevTip运营者<br/>
    <br/><strong>出师未捷名已落</strong>
    <br/>
    <br/>新浪微博: <a href='http://weibo.com/ligangnc' target='_blank'>李刚移动</a>
    <br/>
    <br/>个人微信: <strong>chinaligang</strong> 欢迎调戏
    <br/>
    <br/>iOS群: <strong>218822587</strong>
  <br/>
</section>

   
 <section>
    <h1>友情链接</h1>
    <ul>
    
       <li>
           <a href="http://www.superqq.com" target="_blank" title=“刚刚在线”>刚刚在线</a>
       </li>
       <li>
           <a href="http://www.90159.com" target="_blank" title=“程序员头条”>程序员头条</a>
       </li>
       <li>
           <a href="http://www.iswifting.com" target="_blank" title=“swift开发”>swift开发</a>
       </li>
       <li>
           <a href="http://www.aswifter.com/" target="_blank" title="APP开发者">APP开发者</a>
       </li>
        <li>
           <a href="http://www.boxingjiaoyu.com/" target="_blank" title="程序员聚合平台">程序员聚合平台</a>
       </li>
       <li>
           <a href="http://www.jq-school.com/" target="_blank" title="jquery教程">jquery教程</a>
       </li>
        <li>
           <a href="http://www.admin10000.com/" target="_blank" title="WEB开发者">WEB开发者</a>
       </li>
       <li>
           <a href="http://www.aichengxu.com/" target="_blank" title="爱程序网">爱程序网</a>
       </li>
       <li>
           <a href="http://www.lai18.com" target="_blank" title="IT技术文章">IT技术文章</a>
       </li>
       <li>
           <a href="http://www.cftea.com/" target="_blank" title="千一网络">千一网络</a>
       </li>
        <li>
           <a href="http://www.bmob.cn/" target="_blank" title="Bmob">Bmob移动后端云</a>
       </li>
       <li>
           <a href="http://www.leichunfeng.com" target="_blank" title="雷纯锋的技术博客">雷纯锋的技术博客</a>
       </li>
       <li>
           <a href="http://cuiqingcai.com/" target="_blank" title="静觅">静觅</a>
       </li>
       <li>
           <a href="http://letsswift.com/" target="_blank" title="一起Swift">一起Swift</a>
       </li>
       <li>
           <a href="http://www.swiftv.cn/" target="_blank" title="SwiftV课堂">SwiftV课堂</a>
       </li>
        <li>
            <a href="http://blog.csdn.net/iosdevtip" target="_blank" title="刚刚在线">CSDN</a>
        </li>
        <li>
            <a href="http://user.qzone.qq.com/1606535851" target="_blank" title="刚刚在线">QQ空间</a>
        </li>
        <li>
            <br/><strong>交换友链：</strong>欢迎各大程序员站点交换友情链接，如需交换，请添加好本站链接后发送邮件至下方邮箱。
            <br/>
            <br/><strong>格式：</strong>（ 友链文字：“ 刚刚在线 ”，链接：“ http://www.superqq.com/ ” ）
            <br/>
            <br/><strong>邮箱：</strong>worldligang@163.com
            <br/>
        </li>
    </ul>
</section>
<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
Copyright &copy; 2015 - 李刚 
<span class="credit">Powered by <a href="http://octopress.org" target="_blank">Octopress</a></span>
 <span class="credit">, 感谢 <a href="http://gitcafe.com/signup?invited_by=tangqiaoboy" target="_blank">GitCafe</a> 为本站提供存储空间</span>

</p>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/17443209.js"></script>
<noscript><a href="http://www.51.la/?17443209" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/17443209.asp" style="border:none" /></a></noscript>
<!--广告位-->
<dic class="flashnews">
    <script type="text/javascript">
        /*960*60 创建于 2015-06-05*/
        var cpro_id = "u2140429";
        </script>
    <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
    </div>
<!--广告链接结束--></footer>
  











</body>
</html>
