
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
      <meta name="baidu-site-verification" content="X93tJz3pCq" />
  <title>《招聘一个靠谱的iOS》面试题参考答案（上） - 刚刚在线</title>
  <meta name="author" content="李刚">
  <meta name="uyan_auth" content="d1112891bb" />
  <meta name="baidu-tc-verification" content="7acda2305fabbf1ddd9f83e385ddd899" />
      
  
  <meta name="description" content="《招聘一个靠谱的iOS》面试题参考答案（上）最近比较火的关于iOS开发面试题的文章。简单喵了一眼，感觉很不错，作者sunnyxx也是个大牛。特此推荐！">
  <meta name="keywords" content="招聘, iOS面试题, iOS面试, iOS开发, 刚刚在线">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.superqq.com/blog/2015/08/08/interview-ios-question-answer">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="刚刚在线" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->


  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">刚刚在线</a></h1>
  
    <h2>分享iOS开发技术经验的自媒体网站</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://zhannei.superqq.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.superqq.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">全部文章</a></li>
  <li><a href="/blog/categories/ioskai-fa/">iOS开发</a></li>
  <li><a href="/blog/categories/swiftkai-fa">swift开发</a></li>
  <li><a href="/blog/categories/cheng-xu-yuan/">程序员</a></li>
  <li><a href="/blog/categories/yuan-dai-ma/">源代码</a></li>
  <li><a href="/blog/categories/sdkfu-wu/">sdk服务</a></li>
  <li><a href="/blog/categories/tui-jian/">推荐</a></li>
  <li><a href="/about">赞助作者</a></li>
  <li><a href="http://www.90159.com/" target="_blank" title=头条>头条</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">《招聘一个靠谱的iOS》面试题参考答案（上）</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-08T00:16:38+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:16 am</span></time>
        
        
          | <a href="#comments">Comments</a>
         
      </p>
    
  </header>


<div class="entry-content"><blockquote><p>推荐理由：最近比较🔥的关于iOS开发面试题的文章。简单喵了一眼，感觉很不错，作者sunnyxx也是个大牛。特此推荐！</p></blockquote>

<p><a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/">《招聘一个靠谱的 iOS》</a>—参考答案（上）</p>

<p>说明：面试题来源是<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a>的这篇博文：<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>

<p>出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>

<p>答案为<a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a>指正。</p>

<hr />

<h3>1. 风格纠错题</h3>

<p><img src="http://i.imgur.com/O7Zev94.png" alt="enter image description here" />
修改完的代码：</p>

<p>修改方法有很多种，现给出一种做示例：</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readonly) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<p>下面对具体修改的地方，分两部分做下介绍：<strong><em>硬伤部分</em></strong>和<strong><em>优化部分</em></strong>
。因为<strong><em>硬伤部分</em></strong>没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看<strong><em>优化部分</em></strong>。</p>

<h4><strong><em>优化部分</em></strong></h4>

<ol>
<li><p>enum建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html">Adopting Modern Objective-C</a> 一文：</p>

<p>&#8220;`objective-c
//定义一个枚举
typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 2. age属性的类型：应避免使用基本类型，建议使Foundation数据类型，对应关系如下：
</span><span class='line'> 
</span><span class='line'> ```Objective-C
</span><span class='line'>  int -&gt; NSInteger
</span><span class='line'>  unsigned -&gt; NSUInteger
</span><span class='line'>  float -&gt; CGFloat
</span><span class='line'>  动画时间 -&gt; NSTimeInterval</span></code></pre></td></tr></table></div></figure>


<p>同时考虑到age的特点，应使用NSUInteger，而非int。
这样做的是基于64-bit 适配考虑，详情可参考出题者的博文<a href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/">《64-bit Tips》</a>。</p>

<ol>
<li>如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。</li>
<li>doLogIn方法不应写在该类中：虽然<code>LogIn</code>的命名不太清晰，但笔者猜测是login的意思，而登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：</li>
</ol>


<blockquote><p>无论是MVC模式还是MVVM模式，业务逻辑都不应当写在Model里。</p></blockquote>

<p> （如果抛开命名规范，假设该类真的是MVVM模式里的 ViewModel ，那么UserModel这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如：login对应的应当是注册并登录的一个Button，出现login方法也可能是合理的。）</p>

<ol>
<li>doLogIn方法命名不规范：添加了多余的动词前缀。
请牢记：</li>
</ol>


<blockquote><p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用<code>do</code>，<code>does</code>这种多余的关键字，动词本身的暗示就足够了。
 11. <code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中不要用<code>with</code>来连接两个参数:<code>withAge:</code>应当换为<code>age:</code>，<code>age:</code>已经足以清晰说明参数的作用，也不建议用<code>andAge:</code>：通常情况下，即使有类似<code>withA:withB:</code>的命名需求，也通常是使用<code>withA:andB:</code>这种命名，用来表示方法执行了两个相对独立的操作（<em>从设计上来说，这时候也可以拆分成两个独立的方法</em>），它不应该用作阐明有多个参数，比如下面的：</p></blockquote>

<p>  &#8220;`objective-c
//错误，不要使用&#8221;and&#8221;来连接参数
- (int)runModalForDirectory:(NSString <em>)path andFile:(NSString </em>)name andTypes:(NSArray <em>)fileTypes;
//错误，不要使用&#8221;and&#8221;来阐明有多个参数
- (instancetype)initWithName:(CGFloat)width andAge:(CGFloat)height;
//正确，使用&#8221;and&#8221;来表示两个相对独立的操作
- (BOOL)openFile:(NSString </em>)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'> 12. 由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为copy。(原因在下文有详细论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？***)
</span><span class='line'> 2. “性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？
</span><span class='line'>
</span><span class='line'> Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'> ```Objective-C
</span><span class='line'>
</span><span class='line'>    // .m文件
</span><span class='line'>    // http://weibo.com/luohanchenyilong/
</span><span class='line'>    // https://github.com/ChenYilong
</span><span class='line'>    //
</span><span class='line'>
</span><span class='line'>    @implementation CYLUser
</span><span class='line'>
</span><span class='line'>    - (instancetype)initWithName:(NSString *)name
</span><span class='line'>                             age:(NSUInteger)age
</span><span class='line'>                             sex:(CYLSex)sex {
</span><span class='line'>        if(self = [super init]) {
</span><span class='line'>            _name = [name copy];
</span><span class='line'>            _age = age;
</span><span class='line'>            _sex = sex;
</span><span class='line'>        }
</span><span class='line'>        return self;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    - (instancetype)initWithName:(NSString *)name
</span><span class='line'>                             age:(NSUInteger)age {
</span><span class='line'>        return [self initWithName:name age:age sex:nil];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @end</span></code></pre></td></tr></table></div></figure>


<p> 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。</p>

<p>  因为出题者没有给出.m文件，所以有两种猜测：1：本来打算只设计一个designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为readwrite属性，最终给出的修改代码应该是：</p>

<p> &#8220;`Objective-C</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 第二种修改方法（基于第一种修改方法的基础上）

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readwrite) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>
</span><span class='line'> .h中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳--》 [***《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》***](http://is.gd/OQ49zk)。）
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> 2. 按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为instancetype，为保持一致性，init方法和快捷构造方法的返回类型最好都用instancetype。
</span><span class='line'> 2. 如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:
</span><span class='line'>那么在设计对应@property时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样
</span><span class='line'>
</span><span class='line'>        @property (nonatomic, copy, readonly) NSString *name;
</span><span class='line'>        @property (nonatomic, assign, readonly) NSUInter age;
</span><span class='line'>        @property (nonatomic, assign, readonly) CYLSex sex;
</span><span class='line'>      由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。
</span><span class='line'> 2. `initUserModelWithUserName`如果改为`initWithName`会更加简洁，而且足够清晰。
</span><span class='line'> 2. `UserModel`如果改为`User`会更加简洁，而且足够清晰。
</span><span class='line'> 2. `UserSex`如果改为`Sex`会更加简洁，而且足够清晰。
</span><span class='line'>
</span><span class='line'>####***硬伤部分***
</span><span class='line'>
</span><span class='line'> 1. 在-和(void)之间应该有一个空格
</span><span class='line'> 3. enum中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。
</span><span class='line'> 3. enum左括号前加一个空格，或者将左括号换到下一行
</span><span class='line'> 4. enum右括号后加一个空格
</span><span class='line'> 2. `UserModel :NSObject` 应为`UserModel : NSObject`，也就是`:`右侧少了一个空格。
</span><span class='line'> 2. @interface与@property属性声明中间应当间隔一行。
</span><span class='line'> 2. 两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。
</span><span class='line'> 9. 
</span><span class='line'>  `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;`方法中方法名与参数之间多了空格。而且`-` 与`(id)`之间少了空格。
</span><span class='line'> 10. 
</span><span class='line'>  `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;`方法中方法名与参数之间多了空格：`(NSString*)name`前多了空格。
</span><span class='line'> 10. 
</span><span class='line'>  `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;`方法中`(NSString*)name`,应为`(NSString *)name`，少了空格。 
</span><span class='line'> 7.  doLogIn方法命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。
</span><span class='line'> 2. 第二个@property中assign和nonatomic调换位置。
</span><span class='line'>
</span><span class='line'>###2. 什么情况使用 weak 关键字，相比 assign 有什么不同？
</span><span class='line'>什么情况使用 weak 关键字？
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> 1. 在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性
</span><span class='line'>
</span><span class='line'> 2. 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong。在下文也有论述：***《IBOutlet连出来的视图属性为什么可以被设置成weak?》***
</span><span class='line'>
</span><span class='line'>不同点：
</span><span class='line'> 
</span><span class='line'> 1. `weak` 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，
</span><span class='line'>然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。
</span><span class='line'>而 `assign` 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 
</span><span class='line'>NSlnteger 等)的简单赋值操作。
</span><span class='line'>
</span><span class='line'> 2. assigin 可以用非OC对象,而weak必须用于OC对象
</span><span class='line'>
</span><span class='line'>###3. 怎么用 copy 关键字？
</span><span class='line'>用途：
</span><span class='line'>
</span><span class='line'> 1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
</span><span class='line'> 2. block也经常使用copy关键字，具体原因见[官方文档：***Objects Use Properties to Keep Track of Blocks***](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12)：
</span><span class='line'>
</span><span class='line'> block使用copy是从MRC遗留下来的“传统”,在MRC中,方法内部的block是在栈区的,使用copy可以把它放到堆区.在ARC中写不写都行：对于block使用copy还是strong效果是一样的，但写上copy也无伤大雅，还能时刻提醒我们：编译器自动对block进行了copy操作。
</span><span class='line'>
</span><span class='line'> ![enter image description here](http://i.imgur.com/VlVKl8L.png)
</span><span class='line'>
</span><span class='line'>下面做下解释：
</span><span class='line'>copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
</span><span class='line'>当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&gt; 用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。
</span><span class='line'> 
</span><span class='line'>该问题在下文中也有论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？***
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>###4. 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`
</span><span class='line'>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为copy就是复制一个不可变NSArray的对象；2、使用了atomic属性会严重影响性能 ； 
</span><span class='line'>
</span><span class='line'>第1条的相关原因在下文中有论述***《用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？》*** 以及上文***《怎么用 copy 关键字？》***也有论述。
</span><span class='line'>
</span><span class='line'>比如下面的代码就会发生崩溃
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p>Objective-C
// .h文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 下面的代码就会发生崩溃</p>

<p>@property (nonatomic, copy) NSMutableArray *mutableArray;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C
// .m文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 下面的代码就会发生崩溃</p>

<p>NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];
self.mutableArray = array;
[self.mutableArray removeObjectAtIndex:0];</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>接下来就会奔溃：
</span><span class='line'>
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p>Objective-C
 -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>第2条原因，如下：
</span><span class='line'>
</span><span class='line'>&gt; 该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明nonatomic可以节省这些虽然很小但是不必要额外开销。
</span><span class='line'>
</span><span class='line'>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备nonatomic特质，那它就是“原子的”(atomic))。
</span><span class='line'>
</span><span class='line'>在iOS开发中，你会发现，几乎所有属性都声明为nonatomic。
</span><span class='line'>
</span><span class='line'>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。
</span><span class='line'>
</span><span class='line'>因此，开发iOS程序时一般都会使用nonatomic属性。但是在开发Mac OS X程序时，使用
</span><span class='line'>atomic属性通常都不会有性能瓶颈。
</span><span class='line'>
</span><span class='line'>###5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&gt; 若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopyiog与NSMutableCopying协议。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>具体步骤：
</span><span class='line'>
</span><span class='line'> 1. 需声明该类遵从NSCopying协议
</span><span class='line'> 2. 实现NSCopying协议。该协议只有一个方法: 
</span><span class='line'>
</span><span class='line'> ```Objective-C
</span><span class='line'>- (id)copyWithZone: (NSZone*) zone</span></code></pre></td></tr></table></div></figure>


<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是“copyWithZone”方法。</p>

<p>以第一题的代码为例：</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 修改完的代码

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readonly) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<p>然后实现协议中规定的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">CYLUser</span> <span class="o">*</span><span class="k">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="nb">self</span> <span class="k">copy</span><span class="p">]</span> <span class="nl">allocWithZone</span><span class="p">:</span><span class="n">zone</span><span class="p">]</span>
</span><span class='line'>                   <span class="nl">initWithName</span><span class="p">:</span><span class="n">_name</span>
</span><span class='line'>                                <span class="nl">age</span><span class="p">:</span><span class="n">_age</span>
</span><span class='line'>                                <span class="nl">sex</span><span class="p">:</span><span class="n">_sex</span><span class="p">];</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如CYLUser中含有一个数组，与其他CYLUser对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 以第一题《风格纠错题》里的代码为例

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readonly) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
- (void)addFriend:(CYLUser *)user;
- (void)removeFriend:(CYLUser *)user;

@end
</code></pre>

<p>// .m文件</p>

<pre><code>// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 

@implementation CYLUser {
    NSMutableSet *_friends;
}

- (void)setName:(NSString *)name {
    _name = [name copy];
}

- (instancetype)initWithName:(NSString *)name 
                             age:(NSUInteger)age 
                             sex:(CYLSex)sex {
     if(self = [super init]) {
        _name = [name copy];
        _age = age;
        _sex = sex;
        _friends = [[NSMutableSet alloc] init];
     }
     return self;
}

- (void)addFriend:(CYLUser *)user {
    [_friends addObject:user];
}

- (void)removeFriend:(CYLUser *)user {
    [_friends removeObject:person];
}

- (id)copyWithZone:(NSZone *)zone {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    copy-&gt;_friends = [_friends mutableCopy];
    return copy;
}

- (id)deepCopy {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends 
                                             copyItems:YES];
    return copy;
}

@end
</code></pre>

<p>以上做法能满足基本的需求，但是也有缺陷：</p>

<blockquote><p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p></blockquote>

<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</em></strong>】</p>

<p>在例子中，存放朋友对象的set是用“copyWithZooe:”方法来拷贝的，这种浅拷贝方式不会逐个复制set中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>

<pre><code>- (id)deepCopy {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends 
                                             copyItems:YES];
    return copy;
}
</code></pre>

<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>

<p>如果抛开本例来回答的话，如下：</p>

<pre><code>- (void)setName:(NSString *)name {
    _name = [name copy];
}
</code></pre>

<p>如果单单就上文的代码而言，我们不需要也不能重写name的 setter ：由于是name是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”&ndash;copy，是因为：如果不写copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效。）。</p>

<p>那如何确保name被copy？在初始化方法(initializer)中做：</p>

<pre><code>- (instancetype)initWithName:(NSString *)name 
                             age:(NSUInteger)age 
                             sex:(CYLSex)sex {
     if(self = [super init]) {
        _name = [name copy];
        _age = age;
        _sex = sex;
        _friends = [[NSMutableSet alloc] init];
     }
     return self;
}
</code></pre>

<h3>6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3>

<p><strong>@property 的本质是什么？</strong></p>

<blockquote><p>@property = ivar + getter + setter;</p></blockquote>

<p>下面解释下：</p>

<blockquote><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p></blockquote>

<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为<code>Objective-C 2.0</code>的一部分。
而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。
正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>

<blockquote><p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。
所以你也可以这么说：</p>

<p>@property = getter + setter;</p></blockquote>

<p>例如下面这个类：</p>

<pre><code>@interface Person : NSObject 
@property NSString *firstName; 
@property NSString *lastName; 
@end 
</code></pre>

<p>上述代码写出来的类与下面这种写法等效：</p>

<pre><code>@interface Person : NSObject 
- (NSString *)firstName; 
- (void)setFirstName:(NSString *)firstName; 
- (NSString *)lastName; 
- (void)setLastName:(NSString *)lastName; 
@end 
</code></pre>

<p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>

<blockquote><p>“自动合成”( autosynthesis)</p></blockquote>

<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”( autosynthesis)。需要强调的是，这个过程由编译
器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为
<code>_firstName</code>与<code>_lastName</code>。也可以在类的实现代码里通过
@synthesize语法来指定实例变量的名字.</p>

<pre><code>@implementation Person 
@synthesize firstName = _myFirstName; 
@synthesize lastName = myLastName; 
@end 
</code></pre>

<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>

<ol>
<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter与getter方法对应的实现函数</li>
<li><code>ivar_list</code> ：成员变量列表</li>
<li><code>method_list</code> ：方法列表</li>
<li><code>prop_list</code> ：属性列表</li>
</ol>


<p>也就是说我们每次在增加一个属性,系统都会在<code>ivar_list</code>中添加一个成员变量的描述,在<code>method_list</code>中增加setter与getter方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出setter与getter方法对应的实现,在setter方法中从偏移量的位置开始赋值,在getter方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>

<h3>7. @protocol 和 category 中如何使用 @property</h3>

<ol>
<li>在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>
<li><p>category 使用 @property 也是只会生成setter和getter方法的声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数：</p></li>
<li><p><code>objc_setAssociatedObject</code></p></li>
<li><code>objc_getAssociatedObject</code></li>
</ol>


<h3>8. runtime 如何实现 weak 属性</h3>

<p>要实现weak属性，首先要搞清楚weak属性的特点：</p>

<blockquote><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<p>那么runtime如何实现weak变量的自动置nil？</p>

<blockquote><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p></blockquote>

<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>

<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>

<p><code>objc_storeWeak</code>函数把第二个参数&ndash;赋值对象（b）的内存地址作为键值key，将第一个参数&ndash;weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>

<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>

<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>

<p>而如果a是由assign修饰的，则：
在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>

<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="c1">// 使用伪代码模拟：runtime如何实现weak属性</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'> <span class="kt">id</span> <span class="n">obj1</span><span class="p">;</span>
</span><span class='line'> <span class="n">objc_initWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="cm">/*obj引用计数变为0，变量作用域结束*/</span>
</span><span class='line'> <span class="n">objc_destroyWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>

<p>总体说来，作用是：
通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>

<p>下面分别介绍下方法的内部实现：</p>

<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="n">obj1</span> <span class="o">=</span> <span class="mi">0</span><span class="err">；</span>
</span><span class='line'><span class="n">obj_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说：</p>

<blockquote><p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p></blockquote>

<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>

<p>前面的源代码与下列源代码相同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="c1">// 使用伪代码模拟：runtime如何实现weak属性</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'><span class="kt">id</span> <span class="n">obj1</span><span class="p">;</span>
</span><span class='line'><span class="n">obj1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="cm">/* ... obj的引用计数变为0，被置nil ... */</span>
</span><span class='line'><span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>objc_storeWeak</code>函数把第二个参数&ndash;赋值对象（obj）的内存地址作为键值，将第一个参数&ndash;weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除，在后面的相关一题会详解。</p>

<p>使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：</p>

<blockquote><p>如何让不使用weak修饰的@property，拥有weak的效果。</p></blockquote>

<p>我们从setter方法入手：</p>

<pre><code>- (void)setObject:(NSObject *)object
{
    objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
    [object cyl_runAtDealloc:^{
        _object = nil;
    }];
}
</code></pre>

<p>也就是有两个步骤：</p>

<ol>
<li><p>在setter方法中做如下设置：</p>

<pre><code>objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
</code></pre></li>
<li><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助runtime：</p></li>
</ol>


<p> &#8220;`Objective-C
//要销毁的目标对象
id objectToBeDeallocated;
//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。
id objectWeWantToBeReleasedWhenThatHappens;
objc_setAssociatedObject(objectToBeDeallocted,
                         someUniqueKey,
                         objectWeWantToBeReleasedWhenThatHappens,
                         OBJC_ASSOCIATION_RETAIN);</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="err">知道了思路，我们就开始实现`</span><span class="n">cyl_runAtDealloc</span><span class="err">`方法，实现过程分两部分：</span>
</span><span class='line'>
</span><span class='line'><span class="err">第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助</span><span class="n">block</span><span class="err">执行“事件”。</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// .h文件</span>
</span><span class='line'>    <span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'>    <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>    <span class="c1">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">voidBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@interface</span> <span class="nc">CYLBlockExecutor</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nl">initWithBlock</span><span class="p">:(</span><span class="n">voidBlock</span><span class="p">)</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// .m文件</span>
</span><span class='line'>    <span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'>    <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>    <span class="c1">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</span>
</span><span class='line'>
</span><span class='line'>    <span class="cp">#import &quot;CYLBlockExecutor.h&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@interface</span> <span class="nc">CYLBlockExecutor</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">voidBlock</span> <span class="n">_block</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">@implementation</span> <span class="nc">CYLBlockExecutor</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nl">initWithBlock</span><span class="p">:(</span><span class="n">voidBlock</span><span class="p">)</span><span class="n">aBlock</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_block</span> <span class="o">=</span> <span class="p">[</span><span class="n">aBlock</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">_block</span> <span class="o">?</span> <span class="n">_block</span><span class="p">()</span> <span class="o">:</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="err">第二部分：核心代码：利用</span><span class="n">runtime</span><span class="err">实现`</span><span class="n">cyl_runAtDealloc</span><span class="err">`方法</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// CYLNSObject+RunAtDealloc.h文件</span>
</span><span class='line'>    <span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'>    <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>    <span class="c1">// 利用runtime实现cyl_runAtDealloc方法</span>
</span><span class='line'>
</span><span class='line'>    <span class="cp">#import &quot;CYLBlockExecutor.h&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">runAtDeallocBlockKey</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">runAtDeallocBlockKey</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@interface</span> <span class="bp">NSObject</span> <span class="nl">(CYLRunAtDealloc)</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">cyl_runAtDealloc</span><span class="p">:(</span><span class="n">voidBlock</span><span class="p">)</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// CYLNSObject+RunAtDealloc.m文件</span>
</span><span class='line'>    <span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'>    <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>    <span class="c1">// 利用runtime实现cyl_runAtDealloc方法</span>
</span><span class='line'>
</span><span class='line'>    <span class="cp">#import &quot;CYLNSObject+RunAtDealloc.h&quot;</span>
</span><span class='line'>    <span class="cp">#import &quot;CYLBlockExecutor.h&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@implementation</span> <span class="bp">NSObject</span> <span class="nl">(CYLRunAtDealloc)</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">cyl_runAtDealloc</span><span class="p">:(</span><span class="n">voidBlock</span><span class="p">)</span><span class="n">block</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CYLBlockExecutor</span> <span class="o">*</span><span class="n">executor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CYLBlockExecutor</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span>
</span><span class='line'>                                     <span class="n">runAtDeallocBlockKey</span><span class="p">,</span>
</span><span class='line'>                                     <span class="n">executor</span><span class="p">,</span>
</span><span class='line'>                                     <span class="n">OBJC_ASSOCIATION_RETAIN</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="err">使用方法：</span>
</span><span class='line'><span class="err">导入</span>
</span><span class='line'>
</span><span class='line'>    <span class="cp">#import &quot;CYLNSObject+RunAtDealloc.h&quot;</span>
</span><span class='line'><span class="err">然后就可以使用了：</span>
</span><span class='line'>
</span><span class='line'>        <span class="bp">NSObject</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">foo</span> <span class="nl">cyl_runAtDealloc</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;正在释放foo!&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">如果对`</span><span class="n">cyl_runAtDealloc</span><span class="err">`的实现原理有兴趣，可以看下这篇博文</span> <span class="p">[</span><span class="o">***</span><span class="n">Fun</span> <span class="n">With</span> <span class="n">the</span> <span class="n">Objective</span><span class="o">-</span><span class="n">C</span> <span class="nl">Runtime</span><span class="p">:</span> <span class="n">Run</span> <span class="n">Code</span> <span class="n">at</span> <span class="n">Deallocation</span> <span class="n">of</span> <span class="n">Any</span> <span class="n">Object</span><span class="o">***</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//stackoverflow.com/a/31560217/3395008)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</span>
</span><span class='line'><span class="err">属性可以拥有的特质分为四类</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">原子性</span><span class="o">---</span><span class="err">`</span><span class="k">nonatomic</span><span class="err">`特质</span>
</span><span class='line'>
</span><span class='line'>    <span class="err">在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性</span><span class="p">(</span><span class="n">atomicity</span><span class="p">)</span><span class="err">。如果属性具备</span><span class="k">nonatomic</span><span class="err">特质，则不使用同步锁。请注意，尽管没有名为“</span><span class="k">atomic</span><span class="err">”的特质</span><span class="p">(</span><span class="err">如果某属性不具备</span><span class="k">nonatomic</span><span class="err">特质，那它就是“原子的”</span> <span class="p">(</span> <span class="k">atomic</span><span class="p">)</span> <span class="p">)</span><span class="err">，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">2.</span> <span class="err">读</span><span class="o">/</span><span class="err">写权限</span><span class="o">---</span><span class="err">`</span><span class="k">readwrite</span><span class="p">(</span><span class="err">读写</span><span class="p">)</span><span class="err">`、`</span><span class="n">readooly</span> <span class="p">(</span><span class="err">只读</span><span class="p">)</span><span class="err">`</span>
</span><span class='line'> <span class="mf">3.</span> <span class="err">内存管理语义</span><span class="o">---</span><span class="err">`</span><span class="k">assign</span><span class="err">`、`</span><span class="k">strong</span><span class="err">`、</span> <span class="err">`</span><span class="k">weak</span><span class="err">`、`</span><span class="k">unsafe_unretained</span><span class="err">`、`</span><span class="k">copy</span><span class="err">`</span>
</span><span class='line'> <span class="mf">4.</span> <span class="err">方法名</span><span class="o">---</span><span class="err">`</span><span class="k">getter</span><span class="o">=&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="err">`</span> <span class="err">、`</span><span class="k">setter</span><span class="o">=&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="err">`</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">`</span><span class="k">getter</span><span class="o">=&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="err">`的样式：</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">getter</span><span class="o">=</span><span class="n">isOn</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">on</span><span class="p">;</span>
</span><span class='line'><span class="err">（</span> <span class="err">`</span><span class="k">setter</span><span class="o">=&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="err">`这种不常用，也不推荐使用。故不在这里给出写法。）</span>
</span><span class='line'> <span class="mf">3.</span> <span class="err">不常用的：`</span><span class="n">nonnull</span><span class="err">`</span><span class="p">,</span><span class="err">`</span><span class="n">null_resettable</span><span class="err">`</span><span class="p">,</span><span class="err">`</span><span class="n">nullable</span><span class="err">`</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###10. weak属性需要在dealloc中置nil么？</span>
</span><span class='line'><span class="err">不需要。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="err">在</span><span class="n">ARC</span><span class="err">环境无论是强指针还是弱指针都无需在</span> <span class="n">dealloc</span> <span class="err">设置为</span> <span class="nb">nil</span> <span class="err">，</span> <span class="n">ARC</span> <span class="err">会自动帮我们处理</span>
</span><span class='line'>
</span><span class='line'><span class="err">即便是编译器不帮我们做这些，</span><span class="k">weak</span><span class="err">也不需要在</span><span class="n">dealloc</span><span class="err">中置</span><span class="nb">nil</span><span class="err">：</span>
</span><span class='line'>
</span><span class='line'><span class="err">正如上文的：</span><span class="o">***</span><span class="n">runtime</span> <span class="err">如何实现</span> <span class="k">weak</span> <span class="err">属性</span><span class="o">***</span> <span class="err">中提到的：</span>
</span><span class='line'>
</span><span class='line'><span class="err">我们模拟下</span><span class="k">weak</span><span class="err">的</span><span class="k">setter</span><span class="err">方法，应该如下：</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setObject</span><span class="p">:(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="s">&quot;object&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_ASSIGN</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">object</span> <span class="nl">cyl_runAtDealloc</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="n">_object</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="err">也即</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="err">在属性所指的对象遭到摧毁时，属性值也会清空</span><span class="p">(</span><span class="nb">nil</span> <span class="k">out</span><span class="p">)</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###11. @synthesize和@dynamic分别有什么作用？</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="k">@property</span><span class="err">有两个对应的词，一个是</span><span class="k">@synthesize</span><span class="err">，一个是</span><span class="k">@dynamic</span><span class="err">。如果</span><span class="k">@synthesize</span><span class="err">和</span><span class="k">@dynamic</span><span class="err">都没写，那么默认的就是`</span><span class="p">@</span><span class="n">syntheszie</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_var</span><span class="p">;</span><span class="err">`</span>
</span><span class='line'> <span class="mf">2.</span> <span class="k">@synthesize</span><span class="err">的语义是如果你没有手动实现</span><span class="k">setter</span><span class="err">方法和</span><span class="k">getter</span><span class="err">方法，那么编译器会自动为你加上这两个方法。</span>
</span><span class='line'> <span class="mf">3.</span> <span class="k">@dynamic</span><span class="err">告诉编译器：属性的</span><span class="k">setter</span><span class="err">与</span><span class="k">getter</span><span class="err">方法由用户自己实现，不自动生成。（当然对于</span><span class="k">readonly</span><span class="err">的属性只需提供</span><span class="k">getter</span><span class="err">即可）。假如一个属性被声明为</span><span class="k">@dynamic</span> <span class="n">var</span><span class="err">，然后你没有提供</span><span class="p">@</span><span class="k">setter</span><span class="err">方法和</span><span class="p">@</span><span class="k">getter</span><span class="err">方法，编译的时候没问题，但是当程序运行到`</span><span class="n">instance</span><span class="p">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">someVar</span><span class="err">`，由于缺</span><span class="k">setter</span><span class="err">方法会导致程序崩溃；或者当运行到</span> <span class="err">`</span><span class="n">someVar</span> <span class="o">=</span> <span class="n">var</span><span class="err">`时，由于缺</span><span class="k">getter</span><span class="err">方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">对应基本数据类型默认关键字是</span>
</span><span class='line'>
</span><span class='line'> <span class="k">atomic</span><span class="p">,</span><span class="k">readwrite</span><span class="p">,</span><span class="k">assign</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">对于普通的</span><span class="n">OC</span><span class="err">对象</span>
</span><span class='line'>
</span><span class='line'> <span class="k">atomic</span><span class="p">,</span><span class="k">readwrite</span><span class="p">,</span><span class="k">strong</span>
</span><span class='line'>
</span><span class='line'><span class="err">参考链接：</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="p">[</span> <span class="o">***</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span> <span class="nl">ARC</span><span class="p">:</span> <span class="k">strong</span> <span class="n">vs</span> <span class="k">retain</span> <span class="n">and</span> <span class="k">weak</span> <span class="n">vs</span> <span class="k">assign</span><span class="o">***</span> <span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//stackoverflow.com/a/15541801/3395008)</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">2.</span> <span class="p">[</span> <span class="o">***</span><span class="n">Variable</span> <span class="n">property</span> <span class="n">attributes</span> <span class="n">or</span> <span class="n">Modifiers</span> <span class="k">in</span> <span class="n">iOS</span><span class="o">***</span> <span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">因为父类指针可以指向子类对象</span><span class="p">,</span><span class="err">使用</span><span class="k">copy</span><span class="err">的目的是为了让本对象的属性不受外界影响</span><span class="p">,</span><span class="err">使用</span><span class="k">copy</span><span class="err">无论给我传入是一个可变对象还是不可对象</span><span class="p">,</span><span class="err">我本身持有的就是一个不可变的副本</span><span class="p">.</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">如果我们使用是</span><span class="k">strong</span><span class="p">,</span><span class="err">那么这个属性就有可能指向一个可变对象</span><span class="p">,</span><span class="err">如果这个可变对象在外部被修改了</span><span class="p">,</span><span class="err">那么会影响该属性</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="k">copy</span><span class="err">此特质所表达的所属关系与</span><span class="k">strong</span><span class="err">类似。然而设置方法并不保留新值，而是将其“拷贝”</span> <span class="p">(</span><span class="k">copy</span><span class="p">)</span><span class="err">。</span>
</span><span class='line'><span class="err">当属性类型为</span><span class="bp">NSString</span><span class="err">时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个</span><span class="bp">NSMutableString</span><span class="err">类的实例。这个类是</span><span class="bp">NSString</span><span class="err">的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”</span> <span class="p">(</span><span class="n">immutable</span><span class="p">)</span><span class="err">的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”</span> <span class="p">(</span><span class="n">mutable</span><span class="p">)</span><span class="err">，就应该在设置新属性值时拷贝一份。</span>
</span><span class='line'>
</span><span class='line'><span class="err">为了理解这种做法，首先要知道，对非集合类对象的</span><span class="k">copy</span><span class="err">操作：</span>
</span><span class='line'>
</span><span class='line'><span class="err">在非集合类对象中：对</span><span class="n">immutable</span><span class="err">对象进行</span><span class="k">copy</span><span class="err">操作，是指针复制，</span><span class="n">mutableCopy</span><span class="err">操作时内容复制；对</span><span class="n">mutable</span><span class="err">对象进行</span><span class="k">copy</span><span class="err">和</span><span class="n">mutableCopy</span><span class="err">都是内容复制。用代码简单表示如下：</span>
</span><span class='line'>
</span><span class='line'> <span class="o">-</span> <span class="p">[</span><span class="n">immutableObject</span> <span class="k">copy</span><span class="p">]</span> <span class="c1">// 浅复制</span>
</span><span class='line'> <span class="o">-</span> <span class="p">[</span><span class="n">immutableObject</span> <span class="n">mutableCopy</span><span class="p">]</span> <span class="c1">//深复制</span>
</span><span class='line'> <span class="o">-</span> <span class="p">[</span><span class="n">mutableObject</span> <span class="k">copy</span><span class="p">]</span> <span class="c1">//深复制</span>
</span><span class='line'> <span class="o">-</span> <span class="p">[</span><span class="n">mutableObject</span> <span class="n">mutableCopy</span><span class="p">]</span> <span class="c1">//深复制</span>
</span><span class='line'>  
</span><span class='line'><span class="err">比如以下代码：</span>
</span><span class='line'>
</span><span class='line'>  <span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableString</span> <span class="nl">stringWithString</span><span class="p">:</span><span class="s">@&quot;origin&quot;</span><span class="p">];</span><span class="c1">//copy</span>
</span><span class='line'>  <span class="bp">NSString</span> <span class="o">*</span><span class="n">stringCopy</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="err">查看内存，会发现</span> <span class="n">string</span><span class="err">、</span><span class="n">stringCopy</span> <span class="err">内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">[</span><span class="n">string</span> <span class="nl">appendString</span><span class="p">:</span><span class="s">@&quot;origion!&quot;</span><span class="p">]</span>
</span><span class='line'><span class="n">stringCopy</span><span class="err">的值也不会因此改变，但是如果不使用</span><span class="k">copy</span><span class="err">，</span><span class="n">stringCopy</span><span class="err">的值就会被改变。</span>
</span><span class='line'>  <span class="err">集合类对象以此类推。</span>
</span><span class='line'><span class="err">所以，</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="err">用</span><span class="k">@property</span><span class="err">声明</span> <span class="bp">NSString</span><span class="err">、</span><span class="bp">NSArray</span><span class="err">、</span><span class="bp">NSDictionary</span> <span class="err">经常使用</span><span class="k">copy</span><span class="err">关键字，是因为他们有对应的可变类型：</span><span class="bp">NSMutableString</span><span class="err">、</span><span class="bp">NSMutableArray</span><span class="err">、</span><span class="bp">NSMutableDictionary</span><span class="err">，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</span>
</span><span class='line'>
</span><span class='line'><span class="err">参考链接：</span><span class="p">[</span><span class="n">iOS</span> <span class="err">集合的深复制与浅复制</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.zybuluo.com/MicroCai/note/50592)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为`_foo`的实例变量，那么还会自动合成新变量么？</span>
</span><span class='line'><span class="err">在回答之前先说明下一个概念：</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="err">实例变量</span> <span class="o">=</span> <span class="err">成员变量</span> <span class="err">＝</span> <span class="n">ivar</span>
</span><span class='line'>
</span><span class='line'><span class="err">这些说法，笔者下文中，可能都会用到，指的是一个东西。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">正如</span>
</span><span class='line'><span class="p">[</span><span class="n">Apple</span><span class="err">官方文档</span> <span class="o">***</span><span class="n">You</span> <span class="n">Can</span> <span class="n">Customize</span> <span class="n">Synthesized</span> <span class="n">Instance</span> <span class="n">Variable</span> <span class="n">Names</span><span class="o">***</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6) 所说：</span>
</span><span class='line'><span class="o">!</span><span class="p">[</span><span class="n">enter</span> <span class="n">image</span> <span class="n">description</span> <span class="n">here</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//i.imgur.com/D6d0zGJ.png)</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”</span><span class="p">(</span> <span class="k">auto</span> <span class="n">synthesis</span><span class="p">)</span><span class="err">。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法”</span> <span class="p">(</span><span class="n">synthesized</span> <span class="n">method</span><span class="p">)</span><span class="err">的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</span>
</span><span class='line'>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C
@interface CYLPerson : NSObject
@property NSString <em>firstName;
@property NSString </em>lastName;
@end</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="err">在上例中，会生成两个实例变量，其名称分别为</span>
</span><span class='line'><span class="err">`</span><span class="n">_firstName</span><span class="err">`与`</span><span class="n">_lastName</span><span class="err">`。也可以在类的实现代码里通过`</span><span class="k">@synthesize</span><span class="err">`语法来指定实例变量的名字</span><span class="o">:</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C
@implementation CYLPerson
@synthesize firstName = <em>myFirstName;
@synthesize lastName = </em>myLastName;
@end</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="err">上述语法会将生成的实例变量命名为`</span><span class="n">_myFirstName</span><span class="err">`与`</span><span class="n">_myLastName</span><span class="err">`，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</span>
</span><span class='line'>
</span><span class='line'><span class="err">总结下</span><span class="k">@synthesize</span><span class="err">合成实例变量的规则，有以下几点：</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">如果指定了成员变量的名称</span><span class="p">,</span><span class="err">会生成一个指定的名称的成员变量</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">2.</span> <span class="err">如果这个成员已经存在了就不再生成了</span><span class="p">.</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">如果是</span> <span class="err">`</span><span class="k">@synthesize</span> <span class="n">foo</span><span class="p">;</span><span class="err">`</span> <span class="err">还会生成一个名称为</span><span class="n">foo</span><span class="err">的成员变量，也就是说：</span>
</span><span class='line'>
</span><span class='line'> <span class="o">&gt;</span> <span class="err">如果没有指定成员变量的名称会自动生成一个属性同名的成员变量</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="mf">2.</span> <span class="err">如果是</span> <span class="err">`</span><span class="k">@synthesize</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">_foo</span><span class="p">;</span><span class="err">`</span> <span class="err">就不会生成成员变量了</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="err">假如</span><span class="n">property</span><span class="err">名为</span><span class="n">foo</span><span class="err">，存在一个名为</span><span class="n">_foo</span><span class="err">的实例变量，那么还会自动合成新变量么？</span>
</span><span class='line'><span class="err">不会。如下图：</span>
</span><span class='line'>
</span><span class='line'><span class="o">!</span><span class="p">[</span><span class="n">enter</span> <span class="n">image</span> <span class="n">description</span> <span class="n">here</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//i.imgur.com/t28ge4W.png)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</span>
</span><span class='line'>
</span><span class='line'><span class="err">回答这个问题前，我们要搞清楚一个问题，什么情况下不会</span><span class="n">autosynthesis</span><span class="err">（自动合成）？</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">同时重写了</span><span class="k">setter</span><span class="err">和</span><span class="k">getter</span><span class="err">时</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">重写了只读属性的</span><span class="k">getter</span><span class="err">时</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">使用了</span><span class="k">@dynamic</span><span class="err">时</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">在</span> <span class="k">@protocol</span> <span class="err">中定义的所有属性</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">在</span> <span class="n">category</span> <span class="err">中定义的所有属性</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">重载的属性</span>
</span><span class='line'>
</span><span class='line'> <span class="err">当你在子类中重载了父类中的属性，你必须</span> <span class="err">使用`</span><span class="k">@synthesize</span><span class="err">`来手动合成</span><span class="n">ivar</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理</span><span class="k">@property</span><span class="err">的所有内容时，你就会尝试通过实现</span><span class="k">@property</span><span class="err">的所有“存取方法”（</span><span class="n">the</span> <span class="n">accessor</span> <span class="n">methods</span><span class="err">）或者使用`</span><span class="k">@dynamic</span><span class="err">`来达到这个目的，这时编译器就会认为你打算手动管理</span><span class="k">@property</span><span class="err">，于是编译器就禁用了</span><span class="n">autosynthesis</span><span class="err">（自动合成）。</span>
</span><span class='line'>
</span><span class='line'><span class="err">因为有了</span><span class="n">autosynthesis</span><span class="err">（自动合成），大部分开发者已经习惯不去手动定义</span><span class="n">ivar</span><span class="err">，而是依赖于</span><span class="n">autosynthesis</span><span class="err">（自动合成），但是一旦你需要使用</span><span class="n">ivar</span><span class="err">，而</span><span class="n">autosynthesis</span><span class="err">（自动合成）又失效了，如果不去手动定义</span><span class="n">ivar</span><span class="err">，那么你就得借助`</span><span class="k">@synthesize</span><span class="err">`来手动合成</span><span class="n">ivar</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">其实，`</span><span class="k">@synthesize</span><span class="err">`语法还有一个应用场景，但是不太建议大家使用：</span>
</span><span class='line'>
</span><span class='line'><span class="err">可以在类的实现代码里通过`</span><span class="k">@synthesize</span><span class="err">`语法来指定实例变量的名字</span><span class="o">:</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C
@implementation CYLPerson
@synthesize firstName = <em>myFirstName;
@synthesize lastName = </em>myLastName;
@end</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="err">上述语法会将生成的实例变量命名为`</span><span class="n">_myFirstName</span><span class="err">`与`</span><span class="n">_myLastName</span><span class="err">`，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">举例说明：应用场景：</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//</span>
</span><span class='line'>  <span class="c1">// .m文件</span>
</span><span class='line'>  <span class="c1">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
</span><span class='line'>  <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>  <span class="c1">// 打开第14行和第17行中任意一行，就可编译成功</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">@</span><span class="n">import</span> <span class="n">Foundation</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">@interface</span> <span class="nc">CYLObject</span> : <span class="bp">NSObject</span>
</span><span class='line'>  <span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">title</span><span class="p">;</span>
</span><span class='line'>  <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">@implementation</span> <span class="nc">CYLObject</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//    NSString *_title;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//@synthesize title = _title;</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="n">init</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">_title</span> <span class="o">=</span> <span class="s">@&quot;微博@iOS程序犭袁&quot;</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">title</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">_title</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setTitle</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">title</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_title</span> <span class="o">=</span> <span class="p">[</span><span class="n">title</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">@end</span>
</span><span class='line'><span class="err">结果编译器报错：</span>
</span><span class='line'><span class="o">!</span><span class="p">[</span><span class="n">enter</span> <span class="n">image</span> <span class="n">description</span> <span class="n">here</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//i.imgur.com/fAEGHIo.png)</span>
</span><span class='line'>
</span><span class='line'><span class="err">当你同时重写了</span><span class="k">setter</span><span class="err">和</span><span class="k">getter</span><span class="err">时，系统就不会生成</span><span class="n">ivar</span><span class="err">（实例变量</span><span class="o">/</span><span class="err">成员变量）。这时候有两种选择：</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">要么如第</span><span class="mi">14</span><span class="err">行：手动创建</span><span class="n">ivar</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">要么如第</span><span class="mi">17</span><span class="err">行：使用`</span><span class="k">@synthesize</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">_foo</span><span class="p">;</span><span class="err">`</span> <span class="err">，关联</span><span class="k">@property</span><span class="err">与</span><span class="n">ivar</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">更多信息，请戳</span><span class="o">-</span> <span class="err">》</span><span class="p">[</span> <span class="o">***</span><span class="n">When</span> <span class="n">should</span> <span class="n">I</span> <span class="n">use</span> <span class="k">@synthesize</span> <span class="n">explicitly</span><span class="o">?***</span> <span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//stackoverflow.com/a/19821816/3395008)</span>
</span><span class='line'><span class="cp">###16. objc中向一个nil对象发送消息将会发生什么？</span>
</span><span class='line'><span class="err">在</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span><span class="err">中向</span><span class="nb">nil</span><span class="err">发送消息是完全有效的——只是在运行时不会有任何作用</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">如果一个方法返回值是一个对象，那么发送给</span><span class="nb">nil</span><span class="err">的消息将返回</span><span class="mi">0</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span><span class="err">。例如：</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="err">```</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span>
</span><span class='line'><span class="n">Person</span> <span class="o">*</span> <span class="n">motherInlaw</span> <span class="o">=</span> <span class="p">[[</span><span class="n">aPerson</span> <span class="n">spouse</span><span class="p">]</span> <span class="n">mother</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p> 如果spouse对象为nil，那么发送给nil的消息mother也将返回nil。
 2. 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。
 2. 如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0。
 2. 如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。</p>

<p>具体原因如下：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="c1">// runtime.h（类在runtime中的定义）</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">objc_class</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">Class</span> <span class="n">isa</span> <span class="n">OBJC_ISA_AVAILABILITY</span><span class="p">;</span> <span class="c1">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span>
</span><span class='line'>  <span class="cp">#if !__OBJC2__</span>
</span><span class='line'>  <span class="kt">Class</span> <span class="n">super_class</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 父类</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 类名</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">version</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 类的版本信息，默认为0</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">info</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 类信息，供运行期使用的一些位标识</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">instance_size</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 该类的实例变量大小</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_ivar_list</span> <span class="o">*</span><span class="n">ivars</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 该类的成员变量链表</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_method_list</span> <span class="o">**</span><span class="n">methodLists</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 方法定义的链表</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_cache</span> <span class="o">*</span><span class="n">cache</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_protocol_list</span> <span class="o">*</span><span class="n">protocols</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 协议链表</span>
</span><span class='line'>  <span class="cp">#endif</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。
那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>

<h3>17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3>

<p>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.如果我没有记错的大概是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="p">((</span><span class="kt">void</span> <span class="p">()(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">obj</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说：</p>

<blockquote><p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p></blockquote>

<h3>18. 什么时候会报unrecognized selector的异常？</h3>

<p>简单来说：</p>

<blockquote><p>当使用某对象上的某个方法,而该对象上没有实现这个方法的时候，
可以通过“消息转发”进行解决。</p></blockquote>

<p>简单的流程如下，在上一题中也提到过：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>

<ol>
<li>Method resolution</li>
</ol>


<p> objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回 YES，那运行时系统就会重新启动一次消息发送的过程，如果 resolve 方法返回 NO ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>

<ol>
<li>Fast forwarding</li>
</ol>


<p> 如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。
这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。
 3. Normal forwarding</p>

<p> 这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>

<h3>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3>

<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li><p>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</p></li>
<li><p>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</p></li>
<li>成员变量的列表,</li>
<li>属性列表,</li>
</ul>


<p> 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>

<p> <img src="http://i.imgur.com/7mJlUj1.png" alt="enter image description here" /></p>

<ul>
<li><p>根对象就是NSobject，它的superclass指针指向nil</p></li>
<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p></li>
</ul>


<p>如图:
<img src="http://i.imgur.com/w6tzFxz.png" alt="enter image description here" /></p>

<h3>20. 一个objc对象的isa的指针指向什么？有什么作用？</h3>

<p>指向他的类对象,从而可以找到对象上的方法</p>

<h3>21. 下面的代码输出什么？</h3>

<pre><code>@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre>

<p><strong>答案：</strong></p>

<p>都输出 Son</p>

<pre><code>NSStringFromClass([self class]) = Son
NSStringFromClass([super class]) = Son
</code></pre>

<p><strong>解惑：</strong></p>

<p>（以下解惑部分摘自<a href="http://weibo.com/junbbcom">微博@Chun_iOS</a>的博文<a href="http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1">刨根问底Objective－C Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)）</p>

<p>这个题目主要是考察关于objc中对 self 和 super 的理解。</p>

<p>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。</p>

<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>

<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>

<p>真的是这样吗？继续看：</p>

<p>使用clang重写命令:</p>

<pre><code>$ clang -rewrite-objc test.m
</code></pre>

<p>发现上述代码被转化为:</p>

<pre><code>NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName("class"))));

NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass("Son")) }, sel_registerName("class"))));
</code></pre>

<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>

<pre><code>id objc_msgSend(id self, SEL op, ...)
</code></pre>

<p>我们把 self 做为第一个参数传递进去。</p>

<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>

<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</code></pre>

<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>

<pre><code>struct objc_super {
   __unsafe_unretained id receiver;
   __unsafe_unretained Class super_class;
};
</code></pre>

<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>

<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>

<p>objc Runtime开源代码对- (Class)class方法的实现:</p>

<pre><code>- (Class)class {
    return object_getClass(self);
}
</code></pre>

<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。
第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。
第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，
此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>

<h3>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3>

<p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>

<h3>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3>

<ul>
<li>在ARC下不需要。</li>
<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>
</ul>


<blockquote><p>无论在MRC下还是ARC下均不需要。</p></blockquote>

<p><a href="https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html"> <strong><em>2011年版本的Apple API 官方文档 - Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="c1">// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">// 摘自2011年版本的Apple API 官方文档 - Associative References </span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">char</span> <span class="n">overviewKey</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithObjects</span><span class="p">:</span><span class="s">@&quot;One&quot;</span><span class="p">,</span> <span class="s">@&quot;Two&quot;</span><span class="p">,</span> <span class="s">@&quot;Three&quot;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="c1">// For the purposes of illustration, use initWithFormat: to ensure</span>
</span><span class='line'><span class="c1">// the string can be deallocated</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">overview</span> <span class="o">=</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="s">@&quot;First three numbers&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">objc_setAssociatedObject</span> <span class="p">(</span>
</span><span class='line'>    <span class="n">array</span><span class="p">,</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">overviewKey</span><span class="p">,</span>
</span><span class='line'>    <span class="n">overview</span><span class="p">,</span>
</span><span class='line'>    <span class="n">OBJC_ASSOCIATION_RETAIN</span>
</span><span class='line'><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">overview</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'><span class="c1">// (1) overview valid</span>
</span><span class='line'><span class="p">[</span><span class="n">array</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'><span class="c1">// (2) overview invalid</span>
</span></code></pre></td></tr></table></div></figure>


<p>文档指出</p>

<blockquote><p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p></blockquote>

<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>

<p>既然会被销毁，那么具体在什么时间点？</p>

<blockquote><p>根据<a href="https://developer.apple.com/videos/wwdc/2011/#322-video"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p></blockquote>

<p>对象的内存销毁时间表，分四个步骤：</p>

<pre><code>// 对象的内存销毁时间表
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 

// 1. 调用 -release ：引用计数变为零
//     * 对象正在被销毁，生命周期即将结束.
//     * 不能再有新的 __weak 弱引用， 否则将指向 nil.
//     * 调用 [self dealloc] 
// 2. 父类 调用 -dealloc
//     * 继承关系中最底层的父类 在调用 -dealloc
//     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）
//     * 继承关系中每一层的父类 都在调用 -dealloc
// 3. NSObject 调 -dealloc
//     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法
// 4. 调用 object_dispose()
//     * 为 C++ 的实例变量们（iVars）调用 destructors 
//     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
//     * 解除所有使用 runtime Associate方法关联的对象
//     * 解除所有 __weak 引用
//     * 调用 free()
</code></pre>

<p>（<a href="http://stackoverflow.com/a/10843510/3395008">对象的内存销毁时间表参考链接</a>）</p>

<h3>24. objc中的类方法和实例方法有什么本质区别和联系？</h3>

<p>类方法：</p>

<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ol>


<p>实例方法：</p>

<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>


<h2>下一篇文章将发布在<a href="https://github.com/ChenYilong/iOSInterviewQuestions">这里</a>，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注<a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a></h2>

<p>@property部分主要参考
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2">Apple官方文档：Properties Encapsulate an Object’s Values</a>
runtime部分主要参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html">Apple官方文档：Declared Properties</a></p>

<h3>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3>

<h3>26. runtime如何实现weak变量的自动置nil？</h3>

<h3>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3>

<h3>28. runloop和线程有什么关系？</h3>

<h3>29. runloop的mode作用是什么？</h3>

<h3>30. 以+ scheduledTimerWithTimeInterval&hellip;的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3>

<h3>31. 猜想runloop内部是如何实现的？</h3>

<h3>32. objc使用什么机制管理对象内存？</h3>

<h3>33. ARC通过什么方式帮助开发者管理内存？</h3>

<h3>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3>

<h3>35. <code>BAD_ACCESS</code>在什么情况下出现？</h3>

<h3>36. 苹果是如何实现autoreleasepool的？</h3>

<h3>37. 使用block时什么情况会发生引用循环，如何解决？</h3>

<h3>38. 在block内如何修改block外部变量？</h3>

<h3>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3>

<h3>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3>

<h3>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3>

<h3>42. <code>dispatch_barrier_async</code>的作用是什么？</h3>

<h3>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3>

<h3>44. 以下代码运行结果如何？</h3>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
</code></pre>

<h3>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3>

<h3>46. 如何手动触发一个value的KVO</h3>

<h3>47. 若一个类有实例变量<code>NSString *_foo</code>，调用setValue:forKey:时，可以以foo还是<code>_foo</code>作为key？</h3>

<h3>48. KVC的keyPath中的集合运算符如何使用？</h3>

<h3>49. KVC和KVO的keyPath一定是属性么？</h3>

<h3>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3>

<h3>51. apple用什么方式实现对一个对象的KVO？</h3>

<h3>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3>

<h3>53. IB中User Defined Runtime Attributes如何使用？</h3>

<h3>54. 如何调试<code>BAD_ACCESS</code>错误</h3>

<h3>55. lldb（gdb）常用的调试命令？</h3>

<hr />

<p>Posted by <a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a><br/>
原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">Creative Commons BY-NC-ND 3.0</a></p>
</div>
<!--广告位-->
<script type="text/javascript">
    /*刚刚在线700*350 创建于 2015-07-31*/
    var cpro_id = "u2238872";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">李刚</span></span>

      




<time class='entry-date' datetime='2015-08-08T00:16:38+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:16 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/tui-jian/'>推荐</a>
  
</span>


      <br>来源：刚刚在线（微信：iOSDevTip），欢迎分享本文，转载请保留出处！
<br>原文链接：<a href="http://www.superqq.com/blog/2015/08/08/interview-ios-question-answer/">http://www.superqq.com/blog/2015/08/08/interview-ios-question-answer/</a> <!-- 添加这一行代码 -->
    </p>
    
      <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_tools_1"></a>
    <a class="jiathis_button_tools_2"></a>
    <a class="jiathis_button_tools_3"></a>
    <a class="jiathis_button_tools_4"></a>
    <a href="http://www.jiathis.com/share?uid=1983651" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
    var jiathis_config = {data_track_clickback:'true'};
    </script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1401863435807252" charset="utf-8"></script>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/08/07/implement-uitextview-placeholder/" title="Previous Post: 实现placeholder属性的UITextView">&laquo; 实现placeholder属性的UITextView</a>
      
      
    </p>
  </footer>
</article>


  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-title="《招聘一个靠谱的iOS》面试题参考答案（上）"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"superqq"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END -->
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
<!--广告位-->
<script type="text/javascript">
    /*刚刚在线250*350 创建于 2015-07-31*/
    var cpro_id = "u2238366";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
  <h1>微信扫一扫，代码写的好</h1>
        <br/>
        <br/><strong>东半球最好的iOS开发公众号</strong> 
        <br/>
        <br/><img width="220px" src="http://images.90159.com/icon/iOSDevTip.jpg" />
        <br/>
        <br/><strong>东半球最好的程序猿公众号</strong>
        <br/>
        <br/><img width="220px" src="http://images.90159.com/icon/codepush.jpg" />
        </p>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/08/interview-ios-question-answer/">《招聘一个靠谱的iOS》面试题参考答案（上）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/07/implement-uitextview-placeholder/">实现placeholder属性的UITextView</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/06/uitextview-placeholder-practice/">UITextView实现placeholder的猥琐做法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/05/multiple-uiimage-merged/">多个UIImage合并成一个UIImage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/04/save-photo-to-own-album/">iOS开发之保存照片到自己创建的相簿</a>
      </li>
    
  </ul>
</section>
</section>
<section>
    <h1>About Me</h1>
    <br/>
    <p> 李刚：百度百家专栏作者，刚刚在线站长，iOS工程师非著名自媒体人，微信公众号iOS开发：iOSDevTip运营者<br/>
    <br/><strong>出师未捷名已落</strong>
    <br/>
    <br/>新浪微博: <a href='http://weibo.com/ligangnc' target='_blank'>李刚移动</a>
    <br/>
    <br/>个人微信: <strong>chinaligang</strong> 欢迎调戏
    <br/>
    <br/>iOS群: <strong>218822587</strong>
  <br/>
</section>

   
 <section>
    <h1>友情链接</h1>
    <ul>
    
       <li>
           <a href="http://www.superqq.com" target="_blank" title=“刚刚在线”>刚刚在线</a>
       </li>
       <li>
           <a href="http://www.90159.com" target="_blank" title=“程序员头条”>程序员头条</a>
       </li>
       <li>
           <a href="http://www.iswifting.com" target="_blank" title=“swift开发”>swift开发</a>
       </li>
       <li>
           <a href="http://www.aswifter.com/" target="_blank" title="APP开发者">APP开发者</a>
       </li>
        <li>
           <a href="http://www.boxingjiaoyu.com/" target="_blank" title="程序员聚合平台">程序员聚合平台</a>
       </li>
      <li>
           <a href="http://www.mobile-open.com/" target="_blank" title="阳和移动开发">阳和移动开发</a>
       </li>
       <li>
           <a href="http://www.jq-school.com/" target="_blank" title="jquery教程">jquery教程</a>
       </li>
        <li>
           <a href="http://www.admin10000.com/" target="_blank" title="WEB开发者">WEB开发者</a>
       </li>
       <li>
           <a href="http://www.aichengxu.com/" target="_blank" title="爱程序网">爱程序网</a>
       </li>
       <li>
           <a href="http://www.lai18.com" target="_blank" title="IT技术文章">IT技术文章</a>
       </li>
       <li>
           <a href="http://www.cftea.com/" target="_blank" title="千一网络">千一网络</a>
       </li>
        <li>
           <a href="http://www.bmob.cn/" target="_blank" title="Bmob">Bmob移动后端云</a>
       </li>
       <li>
           <a href="http://www.leichunfeng.com" target="_blank" title="雷纯锋的技术博客">雷纯锋的技术博客</a>
       </li>
       <li>
           <a href="http://cuiqingcai.com/" target="_blank" title="静觅">静觅</a>
       </li>
       <li>
           <a href="http://letsswift.com/" target="_blank" title="一起Swift">一起Swift</a>
       </li>
       <li>
           <a href="http://www.swiftv.cn/" target="_blank" title="SwiftV课堂">SwiftV课堂</a>
       </li>
        <li>
            <a href="http://blog.csdn.net/iosdevtip" target="_blank" title="刚刚在线">CSDN</a>
        </li>
        <li>
            <a href="http://user.qzone.qq.com/1606535851" target="_blank" title="刚刚在线">QQ空间</a>
        </li>
        <li>
            <br/><strong>交换友链：</strong>欢迎各大程序员站点交换友情链接，如需交换，请添加好本站链接后发送邮件至下方邮箱。
            <br/>
            <br/><strong>格式：</strong>（ 友链文字：“ 刚刚在线 ”，链接：“ http://www.superqq.com/ ” ）
            <br/>
            <br/><strong>邮箱：</strong>worldligang@163.com
            <br/>
        </li>
    </ul>
<br/>
<h1>热门推荐</h1>
<!--广告位-->
<script type="text/javascript">
var cpro_id="u2240614";
(window["cproStyleApi"] = window["cproStyleApi"] || {})[cpro_id]={at:"3",rsi0:"250",rsi1:"350",pat:"6",tn:"baiduCustNativeAD",rss1:"#FFFFFF",conBW:"1",adp:"1",ptt:"0",titFF:"%E5%BE%AE%E8%BD%AF%E9%9B%85%E9%BB%91",titFS:"14",rss2:"#000000",titSU:"0",ptbg:"90",piw:"0",pih:"0",ptp:"0"}
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
Copyright &copy; 2015 - 李刚 
<span class="credit">Powered by <a href="http://octopress.org" target="_blank">Octopress</a></span>
 <span class="credit">, 感谢 <a href="http://gitcafe.com/signup?invited_by=tangqiaoboy" target="_blank">GitCafe</a> 为本站提供存储空间</span>

</p>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/17443209.js"></script>
<noscript><a href="http://www.51.la/?17443209" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/17443209.asp" style="border:none" /></a></noscript>
</footer>
  











</body>
</html>
