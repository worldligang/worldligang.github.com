<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios开发 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-11-12T18:24:59+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Add "Remote-notification" to the List of Your Supported UIBackgroundModes in Your Info.plist.解决方案]]></title>
    <link href="http://www.superqq.com/blog/2015/11/12/remote-notification-error/"/>
    <updated>2015-11-12T18:21:17+08:00</updated>
    <id>http://www.superqq.com/blog/2015/11/12/remote-notification-error</id>
    <content type="html"><![CDATA[<p>做推送的童鞋可能会遇到这样的问题，控制台会打印一句话：</p>

<p>You&rsquo;ve implemented -[<UIApplicationDelegate> application:didReceiveRemoteNotification:fetchCompletionHandler:], but you still need to add &ldquo;remote-notification&rdquo; to the list of your supported UIBackgroundModes in your Info.plist.</p>

<p>解决办法：</p>

<p><img src="http://images.90159.com/11/error1.png" alt="error1" /></p>

<p>这个时候再去看看Info.plist文件：</p>

<p><img src="http://images.90159.com/11/error2.png" alt="error2" /></p>

<p>再次运行，问题就解决啦！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个非常不错的自定义UIAlertView第三方类库]]></title>
    <link href="http://www.superqq.com/blog/2015/10/30/two-nice-uialertview/"/>
    <updated>2015-10-30T10:08:00+08:00</updated>
    <id>http://www.superqq.com/blog/2015/10/30/two-nice-uialertview</id>
    <content type="html"><![CDATA[<p>UIAlertView大家都不陌生了。UIAlertView不可以添加控件，比如说：UILabel、UITextView等等，所以遇到这个需求，一般都要自定义UIAlertView来解决。</p>

<p>我再github上找到了两个非常错的自定义UIAlertView第三方类库，分别是：LMAlertView和CustomIOSAlertView。</p>

<h2>LMAlertView使用简介</h2>

<p><a href="https://github.com/lmcd/LMAlertView">LMAlertView</a>在github上有610个star。说明这个第三方的UIAlertView还不错，我大概看了一下用法也比较简单。</p>

<p>来看看两个个案例效果：</p>

<p><img src="https://camo.githubusercontent.com/eb9242282b703a847c5ca45ef47462ec507ba573/687474703a2f2f6c6d63642e6d652f4c4d416c657274566965772d637573746f6d4032782e706e67" alt="1" /></p>

<!--more-->


<p><img src="https://camo.githubusercontent.com/b1c95e3be84a8d277e1c542ca768b3bdebe043a6/687474703a2f2f6c6d63642e6d652f4c4d416c657274566965772d7265766965774032782e706e673f33" alt="2" /></p>

<h3>用CocoaPods安装LMAlertView</h3>

<pre><code>pod 'LMAlertView'
</code></pre>

<h3>使用案例</h3>

<pre><code>LMAlertView *alertView = [[LMAlertView alloc] initWithTitle:@"iOSDevTip"
                                        message:@"关注一下"
                                       delegate:nil
                              cancelButtonTitle:@"ok"
                              otherButtonTitles:nil];

// Add your subviews here to customise
UIView *contentView = alertView.contentView;

[alertView show];   
</code></pre>

<p>LMAlertView还保持着UIAlertView的创建方法，作者还比较用心。</p>

<h2>CustomIOSAlertView使用简介</h2>

<p><a href="https://github.com/wimagguc/ios-custom-alertview">CustomIOSAlertView</a>比LMAlertView的star还多一些，有861个。同样我们先看一下效果：</p>

<p><img src="https://github.com/wimagguc/ios-custom-alertview/raw/master/Docs/screen.png" alt="3" /></p>

<h3>用CocoaPods安装CustomIOSAlertView</h3>

<pre><code>pod 'CustomIOSAlertView', '~&gt; 0.9.3'
</code></pre>

<h3>使用案例</h3>

<pre><code>CustomIOSAlertView *alertView = [[CustomIOSAlertView alloc] init];  UIView *customView ..;

[alertView setContainerView:customView];
[alertView show];
</code></pre>

<p>CustomIOSAlertView可以设置代理，还可以通过block来实现按钮的点击事件。功能相对比较齐全。</p>

<p>喜欢的童鞋可以star一下，以备不时之需。如果你觉得不错，记得分享给更多朋友哈，谢谢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIViewController的edgesForExtendedLayout属性]]></title>
    <link href="http://www.superqq.com/blog/2015/10/09/uiviewcontroller-rectedge/"/>
    <updated>2015-10-09T16:36:41+08:00</updated>
    <id>http://www.superqq.com/blog/2015/10/09/uiviewcontroller-rectedge</id>
    <content type="html"><![CDATA[<p>想必大家都遇到一种情况，明明y坐标设置的是0，但是总是被讨厌的导航栏给遮住。比如下面这个情况：</p>

<pre><code>UILabel *label = [[UILabel alloc] init];
label.frame = CGRectMake(10, 0, SCREEN.width - 20, 88);
label.backgroundColor = [UIColor redColor];
label.text = @"关注公众号iOS开发：iOSDevTip";
label.textColor = [UIColor whiteColor];
label.textAlignment = NSTextAlignmentCenter;
[self.view addSubview:label];
</code></pre>

<p>一起来看看效果：</p>

<p><img src="http://images.90159.com/10/RectEdge2.png" alt="RectEdge2" /></p>

<p>是不是很讨厌！其实，在iOS 7中，UIViewController引入了一个新的属性：edgesForExtendedLayout。 这个属性的默认值是UIRectEdgeAll。当你的容器是UINavigationController的shih，默认的布局就是从状态栏的顶部开始的。这就是为什么你设置的控件都往上漂移了66ot的原因。</p>

<pre><code>@property(nonatomic,assign) UIRectEdge edgesForExtendedLayout NS_AVAILABLE_IOS(7_0); // Defaults to UIRectEdgeAll
</code></pre>

<p>那么如何解决这个问题呢？有两种方法。</p>

<h2>方法一：改变edgesForExtendedLayout</h2>

<pre><code>self.edgesForExtendedLayout = UIRectEdgeNone;
</code></pre>

<p>将edgesForExtendedLayout属性设置为UIRectEdgeNone，这样布局就是从导航栏下面开始了。设置之后，再来看看效果：</p>

<p><img src="http://images.90159.com/10/RectEdge1.png" alt="RectEdge1" /></p>

<h2>方法二：导航栏半透明属性设置为NO</h2>

<pre><code>@property(nonatomic,assign,getter=isTranslucent) BOOL translucent NS_AVAILABLE_IOS(3_0) UI_APPEARANCE_SELECTOR; // Default is NO on iOS 6 and earlier. Always YES if barStyle is set to UIBarStyleBlackTranslucent
</code></pre>

<p>在iOS 6之前（包括iOS 6）translucent默认就是NO，在iOS 7就默认是YES了。</p>

<pre><code>self.navigationController.navigationBar.translucent = NO;
</code></pre>

<p>将导航栏的半透明属性关闭掉，布局也是从导航栏下面开始了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[报错：You Must Rebuild It With Bitcode Enabled (Xcode Setting ENABLE_BITCODE)（解决方案）]]></title>
    <link href="http://www.superqq.com/blog/2015/09/29/rebuild-bitcode-enable/"/>
    <updated>2015-09-29T15:08:00+08:00</updated>
    <id>http://www.superqq.com/blog/2015/09/29/rebuild-bitcode-enable</id>
    <content type="html"><![CDATA[<p>马上就要十一放假啦！大家是不是都很期待这一天到来，哈哈。相信有不少人跟我一样，早就请三天假回家了吧。希望大家十一都玩的开心噢！</p>

<p>今天在家里闲来无事，我就用Xcode7.0建一个项目。然后，引入一个第三方库，竟然运行不起来。报错如下：</p>

<p><img src="http://images.90159.com/09/error1.png" alt="1" /></p>

<p>我把错误提示复制出来，方便大家搜索：</p>

<pre><code>ld: 'XXX' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>

<p>Xcode7.0默认是开启Enable Bitcode的，如果你导入的一些第三方库在编译的时候没有Enable Bitcode 的话，就会导致报错。</p>

<p>解决方法有两种：</p>

<p>方法一：使用Enable Bitcode的第三方库</p>

<p>方法二：将工程中的Enable Bitcode设置为NO</p>

<p><img src="http://images.90159.com/09/error2.png" alt="1" /></p>

<p>如果你有更好的解决方法，记得告诉我噢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITablView上下滑动控制底部按钮的出现和消失]]></title>
    <link href="http://www.superqq.com/blog/2015/09/01/uitablview-up-down-slide/"/>
    <updated>2015-09-01T00:49:19+08:00</updated>
    <id>http://www.superqq.com/blog/2015/09/01/uitablview-up-down-slide</id>
    <content type="html"><![CDATA[<p>今天我们一起来做一个好玩的功能，通过UITablView上下滑动控制底部按钮的出现和消失。先来看看效果：</p>

<p><img src="http://images.90159.com/09/bottombutton.gif" alt="1" /></p>

<h2>需求分析</h2>

<p>要做一个这样的功能，对你来说应该不难，实现的方式也有很多。我们来分析一下要实现那几个小功能点：</p>

<ul>
<li>UITablView向上滑动，底部按钮消失</li>
<li>UITablView向下滑动，底部按钮出现</li>
<li>UITablView滑动到底部，底部按钮出现</li>
</ul>


<p>主要就是这三个小功能点。那么很简单，我们只需要判断UITablView是往上滑动，还是往下滑动，以及判断UITablView是否滑动到底部即可。</p>

<h2>代码实现</h2>

<h3>创建一个底部按钮</h3>

<pre><code>self.bottomButton = [UIButton buttonWithType:UIButtonTypeCustom];
self.bottomButton.frame = CGRectMake(SCREEN.width / 2 - 25, SCREEN.height - 50, 50, 50);
[self.bottomButton setBackgroundImage:[UIImage imageNamed:@"bottom"] forState:UIControlStateNormal];
[self.view addSubview:self.bottomButton];
</code></pre>

<p>既然是控制按钮的出现和消失，首先要创建一个底部按钮。SCREEN是个宏定义：</p>

<pre><code>#define SCREEN [UIScreen mainScreen].bounds.size
</code></pre>

<h3>判断UITablView上下滑动</h3>

<p>我们都知道，UITablView是继承UIScrollView的。所以UIScrollView的代理方法在UITablView是可以使用的。要判断UITablView上下滑动，我们需要实现UIScrollView的scrollViewDidScroll:代理方法：</p>

<pre><code>-(void)scrollViewDidScroll:(UIScrollView *)scrollView{
    if (scrollView.contentOffset.y &gt; self.offsetY &amp;&amp; scrollView.contentOffset.y &gt; 0) {//向上滑动

    }else if (scrollView.contentOffset.y &lt; self.offsetY ){//向上滑动

    }
    self.offsetY = scrollView.contentOffset.y;//将当前位移变成缓存位移
}
</code></pre>

<!--more-->


<h3>判断UITablView滑动到底部</h3>

<p>也是在scrollViewDidScroll:这个方法里面判断：</p>

<pre><code> //判断滑动到底部
if (scrollView.contentOffset.y == scrollView.contentSize.height - self.tableView.frame.size.height) {

}
</code></pre>

<h3>按钮消失和出现</h3>

<pre><code>//按钮消失
[UIView transitionWithView:self.bottomButton duration:0.1 options:UIViewAnimationOptionTransitionNone animations:^{
            self.bottomButton.frame = CGRectMake(SCREEN.width / 2 - 25, SCREEN.height, 50, 50);
        } completion:NULL];

//按钮出现        
[UIView transitionWithView:self.bottomButton duration:0.1 options:UIViewAnimationOptionTransitionNone animations:^{
  self.bottomButton.frame = CGRectMake(SCREEN.width / 2 - 25, SCREEN.height - 50, 50, 50);
  } completion:NULL];
</code></pre>

<p>按钮消失其实就是移除屏幕，这里我加了一个旋转的过度动画，需要什么动画效果都可以选择。按钮出现就是把按钮的frame设置到初始化时候的frame即可。</p>

<p>这样我们就实现了通过UITablView上下滑动控制底部按钮的出现和消失。代码我已经上传的github，下载地址还是<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>

<p>如果你觉得文章还不错，请分享给你的同学和朋友，欢迎推荐他们关注iOS开发：iOSDevTip 公众号。</p>
]]></content>
  </entry>
  
</feed>
