<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios开发 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-08-19T10:02:06+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS开发小技巧：刷新UITableView]]></title>
    <link href="http://www.superqq.com/blog/2015/08/18/ios-development-refresh-uitableview/"/>
    <updated>2015-08-18T15:25:58+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/18/ios-development-refresh-uitableview</id>
    <content type="html"><![CDATA[<blockquote><p>我创建了iOS开发博主联盟群：<strong>364679270</strong>，有博客的朋友欢迎加入。一起打造一个优质的iOS技术分享社群。</p></blockquote>

<p>UITableView对于iOS开发者来说一定不会陌生，很有可能你的APP很多界面都用到它。关于UITableView的文章，想必已经不计其数，没事可以多看看。特别是UITableView优化的文章，非常值得仔细琢磨一番。</p>

<p>今天我们来看看如何刷新UITableView的，一般情况下，刷新UITableView，我们会直接调用reloadData方法。</p>

<h2>刷新UITableView</h2>

<pre><code>[self.tableView reloadData];
</code></pre>

<p>reloadData是刷新整个UITableView，有时候，我们可能需要局部刷新。比如：只刷新一个cell、只刷新一个section等等。这个时候在调用reloadData方法，虽然用户看不出来，但是有些浪费资源。</p>

<h2>刷新局部cell</h2>

<pre><code> NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:0];
 [self.tableView reloadRowsAtIndexPaths:[NSArray arrayWithObjects:indexPath,nil] withRowAnimation:UITableViewRowAnimationFade];
</code></pre>

<p>这样就可以很方便的刷新第一个section的第一个cell。虽然看起来代码多了，但是确实比较节省资源。尽量少的刷新，也是UITableView的一种优化。</p>

<h2>局部刷新section</h2>

<pre><code>NSIndexSet *indexSet = [[NSIndexSet alloc] initWithIndex:0];
[self.tableView reloadSections:indexSet withRowAnimation:UITableViewRowAnimationFade];
</code></pre>

<p>上面这段代码是刷新第0个section。</p>

<h2>刷新动画</h2>

<p>刷新UITableView还有几个动画：</p>

<pre><code>typedef NS_ENUM(NSInteger, UITableViewRowAnimation) {
    UITableViewRowAnimationFade,   //淡入淡出
    UITableViewRowAnimationRight,  //从右滑入         // slide in from right (or out to right)
    UITableViewRowAnimationLeft,   //从左滑入
    UITableViewRowAnimationTop,     //从上滑入
    UITableViewRowAnimationBottom,  //从下滑入
    UITableViewRowAnimationNone,            // available in iOS 3.0
    UITableViewRowAnimationMiddle,          // available in iOS 3.2.  attempts to keep cell centered in the space it will/did occupy
    UITableViewRowAnimationAutomatic = 100  // available in iOS 5.0.  chooses an appropriate animation style for you
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreMotion框架中加速度计使用简明教程]]></title>
    <link href="http://www.superqq.com/blog/2015/08/10/coremotion-framework-use-accelerometer/"/>
    <updated>2015-08-10T00:37:33+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/10/coremotion-framework-use-accelerometer</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>之前有人通过iPhone的加速度计做出一个手机防盗APP，而且正是通过这个防盗APP拿到天使投资。从此以后华丽转身，公司发展的有声有色。虽然这个项目最后不怎么样，但是，确实是一个不错的想法。</p>

<p>也许你不知道，每一台iPhone都内置的有加速度计。这样当用户操作手机的的时候，比如旋转手机，内置的加速度计就会做出反应。</p>

<p>在iOS4之前加速度计是由<code>UIAccelerometer</code>来采集数据的，现在都是用<code>CoreMotion</code>来处理。两种使用都比较简单，相对来说<code>UIAccelerometer</code>更简单一些。本文将分享两者的用法。</p>

<h2>加速度计原理</h2>

<p><img src="http://images.90159.com/08/Accelerometer.png" alt="Accelerometer.png" /></p>

<p>来自网络</p>

<p>iPhone的加速度计有三个轴，分别是x轴、y轴、z轴，如上图所示。这是一个三维立体空间，可以捕获用户每一个角度的操作。通过这三个轴可以计算iPhone倾斜的角度，从而计算出加速度。</p>

<h2>UIAccelerometer使用</h2>

<p><code>UIAccelerometer</code>的使用比较简单，需要实现<code>UIAccelerometerDelegate</code>的代理方法，具体代码如下：</p>

<pre><code>UIAccelerometer *accelerometer = [UIAccelerometer sharedAccelerometer];
accelerometer.delegate = self;
accelerometer.updateInterval = 0.1;
</code></pre>

<p>实现<code>UIAccelerometerDelegate</code>代理方法：</p>

<pre><code>- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration NS_DEPRECATED_IOS(2_0, 5_0)
{
    NSLog(@"x -&gt; %f y - &gt; %f z -&gt; %f",accelerometer.x,accelerometer.y,accelerometer.z);
}
</code></pre>

<h2>CoreMotion加速度计</h2>

<p>首先需要引入<code>#import &lt;CoreMotion/CoreMotion.h&gt;</code>，直接通过<code>block</code>回调，然后处理三个轴的数据。代码如下：</p>

<pre><code>CMMotionManager *motionManager = [[CMMotionManager alloc] init];
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
//加速计
if (motionManager.accelerometerAvailable) {
    motionManager.accelerometerUpdateInterval = 0.1;
    [motionManager startAccelerometerUpdatesToQueue:queue withHandler:^(CMAccelerometerData *accelerometerData,NSError *error){
        if (error) {
            [motionManager stopAccelerometerUpdates];
            NSLog(@"error");
        }else{
            NSLog(@"x -&gt; %f y - &gt; %f z -&gt; %f",accelerometerData.acceleration.x,accelerometerData.acceleration.y,accelerometerData.acceleration.z);
        }
    }];
}else{
    NSLog(@"This device has no accelerometer");
}
</code></pre>

<p>以上就是关于<code>UIAccelerometer</code>和<code>CoreMotion</code>的使用，加速度计确实是iPhone手机的亮点功能。具体用途，需要我们发散思维，说不定哪一天你也有一个很牛的创意。屌丝逆袭也许就在下一刻。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现placeholder属性的UITextView]]></title>
    <link href="http://www.superqq.com/blog/2015/08/07/implement-uitextview-placeholder/"/>
    <updated>2015-08-07T00:27:43+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/07/implement-uitextview-placeholder</id>
    <content type="html"><![CDATA[<p>iOS开发微信公众号上的iOS技术文章，都将发布在<a href="http://www.superqq.com/">刚刚在线</a>。所以大家可以到我的网站上查看之前的文章，也可以在底部的精彩文章查看历史文章。</p>

<p>上一篇文章<a href="http://www.superqq.com/blog/2015/08/06/uitextview-placeholder-practice/">UITextView实现placeholder的猥琐做法</a>讲了关于<code>UITextView</code>的<code>placeholder</code>实现原理。大家都一致认为做法比较猥琐。</p>

<p>那么，这一次我将简单的封装一个<code>UITextView</code>。暂且取名叫<code>GGPlaceholderTextView</code>，GG前缀看着有点任性的哈。</p>

<h2>GGPlaceholderTextView简介</h2>

<p><code>GGPlaceholderTextView</code>也是对<code>text</code>操作，具体逻辑如下：</p>

<ol>
<li>继承<code>UITextView</code>，并设置<code>placeholder</code>属性</li>
<li>注册开始编辑和结束编辑通知，然后对<code>text</code>做相应的操作</li>
<li>通过<code>UIApplicationWillTerminateNotification</code>通知，在APP退出的时候移除通知。</li>
</ol>


<p>我把<code>GGPlaceholderTextView</code>写在下面。不过，微信里看代码还是不太方便，我已经把代码push到:<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>。你可以下载下来。</p>

<h2>GGPlaceholderTextView.h</h2>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface GGPlaceholderTextView : UITextView
@property(nonatomic, strong) NSString *placeholder;

@end
</code></pre>

<p>定义<code>placeholder</code>属性，类似于<code>UITextField</code>。</p>

<h2>GGPlaceholderTextView.m</h2>

<pre><code>#import "GGPlaceholderTextView.h"

@implementation GGPlaceholderTextView

- (id)initWithFrame:(CGRect)frame {
    if (self = [super initWithFrame:frame]) {
        [self addObserver];
    }
    return self;
}

- (id)init {
    if (self = [super init]) {
        [self addObserver];
    }
    return self;
}

- (void)setPlaceholder:(NSString *)placeholder
{
    _placeholder = placeholder;
    self.text = placeholder;
    self.textColor = [UIColor grayColor];
}

-(void)addObserver
{
    //注册通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didBeginEditing:) name:UITextViewTextDidBeginEditingNotification object:self];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didEndEditing:) name:UITextViewTextDidEndEditingNotification object:self];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(terminate:) name:UIApplicationWillTerminateNotification object:[UIApplication sharedApplication]];
}

- (void)terminate:(NSNotification *)notification {
    //移除通知
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

- (void)didBeginEditing:(NSNotification *)notification {
    if ([self.text isEqualToString:self.placeholder]) {
        self.text = @"";
        self.textColor = [UIColor blackColor];
    }
}

- (void)didEndEditing:(NSNotification *)notification {
    if (self.text.length&lt;1) {
        self.text = self.placeholder;
        self.textColor = [UIColor grayColor];
    }
}

@end
</code></pre>

<p>以上就是关于<code>GGPlaceholderTextView</code>的实现，如果你有类似需求，直接拿去用吧！具体用法请往下看。</p>

<h2>实践</h2>

<pre><code>GGPlaceholderTextView *textView = [[GGPlaceholderTextView alloc] initWithFrame:CGRectMake(0, 64, SCREEN.width , 200)];
textView.backgroundColor = [UIColor whiteColor];
textView.placeholder = @"关注微信公众号iOS开发：iOSDevTip";
[self.view addSubview:textView];
</code></pre>

<p>经过封装后的<code>GGPlaceholderTextView</code>，使用起来是不是跟<code>UITextField</code>非常相似。当然，我封装的比较简单，github上也有一些朋友封装带<code>placeholder</code>属性的<code>UITextView</code>。比如：TextViewPlaceholder。感兴趣的童鞋可以去试用一下。</p>

<p><strong>广告时间</strong></p>

<p>你的分享就是对我最大的支持，希望你能把iOS开发推荐给你的朋友，不甚感激！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITextView实现placeholder的猥琐做法]]></title>
    <link href="http://www.superqq.com/blog/2015/08/06/uitextview-placeholder-practice/"/>
    <updated>2015-08-06T21:37:38+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/06/uitextview-placeholder-practice</id>
    <content type="html"><![CDATA[<p>我经常写一些<a href="http://www.superqq.com/">iOS开发</a>的小技巧，为了在自己需要的时候能用得上，也希望能对正在看文章的你一些帮助，亦或是引发一些思考。</p>

<p>如果你觉得文章对你有帮助，请多多分享。你身边一定有很多做iOS开发的朋友，希望你能把我的iOS开发：<strong>iOSDevTip</strong>推荐给你的朋友。不甚感激！</p>

<p>我们都知道iOS开发中的<code>UITextField</code>有个<code>placeholder</code>属性，<code>placeholder</code>可以很方便引导用户输入。但是<code>UITextView</code>却没有<code>placeholder</code>属性。</p>

<h2>猥琐法分析</h2>

<p>如何让<code>UITextView</code>也有<code>placeholder</code>功能呢？今天给各位分享一个比较猥琐的做法。思路大概是这样的：</p>

<ol>
<li>把<code>UITextView</code>的<code>text</code>当<code>placeholder</code>使用。</li>
<li>在开始编辑的代理方法里清除<code>placeholder</code>。</li>
<li>在结束编辑的代理方法里在设置<code>placeholder</code>。</li>
</ol>


<h2>实现方法</h2>

<h3>创建UITextView</h3>

<pre><code>UITextView *textViewPlaceholder = [[UITextView alloc] initWithFrame:CGRectMake(20, 70, SCREEN.width - 40, 100)];
textViewPlaceholder.backgroundColor = [UIColor whiteColor];
textViewPlaceholder.text = @"关注微信公众号iOS开发：iOSDevTip";
textViewPlaceholder.textColor = [UIColor grayColor];
textViewPlaceholder.delegate = self;
[self.view addSubview:textViewPlaceholder];
</code></pre>

<p>初始化<code>UITextView</code>，给<code>UITextView</code>的<code>text</code>赋值，并且给<code>UITextView</code>的<code>textColor</code>属性设置成灰色，让其看起来更像<code>placeholder</code>。</p>

<p>别忘了设置<code>UITextView</code>的代理，因为后面我们要用到<code>UITextView</code>的两个代理方法。</p>

<h3>开始编辑的代理方法</h3>

<pre><code>- (void)textViewDidBeginEditing:(UITextView *)textView {

    if ([textView.text isEqualToString:@"关注微信公众号iOS开发：iOSDevTip"]) {
        textView.text = @"";
        textView.textColor = [UIColor blackColor];
    }
}
</code></pre>

<p>在开始编辑的代理方法里面，判断如果是<code>UITextView</code>的<code>text</code>的值是<code>placeholder</code>，那么，就清空<code>text</code>，并且把<code>textColor</code>设置成真正的内容颜色，假设是黑色。</p>

<h3>结束编辑的代理方法</h3>

<pre><code>- (void)textViewDidEndEditing:(UITextView *)textView {
    if (textView.text.length&lt;1) {
        textView.text = @"关注微信公众号iOS开发：iOSDevTip";
        textView.textColor = [UIColor grayColor];
    }
}
</code></pre>

<p>在结束编辑的代理方法里，判断如果<code>UITextView</code>的<code>text</code>值为空，那么，就要把需要设置的<code>placeholder</code>赋值给<code>UITextView</code>的<code>text</code>，并且将<code>textColor</code>属性设置成灰色。</p>

<h2>添加轻击手势</h2>

<pre><code>UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapGesture:)];
tapGesture.numberOfTapsRequired = 1; //点击次数
tapGesture.numberOfTouchesRequired = 1; //点击手指数
[self.view addGestureRecognizer:tapGesture];

//轻击手势触发方法
-(void)tapGesture:(UITapGestureRecognizer *)sender
{
    [self.view endEditing:YES];
}
</code></pre>

<p>至此，就很猥琐的实现了<code>placeholder</code>功能。为了方便测试，我加了一个手势。作用是用键盘消失，这样可以测试结束编辑的时候<code>placeholder</code>会不会显示。demo地址：Demo地址:<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>

<p>添加手势的方法很简单，关于iOS开发中的手势汇总，你可以看这篇文章<a href="http://www.superqq.com/blog/2015/01/14/ioskai-fa-zhi-shou-shi-shi-bie-hui-zong/">iOS开发之手势识别汇总</a>。</p>

<p>我看了网上一些实现<code>UITextView</code>的<code>placeholder</code>功能的更猥琐的做法，在<code>UITextView</code>上面盖一个<code>UILabel</code>，然后在<code>UITextView</code>的代理方法里控制<code>UILabel</code>的值。还有用两个<code>UITextView</code>实现的。</p>

<p>在这里，我只是抛砖引玉，如果你有更好的实现方法欢迎投稿给我：<strong>worldligang@163.com</strong>，下一篇文章，我将会封装一个带有<code>placeholder</code>属性的<code>UITextView</code>，敬请期待！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多个UIImage合并成一个UIImage]]></title>
    <link href="http://www.superqq.com/blog/2015/08/05/multiple-uiimage-merged/"/>
    <updated>2015-08-05T17:43:53+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/05/multiple-uiimage-merged</id>
    <content type="html"><![CDATA[<p>写了两篇关于照片保存的文章：</p>

<ol>
<li><a href="http://www.superqq.com/blog/2015/08/03/ioskai-fa-zhi-bao-cun-zhao-pian-dao-xi-tong-xiang-ce-%28photo-album%29/">iOS开发之保存照片到系统相册（Photo Album）</a></li>
<li><a href="http://www.superqq.com/blog/2015/08/04/save-photo-to-own-album/">iOS开发之保存照片到自己创建的相簿</a></li>
</ol>


<p>介绍了如何将图片保存到系统相册，也可以将照片保存到自己的相簿。里面还介绍了一个第三方<code>ALAssetsLibrary+CustomPhotoAlbum</code>保存照片的方法。</p>

<p>本篇文章将会介绍如何将多个<code>UIImage</code>合并成一个<code>UIImage</code>。听起来似乎有点晕晕乎乎的，这个可以合并吗？答案是肯定的。我们拿两个<code>UIImage</code>来举例。</p>

<h2>创建两个UIImage</h2>

<pre><code>UIImage *image1 = [UIImage imageNamed:@"iOSDevTip"];
UIImage *image2 = [UIImage imageNamed:@"CodePush"];
</code></pre>

<p>创建<code>UIImage</code>的方法有很多种，我们就简单的通过<code>imageNamed:</code>方法来创建。</p>

<h2>合并之后的size</h2>

<pre><code>CGSize size = CGSizeMake(image1.size.width + image2.size.width, image1.size.height);
</code></pre>

<p>合并两个<code>UIImage</code>，需要计算合并之后的<code>size</code>。假设这两个<code>UIImage</code>的高度是是相同的，把他们的宽度相加，得到合并之后的<code>UIImage</code>的<code>size</code>。</p>

<h2>合并方法</h2>

<p>有了<code>UIImage</code>和<code>size</code>接下来就是把两个<code>UIImage</code>合并，方法如下：</p>

<pre><code> UIGraphicsBeginImageContext(size);
[image1 drawInRect:CGRectMake(0, 0, image1.size.width, size.height)];
[image2 drawInRect:CGRectMake(image1.size.width, 0, image2.size.width, size.height)];
UIImage *togetherImage = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
</code></pre>

<p>通过上述的代码，就可以实现两个<code>UIImage</code>的合并。` 这个小功能还挺有用的。</p>
]]></content>
  </entry>
  
</feed>
