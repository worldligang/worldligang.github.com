<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios开发 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-11-27T23:30:35+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一组功能丰富的iOS组件:YYKit]]></title>
    <link href="http://www.superqq.com/blog/2015/11/27/ios-rich-components-yykit/"/>
    <updated>2015-11-27T23:27:37+08:00</updated>
    <id>http://www.superqq.com/blog/2015/11/27/ios-rich-components-yykit</id>
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/ibireme/YYKit">https://github.com/ibireme/YYKit</a></p>

<h1>中文介绍</h1>

<p>YYKit 是一组庞大、功能丰富的 iOS 组件。</p>

<p>为了尽量复用代码，这个项目中的某些组件之间有比较强的依赖关系。为了方便其他开发者使用，我从中拆分出以下独立组件：</p>

<ul>
<li><a href="https://github.com/ibireme/YYModel">YYModel</a> — 高性能的 iOS JSON 模型框架。</li>
<li><a href="https://github.com/ibireme/YYCache">YYCache</a> — 高性能的 iOS 缓存框架。</li>
<li><a href="https://github.com/ibireme/YYImage">YYImage</a> — 功能强大的 iOS 图像框架。</li>
<li><a href="https://github.com/ibireme/YYWebImage">YYWebImage</a> — 高性能的 iOS 异步图像加载框架。</li>
<li><a href="https://github.com/ibireme/YYText">YYText</a> — 功能强大的 iOS 富文本框架。</li>
<li></li>
<li><a href="https://github.com/ibireme/YYKeyboardManager">YYKeyboardManager</a> — iOS 键盘监听管理工具。</li>
<li><a href="https://github.com/ibireme/YYDispatchQueuePool">YYDispatchQueuePool</a> — iOS 全局并发队列管理工具。</li>
<li><a href="https://github.com/ibireme/YYAsyncLayer">YYAsyncLayer</a> — iOS 异步绘制与显示的工具。</li>
<li><a href="https://github.com/ibireme/YYCategories">YYCategories</a> — 功能丰富的 Category 类型工具库。</li>
</ul>


<h1>演示项目</h1>

<p>查看并运行 <code>Demo/YYKitDemo.xcodeproj</code></p>

<p><img src="https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/twitter.png" width="320"><br/>
<img src="https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/weibo.png" width="320"> <img src="https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/weibo_compose.png" width="320"></p>

<h1>安装</h1>

<h3>CocoaPods</h3>

<ol>
<li>在 Podfile 中添加  <code>pod "YYKit"</code>。</li>
<li>执行 <code>pod install</code> 或 <code>pod update</code>。</li>
<li>导入 \&lt;YYKit/YYKit.h>。</li>
</ol>


<h3>Carthage</h3>

<ol>
<li>在 Cartfile 中添加 <code>github "ibireme/YYKit"</code>。</li>
<li>执行 <code>carthage update --platform ios</code> 并将生成的 framework 添加到你的工程。</li>
<li>导入 \&lt;YYKit/YYKit.h>。</li>
<li>注意: carthage framework 并没有包含 webp 组件。如果你需要支持 webp，可以用 CocoaPods 安装，或者手动安装。</li>
</ol>


<h3>手动安装</h3>

<ol>
<li>下载 YYKit 文件夹内的所有内容。</li>
<li>将 YYKit 内的源文件添加(拖放)到你的工程。</li>
<li>为 <code>NSObject+YYAddForARC.m</code> 和 <code>NSThread+YYAdd.m</code> 添加编译参数 <code>-fno-objc-arc</code>。</li>
<li>链接以下 frameworks:

<ul>
<li>UIKit</li>
<li>CoreFoundation</li>
<li>CoreText</li>
<li>CoreGraphics</li>
<li>CoreImage</li>
<li>QuartzCore</li>
<li>ImageIO</li>
<li>AssetsLibrary</li>
<li>Accelerate</li>
<li>MobileCoreServices</li>
<li>SystemConfiguration</li>
<li>sqlite3</li>
<li>libz</li>
</ul>
</li>
<li>如果你需要支持 WebP，可以将 <code>Vendor/WebP.framework</code>(静态库) 加入你的工程。</li>
<li>导入 <code>YYKit.h</code>。</li>
</ol>


<h1>文档</h1>

<p>你可以在 <a href="http://cocoadocs.org/docsets/YYKit/">CocoaDocs</a> 查看在线 API 文档，也可以用 <a href="https://github.com/tomaz/appledoc">appledoc</a> 本地生成文档。</p>

<h1>系统要求</h1>

<p>该项目最低支持 iOS 6.0。</p>

<h1>关于</h1>

<p>我希望调用 API 时，有着和调用系统自带 API 一样的体验，所以我并没有为 Category 方法添加前缀。我已经用工具扫描过这个项目中的 API，确保没有对系统 API 产生影响。我知道没有前缀的 Category 可能会带来麻烦，所以如果你只需要其中部分功能，请先查看上面那些拆分出来的子项目。</p>

<h1>许可证</h1>

<p>YYKit 使用 MIT 许可证，详情见 LICENSE 文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS提交审核：您的 App 正在使用广告标识符 (IDFA)]]></title>
    <link href="http://www.superqq.com/blog/2015/11/13/ios-submit-using-idfa/"/>
    <updated>2015-11-13T10:34:12+08:00</updated>
    <id>http://www.superqq.com/blog/2015/11/13/ios-submit-using-idfa</id>
    <content type="html"><![CDATA[<p>提交审核也是iOS开发者必备技能之一。关于提交审核的教程数不胜数，不会的童鞋赶紧尝试一下吧！</p>

<p>这篇文章我们来解决一个问题，关于IDFA的：</p>

<pre><code>您的 App 正在使用广告标识符 (IDFA)。您必须先提供关于 IDFA 的使用信息或将其从 App 中移除，然后再上传您的二进制文件。
</code></pre>

<p>从14年2月初开始，Apple开始拒绝采集IDFA(identifier for advertising)而未集成任何广告服务的应用进入AppStore。怎么看自己的项目是否采集了IDFA呢？方法很简单，大家去看framework，看看有没有一个framework叫AdSupport.framework。</p>

<p>如果有，那就惨了，上两张图看看：</p>

<p><img src="http://images.90159.com/11/idfa1.png" alt="idfa1" /></p>

<!--more-->


<p>如果你选择了“否”：</p>

<p><img src="http://images.90159.com/11/idfa2.png" alt="idfa2" /></p>

<h2>方案一：重新下载xcode</h2>

<ol>
<li>如果你的xcode不是最新版本的，建议下载最新版本的。重新打包后，再次提交审核。</li>
<li>如果你的xcode不是正规渠道下载的，建议从苹果官方下载。</li>
</ol>


<p>有朋友尝试过方案一，问题得到解决。如果解决不了，还有方案二。</p>

<h2>方案二：检测哪里用到IDFA</h2>

<p>首先cd到你的工程目录下，然后执行命令：</p>

<pre><code>grep -r advertisingIdentifier .
</code></pre>

<p>果然找到了罪魁祸首，原来是SinaWeiboSDK/libWeiboSDK.a</p>

<p><img src="http://images.90159.com/11/idfa3.png" alt="idfa3" /></p>

<p>ios9之后新浪微博分享可使用的前提是加入ADSupport.framework,打包提交后一直报您的 App 正在使用广告标识符 (IDFA)。您必须先提供关于 IDFA 的使用信息或将其从app中移除，再上传二进制文件。</p>

<p>找到了源头，那么接下来怎么做就简单了。</p>

<ol>
<li>承认使用了IDFA，然后选择相应的选项。</li>
<li>移除SinaWeiboSDK/libWeiboSDK.a，分享还是可以成功的。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[远程推送控制台提示Add “Remote-notification”...解决方案]]></title>
    <link href="http://www.superqq.com/blog/2015/11/12/remote-notification-error/"/>
    <updated>2015-11-12T18:21:17+08:00</updated>
    <id>http://www.superqq.com/blog/2015/11/12/remote-notification-error</id>
    <content type="html"><![CDATA[<p>做推送的童鞋可能会遇到这样的问题，控制台会打印一句话：</p>

<p>You&rsquo;ve implemented -[<UIApplicationDelegate> application:didReceiveRemoteNotification:fetchCompletionHandler:], but you still need to add &ldquo;remote-notification&rdquo; to the list of your supported UIBackgroundModes in your Info.plist.</p>

<p>解决办法：</p>

<p><img src="http://images.90159.com/11/error1.png" alt="error1" /></p>

<!--more-->


<p>这个时候再去看看Info.plist文件：</p>

<p><img src="http://images.90159.com/11/error2.png" alt="error2" /></p>

<p>再次运行，问题就解决啦！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个非常不错的自定义UIAlertView第三方类库]]></title>
    <link href="http://www.superqq.com/blog/2015/10/30/two-nice-uialertview/"/>
    <updated>2015-10-30T10:08:00+08:00</updated>
    <id>http://www.superqq.com/blog/2015/10/30/two-nice-uialertview</id>
    <content type="html"><![CDATA[<p>UIAlertView大家都不陌生了。UIAlertView不可以添加控件，比如说：UILabel、UITextView等等，所以遇到这个需求，一般都要自定义UIAlertView来解决。</p>

<p>我再github上找到了两个非常错的自定义UIAlertView第三方类库，分别是：LMAlertView和CustomIOSAlertView。</p>

<h2>LMAlertView使用简介</h2>

<p><a href="https://github.com/lmcd/LMAlertView">LMAlertView</a>在github上有610个star。说明这个第三方的UIAlertView还不错，我大概看了一下用法也比较简单。</p>

<p>来看看两个个案例效果：</p>

<p><img src="https://camo.githubusercontent.com/eb9242282b703a847c5ca45ef47462ec507ba573/687474703a2f2f6c6d63642e6d652f4c4d416c657274566965772d637573746f6d4032782e706e67" alt="1" /></p>

<!--more-->


<p><img src="https://camo.githubusercontent.com/b1c95e3be84a8d277e1c542ca768b3bdebe043a6/687474703a2f2f6c6d63642e6d652f4c4d416c657274566965772d7265766965774032782e706e673f33" alt="2" /></p>

<h3>用CocoaPods安装LMAlertView</h3>

<pre><code>pod 'LMAlertView'
</code></pre>

<h3>使用案例</h3>

<pre><code>LMAlertView *alertView = [[LMAlertView alloc] initWithTitle:@"iOSDevTip"
                                        message:@"关注一下"
                                       delegate:nil
                              cancelButtonTitle:@"ok"
                              otherButtonTitles:nil];

// Add your subviews here to customise
UIView *contentView = alertView.contentView;

[alertView show];   
</code></pre>

<p>LMAlertView还保持着UIAlertView的创建方法，作者还比较用心。</p>

<h2>CustomIOSAlertView使用简介</h2>

<p><a href="https://github.com/wimagguc/ios-custom-alertview">CustomIOSAlertView</a>比LMAlertView的star还多一些，有861个。同样我们先看一下效果：</p>

<p><img src="https://github.com/wimagguc/ios-custom-alertview/raw/master/Docs/screen.png" alt="3" /></p>

<h3>用CocoaPods安装CustomIOSAlertView</h3>

<pre><code>pod 'CustomIOSAlertView', '~&gt; 0.9.3'
</code></pre>

<h3>使用案例</h3>

<pre><code>CustomIOSAlertView *alertView = [[CustomIOSAlertView alloc] init];  UIView *customView ..;

[alertView setContainerView:customView];
[alertView show];
</code></pre>

<p>CustomIOSAlertView可以设置代理，还可以通过block来实现按钮的点击事件。功能相对比较齐全。</p>

<p>喜欢的童鞋可以star一下，以备不时之需。如果你觉得不错，记得分享给更多朋友哈，谢谢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIViewController的edgesForExtendedLayout属性]]></title>
    <link href="http://www.superqq.com/blog/2015/10/09/uiviewcontroller-rectedge/"/>
    <updated>2015-10-09T16:36:41+08:00</updated>
    <id>http://www.superqq.com/blog/2015/10/09/uiviewcontroller-rectedge</id>
    <content type="html"><![CDATA[<p>想必大家都遇到一种情况，明明y坐标设置的是0，但是总是被讨厌的导航栏给遮住。比如下面这个情况：</p>

<pre><code>UILabel *label = [[UILabel alloc] init];
label.frame = CGRectMake(10, 0, SCREEN.width - 20, 88);
label.backgroundColor = [UIColor redColor];
label.text = @"关注公众号iOS开发：iOSDevTip";
label.textColor = [UIColor whiteColor];
label.textAlignment = NSTextAlignmentCenter;
[self.view addSubview:label];
</code></pre>

<p>一起来看看效果：</p>

<p><img src="http://images.90159.com/10/RectEdge2.png" alt="RectEdge2" /></p>

<p>是不是很讨厌！其实，在iOS 7中，UIViewController引入了一个新的属性：edgesForExtendedLayout。 这个属性的默认值是UIRectEdgeAll。当你的容器是UINavigationController的shih，默认的布局就是从状态栏的顶部开始的。这就是为什么你设置的控件都往上漂移了66ot的原因。</p>

<pre><code>@property(nonatomic,assign) UIRectEdge edgesForExtendedLayout NS_AVAILABLE_IOS(7_0); // Defaults to UIRectEdgeAll
</code></pre>

<p>那么如何解决这个问题呢？有两种方法。</p>

<h2>方法一：改变edgesForExtendedLayout</h2>

<pre><code>self.edgesForExtendedLayout = UIRectEdgeNone;
</code></pre>

<p>将edgesForExtendedLayout属性设置为UIRectEdgeNone，这样布局就是从导航栏下面开始了。设置之后，再来看看效果：</p>

<p><img src="http://images.90159.com/10/RectEdge1.png" alt="RectEdge1" /></p>

<h2>方法二：导航栏半透明属性设置为NO</h2>

<pre><code>@property(nonatomic,assign,getter=isTranslucent) BOOL translucent NS_AVAILABLE_IOS(3_0) UI_APPEARANCE_SELECTOR; // Default is NO on iOS 6 and earlier. Always YES if barStyle is set to UIBarStyleBlackTranslucent
</code></pre>

<p>在iOS 6之前（包括iOS 6）translucent默认就是NO，在iOS 7就默认是YES了。</p>

<pre><code>self.navigationController.navigationBar.translucent = NO;
</code></pre>

<p>将导航栏的半透明属性关闭掉，布局也是从导航栏下面开始了。</p>
]]></content>
  </entry>
  
</feed>
