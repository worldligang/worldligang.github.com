<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios开发 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-07-03T15:51:29+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UIButton文字居左显示]]></title>
    <link href="http://www.superqq.com/blog/2015/07/02/uibuttonwen-zi-ju-zuo-xian-shi/"/>
    <updated>2015-07-02T22:18:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/02/uibuttonwen-zi-ju-zuo-xian-shi</id>
    <content type="html"><![CDATA[<p>题外话：时间依旧过的很快，不知不觉2015年就过去一半了。感觉自己好像没有大的改变，只能感叹时间飞逝，却不能有所收获。</p>

<p>我从来都不是一个安于现状的人，改变自己的想法从未停止过。我想大多数人都跟我有类似的想法。但是为什么很难有所成就呢？我觉得最重要的原因就是，<strong>只是想一下，而没有去行动</strong>。</p>

<p>这是一个全民创业的时代，不把握机会，只能错过。错过的机会，越多遗憾就越多。有句话说：<strong>老了之后，回想人生，不会因为自己做过什么而后悔，而会因为自己没有做过什么而遗憾。</strong>不想给人生留下遗憾，所以努力去尝试是唯一的选择。</p>

<p>随便感慨一下。每天上班太舒服了，淡忘了自己的理想，借此提醒一下自己。</p>

<p>来来，收回思路，今天我们来讲如何让UIButton文字居左显示？我们都应该写过让UILabel的text居左显示。代码也非常简单。</p>

<h2>UILabel文字居左显示</h2>

<p>实现文字居左显示代码如下：</p>

<pre><code>UILabel *label = [[UILabel alloc] init];
label.frame = CGRectMake(50, 100, 200, 50);
label.text = @"我是label";
label.textAlignment = NSTextAlignmentLeft;
label.backgroundColor = [UIColor orangeColor];
[self.view addSubview:label];
</code></pre>

<p>运行起来看一下效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/labelleft.png" alt="1" /></p>

<p>label.backgroundColor = [UIColor orangeColor];设置label的背景颜色方便我们参考。你是不是这样做的。依次类推UIButton也很简单，你肯定能想到。我们来看看。</p>

<h2>UIButton文字居左显示</h2>

<h3>创建UIButton</h3>

<pre><code>UIButton *button = [[UIButton alloc] init];
//设置坐标
button.frame = CGRectMake(100, 100, 100, 50);
//设置标题
[button setTitle:@"我是UIButton" forState:UIControlStateNormal];
//设置标题颜色
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
//设置背景颜色    
[button setBackgroundColor:[UIColor orangeColor]];
[self.view addSubview:button];
</code></pre>

<p>以上代码是创建一个button，设置坐标、标题、和标题颜色。</p>

<h3>让文字居左</h3>

<p>按照UILabel文字居左的写法，UIButton应该这么写：</p>

<pre><code> button.titleLabel.textAlignment = NSTextAlignmentLeft;
</code></pre>

<p>运行一下看一下效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/buttonnoleft.png" alt="2" /></p>

<p>我们发现UIButton的文字还是居中显示。竟然没有居左显示，怎么办呢？进UIButton看看，还有哪些属性。很快发现：</p>

<pre><code>@property(nonatomic) UIControlContentHorizontalAlignment contentHorizontalAlignment; // how to position content hozontally inside control. default is center

typedef NS_ENUM(NSInteger, UIControlContentHorizontalAlignment) {
    UIControlContentHorizontalAlignmentCenter = 0,
    UIControlContentHorizontalAlignmentLeft   = 1,
    UIControlContentHorizontalAlignmentRight  = 2,
    UIControlContentHorizontalAlignmentFill   = 3,
};
</code></pre>

<h3>设置contentHorizontalAlignment</h3>

<pre><code>button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;
</code></pre>

<p>再次运行起来看效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/buttonleft.png" alt="3" /></p>

<p>果然可以，是不是看着居左显示很难看，太靠边了。很简单，设置UIButton的titleEdgeInsets属性：</p>

<pre><code>button.titleEdgeInsets = UIEdgeInsetsMake(0, 10, 0, 0);
</code></pre>

<p>这样button的title就距左边10个像素的距离。</p>

<p>居右显示就很简单了：</p>

<pre><code>button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentRight;
</code></pre>

<p>ok，UIButton文字居左显示完成了。更多iOS技术请点击<a href="www.superqq.com">刚刚在线</a> : <strong>www.superqq.com</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EGOCache如何检测缓存时间过期]]></title>
    <link href="http://www.superqq.com/blog/2015/07/02/egocacheru-he-jian-ce-huan-cun-shi-jian-guo-qi/"/>
    <updated>2015-07-02T00:38:14+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/02/egocacheru-he-jian-ce-huan-cun-shi-jian-guo-qi</id>
    <content type="html"><![CDATA[<blockquote><p>子曰:学而不思则罔,思而不学则殆。</p></blockquote>

<p>在上一篇文章中：<a href="http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie/">EGOCache缓存框架详细讲解</a> 提到<strong>EGOCache</strong>可以设定缓存过期时间，默认是1天。查看了一下EGOCache源码，设置默认时间：</p>

<pre><code>    [self setDefaultTimeoutInterval:86400];

    //86400 = 24 * 60 * 60 刚好是一天时间。
</code></pre>

<p>EGOCache为什么要提供设定缓存过期时间呢？或者说设定缓存过期时间有什么好处呢？我觉得最大的好处就是可以定时清除缓存。可以设置某一项的缓存时间，很方便管理缓存。</p>

<p>那么问题来了：</p>

<ol>
<li>EGOCache是怎么检测缓存过期时间的呢？</li>
<li>检测到时间过期之后，什么时候触发删除缓存项的？</li>
</ol>


<p>带着这两个问题，我们来继续分析。</p>

<h2>你会怎么实现</h2>

<p>记得在公司里，老板经常会举这样的例子：</p>

<pre><code>某某同志，刚来我们公司的时候，遇到问题就知道抱怨。从来不知道去思考怎么解决，只知道把问题抛给领导。工作半年下来，成长了很多。现在碰到问题，不仅把问题抛出来，而且还提供了自己的解决方案...
</code></pre>

<p>类似的例子，相信大家都听过。同样，既然前面我们提出这两个问题，我们也先来思考一下，如果我们来做该怎么解决？</p>

<p>如果让我来写的话，我脑海里初步实现方法有几个：</p>

<ol>
<li>通过定时器来轮询，每隔一段时间检测一次。</li>
<li>写一个while循环来检测。</li>
<li>每次去读取缓存项的时候，判断缓存时间有没有过期。没过期，就返回读取的缓存项；否则，返回nil。</li>
</ol>


<p>当然，还有一些方法，不一一例举了。仔细想想，这些方法弊端很容易显露出来。</p>

<ol>
<li>为了小小的缓存时间，就用定时器轮询，显然是资源浪费</li>
<li>跟方法1差不多。</li>
<li>每次读取的时候判断是否过期，如果一直不读取，app的缓存会越来越大，也不可取。</li>
</ol>


<p>这些方法都被排除了，还有好的方法吗？继续往下看：</p>

<h2>EGOCache是怎么实现的？</h2>

<p>仔细查看EGOCache源码，发现在initWithCacheDirectory:方法里，每次初始化EGOCache实例对象的时，会遍历一遍plist文件中所有已存在的缓存项，拿每个缓存项的时间和当前时间作比较，缓存项过期时间早于当前时间，则删除对应缓存文件，并删除 plist 文件中对应 key 的记录。</p>

<p>具体实现代码如下：</p>

<h3>读取缓存项信息</h3>

<pre><code>_cacheInfo = [[NSDictionary dictionaryWithContentsOfFile:cachePathForKey(_directory, @"EGOCache.plist")] mutableCopy];

if(!_cacheInfo) {
    _cacheInfo = [[NSMutableDictionary alloc] init];
}
</code></pre>

<h3>获取当前时间的NSTimeInterval</h3>

<pre><code>NSTimeInterval now = [[NSDate date] timeIntervalSinceReferenceDate];
</code></pre>

<h3>声明removedKeys保存过期的缓存项对应的key</h3>

<pre><code>NSMutableArray* removedKeys = [[NSMutableArray alloc] init];
</code></pre>

<h3>遍历缓存项信息并判断缓存时间</h3>

<pre><code>for(NSString* key in _cacheInfo) {
    //判断缓存项过期时间是否早于当前时间
    if([_cacheInfo[key] timeIntervalSinceReferenceDate] &lt;= now) {
        //如果缓存项过期时间早于当前时间，移除缓存项
        [[NSFileManager defaultManager] removeItemAtPath:cachePathForKey(_directory, key) error:NULL];
        //把过期的缓存项对于的key保存到removedKeys里面
        [removedKeys addObject:key];
    }
}
</code></pre>

<h3>删除过期缓存项对于的key</h3>

<pre><code>[_cacheInfo removeObjectsForKeys:removedKeys];
</code></pre>

<p>看到这些，是不是觉得人家思路特牛叉，反正，我是觉得这个作者不简单。到这一步就解决了吗？</p>

<h2>EGOCache还做了什么？</h2>

<p>细心的童鞋会发现：<strong>EGOCache是个<a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">单列类</a></strong>，也就是说整个程序应用周期只初始化一次。</p>

<pre><code>+ (instancetype)globalCache {
    static id instance;

    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        instance = [[[self class] alloc] init];
    });

    return instance;
}
</code></pre>

<p>每次初始化的时候去判断了缓存项是否过期，这样做非常正确。思考一个场景：</p>

<ol>
<li>用户打开app，EGOCache被初始化，并判断了缓存项是否过期。</li>
<li>如果刚好有一些缓存项在EGOCache被初始化之后过期。这个时候我们依然可以读到这个缓存项。这就不对了。</li>
</ol>


<p>继续分析EGOCache源码发现，EGOCache在读取一个缓存项的时候，先判断缓存项是否存在，然后读取缓存项（注意：是读取EGOCache初始化的时候没有过期的缓存项，并没有说现在没有过期），最后去判断读取到的缓存项跟当前时间相比是否过期.</p>

<p>具体实现如下：</p>

<pre><code>- (BOOL)hasCacheForKey:(NSString*)key {
    //读取EGOCache初始化的时候没有过期的缓存项
    NSDate* date = [self dateForKey:key];
    if(date == nil) return NO;
    //判断读取到的缓存项当前是否过期
    if([date timeIntervalSinceReferenceDate] &lt; CFAbsoluteTimeGetCurrent()) return NO;

    return [[NSFileManager defaultManager] fileExistsAtPath:cachePathForKey(_directory, key)];
}

- (NSDate*)dateForKey:(NSString*)key {
    __block NSDate* date = nil;

    dispatch_sync(_frozenCacheInfoQueue, ^{
        date = (self.frozenCacheInfo)[key];
    });

    return date;
}
</code></pre>

<p>EGOCache检测缓存时间过期的思路值得学习，以后遇到类似场景，完全可以借鉴。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EGOCache缓存框架详细讲解]]></title>
    <link href="http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie/"/>
    <updated>2015-07-01T00:10:18+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie</id>
    <content type="html"><![CDATA[<p><strong>EGOCache</strong>是一个轻量级的缓存框架。用法简单方便，在现在的项目中，我就用到EGOCache来缓存下载过的照片和字符串。</p>

<p>有人可能会问到，缓存照片还需要用EGOCache吗？<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">AFNetworking</a>和<a href="http://www.superqq.com/blog/2015/06/09/sdwebimagejia-zai-tu-pian-huan-cun-tu-pian/">SDWebImage</a>不是已经有这些功能了吗？</p>

<p>是的，不过AFNetworking和SDWebImage是http。我的项目用的是socket，所以我选择EGOCache来做缓存。用下来觉得EGOCache还是挺强大的。</p>

<h2>EGOCache简介</h2>

<pre><code>EGOCache is a simple, thread-safe key value cache store. It has native support for NSString, UI/NSImage, and NSData, but can store anything that implements &lt;NSCoding&gt;. All cached items expire after the timeout, which by default, is one day.
</code></pre>

<p>翻译过来就是：EGOCache一个简单、线程安全的基于 key-value 的缓存框架，原生支持NSString、UI/NSImage、和NSData，也支持储存任何实现<NSCoding>协议的类，可以设定缓存过期时间，默认是1天。</p>

<p>EGOCache只有一个类，EGOCache.h和EGOCache.m两个文件。用法也比较容易掌握，仔细研究一下EGOCache.h的方法，很快就可以上手。</p>

<p>EGOCache只提供了磁盘缓存，没有提供内存缓存。同时，也提供了清理缓存的方法：</p>

<pre><code>- (void)clearCache;
</code></pre>

<p>EGOCache还提供了判断缓存是否存在的方法：</p>

<pre><code>- (BOOL)hasCacheForKey:(NSString* __nonnull)key;
</code></pre>

<h2>通过Cocoapods直接加入项目</h2>

<p>直接在你的项目的Podfile加入下面一行：</p>

<pre><code>pod 'EGOCache'
</code></pre>

<p>然后执行：</p>

<pre><code>$ pod update
</code></pre>

<h2>EGOCache用法</h2>

<h3>用EGOCache缓存NSString</h3>

<p>存储：</p>

<pre><code>NSString *saveString = @"把我保存起来吧";
[[EGOCache globalCache] setString:saveString forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[saveString hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>NSString *getSaveString = [[EGOCache globalCache] stringForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveString" hash]]];
</code></pre>

<p>是不是感觉跟NSDictionary很相似，确实，前面我们说了EGOCache是基于key-value 的缓存框架。</p>

<h3>用EGOCache缓存UIImage</h3>

<p>存储：</p>

<pre><code> UIImage *saveImage = [UIImage imageNamed:@"iOSDevTip"];
[[EGOCache globalCache] setImage:saveImage forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveImage" hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>UIImage *getSaveImage = [[EGOCache globalCache] imageForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveImage" hash]]];
</code></pre>

<h3>用EGOCache缓存NSData</h3>

<p>存储：</p>

<pre><code>NSData *saveData = [NSData data];
[[EGOCache globalCache] setData:saveData forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveData" hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>UIImage *getSaveData = [[EGOCache globalCache] dataForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveData" hash]]];
</code></pre>

<h2>EGOCache源码下载</h2>

<p><a href="https://github.com/enormego/EGOCache">EGOCache</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CGContextRef使用简要教程]]></title>
    <link href="http://www.superqq.com/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng/"/>
    <updated>2015-06-29T10:55:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng</id>
    <content type="html"><![CDATA[<p>Graphics Context是图形上下文,也可以理解为一块画布,我们可以在上面进行绘画操作,绘制完成后,将画布放到我们的view中显示即可,view看作是一个画框.</p>

<p>CGContextRef功能强大，我们借助它可以画各种图形。开发过程中灵活运用这些技巧，可以帮助我们提供代码水平。</p>

<p>说到画图，我就立马想到：我的数学公式都快忘完了。</p>

<h2>高中数学你还记得多少？</h2>

<p>我记得我上学的时候，数学一直都很好。以至于在班里都不敢和别人吵吵闹闹。一吵吵闹闹，别人就会来一句：以为你数学好，就可以怎么样怎么样了是吧？说的我好无奈啊。</p>

<p>这么多年过去了，说句实话，高中时学的数学公式什么的，都忘记的差不多了。现在要去做高三的考题，估计比写代码还难。</p>

<p>作为一名程序员，数学好，一定是优势。就拿画图来说吧，如果你还清楚的记得那些公式，那么你就可以很随意地画出一些好看的图形出来。</p>

<p>接下来，我们来看看CGContextRef到底能实现些什么？</p>

<h2>写文字</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //开始写字
    [@"我是文字" drawInRect:CGRectMake(10, 10, 100, 30) withFont:font];  
    [super drawRect:rect];
}
</code></pre>

<p>这段代码就可以很漂亮的写出四个大字：我是文字。很容易理解，每句话都有注释。</p>

<h2>画直线</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //顶部横线
    CGContextMoveToPoint(ctx, 0, 10);
    CGContextAddLineToPoint(ctx, self.bounds.size.width, 10);
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<h2>画圆</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //void CGContextAddArc(CGContextRef c,CGFloat x, CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle, int clockwise)1弧度＝180°/π （≈57.3°） 度＝弧度×180°/π 360°＝360×π/180 ＝2π 弧度
    // x,y为圆点坐标，radius半径，startAngle为开始的弧度，endAngle为 结束的弧度，clockwise 0为顺时针，1为逆时针。
    CGContextAddArc(ctx, 100, 20, 20, 0, 2*M_PI, 0); //添加一个圆
    CGContextDrawPath(ctx, kCGPathStroke); //绘制路径
    [super drawRect:rect];
}
</code></pre>

<p>这个画圆的公式你还记得吗？你还知道M_PI是什么吗？等于多少吗？赶紧脑补一下吧！</p>

<h2>画矩形</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    CGContextAddRect(ctx, CGRectMake(2, 2, 30, 30));
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<p>图形千千万，万变不离其宗。更多画图方法，期待你的探索。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用正则表达式验证邮箱和手机号]]></title>
    <link href="http://www.superqq.com/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao/"/>
    <updated>2015-06-27T07:35:42+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao</id>
    <content type="html"><![CDATA[<blockquote><p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></blockquote>

<p>做iOS开发的童鞋，应该都用过正则表达式吧。正则表达式很好地，帮助我们判断一个字符串是否合法。比如：</p>

<ol>
<li><p>在做app注册页面的时候，需要判断手机号是否格式正确，是否够11位。</p></li>
<li><p>在做意见反馈的时候，需要判断邮箱格式是否正确。</p></li>
</ol>


<p>判断手机号和判断邮箱，应该是iOS开发者们最常用的。具体如何判断，简单整理如下：</p>

<h2>验证邮箱</h2>

<pre><code>+ (BOOL)validateEmail:(NSString *)email
{
    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}";
    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex];
    return [emailTest evaluateWithObject:email];
}
</code></pre>

<p>NSPredicate是一个Foundation类，是用来查询的，原理和用法都类似于SQL中的where。</p>

<h2>验证手机号</h2>

<h3>简单的判断方法</h3>

<pre><code>+ (BOOL)validatePhone:(NSString *)phone
{
    NSString *phoneRegex = @"1[3|5|7|8|][0-9]{9}";
    NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", phoneRegex];
    return [phoneTest evaluateWithObject:phone];
}
</code></pre>

<p>这只是简单地判断手机号格式。其实手机的格式还是有一点复杂的。</p>

<h3>详细的判断方法</h3>

<pre><code>//正则判断手机号码格式
+ (BOOL)validatePhone:(NSString *)phone
{
       /**
        * 手机号码
        * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        * 联通：130,131,132,152,155,156,185,186
        * 电信：133,1349,153,180,189
        */
       NSString * MOBILE = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";
       /**
        10         * 中国移动：China Mobile
        11         * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        12         */
       NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d{7}$";
       /**
        15         * 中国联通：China Unicom
        16         * 130,131,132,152,155,156,185,186
        17         */
       NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d{8}$";
       /**
        20         * 中国电信：China Telecom
        21         * 133,1349,153,180,189
        22         */
       NSString * CT = @"^1((33|53|8[09])[0-9]|349)\\d{7}$";
       /**
        25         * 大陆地区固话及小灵通
        26         * 区号：010,020,021,022,023,024,025,027,028,029
        27         * 号码：七位或八位
        28         */
      // NSString * PHS = @"^0(10|2[0-5789]|\\d{3})\\d{7,8}$";

     NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBILE];
     NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM];
     NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU];
     NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT];

    if (([regextestmobile evaluateWithObject:phone] == YES)
    || ([regextestcm evaluateWithObject:phone] == YES)
    || ([regextestct evaluateWithObject:phone] == YES)
    || ([regextestcu evaluateWithObject:phone] == YES))
    {
        if([regextestcm evaluateWithObject:phone] == YES) {
          NSLog(@"China Mobile");
        } else if([regextestct evaluateWithObject:phone] == YES) {
          NSLog(@"China Telecom");
        } else if ([regextestcu evaluateWithObject:phone] == YES) {
          NSLog(@"China Unicom");
        } else {
          NSLog(@"Unknow");
        }

        return YES;
    }
    else 
    {
        return NO;
    }
}
</code></pre>

<p>以上这段（来自网络）是手机号判断的详细方法。基本上这个判断就够用了，如果三大运营商，再出其他段的手机号。直接子啊上面做简单修改即可。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
</feed>
