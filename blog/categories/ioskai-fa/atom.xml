<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios开发 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-07-01T09:49:55+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EGOCache缓存框架详细讲解]]></title>
    <link href="http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie/"/>
    <updated>2015-07-01T00:10:18+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie</id>
    <content type="html"><![CDATA[<p><strong>EGOCache</strong>是一个轻量级的缓存框架。用法简单方便，在现在的项目中，我就用到EGOCache来缓存下载过的照片和字符串。</p>

<p>有人可能会问到，缓存照片还需要用EGOCache吗？<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">AFNetworking</a>和<a href="http://www.superqq.com/blog/2015/06/09/sdwebimagejia-zai-tu-pian-huan-cun-tu-pian/">SDWebImage</a>不是已经有这些功能了吗？</p>

<p>是的，不过AFNetworking和SDWebImage是http。我的项目用的是socket，所以我选择EGOCache来做缓存。用下来觉得EGOCache还是挺强大的。</p>

<h2>EGOCache简介</h2>

<pre><code>EGOCache is a simple, thread-safe key value cache store. It has native support for NSString, UI/NSImage, and NSData, but can store anything that implements &lt;NSCoding&gt;. All cached items expire after the timeout, which by default, is one day.
</code></pre>

<p>翻译过来就是：EGOCache一个简单、线程安全的基于 key-value 的缓存框架，原生支持NSString、UI/NSImage、和NSData，也支持储存任何实现<NSCoding>协议的类，可以设定缓存过期时间，默认是1天。</p>

<p>EGOCache只有一个类，EGOCache.h和EGOCache.m两个文件。用法也比较容易掌握，仔细研究一下EGOCache.h的方法，很快就可以上手。</p>

<p>EGOCache只提供了磁盘缓存，没有提供内存缓存。同时，也提供了清理缓存的方法：</p>

<pre><code>- (void)clearCache;
</code></pre>

<p>EGOCache还提供了判断缓存是否存在的方法：</p>

<pre><code>- (BOOL)hasCacheForKey:(NSString* __nonnull)key;
</code></pre>

<h2>通过Cocoapods直接加入项目</h2>

<p>直接在你的项目的Podfile加入下面一行：</p>

<pre><code>pod 'EGOCache'
</code></pre>

<p>然后执行：</p>

<pre><code>$ pod update
</code></pre>

<h2>EGOCache用法</h2>

<h3>用EGOCache缓存NSString</h3>

<p>存储：</p>

<pre><code>NSString *saveString = @"把我保存起来吧";
[[EGOCache globalCache] setString:saveString forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[saveString hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>NSString *getSaveString = [[EGOCache globalCache] stringForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveString" hash]]];
</code></pre>

<p>是不是感觉跟NSDictionary很相似，确实，前面我们说了EGOCache是基于key-value 的缓存框架。</p>

<h3>用EGOCache缓存UIImage</h3>

<p>存储：</p>

<pre><code> UIImage *saveImage = [UIImage imageNamed:@"iOSDevTip"];
[[EGOCache globalCache] setImage:saveImage forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveImage" hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>UIImage *getSaveImage = [[EGOCache globalCache] imageForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveImage" hash]]];
</code></pre>

<h3>用EGOCache缓存NSData</h3>

<p>存储：</p>

<pre><code>NSData *saveData = [NSData data];
[[EGOCache globalCache] setData:saveData forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveData" hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>UIImage *getSaveData = [[EGOCache globalCache] dataForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveData" hash]]];
</code></pre>

<h2>EGOCache源码下载</h2>

<p><a href="https://github.com/enormego/EGOCache">EGOCache</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CGContextRef使用简要教程]]></title>
    <link href="http://www.superqq.com/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng/"/>
    <updated>2015-06-29T10:55:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng</id>
    <content type="html"><![CDATA[<p>Graphics Context是图形上下文,也可以理解为一块画布,我们可以在上面进行绘画操作,绘制完成后,将画布放到我们的view中显示即可,view看作是一个画框.</p>

<p>CGContextRef功能强大，我们借助它可以画各种图形。开发过程中灵活运用这些技巧，可以帮助我们提供代码水平。</p>

<p>说到画图，我就立马想到：我的数学公式都快忘完了。</p>

<h2>高中数学你还记得多少？</h2>

<p>我记得我上学的时候，数学一直都很好。以至于在班里都不敢和别人吵吵闹闹。一吵吵闹闹，别人就会来一句：以为你数学好，就可以怎么样怎么样了是吧？说的我好无奈啊。</p>

<p>这么多年过去了，说句实话，高中时学的数学公式什么的，都忘记的差不多了。现在要去做高三的考题，估计比写代码还难。</p>

<p>作为一名程序员，数学好，一定是优势。就拿画图来说吧，如果你还清楚的记得那些公式，那么你就可以很随意地画出一些好看的图形出来。</p>

<p>接下来，我们来看看CGContextRef到底能实现些什么？</p>

<h2>写文字</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //开始写字
    [@"我是文字" drawInRect:CGRectMake(10, 10, 100, 30) withFont:font];  
    [super drawRect:rect];
}
</code></pre>

<p>这段代码就可以很漂亮的写出四个大字：我是文字。很容易理解，每句话都有注释。</p>

<h2>画直线</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //顶部横线
    CGContextMoveToPoint(ctx, 0, 10);
    CGContextAddLineToPoint(ctx, self.bounds.size.width, 10);
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<h2>画圆</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //void CGContextAddArc(CGContextRef c,CGFloat x, CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle, int clockwise)1弧度＝180°/π （≈57.3°） 度＝弧度×180°/π 360°＝360×π/180 ＝2π 弧度
    // x,y为圆点坐标，radius半径，startAngle为开始的弧度，endAngle为 结束的弧度，clockwise 0为顺时针，1为逆时针。
    CGContextAddArc(ctx, 100, 20, 20, 0, 2*M_PI, 0); //添加一个圆
    CGContextDrawPath(ctx, kCGPathStroke); //绘制路径
    [super drawRect:rect];
}
</code></pre>

<p>这个画圆的公式你还记得吗？你还知道M_PI是什么吗？等于多少吗？赶紧脑补一下吧！</p>

<h2>画矩形</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    CGContextAddRect(ctx, CGRectMake(2, 2, 30, 30));
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<p>图形千千万，万变不离其宗。更多画图方法，期待你的探索。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用正则表达式验证邮箱和手机号]]></title>
    <link href="http://www.superqq.com/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao/"/>
    <updated>2015-06-27T07:35:42+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao</id>
    <content type="html"><![CDATA[<blockquote><p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></blockquote>

<p>做iOS开发的童鞋，应该都用过正则表达式吧。正则表达式很好地，帮助我们判断一个字符串是否合法。比如：</p>

<ol>
<li><p>在做app注册页面的时候，需要判断手机号是否格式正确，是否够11位。</p></li>
<li><p>在做意见反馈的时候，需要判断邮箱格式是否正确。</p></li>
</ol>


<p>判断手机号和判断邮箱，应该是iOS开发者们最常用的。具体如何判断，简单整理如下：</p>

<h2>验证邮箱</h2>

<pre><code>+ (BOOL)validateEmail:(NSString *)email
{
    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}";
    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex];
    return [emailTest evaluateWithObject:email];
}
</code></pre>

<p>NSPredicate是一个Foundation类，是用来查询的，原理和用法都类似于SQL中的where。</p>

<h2>验证手机号</h2>

<h3>简单的判断方法</h3>

<pre><code>+ (BOOL)validatePhone:(NSString *)phone
{
    NSString *phoneRegex = @"1[3|5|7|8|][0-9]{9}";
    NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", phoneRegex];
    return [phoneTest evaluateWithObject:phone];
}
</code></pre>

<p>这只是简单地判断手机号格式。其实手机的格式还是有一点复杂的。</p>

<h3>详细的判断方法</h3>

<pre><code>//正则判断手机号码格式
+ (BOOL)validatePhone:(NSString *)phone
{
       /**
        * 手机号码
        * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        * 联通：130,131,132,152,155,156,185,186
        * 电信：133,1349,153,180,189
        */
       NSString * MOBILE = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";
       /**
        10         * 中国移动：China Mobile
        11         * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        12         */
       NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d{7}$";
       /**
        15         * 中国联通：China Unicom
        16         * 130,131,132,152,155,156,185,186
        17         */
       NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d{8}$";
       /**
        20         * 中国电信：China Telecom
        21         * 133,1349,153,180,189
        22         */
       NSString * CT = @"^1((33|53|8[09])[0-9]|349)\\d{7}$";
       /**
        25         * 大陆地区固话及小灵通
        26         * 区号：010,020,021,022,023,024,025,027,028,029
        27         * 号码：七位或八位
        28         */
      // NSString * PHS = @"^0(10|2[0-5789]|\\d{3})\\d{7,8}$";

     NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBILE];
     NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM];
     NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU];
     NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT];

    if (([regextestmobile evaluateWithObject:phone] == YES)
    || ([regextestcm evaluateWithObject:phone] == YES)
    || ([regextestct evaluateWithObject:phone] == YES)
    || ([regextestcu evaluateWithObject:phone] == YES))
    {
        if([regextestcm evaluateWithObject:phone] == YES) {
          NSLog(@"China Mobile");
        } else if([regextestct evaluateWithObject:phone] == YES) {
          NSLog(@"China Telecom");
        } else if ([regextestcu evaluateWithObject:phone] == YES) {
          NSLog(@"China Unicom");
        } else {
          NSLog(@"Unknow");
        }

        return YES;
    }
    else 
    {
        return NO;
    }
}
</code></pre>

<p>以上这段（来自网络）是手机号判断的详细方法。基本上这个判断就够用了，如果三大运营商，再出其他段的手机号。直接子啊上面做简单修改即可。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode真机调试报错：The Application Could Not Be Verified.]]></title>
    <link href="http://www.superqq.com/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified/"/>
    <updated>2015-06-26T15:33:34+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified</id>
    <content type="html"><![CDATA[<p> 今天真机调试的时候遇到这个错误：</p>

<pre><code>The application could not be verified.
</code></pre>

<p> 这还是第一次遇到，应该是手机上的app的证书跟现在的证书不一致导致。</p>

<p> 解决方法有两个</p>

<p> ###xcode中切换证书：</p>

<pre><code>你手机上的app用的是哪个证书，你现在还用那个证书运行。
</code></pre>

<p> ###删除手机上的app</p>

<pre><code>直接删除手机上的app，再运行就可以啦！
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSDate和NSString相互转换]]></title>
    <link href="http://www.superqq.com/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan/"/>
    <updated>2015-06-26T07:34:32+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan</id>
    <content type="html"><![CDATA[<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/2NSDate.jpg" alt="1" /></p>

<p>不积小流无以成江海，不及硅步无以至千里。做<a href="http://www.superqq.com/blog/2015/01/14/ioskai-fa-zhi-shou-shi-shi-bie-hui-zong/">iOS开发</a>也是这样，平时写代码要多收集一些有用的代码，以免每次都从新来一遍，不仅浪费时间，也影响开发效率。</p>

<p>有人把做app形容成盖房子，码农就是搬砖的，真的是形象无比。随着时间的推移，手里积累的优秀代码就越来越多。这样，盖起房子来，效率肯定是杠杠的。</p>

<p>我也会收集一些有用的代码，有的会写在博客里，有的会写成demo放在<a href="http://www.superqq.com/blog/2014/11/19/ioskai-fa-zhong-gitfen-zhi-chuang-jian-he-guan-li/">github</a>上面，有的就很安静的躺在我的电脑里。每次我用到的时候，我都会顺手复制过来。</p>

<p>今天给大家分享一些关于NSDate和NSString相互转换。百度一下，有一大推相关的方法。每次都百度，不如自己收集起来方便。</p>

<h2>NSDate转NSString</h2>

<p>日期转成字符串。这个虽然简单，但是我相信很多朋友初次遇到肯定束手无策。脑子里蹦出四个字：这怎么转？直接上代码：</p>

<pre><code>//获取系统当前时间
NSDate *currentDate = [NSDate date];
//用于格式化NSDate对象
NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
//设置格式：zzz表示时区
[dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
//NSDate转NSString
NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
//输出currentDateString
NSLog(@"%@",currentDateString);
</code></pre>

<p>NSDate对象包含两个部分，日期（Date）和时间（Time）。格式化的时间字符串主要也是针对日期和时间的。NSDateFormatter是一个很常用的类，用于格式化NSDate对象，支持本地化的信息。</p>

<p>NSDateFormatter常用的格式有：</p>

<pre><code>yyyy-MM-dd HH:mm:ss.SSS 
yyyy-MM-dd HH:mm:ss
yyyy-MM-dd
MM dd yyyy
</code></pre>

<p>NSDateFormatter格式化参数如下：</p>

<pre><code>G: 公元时代，例如AD公元
yy: 年的后2位
yyyy: 完整年
MM: 月，显示为1-12
MMM: 月，显示为英文月份简写,如 Jan
MMMM: 月，显示为英文月份全称，如 Janualy
dd: 日，2位数表示，如02
d: 日，1-2位显示，如 2
EEE: 简写星期几，如Sun
EEEE: 全写星期几，如Sunday
aa: 上下午，AM/PM
H: 时，24小时制，0-23
K：时，12小时制，0-11
m: 分，1-2位
mm: 分，2位
s: 秒，1-2位
ss: 秒，2位
S: 毫秒
</code></pre>

<h2>NSString转NSDate</h2>

<p>既然NSDate可以转成NSString，毫无疑问NSString也可以转成NSDate。代码如下：</p>

<pre><code>//需要转换的字符串
NSString *dateString = @"2015-06-26 08:08:08";
 //设置转换格式
NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
[formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
//NSString转NSDate
NSDate *date=[formatter dateFromString:dateString];
</code></pre>

<p>NSDate和NSString相互转换就是这么简单。</p>

<h2>转换工具类</h2>

<p>在项目中，我们需要用到转换的地方可能不止一处，所以建议我们定义一个工具类。在工具类里实现如下两个方法：</p>

<pre><code>//NSDate转NSString
+ (NSString *)stringFromDate:(NSDate *)date
{
    //获取系统当前时间
    NSDate *currentDate = [NSDate date];
    //用于格式化NSDate对象
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //设置格式：zzz表示时区
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
    //NSDate转NSString
    NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
    //输出currentDateString
    NSLog(@"%@",currentDateString);
    return currentDateString;
}

//NSString转NSDate
+ (NSDate *)dateFromString:(NSString *)string
{
    //需要转换的字符串
    NSString *dateString = @"2015-06-26 08:08:08";
    //设置转换格式
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    //NSString转NSDate
    NSDate *date=[formatter dateFromString:dateString];
    return date;
}
</code></pre>

<p>有了这个工具类，妈妈再也不用担心我的转换能力啦！</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
</feed>
