<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios开发 | 刚刚在线]]></title>
  <link href="http://worldligang.github.io/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://worldligang.github.io/"/>
  <updated>2015-04-03T16:50:35+08:00</updated>
  <id>http://worldligang.github.io/</id>
  <author>
    <name><![CDATA[刚刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSSortDescriptor排序]]></title>
    <link href="http://worldligang.github.io/blog/2015/03/27/nssortdescriptorpai-xu/"/>
    <updated>2015-03-27T19:01:45+08:00</updated>
    <id>http://worldligang.github.io/blog/2015/03/27/nssortdescriptorpai-xu</id>
    <content type="html"><![CDATA[<p>NSSortDescriptor可以实现按照对象的属性进行排序。比如我们有一个对象（LGPeople）。LGPeople有两个属性分别是名字（name）和年龄（age）。现在我们要按照LGPeople的年龄（age）来进行排序。</p>

<p>代码如下：</p>

<pre><code>    //按年龄排序
    NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"_age" ascending:NO];
    NSArray *sortDescriptors = [NSArray arrayWithObjects:sortDescriptor, nil];
    [arrayPeople sortUsingDescriptors:sortDescriptors];
</code></pre>

<p>这样是按照年龄的降序进行排序。如果想升序的话将NO改为YES即可。如果是按照名字进行排序的话也很简单：</p>

<pre><code>    //按姓名排序
    NSSortDescriptor *sortDescriptorName = [[NSSortDescriptor alloc] initWithKey:@"_name" ascending:NO];
    NSArray *sortDescriptors = [NSArray arrayWithObjects:sortDescriptorName, nil];
    [arrayPeople sortUsingDescriptors:sortDescriptors];
</code></pre>

<p>也许我们还有一种需求：先按照年龄排序，再按名字进行排序。代码如下：</p>

<pre><code>    //按年龄和名字排序
    NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"_age" ascending:NO];
    NSSortDescriptor *sortDescriptorName = [[NSSortDescriptor alloc] initWithKey:@"_name" ascending:NO];
    NSArray *sortDescriptors = [NSArray arrayWithObjects:sortDescriptor, sortDescriptorName, nil];
    [_mutArrVideo sortUsingDescriptors:sortDescriptors];
</code></pre>

<p>这样相同年龄的情况下，就会按照名字进行排序。当然还可以设置两个以上的排序条件。</p>

<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自己动手实现一个队列LGQueue]]></title>
    <link href="http://worldligang.github.io/blog/2015/03/24/zi-ji-dong-shou-chuang-jian-%5B%3F%5D-ge-dui-lie-lgqueue/"/>
    <updated>2015-03-24T17:13:39+08:00</updated>
    <id>http://worldligang.github.io/blog/2015/03/24/zi-ji-dong-shou-chuang-jian-[?]-ge-dui-lie-lgqueue</id>
    <content type="html"><![CDATA[<p>iOS系统没有提供queue容器，如果想用，需要手动自己来写一个：</p>

<p>.h</p>

<pre><code>//
//  LGQueue.h
//  AntsSportApp
//
//  Created by ligang on 15/3/24.
//  Copyright (c) 2015年 ligang. All rights reserved.
//

#import &lt;Foundation/Foundation.h&gt;

@interface LGQueue : NSObject

@property (nonatomic, strong) NSMutableArray *queue;

@property (nonatomic, readonly) NSInteger count;

- (void)enterQueue:(id)object;
- (id)exitQueue;
- (void)clear;



@end
</code></pre>

<p>.m</p>

<pre><code>//
//  LGQueue.m
//  AntsSportApp
//
//  Created by ligang on 15/3/24.
//  Copyright (c) 2015年 ligang. All rights reserved.
//

#import "LGQueue.h"

@implementation LGQueue

- (id)init
{
    if ( self = [super init] ) {

        self.queue = [[NSMutableArray alloc] init];
        _count = 0;

    }
    return self;
}

- (void)enterQueue:(id)object
{
    [self.queue addObject:object];
    _count = self.queue.count;
}


- (id)exitQueue
{
    if ( self.queue.count == 0 )  return nil;

    id object = [self.queue objectAtIndex:0];
    [self.queue removeObjectAtIndex:0];
    _count = self.queue.count;

    return object;

}


- (void)clear
{
    [self.queue removeAllObjects];
    _count = 0;
}

@end
</code></pre>

<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单例模式的两种写法]]></title>
    <link href="http://worldligang.github.io/blog/2015/03/21/dan-li-mo-shi-de-xie-fa/"/>
    <updated>2015-03-21T17:39:16+08:00</updated>
    <id>http://worldligang.github.io/blog/2015/03/21/dan-li-mo-shi-de-xie-fa</id>
    <content type="html"><![CDATA[<p>单例模式是iOS开发中最常用的设计模式，iOS的单例模式有两种官方写法，如下：</p>

<h3>1，常用写法</h3>

<pre><code>#import "LGManagerCenter.h"

static LGManagerCenter *managerCenter;

@implementation LGManagerCenter

+(LGManagerCenter *)sharedManager{
    if(!managerCenter)
        managerCenter=[[self allocWithZone:NULL] init];
    return  managerCenter;
}

@end
</code></pre>

<h3>2,用GCD创建单例类</h3>

<pre><code>#import "LGManagerCenter.h"


@implementation LGManagerCenter


+(LGManagerCenter *)sharedManager{
    static dispatch_once_t predicate;
    static LGManagerCenter * managerCenter;
    dispatch_once(&amp;predicate, ^{
        managerCenter=[[LGManagerCenter alloc] init];
    });
    return managerCenter;
}

@end
</code></pre>

<p>其中dispatch_once函数只执行一次。</p>

<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统提供的dispatch方法]]></title>
    <link href="http://worldligang.github.io/blog/2015/03/13/xi-tong-ti-gong-de-dispatchfang-fa/"/>
    <updated>2015-03-13T17:41:11+08:00</updated>
    <id>http://worldligang.github.io/blog/2015/03/13/xi-tong-ti-gong-de-dispatchfang-fa</id>
    <content type="html"><![CDATA[<p>为了方便地使用GCD，苹果提供了一些方法方便我们将block放在主线程或后台线程执行，或者延后执行。使用的例子如下所示：</p>

<pre><code> //  后台执行：
 dispatch_async(dispatch_get_global_queue(0, 0), ^{
      // something
 });

 // 主线程执行：
 dispatch_async(dispatch_get_main_queue(), ^{
      // something
 });

 // 一次性执行：
 static dispatch_once_t onceToken;
 dispatch_once(&amp;onceToken, ^{
     // code to be executed once
 });

 // 延迟2秒执行：
 double delayInSeconds = 2.0;
 dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
     // code to be executed on the main queue after delay
 });
</code></pre>

<p>dispatch_queue_t也可以自己定义，如要自定义queue，可以用dispatch_queue_create方法，示例如下：</p>

<pre><code> // 自定义dispatch_queue_t
 dispatch_queue_t urls_queue = dispatch_queue_create("blog.devtang.com", NULL);
 dispatch_async(urls_queue, ^{  
　 　// your code 
 });
 dispatch_release(urls_queue);
</code></pre>

<p>另外，GCD还有一些高级用法，例如让后台两个线程并行执行，然后等两个线程都结束后，再汇总执行结果。这个可以用dispatch_group_t、dispatch_group_async、dispatch_group_notify来实现，示例如下：</p>

<pre><code> // 合并汇总结果
 dispatch_group_t group = dispatch_group_create();
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程一
 });
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程二
 });
 dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{
      // 汇总结果
 });
</code></pre>

<p>文章来自唐巧《iOS开发进阶》</p>

<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发下载文件速度计算]]></title>
    <link href="http://worldligang.github.io/blog/2015/01/29/ioskai-fa-xia-zai-wen-jian-su-du-ji-suan/"/>
    <updated>2015-01-29T10:40:38+08:00</updated>
    <id>http://worldligang.github.io/blog/2015/01/29/ioskai-fa-xia-zai-wen-jian-su-du-ji-suan</id>
    <content type="html"><![CDATA[<p>当我们写下载界面的时候，需要向用户展示每秒下载多少KB，这个时候就需要计算速度。如下：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlykfVEtYcoETGMzCaNgWWfvvjjxmJYIj9ibjNHHmn7f1oOTgEbcTstj44G2EjdqRjeMxSqdJfVaAibPA/640" /></a></p>

<p>我用的是AFNetworking来做下载的，我们拿AFHTTPRequestOperation来举列，AFHTTPRequestOperation中有个方法：</p>

<pre><code>- (void)setDownloadProgressBlock:(void (^)(NSUInteger bytesRead, long long totalBytesRead, long long totalBytesExpectedToRead))block
</code></pre>

<p>这个方法读取导数据之后通过block回调。计算速度就是在这个block里面完成的。</p>

<p>需要定义一个下载对象：DownTask。DownTask需要有的属性：totalRead（一秒读取的数据）、speed（速度）、date（记录上一秒计算之后的时间）。注意：这里的一秒不是严格意义上的一秒，有可能大于一秒，我们计算的是平均速度，所以不会误差太大。</p>

<pre><code>        //计算一秒中的速度
        downTask.totalRead += bytesRead;

        //获取当前时间
        NSDate *currentDate = [NSDate date];

        //当前时间和上一秒时间做对比，大于等于一秒就去计算
        if ([currentDate timeIntervalSinceDate:downTask.date] &gt;= 1) {
            //时间差
            double time = [currentDate timeIntervalSinceDate:downTask.date];

            //计算速度
            long long speed = downTask.total/time;

            //把速度转成KB或M
            downTask.speed = [downTask formatByteCount:speed];

            //维护变量，将计算过的清零
            downTask.totalRead = 0.0;

            //维护变量，记录这次计算的时间

            downTask.date = currentDate;
</code></pre>

<p>其中， downTask.speed = [downTask formatByteCount:speed];是用来将字节转化成我们需要的KB或M。用到的是：NSByteCountFormatter，具体实现如下：</p>

<pre><code>- (NSString*)formatByteCount:(long long)size
{
    return [NSByteCountFormatter stringFromByteCount:size countStyle:NSByteCountFormatterCountStyleFile];
}
</code></pre>

<p>这个方法是放在下载对象DownTask里面的。</p>

<p>以上就是我计算下载速度的方法。希望能给你带来帮助。</p>

<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
</feed>
