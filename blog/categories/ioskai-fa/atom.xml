<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios开发 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-12-08T21:56:43+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于启用 HTTPS 的一些经验分享]]></title>
    <link href="http://www.superqq.com/blog/2015/12/08/some-experiences-https/"/>
    <updated>2015-12-08T21:54:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/08/some-experiences-https</id>
    <content type="html"><![CDATA[<p><img src="http://images.90159.com/12/https.jpg" alt="https" /></p>

<p>随着国内网络环境的持续恶化，各种篡改和劫持层出不穷，越来越多的网站选择了全站 HTTPS。HTTPS 通过 TLS 层和证书机制提供了内容加密、身份认证和数据完整性三大功能，可以有效防止数据被查看或篡改，以及防止中间人冒充。本文分享一些启用 HTTPS 过程中的经验，重点是如何与一些新出的安全规范配合使用。至于 HTTPS 的部署及优化，之前写过很多，本文不重复了。</p>

<!--more-->


<h2>理解 Mixed Content</h2>

<p>HTTPS 网页中加载的 HTTP 资源被称之为 Mixed Content(混合内容)，不同浏览器对 Mixed Content 有不一样的处理规则。</p>

<h2>早期的 IE</h2>

<p>早期的 IE 在发现 Mixed Content 请求时，会弹出「是否只查看安全传送的网页内容?」这样一个模态对话框，一旦用户选择「是」，所有 Mixed Content 资源都不会加载;选择「否」，所有资源都加载。</p>

<h2>比较新的 IE</h2>

<p>比较新的 IE 将模态对话框改为页面底部的提示条，没有之前那么干扰用户。而且默认会加载图片类 Mixed Content，其它如 JavaScript、CSS 等资源还是会根据用户选择来决定是否加载。</p>

<h2>现代浏览器</h2>

<p>现代浏览器(Chrome、Firefox、Safari、Microsoft Edge)，基本上都遵守了 W3C 的 Mixed Content 规范，将 Mixed Content 分为Optionally-blockable 和 Blockable 两类：</p>

<p>Optionally-blockable 类 Mixed Content 包含那些危险较小，即使被中间人篡改也无大碍的资源。现代浏览器默认会加载这类资源，同时会在控制台打印警告信息。这类资源包括：</p>

<pre><code>通过  标签加载的图片(包括 SVG 图片);

通过 &lt;img&gt; 标签加载的图片（包括 SVG 图片）；

通过 &lt;video&gt; / &lt;audio&gt; 和 &lt;source&gt; 标签加载的视频或音频；

预读的（Prefetched）资源；
</code></pre>

<h2>预读的(Prefetched)资源;</h2>

<p>除此之外所有的 Mixed Content 都是 Blockable，浏览器必须禁止加载这类资源。所以现代浏览器中，对于 HTTPS 页面中的 JavaScript、CSS 等 HTTP 资源，一律不加载，直接在控制台打印错误信息。</p>

<h2>移动浏览器</h2>

<p>前面所说都是桌面浏览器的行为，移动端情况比较复杂，当前大部分移动浏览器默认都允许加载 Mixed Content。也就是说，对于移动浏览器来说，HTTPS 中的 HTTP 资源，无论是图片还是 JavaScript、CSS，默认都会加载。</p>

<p>一般选择了全站 HTTPS，就要避免出现 Mixed Content，页面所有资源请求都走 HTTPS 协议才能保证所有平台所有浏览器下都没有问题。</p>

<h2>合理使用 CSP</h2>

<p>CSP，全称是 Content Security Policy，它有非常多的指令，用来实现各种各样与页面内容安全相关的功能。</p>

<pre><code>block-all-mixed-content
</code></pre>

<p>前面说过，对于 HTTPS 中的图片等 Optionally-blockable 类 HTTP 资源，现代浏览器默认会加载。图片类资源被劫持，通常不会有太大的问题，但也有一些风险，例如很多网页按钮是用图片实现的，中间人把这些图片改掉，也会干扰用户使用。</p>

<p>通过 CSP 的 block-all-mixed-content 指令，可以让页面进入对混合内容的严格检测(Strict Mixed Content Checking)模式。在这种模式下，所有非 HTTPS 资源都不允许加载。跟其它所有 CSP 规则一样，可以通过以下两种方式启用这个指令：</p>

<h2>HTTP 响应头方式：</h2>

<pre><code>Content-Security-Policy: block-all-mixed-content 
</code></pre>

<p><meta>标签方式：</p>

<pre><code>&lt;meta http-equiv="Content-Security-Policy" content="block-all-mixed-content"&gt; 


upgrade-insecure-requests
</code></pre>

<p>历史悠久的大站在往 HTTPS 迁移的过程中，工作量往往非常巨大，尤其是将所有资源都替换为 HTTPS 这一步，很容易产生疏漏。即使所有代码都确认没有问题，很可能某些从数据库读取的字段中还存在 HTTP 链接。</p>

<p>而通过 upgrade-insecure-requests 这个 CSP 指令，可以让浏览器帮忙做这个转换。启用这个策略后，有两个变化：</p>

<pre><code>页面所有 HTTP 资源，会被替换为 HTTPS 地址再发起请求;

页面所有站内链接，点击后会被替换为 HTTPS 地址再跳转;
</code></pre>

<p>跟其它所有 CSP 规则一样，这个指令也有两种方式来启用，具体格式请参考上一节。需要注意的是 upgrade-insecure-requests 只替换协议部分，所以只适用于 HTTP/HTTPS 域名和路径完全一致的场景。</p>

<h2>合理使用 HSTS</h2>

<p>在网站全站 HTTPS 后，如果用户手动敲入网站的 HTTP 地址，或者从其它地方点击了网站的 HTTP 链接，依赖于服务端 301/302 跳转才能使用 HTTPS 服务。而第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>

<h2>HSTS 基本使用</h2>

<p>这个问题可以通过 HSTS(HTTP Strict Transport Security，RFC6797)来解决。HSTS 是一个响应头，格式如下：</p>

<pre><code>Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload] 
</code></pre>

<p>max-age，单位是秒，用来告诉浏览器在指定时间内，这个网站必须通过 HTTPS 协议来访问。也就是对于这个网站的 HTTP 地址，浏览器需要先在本地替换为 HTTPS 之后再发送请求。</p>

<p>includeSubDomains，可选参数，如果指定这个参数，表明这个网站所有子域名也必须通过 HTTPS 协议来访问。</p>

<p>preload，可选参数，后面再介绍它的作用。</p>

<p>HSTS 这个响应头只能用于 HTTPS 响应;网站必须使用默认的 443 端口;必须使用域名，不能是 IP。而且启用 HSTS 之后，一旦网站证书错误，用户无法选择忽略。</p>

<p>HSTS Preload List</p>

<p>可以看到 HSTS 可以很好的解决 HTTPS 降级攻击，但是对于 HSTS 生效前的首次 HTTP 请求，依然无法避免被劫持。浏览器厂商们为了解决这个问题，提出了 HSTS Preload List 方案：内置一份列表，对于列表中的域名，即使用户之前没有访问过，也会使用 HTTPS 协议;列表可以定期更新。</p>

<p>目前这个 Preload List 由 Google Chrome 维护，Chrome、Firefox、Safari、IE 11 和 Microsoft Edge 都在使用。如果要想把自己的域名加进这个列表，首先需要满足以下条件：</p>

<pre><code>拥有合法的证书(如果使用 SHA-1 证书，过期时间必须早于 2016 年);

将所有 HTTP 流量重定向到 HTTPS;

确保所有子域名都启用了 HTTPS;

输出 HSTS 响应头：

max-age 不能低于 18 周(10886400 秒);

必须指定 includeSubdomains 参数;

必须指定 preload 参数;
</code></pre>

<p>即便满足了上述所有条件，也不一定能进入 HSTS Preload Lis。通过 Chrome 的 chrome://net-internals/#hsts 工具，可以查询某个网站是否在 Preload List 之中，还可以手动把某个域名加到本机 Preload List。</p>

<p>对于 HSTS 以及 HSTS Preload List，我的建议是只要你不能确保永远提供 HTTPS 服务，就不要启用。因为一旦 HSTS 生效，你再想把网站重定向为 HTTP，之前的老用户会被无限重定向，唯一的办法是换新域名。</p>

<h2>CDN 安全</h2>

<p>对于大站来说，全站迁移到 HTTPS 后还是得用 CDN，只是必须选择支持 HTTPS 的 CDN 了。如果使用第三方 CDN，安全方面有一些需要考虑的地方。</p>

<h2>合理使用 SRI</h2>

<p>HTTPS 可以防止数据在传输中被篡改，合法的证书也可以起到验证服务器身份的作用，但是如果 CDN 服务器被入侵，导致静态文件在服务器上被篡改，HTTPS 也无能为力。</p>

<p>W3C 的 SRI(Subresource Integrity)规范可以用来解决这个问题。SRI 通过在页面引用资源时指定资源的摘要签名，来实现让浏览器验证资源是否被篡改的目的。只要页面不被篡改，SRI 策略就是可靠的。</p>

<p>SRI 并不是 HTTPS 专用，但如果主页面被劫持，攻击者可以轻松去掉资源摘要，从而失去浏览器的 SRI 校验机制。</p>

<h2>了解 Keyless SSL</h2>

<p>另外一个问题是，在使用第三方 CDN 的 HTTPS 服务时，如果要使用自己的域名，需要把对应的证书私钥给第三方，这也是一件风险很高的事情。</p>

<p>CloudFlare 公司针对这种场景研发了 Keyless SSL 技术。你可以不把证书私钥给第三方，改为提供一台实时计算的 Key Server 即可。CDN 要用到私钥时，通过加密通道将必要的参数传给 Key Server，由 Key Server 算出结果并返回即可。整个过程中，私钥都保管在自己的 Key Server 之中，不会暴露给第三方。</p>

<p>CloudFlare 的这套机制已经开源，如需了解详情，可以查看他们官方博客的这篇文章：Keyless SSL: The Nitty Gritty Technical Details。</p>

<p>好了，本文先就写到这里，需要注意的是本文提到的 CSP、HSTS 以及 SRI 等策略都只有最新的浏览器才支持，详细的支持度可以去 CanIUse 查。切换到 HTTPS 之后，在性能优化上有很多新工作要做，这部分内容我在之前的博客中写过很多，这里不再重复，只说最重要的一点：既然都 HTTPS 了，赶紧上 HTTP/2 才是正道。</p>

<p>内容来源：Jerry Qu的小站</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9横竖屏设置的处理方法和实例讲解]]></title>
    <link href="http://www.superqq.com/blog/2015/12/07/ios9-interface-orientation/"/>
    <updated>2015-12-07T23:30:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/07/ios9-interface-orientation</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://www.superqq.com/blog/2015/12/07/ios9-interface-orientation/">http://www.superqq.com/blog/2015/12/07/ios9-interface-orientation/</a></p>

<p>在一般的视频类APP播放的时候都会支持横屏，这样做的好处就是便于观看。你的项目中支持横屏吗？我们一起了解一下，在iOS9中横竖屏设置的处理方法吧！</p>

<h2>支持横竖屏配置</h2>

<p>在iOS6以后，如果APP需要支持横屏，需要在xcode设置中General里面进行勾选配置：</p>

<!--more-->


<p><img src="http://images.90159.com/12/orientation1.png" alt="orientation1" /></p>

<p>配置完成之后，我们可以看一下Info.plist里面的Supported interface orientations选项也相应的改变了。如下图：</p>

<p><img src="http://images.90159.com/12/orientation2.png" alt="orientation2" /></p>

<p>当然，我们也可以直接在Info.plist进行配置。</p>

<h2>支持横竖屏方法</h2>

<p>在iOS6之前我们可以直接用这个方法进行配置：</p>

<pre><code>- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0) __TVOS_PROHIBITED;
</code></pre>

<p>在iOS6之后，这个方法被NS_DEPRECATED_IOS，也就是废弃掉了。废弃了这个方法，苹果相应的也给出了新的方法来代替：</p>

<pre><code>// New Autorotation support.
- (BOOL)shouldAutorotate NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;
- (UIInterfaceOrientationMask)supportedInterfaceOrientations NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;
</code></pre>

<p>我们可以看到iOS6之前是一个方法，在iOS6之后变成两个方法了，一个是是否旋转的方法，一个是支持的方向的方法。</p>

<h2>实例一：</h2>

<p>假设：我们ViewController是直接加载window的self.window.rootViewController上面的。代码如下：</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    ViewController *vc = [[ViewController alloc] init];
    self.window.rootViewController = vc;
    [self.window makeKeyAndVisible];
    return YES;
}
</code></pre>

<p>如果我们要是想支持上面General里勾选的方向（竖屏、横屏向左已经横屏向右）该如何实现呢？首先，我们应该设置让他支持旋转，然后在设置支持的方向。代码如下：</p>

<pre><code>//支持旋转
-(BOOL)shouldAutorotate{
   return YES;
}
//支持的方向
- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    return UIInterfaceOrientationMaskAllButUpsideDown;
}
</code></pre>

<p>其中UIInterfaceOrientationMask是一个枚举：</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {
    UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait),
    UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft),
    UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight),
    UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown),
    UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),
    UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown),
    UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),
} __TVOS_PROHIBITED;    
</code></pre>

<p>可以根据自己的需求来选择。上面我们说了假设这个条件，如果rootViewController上导航，我们直接在ViewController里面设置，这个方法就不灵了。（大家可以自己测试一下）</p>

<h2>实例二：</h2>

<p>为什么是导航上面的方法就不灵了呢？原因很简单，我们没有设置导航支持的方向。别忘了UINavigationController也是UIViewController的子类。需要受到同样的待遇的。</p>

<p>如何设置呢？我们可以创建一个UINavigationController的子类，假设叫GGPublicNavigationViewController。然后，我们在GGPublicNavigationViewController.m文件里面也实现着两个方法：</p>

<pre><code>//支持旋转
-(BOOL)shouldAutorotate{
   return YES;
}
//支持的方向
- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    return UIInterfaceOrientationMaskAllButUpsideDown;
}
</code></pre>

<p>这样设置之后，即使我们push进去的UIViewController没有实现上面的连个方法，也是可以支持横屏的。也就是说，我们push的所有都支持横屏。这个做法是不是很暴力！</p>

<h2>实例三：</h2>

<p>有些童鞋会问了，如何控制每个界面支持的方向呢？这也是可以办到的，在GGPublicNavigationViewController不能写死支持哪个。我们可以这么写：</p>

<pre><code>-(BOOL)shouldAutorotate{
    return [self.topViewController shouldAutorotate];
}
//支持的方向
- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    return [self.topViewController supportedInterfaceOrientations];;
}
</code></pre>

<p>self.topViewController是当前导航显示的UIViewController，这样就可以控制每个UIViewController所支持的方向啦！</p>

<p>好啦，关于iOS9中横竖屏的处理就说这么多吧！（其实iOS7、iOS8也是这么设置的）如果你觉得文章还不错，分享一下吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VIP群福利：Git使用教程（视频+PPT）]]></title>
    <link href="http://www.superqq.com/blog/2015/12/05/git-use-video-ppt/"/>
    <updated>2015-12-05T20:07:12+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/05/git-use-video-ppt</id>
    <content type="html"><![CDATA[<p>天才帝一步应用源代码分享到<a href="http://www.superqq.com/blog/2015/11/19/create-high-efficiency-ios-group/">iOS开发实战交流VIP群</a>，已经有不少朋友下载。这个APP也是一个小小的想法，希望能激发大家的灵感，做出更多有意义的属于自己的APP。</p>

<p>iOS开发实战交流VIP群已经有几百位朋友加入，这里是一个非常不错的交流平台，欢迎更多朋友加入！详情点击这里。</p>

<p>愿大家除了思维上、技术上有所提高，更能成为网络上无话不谈的知心朋友！</p>

<p>今天给大家分享Git使用教程：</p>

<h2>Git是什么？</h2>

<!--more-->


<p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。作为一名iOS开发者，应该掌握！当然，也有朋友用SVN来管理，SVN也是有相应的命令。</p>

<p>在使用Git之前，我还用过最笨的办法通过手动来管理代码。管理起来相当不便，尤其是团队多人开发时，根本无法用手动来管理代码。</p>

<p>直到接触的Git，才感受到它的强大。Git其实没有大家想象的那么难，刚开始接触的时候，可能不知道如何下手。当你真正的用一段时间之后，你会掌握一些常用的命令，比如：git status、git commit -m “message”、也会理解里面的一些术语，比如仓库、分支等等。</p>

<h2>Git视频教程</h2>

<p>为了帮助大家快速上手Git，上周录制了一期视频教程《Git使用教程》已经上传到iOS开发实战交流VIP群。欢迎大家到群文件里面下载。</p>

<p>视频里面有讲到用Homebrew来安装Git，大家电脑上如果没有装Homebrew，可以通过下面的命令来安装：</p>

<pre><code>ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></pre>

<p>Homebrew的官方：</p>

<pre><code>http://brew.sh/
</code></pre>

<p>如果在看视频教程中，遇到问题，可以到VIP群里讨论。来吧，一起征服Git！</p>

<h2>PPT截图</h2>

<p>PPT里面整理了Git的常用命令、别名设置、一些资料网站等等，我把PPT里面的内容整理出来，大家一起学习：</p>

<p><img src="http://images.90159.com/git/1.png" alt="1" />
<img src="http://images.90159.com/git/2.png" alt="1" />
<img src="http://images.90159.com/git/3.png" alt="1" />
<img src="http://images.90159.com/git/4.png" alt="1" />
<img src="http://images.90159.com/git/5.png" alt="1" />
<img src="http://images.90159.com/git/6.png" alt="1" />
<img src="http://images.90159.com/git/7.png" alt="1" />
<img src="http://images.90159.com/git/8.png" alt="1" />
<img src="http://images.90159.com/git/9.png" alt="1" />
<img src="http://images.90159.com/git/10.png" alt="1" />
<img src="http://images.90159.com/git/11.png" alt="1" />
<img src="http://images.90159.com/git/12.png" alt="1" />
<img src="http://images.90159.com/git/13.png" alt="1" />
<img src="http://images.90159.com/git/14.png" alt="1" />
<img src="http://images.90159.com/git/15.png" alt="1" />
<img src="http://images.90159.com/git/16.png" alt="1" />
<img src="http://images.90159.com/git/17.png" alt="1" />
<img src="http://images.90159.com/git/18.png" alt="1" />
<img src="http://images.90159.com/git/19.png" alt="1" />
<img src="http://images.90159.com/git/20.png" alt="1" />
<img src="http://images.90159.com/git/21.png" alt="1" />
<img src="http://images.90159.com/git/22.png" alt="1" />
<img src="http://images.90159.com/git/23.png" alt="1" />
<img src="http://images.90159.com/git/24.png" alt="1" />
<img src="http://images.90159.com/git/25.png" alt="1" />
<img src="http://images.90159.com/git/26.png" alt="1" />
<img src="http://images.90159.com/git/27.png" alt="1" />
<img src="http://images.90159.com/git/28.png" alt="1" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级Xcode7之后VVDocumenter-Xcode不能用的解决办法]]></title>
    <link href="http://www.superqq.com/blog/2015/12/03/vvdocumenter-xcode7-not-work/"/>
    <updated>2015-12-03T22:24:57+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/03/vvdocumenter-xcode7-not-work</id>
    <content type="html"><![CDATA[<p>VVDocumenter-Xcode是Xcode上一款快速添加标准注释，并可以自动生成文档的插件。有了VVDocumenter-Xcode，规范化的注释，只需要输入三个斜线“///”就可以搞定，非常方面实用，目前已经支持Swift。</p>

<p>Objective-C效果图：</p>

<p><img src="http://images.90159.com/11/vvdocumenter1.gif" alt="VVDocumenter1" /></p>

<p>Swift效果图：</p>

<p><img src="http://images.90159.com/11/vvdocumenter2.gif" alt="VVDocumenter1" /></p>

<p>从Xcode 5开始，苹果要求加入UUID证书从而保证插件的稳定性。因此Xcode版本更新之后需要在VVDocumenter-Xcode的Info.plist文件中添加Xcode的UUID。</p>

<h2>步骤如下：</h2>

<h3>一、查看Xcode的UUID</h3>

<h4>方式1</h4>

<p>在终端执行</p>

<pre><code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID
</code></pre>

<p><img src="http://images.90159.com/11/vvdocumenter3.jpg" alt="VVDocumenter1" /></p>

<p>拷贝选中的字符串。</p>

<h4>方式2</h4>

<p>在/Applications目录中找到Xcode.app，右键”显示包内容”，进入Contents文件夹，双击Info.plist打开，找到DVTPlugInCompatibilityUUID，拷贝后面的字符串。</p>

<h3>二、添加Xcode的UUID到VVDocumenter-Xcode的Info.plist文件</h3>

<h4>方式1&ndash;插件已经安装完成</h4>

<p>1、打开xcode插件所在的目录：~/Library/Application Support/Developer/Shared/Xcode/Plug-ins；</p>

<p>2、选择已经安装的插件例如VVDocumenter-Xcode，右键”显示包内容”；</p>

<p>3、找到info.plist 文件，找到DVTPlugInCompatibilityUUIDs的项目，添加一个Item，Value的值为之前Xcode的UUID，保存。</p>

<p><img src="http://images.90159.com/11/vvdocumenter4.jpg" alt="VVDocumenter1" /></p>

<h4>方式2&ndash;插件还未安装/重新安装</h4>

<p>1、从GitHub克隆仓库到本地，在Xcode中打开项目，选择项目名称，在TAGETS下选中VVDocumenter-Xcode；</p>

<p>2、选择Info，找到DVTPlugInCompatibilityUUIDs的项目，添加一个Item，Value的值为之前Xcode的UUID；</p>

<p>3、Build项目，VVDocumenter-Xcode会自动安装。</p>

<h3>三、重启Xcode</h3>

<p>Xcode 6之后，重启Xcode时会提示“Load bundle”、 “Skip Bundle”，这里必须选择“Load bundle”，不然插件无法使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之如何跳到系统设置里的各种设置界面]]></title>
    <link href="http://www.superqq.com/blog/2015/12/01/jump-setting-per-page/"/>
    <updated>2015-12-01T22:12:54+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/01/jump-setting-per-page</id>
    <content type="html"><![CDATA[<p>昨天的文章<a href="http://www.superqq.com/blog/2015/11/30/jump-to-setting-wifi/">《iOS开发之如何跳到系统设置里的WiFi界面》</a>介绍了如何从APP里跳到WiFi设置界面，很多朋友非常喜欢这样的小功能，还有朋友正想做这个功能刚好看见啦！</p>

<h2>跳到更多设置界面</h2>

<p>除了跳到WiFi设置界面，能不能跳到其他的设置界面呢？比如：定位服务、FaceTime、音乐等等。都是可以的，一起来看看如何实现的！</p>

<!--more-->


<h2>定位服务</h2>

<p>定位服务有很多APP都有，如果用户关闭了定位，那么，我们在APP里面可以提示用户打开定位服务。点击到设置界面设置，直接跳到定位服务设置界面。代码如下：</p>

<pre><code>//定位服务设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=LOCATION_SERVICES"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<p>这样就可以跳到系统设置的定位服务界面啦！我们继续看几个列子。</p>

<h2>FaceTime</h2>

<pre><code>//FaceTime设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=FACETIME"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>音乐</h2>

<pre><code>//音乐设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=MUSIC"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>墙纸设置界面</h2>

<pre><code>//墙纸设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=Wallpaper"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>蓝牙设置界面</h2>

<pre><code>//蓝牙设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=Bluetooth"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
   [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>iCloud设置界面</h2>

<pre><code>//iCloud设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=CASTLE"];
if ([[UIApplication sharedApplication] canOpenURL:url]
{
   [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>参数配置</h2>

<p>看到这几个例子，大家有没有发现，想跳到哪个设置界面只需要prefs:root=后面的值即可！是的，就是这样的。</p>

<p>我在网上找到一个列表，可以跳到这些界面的参数配置：</p>

<pre><code>About — prefs:root=General&amp;path=About
Accessibility — prefs:root=General&amp;path=ACCESSIBILITY
Airplane Mode On — prefs:root=AIRPLANE_MODE
Auto-Lock — prefs:root=General&amp;path=AUTOLOCK
Brightness — prefs:root=Brightness
Bluetooth — prefs:root=General&amp;path=Bluetooth
Date &amp; Time — prefs:root=General&amp;path=DATE_AND_TIME
FaceTime — prefs:root=FACETIME
General — prefs:root=General
Keyboard — prefs:root=General&amp;path=Keyboard
iCloud — prefs:root=CASTLE
iCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP
International — prefs:root=General&amp;path=INTERNATIONAL
Location Services — prefs:root=LOCATION_SERVICES
Music — prefs:root=MUSIC
Music Equalizer — prefs:root=MUSIC&amp;path=EQ
Music Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimit
Network — prefs:root=General&amp;path=Network
Nike + iPod — prefs:root=NIKE_PLUS_IPOD
Notes — prefs:root=NOTES
Notification — prefs:root=NOTIFICATIONS_ID
Phone — prefs:root=Phone
Photos — prefs:root=Photos
Profile — prefs:root=General&amp;path=ManagedConfigurationList
Reset — prefs:root=General&amp;path=Reset
Safari — prefs:root=Safari
Siri — prefs:root=General&amp;path=Assistant
Sounds — prefs:root=Sounds
Software Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK
Store — prefs:root=STORE
Twitter — prefs:root=TWITTER
Usage — prefs:root=General&amp;path=USAGE
VPN — prefs:root=General&amp;path=Network/VPN
Wallpaper — prefs:root=Wallpaper
Wi-Fi — prefs:root=WIFI
</code></pre>

<p>大家可以根据自己的需求，跳到不同的设置界面。如果你喜欢这篇文章的话，欢迎分享给更多的朋友，也可以收藏起来，以备不时之需！</p>

<p><a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>
]]></content>
  </entry>
  
</feed>
