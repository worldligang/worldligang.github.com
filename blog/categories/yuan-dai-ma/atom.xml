<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 源代码 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/yuan-dai-ma/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-07-28T20:45:48+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[著名的AFNetworking网络基础库Swift版Alamofire]]></title>
    <link href="http://www.superqq.com/blog/2015/07/28/swift-alamofire/"/>
    <updated>2015-07-28T20:42:52+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/28/swift-alamofire</id>
    <content type="html"><![CDATA[<blockquote><p>作者李刚是刚刚在线（www.superqq.com）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://upload-images.jianshu.io/upload_images/624136-963198258f95cc10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOSDevTip" /></p>

<p><a href="https://github.com/Alamofire/Alamofire" target="_blank" title=“源代码”>源代码</a></p>

<p><img src="https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png" alt="Alamofire: Elegant Networking in Swift" /></p>

<p><a href="https://travis-ci.org/Alamofire/Alamofire"><img src="https://travis-ci.org/Alamofire/Alamofire.svg" alt="Build Status" /></a>
<a href="https://img.shields.io/cocoapods/v/Alamofire.svg"><img src="https://img.shields.io/cocoapods/v/Alamofire.svg" alt="Cocoapods Compatible" /></a>
<a href="https://github.com/Carthage/Carthage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage Compatible" /></a>
<a href="http://cocoadocs.org/docsets/Alamofire"><img src="https://img.shields.io/cocoapods/l/Alamofire.svg?style=flat&amp;color=gray" alt="License" /></a>
<a href="http://cocoadocs.org/docsets/Alamofire"><img src="https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat" alt="Platform" /></a>
<a href="http://twitter.com/AlamofireSF"><img src="https://img.shields.io/badge/twitter-@AlamofireSF-blue.svg?style=flat" alt="Twitter" /></a></p>

<p>Alamofire is an HTTP networking library written in Swift.</p>

<h2>Features</h2>

<ul>
<li>[x] Chainable Request / Response methods</li>
<li>[x] URL / JSON / plist Parameter Encoding</li>
<li>[x] Upload File / Data / Stream / MultipartFormData</li>
<li>[x] Download using Request or Resume data</li>
<li>[x] Authentication with NSURLCredential</li>
<li>[x] HTTP Response Validation</li>
<li>[x] TLS Certificate and Public Key Pinning</li>
<li>[x] Progress Closure &amp; NSProgress</li>
<li>[x] cURL Debug Output</li>
<li>[x] Comprehensive Unit Test Coverage</li>
<li>[x] <a href="http://cocoadocs.org/docsets/Alamofire">Complete Documentation</a></li>
</ul>


<h2>Requirements</h2>

<ul>
<li>iOS 7.0+ / Mac OS X 10.9+</li>
<li>Xcode 6.4</li>
</ul>


<h2>Communication</h2>

<ul>
<li>If you <strong>need help</strong>, use <a href="http://stackoverflow.com/questions/tagged/alamofire">Stack Overflow</a>. (Tag &lsquo;alamofire&rsquo;)</li>
<li>If you&rsquo;d like to <strong>ask a general question</strong>, use <a href="http://stackoverflow.com/questions/tagged/alamofire">Stack Overflow</a>.</li>
<li>If you <strong>found a bug</strong>, open an issue.</li>
<li>If you <strong>have a feature request</strong>, open an issue.</li>
<li>If you <strong>want to contribute</strong>, submit a pull request.</li>
</ul>


<h2>Installation</h2>

<blockquote><p><strong>Embedded frameworks require a minimum deployment target of iOS 8 or OS X Mavericks.</strong></p>

<p>To use Alamofire with a project targeting iOS 7, you must include all Swift files located inside the <code>Source</code> directory directly in your project. See the <a href="#source-file">&lsquo;Source File&rsquo;</a> section for additional instructions.</p></blockquote>

<h3>CocoaPods</h3>

<p><a href="http://cocoapods.org">CocoaPods</a> is a dependency manager for Cocoa projects.</p>

<p>CocoaPods 0.36 adds supports for Swift and embedded frameworks. You can install it with the following command:</p>

<pre><code class="bash">$ gem install cocoapods
</code></pre>

<p>To integrate Alamofire into your Xcode project using CocoaPods, specify it in your <code>Podfile</code>:</p>

<pre><code class="ruby">source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', '~&gt; 1.3'
</code></pre>

<p>Then, run the following command:</p>

<pre><code class="bash">$ pod install
</code></pre>

<h3>Carthage</h3>

<p><a href="https://github.com/Carthage/Carthage">Carthage</a> is a decentralized dependency manager that automates the process of adding frameworks to your Cocoa application.</p>

<p>You can install Carthage with <a href="http://brew.sh/">Homebrew</a> using the following command:</p>

<pre><code class="bash">$ brew update
$ brew install carthage
</code></pre>

<p>To integrate Alamofire into your Xcode project using Carthage, specify it in your <code>Cartfile</code>:</p>

<pre><code class="ogdl">github "Alamofire/Alamofire" &gt;= 1.3
</code></pre>

<h3>Manually</h3>

<p>If you prefer not to use either of the aforementioned dependency managers, you can integrate Alamofire into your project manually.</p>

<h4>Embedded Framework</h4>

<ul>
<li>Add Alamofire as a <a href="http://git-scm.com/docs/git-submodule">submodule</a> by opening the Terminal, <code>cd</code>-ing into your top-level project directory, and entering the following command:</li>
</ul>


<pre><code class="bash">$ git submodule add https://github.com/Alamofire/Alamofire.git
</code></pre>

<ul>
<li><p>Open the new <code>Alamofire</code> folder, and drag the <code>Alamofire.xcodeproj</code> into the Project Navigator of your application&rsquo;s Xcode project.</p>

<blockquote><p>It should appear nested underneath your application&rsquo;s blue project icon. Whether it is above or below all the other Xcode groups does not matter.</p></blockquote></li>
<li><p>Select the <code>Alamofire.xcodeproj</code> in the Project Navigator and verify the deployment target matches that of your application target.</p></li>
<li>Next, select your application project in the Project Navigator (blue project icon) to navigate to the target configuration window and select the application target under the &ldquo;Targets&rdquo; heading in the sidebar.</li>
<li>In the tab bar at the top of that window, open the &ldquo;General&rdquo; panel.</li>
<li>Click on the <code>+</code> button under the &ldquo;Embedded Binaries&rdquo; section.</li>
<li><p>You will see two different <code>Alamofire.xcodeproj</code> folders each with two different versions of the <code>Alamofire.framework</code> nested inside a <code>Products</code> folder.</p>

<blockquote><p>It does not matter which <code>Products</code> folder you choose from, but it does matter whether you choose the top or bottom <code>Alamofire.framework</code>.</p></blockquote></li>
<li><p>Select the top <code>Alamofire.framework</code> for iOS and the bottom one for OS X.</p>

<blockquote><p>You can verify which one you selected by inspecting the build log for your project. The build target for <code>Alamofire</code> will be listed as either <code>Alamofire iOS</code> or <code>Alamofire OSX</code>.</p></blockquote></li>
<li><p>And that&rsquo;s it!</p></li>
</ul>


<blockquote><p>The <code>Alamofire.framework</code> is automagically added as a target dependency, linked framework and embedded framework in a copy files build phase which is all you need to build on the simulator and a device.</p></blockquote>

<h4>Source File</h4>

<p>For application targets that do not support embedded frameworks, such as iOS 7, Alamofire can be integrated by adding all the Swift files located inside the <code>Source</code> directory (<code>Source/*.swift</code>) directly into your project. Note that you will no longer need to <code>import Alamofire</code> since you are not actually loading a framework. Additionally, any of the calling conventions described in the <a href="#usage">&lsquo;Usage&rsquo;</a> section with the <code>Alamofire</code> prefix would instead omit it (for example, <code>Alamofire.request</code> becomes <code>request</code>), since this functionality is incorporated into the top-level namespace.</p>

<hr />

<h2>Usage</h2>

<h3>Making a Request</h3>

<pre><code class="swift">import Alamofire

Alamofire.request(.GET, "http://httpbin.org/get")
</code></pre>

<h3>Response Handling</h3>

<pre><code class="swift">Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .response { request, response, data, error in
              println(request)
              println(response)
              println(error)
          }
</code></pre>

<blockquote><p>Networking in Alamofire is done <em>asynchronously</em>. Asynchronous programming may be a source of frustration to programmers unfamiliar with the concept, but there are <a href="https://developer.apple.com/library/ios/qa/qa1693/_index.html">very good reasons</a> for doing it this way.</p>

<p>Rather than blocking execution to wait for a response from the server, a <a href="http://en.wikipedia.org/wiki/Callback_%28computer_programming%29">callback</a> is specified to handle the response once it&rsquo;s received. The result of a request is only available inside the scope of a response handler. Any execution contingent on the response or data received from the server must be done within a handler.</p></blockquote>

<h3>Response Serialization</h3>

<p><strong>Built-in Response Methods</strong></p>

<ul>
<li><code>response()</code></li>
<li><code>responseString(encoding: NSStringEncoding)</code></li>
<li><code>responseJSON(options: NSJSONReadingOptions)</code></li>
<li><code>responsePropertyList(options: NSPropertyListReadOptions)</code></li>
</ul>


<h4>Response String Handler</h4>

<pre><code class="swift">Alamofire.request(.GET, "http://httpbin.org/get")
         .responseString { _, _, string, _ in
             println(string)
         }
</code></pre>

<h4>Response JSON Handler</h4>

<pre><code class="swift">Alamofire.request(.GET, "http://httpbin.org/get")
         .responseJSON { _, _, JSON, _ in
             println(JSON)
         }
</code></pre>

<h4>Chained Response Handlers</h4>

<p>Response handlers can even be chained:</p>

<pre><code class="swift">Alamofire.request(.GET, "http://httpbin.org/get")
         .responseString { _, _, string, _ in
             println(string)
         }
         .responseJSON { _, _, JSON, _ in
             println(JSON)
         }
</code></pre>

<h3>HTTP Methods</h3>

<p><code>Alamofire.Method</code> lists the HTTP methods defined in <a href="http://tools.ietf.org/html/rfc7231#section-4.3">RFC 7231 §4.3</a>:</p>

<pre><code class="swift">public enum Method: String {
    case OPTIONS = "OPTIONS"
    case GET = "GET"
    case HEAD = "HEAD"
    case POST = "POST"
    case PUT = "PUT"
    case PATCH = "PATCH"
    case DELETE = "DELETE"
    case TRACE = "TRACE"
    case CONNECT = "CONNECT"
}
</code></pre>

<p>These values can be passed as the first argument of the <code>Alamofire.request</code> method:</p>

<pre><code class="swift">Alamofire.request(.POST, "http://httpbin.org/post")

Alamofire.request(.PUT, "http://httpbin.org/put")

Alamofire.request(.DELETE, "http://httpbin.org/delete")
</code></pre>

<h3>Parameters</h3>

<h4>GET Request With URL-Encoded Parameters</h4>

<pre><code class="swift">Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
// http://httpbin.org/get?foo=bar
</code></pre>

<h4>POST Request With URL-Encoded Parameters</h4>

<pre><code class="swift">let parameters = [
    "foo": "bar",
    "baz": ["a", 1],
    "qux": [
        "x": 1,
        "y": 2,
        "z": 3
    ]
]

Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters)
// HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3
</code></pre>

<h3>Parameter Encoding</h3>

<p>Parameters can also be encoded as JSON, Property List, or any custom format, using the <code>ParameterEncoding</code> enum:</p>

<pre><code class="swift">enum ParameterEncoding {
    case URL
    case JSON
    case PropertyList(format: NSPropertyListFormat, options: NSPropertyListWriteOptions)
    case Custom((URLRequestConvertible, [String: AnyObject]?) -&gt; (NSMutableURLRequest, NSError?))

    func encode(request: NSURLRequest, parameters: [String: AnyObject]?) -&gt; (NSURLRequest, NSError?)
    { ... }
}
</code></pre>

<ul>
<li><code>URL</code>: A query string to be set as or appended to any existing URL query for <code>GET</code>, <code>HEAD</code>, and <code>DELETE</code> requests, or set as the body for requests with any other HTTP method. The <code>Content-Type</code> HTTP header field of an encoded request with HTTP body is set to <code>application/x-www-form-urlencoded</code>. <em>Since there is no published specification for how to encode collection types, Alamofire follows the convention of appending <code>[]</code> to the key for array values (<code>foo[]=1&amp;foo[]=2</code>), and appending the key surrounded by square brackets for nested dictionary values (<code>foo[bar]=baz</code>).</em></li>
<li><code>JSON</code>: Uses <code>NSJSONSerialization</code> to create a JSON representation of the parameters object, which is set as the body of the request. The <code>Content-Type</code> HTTP header field of an encoded request is set to <code>application/json</code>.</li>
<li><code>PropertyList</code>: Uses <code>NSPropertyListSerialization</code> to create a plist representation of the parameters object, according to the associated format and write options values, which is set as the body of the request. The <code>Content-Type</code> HTTP header field of an encoded request is set to <code>application/x-plist</code>.</li>
<li><code>Custom</code>: Uses the associated closure value to construct a new request given an existing request and parameters.</li>
</ul>


<h4>Manual Parameter Encoding of an NSURLRequest</h4>

<pre><code class="swift">let URL = NSURL(string: "http://httpbin.org/get")!
var request = NSURLRequest(URL: URL)

let parameters = ["foo": "bar"]
let encoding = Alamofire.ParameterEncoding.URL
(request, _) = encoding.encode(request, parameters: parameters)
</code></pre>

<h4>POST Request with JSON-encoded Parameters</h4>

<pre><code class="swift">let parameters = [
    "foo": [1,2,3],
    "bar": [
        "baz": "qux"
    ]
]

Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters, encoding: .JSON)
// HTTP body: {"foo": [1, 2, 3], "bar": {"baz": "qux"}}
</code></pre>

<h3>HTTP Headers</h3>

<p>Adding a custom HTTP header to a <code>Request</code> is supported directly in the global <code>request</code> method. This makes it easy to attach HTTP headers to a <code>Request</code> that can be constantly changing.</p>

<blockquote><p>For HTTP headers that do not change, it is recommended to set them on the <code>NSURLSessionConfiguration</code> so they are automatically applied to any <code>NSURLSessionTask</code> created by the underlying <code>NSURLSession</code>.</p></blockquote>

<pre><code class="swift">let headers = [
    "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==",
    "Content-Type": "application/x-www-form-urlencoded"
]

Alamofire.request(.GET, "http://httpbin.org/get", headers: headers)
         .responseJSON { _, _, JSON, _ in
             println(JSON)
         }
</code></pre>

<h3>Caching</h3>

<p>Caching is handled on the system framework level by <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html#//apple_ref/occ/cl/NSURLCache"><code>NSURLCache</code></a>.</p>

<h3>Uploading</h3>

<p><strong>Supported Upload Types</strong></p>

<ul>
<li>File</li>
<li>Data</li>
<li>Stream</li>
<li>MultipartFormData</li>
</ul>


<h4>Uploading a File</h4>

<pre><code class="swift">let fileURL = NSBundle.mainBundle().URLForResource("Default", withExtension: "png")
Alamofire.upload(.POST, "http://httpbin.org/post", file: fileURL)
</code></pre>

<h4>Uploading with Progress</h4>

<pre><code class="swift">Alamofire.upload(.POST, "http://httpbin.org/post", file: fileURL)
         .progress { bytesWritten, totalBytesWritten, totalBytesExpectedToWrite in
             println(totalBytesWritten)
         }
         .responseJSON { request, response, JSON, error in
             println(JSON)
         }
</code></pre>

<h4>Uploading MultipartFormData</h4>

<pre><code class="swift">Alamofire.upload(
    .POST,
    URLString: "http://httpbin.org/post",
    multipartFormData: { multipartFormData in
        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
        multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.responseJSON { request, response, JSON, error in
                println(JSON)
            }
        case .Failure(let encodingError):
            println(encodingError)
        }
    }
)
</code></pre>

<h3>Downloading</h3>

<p><strong>Supported Download Types</strong></p>

<ul>
<li>Request</li>
<li>Resume Data</li>
</ul>


<h4>Downloading a File</h4>

<pre><code class="swift">Alamofire.download(.GET, "http://httpbin.org/stream/100") { temporaryURL, response in
    let fileManager = NSFileManager.defaultManager()
    if let directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0] as? NSURL {
        let pathComponent = response.suggestedFilename
        return directoryURL.URLByAppendingPathComponent(pathComponent!)
    }

    return temporaryURL
}
</code></pre>

<h4>Using the Default Download Destination</h4>

<pre><code class="swift">let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)
Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
</code></pre>

<h4>Downloading a File w/Progress</h4>

<pre><code class="swift">Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
         .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
             println(totalBytesRead)
         }
         .response { request, response, _, error in
             println(response)
         }
</code></pre>

<h3>Authentication</h3>

<p>Authentication is handled on the system framework level by <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLAuthenticationChallenge_Class/Reference/Reference.html"><code>NSURLCredential</code> and <code>NSURLAuthenticationChallenge</code></a>.</p>

<p><strong>Supported Authentication Schemes</strong></p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Basic_access_authentication">HTTP Basic</a></li>
<li><a href="http://en.wikipedia.org/wiki/Digest_access_authentication">HTTP Digest</a></li>
<li><a href="http://en.wikipedia.org/wiki/Kerberos_%28protocol%29">Kerberos</a></li>
<li><a href="http://en.wikipedia.org/wiki/NT_LAN_Manager">NTLM</a></li>
</ul>


<h4>HTTP Basic Authentication</h4>

<p>The <code>authenticate</code> method on a <code>Request</code> will automatically provide an <code>NSURLCredential</code> to an <code>NSURLAuthenticationChallenge</code> when appropriate:</p>

<pre><code class="swift">let user = "user"
let password = "password"

Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
         .authenticate(user: user, password: password)
         .response { request, response, _, error in
             println(response)
         }
</code></pre>

<p>Depending upon your server implementation, an <code>Authorization</code> header may also be appropriate:</p>

<pre><code class="swift">let user = "user"
let password = "password"

let credentialData = "\(user):\(password)".dataUsingEncoding(NSUTF8StringEncoding)!
let base64Credentials = credentialData.base64EncodedStringWithOptions(nil)

let headers = ["Authorization": "Basic \(base64Credentials)"]

Alamofire.request(.GET, "http://httpbin.org/basic-auth/user/password", headers: headers)
         .responseJSON { _, _, JSON, _ in
             println(JSON)
         }
</code></pre>

<h4>Authentication with NSURLCredential</h4>

<pre><code class="swift">let user = "user"
let password = "password"

let credential = NSURLCredential(user: user, password: password, persistence: .ForSession)

Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
         .authenticate(usingCredential: credential)
         .response { request, response, _, error in
             println(response)
         }
</code></pre>

<h3>Validation</h3>

<p>By default, Alamofire treats any completed request to be successful, regardless of the content of the response. Calling <code>validate</code> before a response handler causes an error to be generated if the response had an unacceptable status code or MIME type.</p>

<h4>Manual Validation</h4>

<pre><code class="swift">Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .validate(statusCode: 200..&lt;300)
         .validate(contentType: ["application/json"])
         .response { _, _, _, error in
             println(error)
         }
</code></pre>

<h4>Automatic Validation</h4>

<p>Automatically validates status code within <code>200...299</code> range, and that the <code>Content-Type</code> header of the response matches the <code>Accept</code> header of the request, if one is provided.</p>

<pre><code class="swift">Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .validate()
         .response { _, _, _, error in
             println(error)
         }
</code></pre>

<h3>Printable</h3>

<pre><code class="swift">let request = Alamofire.request(.GET, "http://httpbin.org/ip")

println(request)
// GET http://httpbin.org/ip (200)
</code></pre>

<h3>DebugPrintable</h3>

<pre><code class="swift">let request = Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])

debugPrintln(request)
</code></pre>

<h4>Output (cURL)</h4>

<pre><code class="bash">$ curl -i \
    -H "User-Agent: Alamofire" \
    -H "Accept-Encoding: Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
    -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
    "http://httpbin.org/get?foo=bar"
</code></pre>

<hr />

<h2>Advanced Usage</h2>

<blockquote><p>Alamofire is built on <code>NSURLSession</code> and the Foundation URL Loading System. To make the most of
this framework, it is recommended that you be familiar with the concepts and capabilities of the underlying networking stack.</p></blockquote>

<p><strong>Recommended Reading</strong></p>

<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">URL Loading System Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/Introduction/Introduction.html#//apple_ref/occ/cl/NSURLSession">NSURLSession Class Reference</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html#//apple_ref/occ/cl/NSURLCache">NSURLCache Class Reference</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLAuthenticationChallenge_Class/Reference/Reference.html">NSURLAuthenticationChallenge Class Reference</a></li>
</ul>


<h3>Manager</h3>

<p>Top-level convenience methods like <code>Alamofire.request</code> use a shared instance of <code>Alamofire.Manager</code>, which is configured with the default <code>NSURLSessionConfiguration</code>.</p>

<p>As such, the following two statements are equivalent:</p>

<pre><code class="swift">Alamofire.request(.GET, "http://httpbin.org/get")
</code></pre>

<pre><code class="swift">let manager = Alamofire.Manager.sharedInstance
manager.request(NSURLRequest(URL: NSURL(string: "http://httpbin.org/get")))
</code></pre>

<p>Applications can create managers for background and ephemeral sessions, as well as new managers that customize the default session configuration, such as for default headers (<code>HTTPAdditionalHeaders</code>) or timeout interval (<code>timeoutIntervalForRequest</code>).</p>

<h4>Creating a Manager with Default Configuration</h4>

<pre><code class="swift">let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
let manager = Alamofire.Manager(configuration: configuration)
</code></pre>

<h4>Creating a Manager with Background Configuration</h4>

<pre><code class="swift">let configuration = NSURLSessionConfiguration.backgroundSessionConfiguration("com.example.app.background")
let manager = Alamofire.Manager(configuration: configuration)
</code></pre>

<h4>Creating a Manager with Ephemeral Configuration</h4>

<pre><code class="swift">let configuration = NSURLSessionConfiguration.ephemeralSessionConfiguration()
let manager = Alamofire.Manager(configuration: configuration)
</code></pre>

<h4>Modifying Session Configuration</h4>

<pre><code class="swift">var defaultHeaders = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:]
defaultHeaders["DNT"] = "1 (Do Not Track Enabled)"

let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
configuration.HTTPAdditionalHeaders = defaultHeaders

let manager = Alamofire.Manager(configuration: configuration)
</code></pre>

<blockquote><p>This is <strong>not</strong> recommended for <code>Authorization</code> or <code>Content-Type</code> headers. Instead, use <code>URLRequestConvertible</code> and <code>ParameterEncoding</code>, respectively.</p></blockquote>

<h3>Request</h3>

<p>The result of a <code>request</code>, <code>upload</code>, or <code>download</code> method is an instance of <code>Alamofire.Request</code>. A request is always created using a constructor method from an owning manager, and never initialized directly.</p>

<p>Methods like <code>authenticate</code>, <code>validate</code>, and <code>response</code> return the caller in order to facilitate chaining.</p>

<p>Requests can be suspended, resumed, and cancelled:</p>

<ul>
<li><code>suspend()</code>: Suspends the underlying task and dispatch queue</li>
<li><code>resume()</code>: Resumes the underlying task and dispatch queue. If the owning manager does not have <code>startRequestsImmediately</code> set to <code>true</code>, the request must call <code>resume()</code> in order to start.</li>
<li><code>cancel()</code>: Cancels the underlying task, producing an error that is passed to any registered response handlers.</li>
</ul>


<h3>Response Serialization</h3>

<h4>Creating a Custom Response Serializer</h4>

<p>Alamofire provides built-in response serialization for strings, JSON, and property lists, but others can be added in extensions on <code>Alamofire.Request</code>.</p>

<p>For example, here&rsquo;s how a response handler using <a href="https://github.com/mattt/Ono">Ono</a> might be implemented:</p>

<pre><code class="swift">extension Request {
    public static func XMLResponseSerializer() -&gt; GenericResponseSerializer&lt;ONOXMLDocument&gt; {
        return GenericResponseSerializer { request, response, data in
            if data == nil {
                return (nil, nil)
            }

            var XMLSerializationError: NSError?
            let XML = ONOXMLDocument(data: data!, error: &amp;XMLSerializationError)

            return (XML, XMLSerializationError)
        }
    }

    public func responseXMLDocument(completionHandler: (NSURLRequest, NSHTTPURLResponse?, ONOXMLDocument?, NSError?) -&gt; Void) -&gt; Self {
        return response(responseSerializer: Request.XMLResponseSerializer(), completionHandler: completionHandler)
    }
}
</code></pre>

<h4>Generic Response Object Serialization</h4>

<p>Generics can be used to provide automatic, type-safe response object serialization.</p>

<pre><code class="swift">@objc public protocol ResponseObjectSerializable {
    init?(response: NSHTTPURLResponse, representation: AnyObject)
}

extension Request {
    public func responseObject&lt;T: ResponseObjectSerializable&gt;(completionHandler: (NSURLRequest, NSHTTPURLResponse?, T?, NSError?) -&gt; Void) -&gt; Self {
        let responseSerializer = GenericResponseSerializer&lt;T&gt; { request, response, data in
            let JSONResponseSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
            let (JSON: AnyObject?, serializationError) = JSONResponseSerializer.serializeResponse(request, response, data)

            if let response = response, JSON: AnyObject = JSON {
                return (T(response: response, representation: JSON), nil)
            } else {
                return (nil, serializationError)
            }
        }

        return response(responseSerializer: responseSerializer, completionHandler: completionHandler)
    }
}
</code></pre>

<pre><code class="swift">final class User: ResponseObjectSerializable {
    let username: String
    let name: String

    @objc required init?(response: NSHTTPURLResponse, representation: AnyObject) {
        self.username = response.URL!.lastPathComponent!
        self.name = representation.valueForKeyPath("name") as! String
    }
}
</code></pre>

<pre><code class="swift">Alamofire.request(.GET, "http://example.com/users/mattt")
         .responseObject { (_, _, user: User?, _) in
             println(user)
         }
</code></pre>

<p>The same approach can also be used to handle endpoints that return a representation of a collection of objects:</p>

<pre><code class="swift">@objc public protocol ResponseCollectionSerializable {
    static func collection(#response: NSHTTPURLResponse, representation: AnyObject) -&gt; [Self]
}

extension Alamofire.Request {
    public func responseCollection&lt;T: ResponseCollectionSerializable&gt;(completionHandler: (NSURLRequest, NSHTTPURLResponse?, [T]?, NSError?) -&gt; Void) -&gt; Self {
        let responseSerializer = GenericResponseSerializer&lt;[T]&gt; { request, response, data in
            let JSONSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
            let (JSON: AnyObject?, serializationError) = JSONSerializer.serializeResponse(request, response, data)

            if let response = response, JSON: AnyObject = JSON {
                return (T.collection(response: response, representation: JSON), nil)
            } else {
                return (nil, serializationError)
            }
        }

        return response(responseSerializer: responseSerializer, completionHandler: completionHandler)
    }
}
</code></pre>

<pre><code class="swift">@objc final class User: ResponseObjectSerializable, ResponseCollectionSerializable {
    let username: String
    let name: String

    required init?(response: NSHTTPURLResponse, representation: AnyObject) {
        self.username = response.URL!.lastPathComponent!
        self.name = representation.valueForKeyPath("name") as! String
    }

    static func collection(#response: NSHTTPURLResponse, representation: AnyObject) -&gt; [User] {
        var users: [User] = []

        if let representation = representation as? [[String: AnyObject]] {
            for userRepresentation in representation {
                if let user = User(response: response, representation: userRepresentation) {
                    users.append(user)
                }
            }
        }

        return users
    }
}
</code></pre>

<pre><code class="swift">Alamofire.request(.GET, "http://example.com/users")
         .responseCollection { (_, _, users: [User]?, _) in
             println(users)
         }
</code></pre>

<h3>URLStringConvertible</h3>

<p>Types adopting the <code>URLStringConvertible</code> protocol can be used to construct URL strings, which are then used to construct URL requests. <code>NSString</code>, <code>NSURL</code>, <code>NSURLComponents</code>, and <code>NSURLRequest</code> conform to <code>URLStringConvertible</code> by default, allowing any of them to be passed as <code>URLString</code> parameters to the <code>request</code>, <code>upload</code>, and <code>download</code> methods:</p>

<pre><code class="swift">let string = NSString(string: "http://httpbin.org/post")
Alamofire.request(.POST, string)

let URL = NSURL(string: string)!
Alamofire.request(.POST, URL)

let URLRequest = NSURLRequest(URL: URL)
Alamofire.request(.POST, URLRequest) // overrides `HTTPMethod` of `URLRequest`

let URLComponents = NSURLComponents(URL: URL, resolvingAgainstBaseURL: true)
Alamofire.request(.POST, URLComponents)
</code></pre>

<p>Applications interacting with web applications in a significant manner are encouraged to have custom types conform to <code>URLStringConvertible</code> as a convenient way to map domain-specific models to server resources.</p>

<h4>Type-Safe Routing</h4>

<pre><code class="swift">extension User: URLStringConvertible {
    static let baseURLString = "http://example.com"

    var URLString: String {
        return User.baseURLString + "/users/\(username)/"
    }
}
</code></pre>

<pre><code class="swift">let user = User(username: "mattt")
Alamofire.request(.GET, user) // http://example.com/users/mattt
</code></pre>

<h3>URLRequestConvertible</h3>

<p>Types adopting the <code>URLRequestConvertible</code> protocol can be used to construct URL requests. <code>NSURLRequest</code> conforms to <code>URLRequestConvertible</code> by default, allowing it to be passed into <code>request</code>, <code>upload</code>, and <code>download</code> methods directly (this is the recommended way to specify custom HTTP header fields or HTTP body for individual requests):</p>

<pre><code class="swift">let URL = NSURL(string: "http://httpbin.org/post")!
let mutableURLRequest = NSMutableURLRequest(URL: URL)
mutableURLRequest.HTTPMethod = "POST"

let parameters = ["foo": "bar"]
var JSONSerializationError: NSError? = nil
mutableURLRequest.HTTPBody = NSJSONSerialization.dataWithJSONObject(parameters, options: nil, error: &amp;JSONSerializationError)
mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")

Alamofire.request(mutableURLRequest)
</code></pre>

<p>Applications interacting with web applications in a significant manner are encouraged to have custom types conform to <code>URLRequestConvertible</code> as a way to ensure consistency of requested endpoints. Such an approach can be used to abstract away server-side inconsistencies and provide type-safe routing, as well as manage authentication credentials and other state.</p>

<h4>API Parameter Abstraction</h4>

<pre><code class="swift">enum Router: URLRequestConvertible {
    static let baseURLString = "http://example.com"
    static let perPage = 50

    case Search(query: String, page: Int)

    // MARK: URLRequestConvertible

    var URLRequest: NSURLRequest {
        let (path: String, parameters: [String: AnyObject]?) = {
            switch self {
            case .Search(let query, let page) where page &gt; 1:
                return ("/search", ["q": query, "offset": Router.perPage * page])
            case .Search(let query, _):
                return ("/search", ["q": query])
            }
        }()

        let URL = NSURL(string: Router.baseURLString)!
        let URLRequest = NSURLRequest(URL: URL.URLByAppendingPathComponent(path))
        let encoding = Alamofire.ParameterEncoding.URL

        return encoding.encode(URLRequest, parameters: parameters).0
    }
}
</code></pre>

<pre><code class="swift">Alamofire.request(Router.Search(query: "foo bar", page: 1)) // ?q=foo%20bar&amp;offset=50
</code></pre>

<h4>CRUD &amp; Authorization</h4>

<pre><code class="swift">enum Router: URLRequestConvertible {
    static let baseURLString = "http://example.com"
    static var OAuthToken: String?

    case CreateUser([String: AnyObject])
    case ReadUser(String)
    case UpdateUser(String, [String: AnyObject])
    case DestroyUser(String)

    var method: Alamofire.Method {
        switch self {
        case .CreateUser:
            return .POST
        case .ReadUser:
            return .GET
        case .UpdateUser:
            return .PUT
        case .DestroyUser:
            return .DELETE
        }
    }

    var path: String {
        switch self {
        case .CreateUser:
            return "/users"
        case .ReadUser(let username):
            return "/users/\(username)"
        case .UpdateUser(let username, _):
            return "/users/\(username)"
        case .DestroyUser(let username):
            return "/users/\(username)"
        }
    }

    // MARK: URLRequestConvertible

    var URLRequest: NSURLRequest {
        let URL = NSURL(string: Router.baseURLString)!
        let mutableURLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(path))
        mutableURLRequest.HTTPMethod = method.rawValue

        if let token = Router.OAuthToken {
            mutableURLRequest.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }

        switch self {
        case .CreateUser(let parameters):
            return Alamofire.ParameterEncoding.JSON.encode(mutableURLRequest, parameters: parameters).0
        case .UpdateUser(_, let parameters):
            return Alamofire.ParameterEncoding.URL.encode(mutableURLRequest, parameters: parameters).0
        default:
            return mutableURLRequest
        }
    }
}
</code></pre>

<pre><code class="swift">Alamofire.request(Router.ReadUser("mattt")) // GET /users/mattt
</code></pre>

<h3>Security</h3>

<p>Using a secure HTTPS connection when communicating with servers and web services is an important step in securing sensitive data. By default, Alamofire will evaluate the certificate chain provided by the server using Apple&rsquo;s built in validation provided by the Security framework. While this guarantees the certificate chain is valid, it does not prevent man-in-the-middle (MITM) attacks or other potential vulnerabilities. In order to mitigate MITM attacks, applications dealing with sensitive customer data or financial information should use certificate or public key pinning provided by the <code>ServerTrustPolicy</code>.</p>

<h4>ServerTrustPolicy</h4>

<p>The <code>ServerTrustPolicy</code> enumeration evaluates the server trust generally provided by an <code>NSURLAuthenticationChallenge</code> when connecting to a server over a secure HTTPS connection.</p>

<pre><code class="swift">let serverTrustPolicy = ServerTrustPolicy.PinCertificates(
    certificates: ServerTrustPolicy.certificatesInBundle(),
    validateCertificateChain: true,
    validateHost: true
)
</code></pre>

<p>There are many different cases of server trust evaluation giving you complete control over the validation process:</p>

<ul>
<li><code>PerformDefaultEvaluation</code>: Uses the default server trust evaluation while allowing you to control whether to validate the host provided by the challenge.</li>
<li><code>PinCertificates</code>: Uses the pinned certificates to validate the server trust. The server trust is considered valid if one of the pinned certificates match one of the server certificates.</li>
<li><code>PinPublicKeys</code>: Uses the pinned public keys to validate the server trust. The server trust is considered valid if one of the pinned public keys match one of the server certificate public keys.</li>
<li><code>DisableEvaluation</code>: Disables all evaluation which in turn will always consider any server trust as valid.</li>
<li><code>CustomEvaluation</code>: Uses the associated closure to evaluate the validity of the server trust thus giving you complete control over the validation process. Use with caution.</li>
</ul>


<h4>Server Trust Policy Manager</h4>

<p>The <code>ServerTrustPolicyManager</code> is responsible for storing an internal mapping of server trust policies to a particular host. This allows Alamofire to evaluate each host against a different server trust policy.</p>

<pre><code class="swift">let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "test.example.com": .PinCertificates(
        certificates: ServerTrustPolicy.certificatesInBundle(),
        validateCertificateChain: true,
        validateHost: true
    ),
    "insecure.expired-apis.com": .DisableEvaluation
]

let manager = Manager(
    configuration: NSURLSessionConfiguration.defaultSessionConfiguration(),
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
)
</code></pre>

<p>These server trust policies will result in the following behavior:</p>

<ul>
<li><code>test.example.com</code> will always use certificate pinning with certificate chain and host validation enabled thus requiring the following criteria to be met to allow the TLS handshake to succeed:

<ul>
<li>Certificate chain MUST be valid.</li>
<li>Certificate chain MUST include one of the pinned certificates.</li>
<li>Challenge host MUST match the host in the certificate chain&rsquo;s leaf certificate.</li>
</ul>
</li>
<li><code>insecure.expired-apis.com</code> will never evaluate the certificate chain and will always allow the TLS handshake to succeed.</li>
<li>All other hosts will use the default evaluation provided by Apple.</li>
</ul>


<hr />

<h2>FAQ</h2>

<h3>When should I use Alamofire?</h3>

<p>If you&rsquo;re starting a new project in Swift, and want to take full advantage of its conventions and language features, Alamofire is a great choice. Although not as fully-featured as AFNetworking, Alamofire is much nicer to work with, and should satisfy the vast majority of networking use cases.</p>

<blockquote><p>It&rsquo;s important to note that two libraries aren&rsquo;t mutually exclusive: AFNetworking and Alamofire can peacefully exist in the same code base.</p></blockquote>

<h3>When should I use AFNetworking?</h3>

<p>AFNetworking remains the premiere networking library available for OS X and iOS, and can easily be used in Swift, just like any other Objective-C code. AFNetworking is stable and reliable, and isn&rsquo;t going anywhere.</p>

<p>Use AFNetworking for any of the following:</p>

<ul>
<li>UIKit extensions, such as asynchronously loading images to <code>UIImageView</code></li>
<li>Network reachability monitoring, using <code>AFNetworkReachabilityManager</code></li>
</ul>


<h3>What&rsquo;s the origin of the name Alamofire?</h3>

<p>Alamofire is named after the <a href="https://aggie-horticulture.tamu.edu/wildseed/alamofire.html">Alamo Fire flower</a>, a hybrid variant of the Bluebonnet, the official state flower of Texas.</p>

<hr />

<h2>Credits</h2>

<p>Alamofire is owned and maintained by the <a href="http://alamofire.org">Alamofire Software Foundation</a>. You can follow them on Twitter at <a href="https://twitter.com/AlamofireSF">@AlamofireSF</a> for project updates and releases.</p>

<h3>Security Disclosure</h3>

<p>If you believe you have identified a security vulnerability with Alamofire, you should report it as soon as possible via email to <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#115;&#101;&#x63;&#x75;&#114;&#105;&#116;&#121;&#64;&#97;&#x6c;&#97;&#109;&#x6f;&#102;&#x69;&#x72;&#x65;&#46;&#x6f;&#x72;&#103;&#x2e;">&#115;&#x65;&#99;&#x75;&#114;&#105;&#x74;&#x79;&#64;&#x61;&#108;&#x61;&#x6d;&#111;&#x66;&#105;&#114;&#x65;&#x2e;&#x6f;&#114;&#103;&#x2e;</a> Please do not post it to a public issue tracker.</p>

<h2>License</h2>

<p>Alamofire is released under the MIT license. See LICENSE for details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SDWebImage加载图片缓存图片]]></title>
    <link href="http://www.superqq.com/blog/2015/06/09/sdwebimagejia-zai-tu-pian-huan-cun-tu-pian/"/>
    <updated>2015-06-09T17:47:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/09/sdwebimagejia-zai-tu-pian-huan-cun-tu-pian</id>
    <content type="html"><![CDATA[<ul>
<li>关注公众号iOS开发：<strong>iOSDevTip</strong> 获取更多源代码。</li>
</ul>


<p> <a href="https://github.com/rs/SDWebImage.git"target="_blank"title="源代码">源代码</a></p>

<h1> Web Image</h1>

<p><a href="https://travis-ci.org/rs/SDWebImage"><img src="http://img.shields.io/travis/rs/SDWebImage/master.svg?style=flat" alt="Build Status" /></a>
<a href="http://cocoadocs.org/docsets/SDWebImage/"><img src="http://img.shields.io/cocoapods/v/SDWebImage.svg?style=flat" alt="Pod Version" /></a>
<a href="http://cocoadocs.org/docsets/SDWebImage/"><img src="http://img.shields.io/cocoapods/p/SDWebImage.svg?style=flat" alt="Pod Platform" /></a>
<a href="https://www.apache.org/licenses/LICENSE-2.0.html"><img src="http://img.shields.io/cocoapods/l/SDWebImage.svg?style=flat" alt="Pod License" /></a>
<a href="https://www.versioneye.com/objective-c/sdwebimage/3.3"><img src="https://www.versioneye.com/objective-c/sdwebimage/3.3/badge.svg?style=flat" alt="Dependency Status" /></a>
<a href="https://www.versioneye.com/objective-c/sdwebimage/references"><img src="https://www.versioneye.com/objective-c/sdwebimage/reference_badge.svg?style=flat" alt="Reference Status" /></a>
<a href="https://github.com/rs/SDWebImage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible" /></a></p>

<p>This library provides a category for UIImageView with support for remote images coming from the web.</p>

<p>It provides:</p>

<ul>
<li>An UIImageView category adding web image and cache management to the Cocoa Touch framework</li>
<li>An asynchronous image downloader</li>
<li>An asynchronous memory + disk image caching with automatic cache expiration handling</li>
<li>Animated GIF support</li>
<li>WebP format support</li>
<li>A background image decompression</li>
<li>A guarantee that the same URL won&rsquo;t be downloaded several times</li>
<li>A guarantee that bogus URLs won&rsquo;t be retried again and again</li>
<li>A guarantee that main thread will never be blocked</li>
<li>Performances!</li>
<li>Use GCD and ARC</li>
<li>Arm64 support</li>
</ul>


<p>NOTE: The version 3.0 of SDWebImage isn&rsquo;t fully backward compatible with 2.0 and requires iOS 5.1.1
minimum deployement version. If you need iOS &lt; 5.0 support, please use the last <a href="https://github.com/rs/SDWebImage/tree/2.0-compat">2.0 version</a>.</p>

<p><a href="https://github.com/rs/SDWebImage/wiki/How-is-SDWebImage-better-than-X%3F">How is SDWebImage better than X?</a></p>

<h2>Who Use It</h2>

<p>Find out <a href="https://github.com/rs/SDWebImage/wiki/Who-Uses-SDWebImage">who uses SDWebImage</a> and add your app to the list.</p>

<h2>How To Use</h2>

<p>API documentation is available at <a href="http://cocoadocs.org/docsets/SDWebImage/">CocoaDocs - SDWebImage</a></p>

<h3>Using UIImageView+WebCache category with UITableView</h3>

<p>Just #import the UIImageView+WebCache.h header, and call the sd_setImageWithURL:placeholderImage:
method from the tableView:cellForRowAtIndexPath: UITableViewDataSource method. Everything will be
handled for you, from async downloads to caching management.</p>

<pre><code class="objective-c">#import &lt;SDWebImage/UIImageView+WebCache.h&gt;

...

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *MyIdentifier = @"MyIdentifier";

    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];

    if (cell == nil)
    {
        cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault
                                       reuseIdentifier:MyIdentifier] autorelease];
    }

    // Here we use the new provided sd_setImageWithURL: method to load the web image
    [cell.imageView sd_setImageWithURL:[NSURL URLWithString:@"http://www.domain.com/path/to/image.jpg"]
                      placeholderImage:[UIImage imageNamed:@"placeholder.png"]];

    cell.textLabel.text = @"My Text";
    return cell;
}
</code></pre>

<h3>Using blocks</h3>

<p>With blocks, you can be notified about the image download progress and whenever the image retrival
has completed with success or not:</p>

<pre><code class="objective-c">// Here we use the new provided sd_setImageWithURL: method to load the web image
[cell.imageView sd_setImageWithURL:[NSURL URLWithString:@"http://www.domain.com/path/to/image.jpg"]
                      placeholderImage:[UIImage imageNamed:@"placeholder.png"]
                             completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {... completion code here ...}];
</code></pre>

<p>Note: neither your success nor failure block will be call if your image request is canceled before completion.</p>

<h3>Using SDWebImageManager</h3>

<p>The SDWebImageManager is the class behind the UIImageView+WebCache category. It ties the
asynchronous downloader with the image cache store. You can use this class directly to benefit
from web image downloading with caching in another context than a UIView (ie: with Cocoa).</p>

<p>Here is a simple example of how to use SDWebImageManager:</p>

<pre><code class="objective-c">SDWebImageManager *manager = [SDWebImageManager sharedManager];
[manager downloadImageWithURL:imageURL
                      options:0
                     progress:^(NSInteger receivedSize, NSInteger expectedSize) {
                         // progression tracking code
                     }
                     completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
                         if (image) {
                             // do something with image
                         }
                     }];
</code></pre>

<h3>Using Asynchronous Image Downloader Independently</h3>

<p>It&rsquo;s also possible to use the async image downloader independently:</p>

<pre><code class="objective-c">[SDWebImageDownloader.sharedDownloader downloadImageWithURL:imageURL
                                                    options:0
                                                   progress:^(NSInteger receivedSize, NSInteger expectedSize)
                                                   {
                                                       // progression tracking code
                                                   }
                                                   completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished)
                                                   {
                                                       if (image &amp;&amp; finished)
                                                       {
                                                           // do something with image
                                                       }
                                                   }];
</code></pre>

<h3>Using Asynchronous Image Caching Independently</h3>

<p>It is also possible to use the async based image cache store independently. SDImageCache
maintains a memory cache and an optional disk cache. Disk cache write operations are performed
asynchronous so it doesn&rsquo;t add unnecessary latency to the UI.</p>

<p>The SDImageCache class provides a singleton instance for convenience but you can create your own
instance if you want to create separated cache namespace.</p>

<p>To lookup the cache, you use the <code>queryDiskCacheForKey:done:</code> method. If the method returns nil, it means the cache
doesn&rsquo;t currently own the image. You are thus responsible for generating and caching it. The cache
key is an application unique identifier for the image to cache. It is generally the absolute URL of
the image.</p>

<pre><code class="objective-c">SDImageCache *imageCache = [[SDImageCache alloc] initWithNamespace:@"myNamespace"];
[imageCache queryDiskCacheForKey:myCacheKey done:^(UIImage *image)
{
    // image is not nil if image was found
}];
</code></pre>

<p>By default SDImageCache will lookup the disk cache if an image can&rsquo;t be found in the memory cache.
You can prevent this from happening by calling the alternative method <code>imageFromMemoryCacheForKey:</code>.</p>

<p>To store an image into the cache, you use the storeImage:forKey: method:</p>

<pre><code class="objective-c">[[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey];
</code></pre>

<p>By default, the image will be stored in memory cache as well as on disk cache (asynchronously). If
you want only the memory cache, use the alternative method storeImage:forKey:toDisk: with a negative
third argument.</p>

<h3>Using cache key filter</h3>

<p>Sometime, you may not want to use the image URL as cache key because part of the URL is dynamic
(i.e.: for access control purpose). SDWebImageManager provides a way to set a cache key filter that
takes the NSURL as input, and output a cache key NSString.</p>

<p>The following example sets a filter in the application delegate that will remove any query-string from
the URL before to use it as a cache key:</p>

<pre><code class="objective-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    SDWebImageManager.sharedManager.cacheKeyFilter = ^(NSURL *url) {
        url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];
        return [url absoluteString];
    };

    // Your app init code...
    return YES;
}
</code></pre>

<h2>Common Problems</h2>

<h3>Using dynamic image size with UITableViewCell</h3>

<p>UITableView determines the size of the image by the first image set for a cell. If your remote images
don&rsquo;t have the same size as your placeholder image, you may experience strange anamorphic scaling issue.
The following article gives a way to workaround this issue:</p>

<p><a href="http://www.wrichards.com/blog/2011/11/sdwebimage-fixed-width-cell-images/">http://www.wrichards.com/blog/2011/11/sdwebimage-fixed-width-cell-images/</a></p>

<h3>Handle image refresh</h3>

<p>SDWebImage does very aggressive caching by default. It ignores all kind of caching control header returned by the HTTP server and cache the returned images with no time restriction. It implies your images URLs are static URLs pointing to images that never change. If the pointed image happen to change, some parts of the URL should change accordingly.</p>

<p>If you don&rsquo;t control the image server you&rsquo;re using, you may not be able to change the URL when its content is updated. This is the case for Facebook avatar URLs for instance. In such case, you may use the <code>SDWebImageRefreshCached</code> flag. This will slightly degrade the performance but will respect the HTTP caching control headers:</p>

<pre><code class="objective-c">[imageView sd_setImageWithURL:[NSURL URLWithString:@"https://graph.facebook.com/olivier.poitrey/picture"]
                 placeholderImage:[UIImage imageNamed:@"avatar-placeholder.png"]
                          options:SDWebImageRefreshCached];
</code></pre>

<h3>Add a progress indicator</h3>

<p>See this category: <a href="https://github.com/JJSaccolo/UIActivityIndicator-for-SDWebImage">https://github.com/JJSaccolo/UIActivityIndicator-for-SDWebImage</a></p>

<h2>Installation</h2>

<p>There are three ways to use SDWebImage in your project:
- using Cocoapods
- copying all the files into your project
- importing the project as a static library</p>

<h3>Installation with CocoaPods</h3>

<p><a href="http://cocoapods.org/">CocoaPods</a> is a dependency manager for Objective-C, which automates and simplifies the process of using 3rd-party libraries in your projects. See the <a href="http://cocoapods.org/#get_started">Get Started</a> section for more details.</p>

<h4>Podfile</h4>

<pre><code>platform :ios, '6.1'
pod 'SDWebImage', '~&gt;3.7'
</code></pre>

<h3>Installation with Carthage (iOS 8+)</h3>

<p><a href="https://github.com/Carthage/Carthage">Carthage</a> is a lightweight dependency manager for Swift and Objective-C. It leverages CocoaTouch modules and ins less invasive than CocoaPods.</p>

<p>To install with carthage, follow the instruction on <a href="https://github.com/Carthage/Carthage">Carthage</a></p>

<h4>Cartfile</h4>

<pre><code>github "rs/SDWebImage"
</code></pre>

<h4>Usage</h4>

<p>Swift</p>

<pre><code>import WebImage
</code></pre>

<p>Objective-C</p>

<pre><code>@import WebImage;
</code></pre>

<h3>Installation by cloning the repository</h3>

<p>In order to gain access to all the files from the repository, you should clone it.
<code>
git clone --recursive https://github.com/rs/SDWebImage.git
</code></p>

<h3>Add the SDWebImage project to your project</h3>

<ul>
<li>Download and unzip the last version of the framework from the <a href="https://github.com/rs/SDWebImage/releases">download page</a></li>
<li>Right-click on the project navigator and select &ldquo;Add Files to &#8220;Your Project&rdquo;:</li>
<li>In the dialog, select SDWebImage.framework:</li>
<li>Check the &ldquo;Copy items into destination group&rsquo;s folder (if needed)&rdquo; checkbox</li>
</ul>


<h3>Add dependencies</h3>

<ul>
<li>In you application project app’s target settings, find the &ldquo;Build Phases&rdquo; section and open the &ldquo;Link Binary With Libraries&rdquo; block:</li>
<li>Click the &ldquo;+&rdquo; button again and select the &ldquo;ImageIO.framework&rdquo;, this is needed by the progressive download feature:</li>
</ul>


<h3>Add Linker Flag</h3>

<p>Open the &ldquo;Build Settings&rdquo; tab, in the &ldquo;Linking&rdquo; section, locate the &ldquo;Other Linker Flags&rdquo; setting and add the &ldquo;-ObjC&rdquo; flag:</p>

<p><img src="http://dl.dropbox.com/u/123346/SDWebImage/10_other_linker_flags.jpg" alt="Other Linker Flags" /></p>

<p>Alternatively, if this causes compilation problems with frameworks that extend optional libraries, such as Parse,  RestKit or opencv2, instead of the -ObjC flag use:
<code>
-force_load SDWebImage.framework/Versions/Current/SDWebImage
</code></p>

<p>If you&rsquo;re using Cocoa Pods and have any frameworks that extend optional libraries, such as Parsen RestKit or opencv2, instead of the -ObjC flag use:
<code>
-force_load $(TARGET_BUILD_DIR)/libPods.a
</code></p>

<h3>Import headers in your source files</h3>

<p>In the source files where you need to use the library, import the header file:</p>

<pre><code class="objective-c">#import &lt;SDWebImage/UIImageView+WebCache.h&gt;
</code></pre>

<h3>Build Project</h3>

<p>At this point your workspace should build without error. If you are having problem, post to the Issue and the
community can help you solve it.</p>

<h2>Future Enhancements</h2>

<ul>
<li>LRU memory cache cleanup instead of reset on memory warning</li>
</ul>


<h2>Licenses</h2>

<p>All source code is licensed under the <a href="https://raw.github.com/rs/SDWebImage/master/LICENSE">MIT License</a>.</p>

<p><strong>更多源代码：</strong></p>

<p><a href="http://www.superqq.com/blog/2015/01/15/objective-cxiang-guan-categoryde-shou-ji/">Objective-C相关Category的收集</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/paperfold-for-ios/">PaperFold-for-iOS</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/dkcirclebutton/">DKCircleButton</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/twittercover/">TwitterCover</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/hackernews/">HackerNews</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C相关Category的收集]]></title>
    <link href="http://www.superqq.com/blog/2015/01/15/objective-cxiang-guan-categoryde-shou-ji/"/>
    <updated>2015-01-15T10:38:25+08:00</updated>
    <id>http://www.superqq.com/blog/2015/01/15/objective-cxiang-guan-categoryde-shou-ji</id>
    <content type="html"><![CDATA[<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p>Categories是给你得不到源码的classes增加功能的一种方法。 <a href="http://cocoacats.com"target="_blank"title="iOS开发">这个页面</a> 收集一些相关的Category，并且持续更新，你可以订阅关注。作者是Fille Åström，是@ IMGNRY的联合创始人和开发者。</p>

<p>感谢大家的反馈，如果你有任何想法、抱怨或者建议，可以给我发送邮件（fille@imgnry.com），也可以在<a href="twitter.com/bobmoff"target="_blank"title="iOS开发">推特</a>或者App.net上给我发信息（@bobmoff）。</p>

<p>参考阅读：
苹果官方文档：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html"target="_blank"title="iOS开发">Customizing Existing Classes </a></p>

<p><a href="https://github.com/Julioacarrettoni/UIImageView_FaceAwareFill"target="_blank"title="iOS开发">UIImageView+FaceAwareFill</a></p>

<p>这个类别使用了Aspect Fill内容模式，可以自动根据图像内容进行调整，当检测到人脸时，它会以脸部中心替代掉以图片的几何中心。
测试环境：Xcode 5.0，iOS 6.0以上</p>

<p><a href="https://github.com/bendytree/Objective-C-RegEx-Categories"target="_blank"title="iOS开发">NSRegularEx+ObjCRegex</a></p>

<p>Objective-C-RegEx-Categories是NSRegularExpression的一个延展，它可以把Object-C中的很多正则表达式合并成一个，简化了代码。
这个库没有任何依赖性，适用于iOS 4+和OS X 10.7+。</p>

<p><a href="https://github.com/nicklockwood/AutoCoding"target="_blank"title="iOS开发">NSObject+AutoCoding</a></p>

<p>AutoCoding是一个NSObject的类目，提供了对NSCoding 和NSCopying的自动支持。
兼容ARC和non-ARC编译目标
支持iOS 7.0/Mac OS 10.9 (Xcode 5.0, Apple LLVM compiler 5.0)</p>

<p><a href="https://gist.github.com/alvesjtiago/8123006"target="_blank"title="iOS开发">NSInvocation+SimpleCreation</a></p>

<p>创建invocations的简单方法</p>

<p><a href="https://github.com/shaahin/SHPersian"target="_blank"title="iOS开发">NSString+SHPersian</a></p>

<p>SHPersian是一个针对使用波斯语和阿拉伯语的iOS开发者提供的工具，包含了一个在Persian iOS app中为文本添加自定义外观的必需的类。</p>

<p><a href="https://github.com/mergesort/UILabel-ContentSize"target="_blank"title="iOS开发">UILabel+ContentSize</a></p>

<p>在UILabel内计算内容的大小。</p>

<p><a href="https://github.com/RuiAAPeres/UIViewController-Swizzled"target="_blank"title="iOS开发">UIViewController+Swizzled</a></p>

<p>记录UIViewController层次：包括你在视图控制器的名字，还有你进入层次的展示。</p>

<p><a href="https://gist.github.com/maciekish/7772693"target="_blank"title="iOS开发">NSObject+Association</a></p>

<p>你是不是一直希望将&#8221;userInfo&#8221;显示到UIAlertView上呢？通过Association这个category可以将任意的对象赋值给其它任意对象(从iOS3.1和mac os 10.6到最新的系统版本。)</p>

<p><a href="https://gist.github.com/maciekish/6268142"target="_blank"title="iOS开发">NSHTTPCookieStorage+FreezeDry</a></p>

<p>app重启时，清除UIWebView cookies。</p>

<p><a href="https://github.com/erica/uidevice-extension"target="_blank"title="iOS开发">UIDevice+Hardware</a></p>

<p>检测硬件设备的版本。</p>

<p><a href="https://gist.github.com/aegzorz/6068741"target="_blank"title="iOS开发">NSObject+LogDealloc</a></p>

<p>是一个NSObject category，对于内存泄露的跟踪非常有用</p>

<p><a href="https://github.com/krzysztofzablocki/SFObservers"target="_blank"title="iOS开发">NSObject+SFObservers</a></p>

<p>是对NSNotificationCenter and KVO的一个扩展，它能够自动移除观察者。</p>

<p><a href="https://gist.github.com/maciekish/6052297"target="_blank"title="iOS开发">UIApplication+NetworkActivity</a></p>

<p>UIApplication+NetworkActivity跟踪你最近进行过的网络操作，并管理NetworkActivityIndicator。</p>

<p><a href="https://gist.github.com/aegzorz/5974444"target="_blank"title="iOS开发">UIView+Recursion</a></p>

<p>以递归的方式遍历(查找)subview</p>

<p><a href="https://gist.github.com/bobmoff/5967220"target="_blank"title="iOS开发">UIView+RoundedCorners</a></p>

<p>使用图层蒙版为视图添加圆角</p>

<p><a href="https://gist.github.com/bobmoff/5967180"target="_blank"title="iOS开发">UIView+Stacker</a></p>

<p>Stack subviews是按照索引进行垂直排序的。主要用于——使用xib时，以及需要进行view布局时(显示/隐藏)——当基于外部数据。不过不能用于autolayout。.</p>

<p><a href="https://github.com/carlbrown/RegexOnNSString"target="_blank"title="iOS开发">NSString+PDRegex</a></p>

<p>简化正则表达式的使用</p>

<p><a href="https://gist.github.com/maciekish/5947238"target="_blank"title="iOS开发">MKMapView+MoveLogo</a></p>

<p>这个类目允许你移动MKMapView logo，即使你放其他东西在mapview上它仍能保持可见。如果隐藏了logo，那将不能通过App Store审核。已经在iOS 5-iOS 7上进行了测试。</p>

<p><a href="https://github.com/azu/NSDate-Escort"target="_blank"title="iOS开发">NSDate+Escort</a></p>

<p>NSDate-Escort是一个NSDate实用库，兼容NSDate-Extensions API</p>

<p><a href="https://gist.github.com/danielphillips/1005520"target="_blank"title="iOS开发">UILabel+DynamicSizeMe</a></p>

<p>调整UILabel来根据内容改变其框架</p>

<p><a href="https://github.com/scalessec/Toast"target="_blank"title="iOS开发">UIView+Toast</a></p>

<p>适用于iOS上的Android风格toas通知。</p>

<p><a href="https://github.com/Nyx0uf/NYXImagesKit"target="_blank"title="iOS开发">UIImage+NYXImagesKit</a></p>

<p>NYXImagesKit是一个重组了多个有用的UIImage categories的iOS项目，可对图像/图片进行多个处理，比如筛选、模糊、优化、蒙版、调整大小、旋转以及保存等等。同时还提供了一个UIImageView子类从URL异步加载图片，并在下载完毕时展示图片。</p>

<p><a href="https://github.com/martinjuhasz/MJPopupViewController"target="_blank"title="iOS开发">UIViewController+MJPopup</a></p>

<p>MJPopupViewController是一个 UIViewController Category，用于使用不同的过渡效果来把ViewController作为弹出视图进行展示。</p>

<p>  <a href="https://github.com/mattgemmell/MGImageUtilities"target="_blank"title="iOS开发">UIImage+MGImageUtilities</a></p>

<p>MGImageUtilities展示两个UIImage category：UIImage+ProportionalFill和UIImage+Tint。你可以通过UIImage+ProportionalFill调整任意图片的尺寸，可以使用UIImage+Tint来为图片着色。</p>

<p><a href="https://github.com/Cocoanetics/DTFoundation"target="_blank"title="iOS开发">MultipleObjects+DTFoundation</a></p>

<p>DTFoundation集合了实用方法和category的扩展，逐渐演变成一个文档齐全的工具集，记录和测试代码以加快开发。</p>

<p><a href="https://github.com/rs/SDWebImage"target="_blank"title="iOS开发">UIImageView+WebCache</a></p>

<p>SDWebImage提供一个UIImageView类别，以支持加载管理源自网络的远程图片。具有异步加载、缓存管理、同一个URL下载次数控制和优化等特征。简单易用。</p>

<p> <a href="https://github.com/bennyguitar/Colours"target="_blank"title="iOS开发">UIColor+Colours</a></p>

<p>100组漂亮的预制的色彩和配色方案可以让你的iOS/OS X开发更轻松。</p>

<p> <a href="https://github.com/ProjectDent/UIImage-PDFColoredImage"target="_blank"title="iOS开发">UIImage+PDFColoredImage</a></p>

<p>UIImage-PDFColoredImage是一个UIImage扩展，可以把黑色的PDF image转换成任意尺寸任意颜色的UIImage，只需一行代码，简单易用。</p>

<p><a href="https://github.com/k06a/NSData-AsyncCacher"target="_blank"title="iOS开发">NSData+AsyncCacher</a></p>

<p>NSData-AsyncCacher是NSData的一个category，用于从url和block中异步加载数据。请求数据使用NSCache缓存，可以多次请求。</p>

<p> <a href="https://github.com/billymeltdown/nsdate-helper"target="_blank"title="iOS开发">NSDate+Helper</a></p>

<p>通过一些便捷函数扩展了Cocoa的NSDate</p>

<p> <a href="https://github.com/supermarin/ObjectiveSugar"target="_blank"title="iOS开发">MultipleObjects+ObjectiveSugar</a></p>

<p>Objective-C additions for humans. Ruby style.</p>

<p><a href="https://github.com/Kjuly/MKMapView-ZoomLevel"target="_blank"title="iOS开发">MKMapView+ZoomLevel</a></p>

<p>在MapView中设置缩放比例。</p>

<p> <a href="https://gist.github.com/Abeansits/5848341"target="_blank"title="iOS开发">NSString+Extensions</a></p>

<p>一个针对NSStrings的category，它能将string转换为SHA1，NSNumber。检测string是否为空、是否包含某个子字符串，以及替换掉NSDictionary中的子字符串。</p>

<p><a href="https://github.com/nicklockwood/ViewUtils"target="_blank"title="iOS开发">UIView+Utils</a></p>

<p>ViewUtils是一个category methods的集合，这些方法是UIView的扩展，包含了许多方便的属性和方法，其中许多都是我们希望苹果内置的。</p>

<p> <a href="https://github.com/kevinlawler/NSDate-TimeAgo"target="_blank"title="iOS开发">NSDate+TimeAgo</a></p>

<p>让NSDate报告时间，比如&#8221;A moment ago&#8221;, &ldquo;30 seconds ago&rdquo;, &ldquo;5 minutes ago&rdquo;, &ldquo;Yesterday&rdquo;, &ldquo;Last month&rdquo;, &ldquo;2 years ago&#8221;以及其他。</p>

<p> <a href="https://github.com/alexdrone/ios-fontawesome"target="_blank"title="iOS开发">NSString+FontAwesome</a></p>

<p>FontAwesome+iOS是一个开源形象字体库，通过扩展 NSString 让你在app中轻松使用 FontAwesome 字体。
官方网站：<a href="http://fortawesome.github.io/Font-Awesome/">http://fortawesome.github.io/Font-Awesome/</a></p>

<p> <a href="https://gist.github.com/aegzorz/5797393"target="_blank"title="iOS开发">NSArray+FirstObject</a></p>

<p>从数组中获得第一个对象，或者从空数组中返回零</p>

<p>  <a href="https://github.com/djmadcat/NSObject-AutoDescription"target="_blank"title="iOS开发">NSObject+AutoDescription</a></p>

<p>能够简单地为任何类描述日志(从 NSObject派生出来)</p>

<p>  <a href="https://gist.github.com/aegzorz/5797337"target="_blank"title="iOS开发">CGRect+Additions</a></p>

<p>处理CGRects的一些函数。</p>

<p> <a href="https://gist.github.com/bobmoff/5276954"target="_blank"title="iOS开发">UIView+ModifyFrame</a></p>

<p>简单实用的UIView类目使修改框架不那么变态。</p>

<p><a href="https://gist.github.com/dsibilly/1038500"target="_blank"title="iOS开发">NSString+UsefulShit</a></p>

<p>Objective-C category 示范</p>

<p><strong>更多源代码：</strong></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/paperfold-for-ios/">PaperFold-for-iOS</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/dkcirclebutton/">DKCircleButton</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/twittercover/">TwitterCover</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/hackernews/">HackerNews</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/06/gpuimage/">GPUImage</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PaperFold-for-iOS]]></title>
    <link href="http://www.superqq.com/blog/2015/01/07/paperfold-for-ios/"/>
    <updated>2015-01-07T14:55:39+08:00</updated>
    <id>http://www.superqq.com/blog/2015/01/07/paperfold-for-ios</id>
    <content type="html"><![CDATA[<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p> <a href="https://github.com/honcheng/PaperFold-for-iOS.git"target="_blank"title="源代码">源代码</a></p>

<h1>PaperFold for iOS</h1>

<p>PaperFold is a simple iOS control that allows hiding of views on the left and right side of the screen by dragging the middle view.
The left view supports only 1 fold. The right view supports variable number of folds.</p>

<p><img width=150 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/1.png"/> <img width=150 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/2.png"/> <img width=150 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/3.png"/> <img width=150 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/4.png"/></p>

<p><em>Vertical fold is still in active testing, in an experimental branch (top-multifold) at the moment.</em></p>

<p><img width=150 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/5-topfold.png"/> <img width=150 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/6-topfold.png"/> <img width=150 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/7-topfold.png"/> <img width=150 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/8-bottomfold.png"/> <img width=150 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/9-bottomfold.png"/><br/>
<img width=300 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/verticalfold.gif"/></p>

<h2>How it works</h2>

<p>During folding, a screen capture of the left/right view is taken, and split up depending on the number of folds required. The virtual light source is on the right side of the screen, so surfaces that faces the left are darker. For the right multi-fold view, the fold closes to the &lsquo;force&rsquo; are opened up faster than the folds that is further away.</p>

<p>A sample project is included.</p>

<h2>Example</h2>

<p>Refer to this <a href="http://www.honcheng.com/2012/02/Playing-with-folding-navigations">link</a> for a video showing the prototype of an app that I was working on. In the end, the proposed project was never completed because I could not obtained reliable data for the app, but I intend to use it for another app.</p>

<p><img width=300 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/leftfold.gif"/> <img width=300 src="https://github.com/honcheng/PaperFold-for-iOS/raw/master/Screenshots/rightfold.gif"/></p>

<p>The animation here looks a bit laggy, but that&rsquo;s because of the low frame rates in GIF.</p>

<h2>Usage</h2>

<p>1) Add PaperFoldView as a subview into your view controller.</p>

<pre><code>_paperFoldView = [[PaperFoldView alloc] initWithFrame:CGRectMake(0,0,100,[self.view bounds].size.height)];
[self.view addSubview:_paperFoldView];
</code></pre>

<p>2) To set left view, use setLeftFoldContentView:foldCount:pullFactor:. Example below uses a UITableView, but it can any UIView.</p>

<pre><code>_leftTableView = [[UITableView alloc] initWithFrame:CGRectMake(0,0,100,[self.view bounds].size.height)];
[_paperFoldView setLeftFoldContentView:_leftTableView foldCount:3 pullFactor:0.9];
</code></pre>

<p>3) To set the right view, use setRightFoldContentView:foldCount:pullFactor:. Example below uses a MKMapView, but it can any UIView. The fold count is the number of folds in the right view. The pull factor controls the ratio of folding/unfolding of the different folds away from the center.</p>

<pre><code>_mapView = [[MKMapView alloc] initWithFrame:CGRectMake(0,0,240,[self.view bounds].size.height)];
[_paperFoldView setRightFoldContentView:_mapView foldCount:3 pullFactor:0.9];
</code></pre>

<p>4) To set the center view</p>

<pre><code>_centerTableView = [[UITableView alloc] initWithFrame:CGRectMake(0,0,[self.view bounds].size.height,[self.view bounds].size.height)];
[_paperFoldView setCenterContentView:_centerTableView];
</code></pre>

<p>4) Sometimes you may want to disable drag-to-unfold if you have a table view in the center view and wish to preserve the swipe gesture functions e.g. to delete cells.</p>

<pre><code>// this disables dragging to unfold the left view
[self.paperFoldView setEnableLeftFoldDragging:NO];

// this disables dragging to unfold the right view
[self.paperFoldView setEnableRightFoldDragging:NO];
</code></pre>

<p>5) To unfold left view without dragging</p>

<pre><code>[self.paperFoldView setPaperFoldState:PaperFoldStateLeftUnfolded];
</code></pre>

<p>6) To unfold right view without dragging</p>

<pre><code>[self.paperFoldView setPaperFoldState:PaperFoldStateRightUnfolded];
</code></pre>

<p>7) To restore view to center without dragging</p>

<pre><code>[self.paperFoldView setPaperFoldState:PaperFoldStateDefault];
</code></pre>

<p>8) To receive callbacks when fold state changes, and if the fold was activated manually by finger gesture, or automatically by calling setPaperFoldState:</p>

<pre><code>// register callback delegate
[self.paperFoldView setDelegate:self];

// callback comes from the following delegate method 
- (void)paperFoldView:(id)paperFoldView didFoldAutomatically:(BOOL)automatic toState:(PaperFoldState)paperFoldState
</code></pre>

<h2>Requirements</h2>

<p>This project uses ARC. If you are not using ARC in your project, add &lsquo;-fobjc-arc&rsquo; as a compiler flag for all the files in this project.
XCode 4.4 is required for auto-synthesis.</p>

<h2>Apps that uses PaperFold</h2>

<p><a href="https://itunes.apple.com/sg/app/id547022322">Showy</a>
, <a href="https://itunes.apple.com/sg/app/largetype-full-screen-text/id568459406">LargeType</a>
, <a href="https://itunes.apple.com/us/app/nextride-singapore-public/id565103559">NextRide</a>
, <a href="https://itunes.apple.com/sg/app/sg-nextbus/id361404839">SG NextBus</a>
, <a href="https://itunes.apple.com/cn/app/hang-zhou-de-tie/id518531257?mt=8">Hangzhou Metro</a></p>

<p><a href="http://twitter.com/honcheng">Contact me</a> if you want your app listed here. Thanks</p>

<h2>Other Projects that uses PaperFold</h2>

<p><a href="https://github.com/honcheng/PaperFoldMenuController">PaperFoldMenuController</a> by me.</p>

<p><a href="https://github.com/yestoall/PaperFold-pod-DEMO">PaperFold CocoaPod Demo for RubyMotion</a> by <a href="yestoall">yestoall</a>.</p>

<p><a href="https://github.com/atsusy/TiPaperFold">Titanium Mobile Mobule for PaperFold</a> by <a href="https://github.com/atsusy/">atsusy</a>.</p>

<h2>Known Problem</h2>

<p>Screen capture of MKMapView is iOS6 is not taken properly. I approached a few Apple engineers at WWDC, and was told that it is most likely a bug that need to fix. I have already filed a bug report (filed as rdar://11813051, closed by Apple because it is a duplicate of rdar://11650331). Hopefully it will be fixed soon.</p>

<p><strong>Update:</strong> This bug is fixed in iOS6b4. No problem taking screenshot of MKMapView.</p>

<h2>Credits</h2>

<p>Special thanks to <a href="http://twitter.com/dilliontan">@dilliontan</a>, my colleague in <a href="http://buuuk.com">buUuk</a> for explaining CAAffineTransform. He&rsquo;s a master at that :p. I&rsquo;m still a noob.
You can check out his <a href="https://github.com/Dillion/iOS-Flip-Transform">iOS-Flip-Transform project here</a>.</p>

<h2>Contact</h2>

<p><a href="http://twitter.com/honcheng">twitter.com/honcheng</a>
<a href="http://honcheng.com">honcheng.com</a></p>

<p><img src="http://www.cocoacontrols.com/analytics/honcheng/paperfold-for-ios.png" alt="" /></p>

<p><strong>更多源代码：</strong></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/dkcirclebutton/">DKCircleButton</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/twittercover/">TwitterCover</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/hackernews/">HackerNews</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/06/gpuimage/">GPUImage</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/06/pop/">Pop</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DKCircleButton]]></title>
    <link href="http://www.superqq.com/blog/2015/01/07/dkcirclebutton/"/>
    <updated>2015-01-07T14:48:23+08:00</updated>
    <id>http://www.superqq.com/blog/2015/01/07/dkcirclebutton</id>
    <content type="html"><![CDATA[<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p> <a href="https://github.com/kronik/DKCircleButton.git"target="_blank"title="源代码">源代码</a></p>

<h1> DKCircleButton</h1>

<p>Sources of DKCircleButton and Demo app to show circle button tap effect.</p>

<h2>Download</h2>

<pre><code>$ git clone https://github.com/kronik/DKCircleButton.git
$ cd DKCircleButton/
</code></pre>

<h2>Usage</h2>

<p>Please check out the demo project included.</p>

<h1><img src="https://raw.github.com/kronik/DKCircleButton/master/example.gif" alt="Screenshot" /></h1>

<h3>Initialization</h3>

<p>Like a regular custom UIButton
&#8220;` objective-c
- (void)viewDidLoad {
  [super viewDidLoad];</p>

<p>  DKCircleButton *button1 = [[DKCircleButton alloc] initWithFrame:CGRectMake(0, 0, 90, 90)];</p>

<p>  button1.center = CGPointMake(160, 200);
  button1.titleLabel.font = [UIFont systemFontOfSize:22];
}
&#8220;`</p>

<h3>Toggle animation mode</h3>

<pre><code class="objective-c">  button1.animateTap = NO;
</code></pre>

<h2>Requirements</h2>

<p>Supported build target - iOS 7.x
Earliest supported deployment target - iOS 7.0</p>

<h2>License</h2>

<p>DKCircleButton is available under the MIT license. See the LICENSE file for more info.</p>
]]></content>
  </entry>
  
</feed>
