<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 推荐 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/tui-jian/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-12-09T23:51:07+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于启用 HTTPS 的一些经验分享]]></title>
    <link href="http://www.superqq.com/blog/2015/12/08/some-experiences-https/"/>
    <updated>2015-12-08T21:54:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/08/some-experiences-https</id>
    <content type="html"><![CDATA[<p><img src="http://images.90159.com/12/https.jpg" alt="https" /></p>

<p>随着国内网络环境的持续恶化，各种篡改和劫持层出不穷，越来越多的网站选择了全站 HTTPS。HTTPS 通过 TLS 层和证书机制提供了内容加密、身份认证和数据完整性三大功能，可以有效防止数据被查看或篡改，以及防止中间人冒充。本文分享一些启用 HTTPS 过程中的经验，重点是如何与一些新出的安全规范配合使用。至于 HTTPS 的部署及优化，之前写过很多，本文不重复了。</p>

<!--more-->


<h2>理解 Mixed Content</h2>

<p>HTTPS 网页中加载的 HTTP 资源被称之为 Mixed Content(混合内容)，不同浏览器对 Mixed Content 有不一样的处理规则。</p>

<h2>早期的 IE</h2>

<p>早期的 IE 在发现 Mixed Content 请求时，会弹出「是否只查看安全传送的网页内容?」这样一个模态对话框，一旦用户选择「是」，所有 Mixed Content 资源都不会加载;选择「否」，所有资源都加载。</p>

<h2>比较新的 IE</h2>

<p>比较新的 IE 将模态对话框改为页面底部的提示条，没有之前那么干扰用户。而且默认会加载图片类 Mixed Content，其它如 JavaScript、CSS 等资源还是会根据用户选择来决定是否加载。</p>

<h2>现代浏览器</h2>

<p>现代浏览器(Chrome、Firefox、Safari、Microsoft Edge)，基本上都遵守了 W3C 的 Mixed Content 规范，将 Mixed Content 分为Optionally-blockable 和 Blockable 两类：</p>

<p>Optionally-blockable 类 Mixed Content 包含那些危险较小，即使被中间人篡改也无大碍的资源。现代浏览器默认会加载这类资源，同时会在控制台打印警告信息。这类资源包括：</p>

<pre><code>通过  标签加载的图片(包括 SVG 图片);

通过 &lt;img&gt; 标签加载的图片（包括 SVG 图片）；

通过 &lt;video&gt; / &lt;audio&gt; 和 &lt;source&gt; 标签加载的视频或音频；

预读的（Prefetched）资源；
</code></pre>

<h2>预读的(Prefetched)资源;</h2>

<p>除此之外所有的 Mixed Content 都是 Blockable，浏览器必须禁止加载这类资源。所以现代浏览器中，对于 HTTPS 页面中的 JavaScript、CSS 等 HTTP 资源，一律不加载，直接在控制台打印错误信息。</p>

<h2>移动浏览器</h2>

<p>前面所说都是桌面浏览器的行为，移动端情况比较复杂，当前大部分移动浏览器默认都允许加载 Mixed Content。也就是说，对于移动浏览器来说，HTTPS 中的 HTTP 资源，无论是图片还是 JavaScript、CSS，默认都会加载。</p>

<p>一般选择了全站 HTTPS，就要避免出现 Mixed Content，页面所有资源请求都走 HTTPS 协议才能保证所有平台所有浏览器下都没有问题。</p>

<h2>合理使用 CSP</h2>

<p>CSP，全称是 Content Security Policy，它有非常多的指令，用来实现各种各样与页面内容安全相关的功能。</p>

<pre><code>block-all-mixed-content
</code></pre>

<p>前面说过，对于 HTTPS 中的图片等 Optionally-blockable 类 HTTP 资源，现代浏览器默认会加载。图片类资源被劫持，通常不会有太大的问题，但也有一些风险，例如很多网页按钮是用图片实现的，中间人把这些图片改掉，也会干扰用户使用。</p>

<p>通过 CSP 的 block-all-mixed-content 指令，可以让页面进入对混合内容的严格检测(Strict Mixed Content Checking)模式。在这种模式下，所有非 HTTPS 资源都不允许加载。跟其它所有 CSP 规则一样，可以通过以下两种方式启用这个指令：</p>

<h2>HTTP 响应头方式：</h2>

<pre><code>Content-Security-Policy: block-all-mixed-content 
</code></pre>

<p><meta>标签方式：</p>

<pre><code>&lt;meta http-equiv="Content-Security-Policy" content="block-all-mixed-content"&gt; 


upgrade-insecure-requests
</code></pre>

<p>历史悠久的大站在往 HTTPS 迁移的过程中，工作量往往非常巨大，尤其是将所有资源都替换为 HTTPS 这一步，很容易产生疏漏。即使所有代码都确认没有问题，很可能某些从数据库读取的字段中还存在 HTTP 链接。</p>

<p>而通过 upgrade-insecure-requests 这个 CSP 指令，可以让浏览器帮忙做这个转换。启用这个策略后，有两个变化：</p>

<pre><code>页面所有 HTTP 资源，会被替换为 HTTPS 地址再发起请求;

页面所有站内链接，点击后会被替换为 HTTPS 地址再跳转;
</code></pre>

<p>跟其它所有 CSP 规则一样，这个指令也有两种方式来启用，具体格式请参考上一节。需要注意的是 upgrade-insecure-requests 只替换协议部分，所以只适用于 HTTP/HTTPS 域名和路径完全一致的场景。</p>

<h2>合理使用 HSTS</h2>

<p>在网站全站 HTTPS 后，如果用户手动敲入网站的 HTTP 地址，或者从其它地方点击了网站的 HTTP 链接，依赖于服务端 301/302 跳转才能使用 HTTPS 服务。而第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>

<h2>HSTS 基本使用</h2>

<p>这个问题可以通过 HSTS(HTTP Strict Transport Security，RFC6797)来解决。HSTS 是一个响应头，格式如下：</p>

<pre><code>Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload] 
</code></pre>

<p>max-age，单位是秒，用来告诉浏览器在指定时间内，这个网站必须通过 HTTPS 协议来访问。也就是对于这个网站的 HTTP 地址，浏览器需要先在本地替换为 HTTPS 之后再发送请求。</p>

<p>includeSubDomains，可选参数，如果指定这个参数，表明这个网站所有子域名也必须通过 HTTPS 协议来访问。</p>

<p>preload，可选参数，后面再介绍它的作用。</p>

<p>HSTS 这个响应头只能用于 HTTPS 响应;网站必须使用默认的 443 端口;必须使用域名，不能是 IP。而且启用 HSTS 之后，一旦网站证书错误，用户无法选择忽略。</p>

<p>HSTS Preload List</p>

<p>可以看到 HSTS 可以很好的解决 HTTPS 降级攻击，但是对于 HSTS 生效前的首次 HTTP 请求，依然无法避免被劫持。浏览器厂商们为了解决这个问题，提出了 HSTS Preload List 方案：内置一份列表，对于列表中的域名，即使用户之前没有访问过，也会使用 HTTPS 协议;列表可以定期更新。</p>

<p>目前这个 Preload List 由 Google Chrome 维护，Chrome、Firefox、Safari、IE 11 和 Microsoft Edge 都在使用。如果要想把自己的域名加进这个列表，首先需要满足以下条件：</p>

<pre><code>拥有合法的证书(如果使用 SHA-1 证书，过期时间必须早于 2016 年);

将所有 HTTP 流量重定向到 HTTPS;

确保所有子域名都启用了 HTTPS;

输出 HSTS 响应头：

max-age 不能低于 18 周(10886400 秒);

必须指定 includeSubdomains 参数;

必须指定 preload 参数;
</code></pre>

<p>即便满足了上述所有条件，也不一定能进入 HSTS Preload Lis。通过 Chrome 的 chrome://net-internals/#hsts 工具，可以查询某个网站是否在 Preload List 之中，还可以手动把某个域名加到本机 Preload List。</p>

<p>对于 HSTS 以及 HSTS Preload List，我的建议是只要你不能确保永远提供 HTTPS 服务，就不要启用。因为一旦 HSTS 生效，你再想把网站重定向为 HTTP，之前的老用户会被无限重定向，唯一的办法是换新域名。</p>

<h2>CDN 安全</h2>

<p>对于大站来说，全站迁移到 HTTPS 后还是得用 CDN，只是必须选择支持 HTTPS 的 CDN 了。如果使用第三方 CDN，安全方面有一些需要考虑的地方。</p>

<h2>合理使用 SRI</h2>

<p>HTTPS 可以防止数据在传输中被篡改，合法的证书也可以起到验证服务器身份的作用，但是如果 CDN 服务器被入侵，导致静态文件在服务器上被篡改，HTTPS 也无能为力。</p>

<p>W3C 的 SRI(Subresource Integrity)规范可以用来解决这个问题。SRI 通过在页面引用资源时指定资源的摘要签名，来实现让浏览器验证资源是否被篡改的目的。只要页面不被篡改，SRI 策略就是可靠的。</p>

<p>SRI 并不是 HTTPS 专用，但如果主页面被劫持，攻击者可以轻松去掉资源摘要，从而失去浏览器的 SRI 校验机制。</p>

<h2>了解 Keyless SSL</h2>

<p>另外一个问题是，在使用第三方 CDN 的 HTTPS 服务时，如果要使用自己的域名，需要把对应的证书私钥给第三方，这也是一件风险很高的事情。</p>

<p>CloudFlare 公司针对这种场景研发了 Keyless SSL 技术。你可以不把证书私钥给第三方，改为提供一台实时计算的 Key Server 即可。CDN 要用到私钥时，通过加密通道将必要的参数传给 Key Server，由 Key Server 算出结果并返回即可。整个过程中，私钥都保管在自己的 Key Server 之中，不会暴露给第三方。</p>

<p>CloudFlare 的这套机制已经开源，如需了解详情，可以查看他们官方博客的这篇文章：Keyless SSL: The Nitty Gritty Technical Details。</p>

<p>好了，本文先就写到这里，需要注意的是本文提到的 CSP、HSTS 以及 SRI 等策略都只有最新的浏览器才支持，详细的支持度可以去 CanIUse 查。切换到 HTTPS 之后，在性能优化上有很多新工作要做，这部分内容我在之前的博客中写过很多，这里不再重复，只说最重要的一点：既然都 HTTPS 了，赶紧上 HTTP/2 才是正道。</p>

<p>内容来源：Jerry Qu的小站</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员的幽默你一定懂得]]></title>
    <link href="http://www.superqq.com/blog/2015/12/08/programmer-must-humor/"/>
    <updated>2015-12-08T21:54:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/08/programmer-must-humor</id>
    <content type="html"><![CDATA[<p>以下是关于程序员的一些笑话，据说看懂的人都还在加班中。</p>

<ol>
<li><p>老婆给当程序员的老公打电话：下班顺路买十个包子，如果看到卖西瓜的，买一个。当晚老公手捧一个包子进了家门。老婆怒道：你怎么只买一个包子？！老公甚恐，喃喃道：因为我真看到卖西瓜的了。”</p></li>
<li><p>一程序员去面试，面试官问：“你毕业才两年，这三年工作经验是怎么来的？！”程序员答：“加班。”</p></li>
<li><p>某程序员对书法十分感兴趣，退休后决定在这方面有所建树。于是花重金购买了上等的文房四宝。一日，饭后突生雅兴，一番磨墨拟纸，并点上了上好的檀香，颇有王羲之风范，又具颜真卿气势，定神片刻，泼墨挥毫，郑重地写下一行字：hello world。</p></li>
<li><p>问：程序员最讨厌康熙的哪个儿子。答：胤禩。因为他是八阿哥（bug）</p></li>
<li><p>程序猿要了3个孩子，分别取名叫Ctrl、Alt 和Delete，如果他们不听话，程序猿就只要同时敲他们一下就会好的。</p></li>
<li><p>今天在公司听到一句惨绝人寰骂人的话：“你TM就是一个没有对象的野指针！”</p></li>
<li><p>程xx遭遇车祸成植物人，医生说她活下来的希望只有万分之一，唤醒更为渺茫。她的同事和亲人没放弃，并根据程xx对testing痴迷的作风，每天都在她身边念：“你测的模块上线后回滚了。”奇迹发生了，程xx醒来第一句话：确认那模块是我测的？</p></li>
<li><p>一个程序员在海滨游泳时溺水身亡。他死前拼命的呼救，当时海滩上有许多救生员，但是没有人救他。因为他一直大喊“F1!”“F1!”，谁都不知道“F1”究竟是什么意思。</p></li>
<li><p>世界上最远的距离，是我在if里你在else里，虽然经常一起出现，但却永不结伴执行。</p></li>
<li><p>正在码代码ing，医院回来的同事一脸的苦逼样子，问他怎么了？他回答：得了类风湿性关节炎了，我怕会遗传给下一代啊。我一脸的问号：谁说类风湿性关节炎能遗传的？丫一脸诧异：类不是继承的吗？</p></li>
<li><p>我很奇怪客栈这个词，难道后入住的必须先退房吗？</p></li>
<li><p>话说，决定一个程序员跳槽与否的关键因素是他前同事的现工资。</p></li>
<li><p>程序员最憋屈的事情就是：你辛辛苦苦熬夜写了一个风格优雅的源文件，被一个代码风格极差的同事改了且没署名，以至于别人都以为你是写的。</p></li>
<li><p>前端工程师说，我去交友网站找女朋友去了。朋友问，找到了么？工程师说，找到了他们页面的一个bug。</p></li>
<li><p>C程序员看不起C++程序员， C++程序员看不起Java程序员， Java程序员看不起C#程序员，C#程序员看不起美工，周末了，美工带着妹子出去约会了，一群程序员还在加班！</p></li>
<li><p>据说一老外年轻的时候，立志要当一名伟大的作家。怎么才算伟大呢？他说：我写的东西全世界都要看到！看完他们必定会歇斯底里！会火冒三丈！会痛苦万分！结果，他成功了，他在微软公司负责写系统蓝屏时的报错提示信息。</p></li>
<li><p>程序员应聘必备词汇：了解＝听过名字；熟悉＝知道是啥；熟练＝用过；精通＝做过东西。</p></li>
<li><p>两程序员聊天，程序员甲抱怨：“做程序员太辛苦了，我想换行……我该怎么办？”程序员乙：“敲一下回车。”</p></li>
<li><p>程序员最讨厌的四件事：写注释、写文档、别人不写注释、别人不写文档……</p></li>
<li><p>假如生活欺骗了你，找50个程序员问问为什么编程；假如生活让你想死，找50个程序员问问Bug改完了没有；假如你觉得生活拮据，找50个程序员问问工资涨了没有；假如你觉得活着无聊，找50个程序员问问他们一天都干了什么！</p></li>
<li><p>男人要记住，与女人吵架的要领是，要像在安装软件或注册网站时阅读“服务条款”那样，直接忽略所有的内容，到最后面勾选“我同意”，然后点击“确定”。</p></li>
<li><p>朋友今天遇到的真事：客户说我们设备卡，死活找不到原因，工程师赶到现场，给客户换了个鼠标垫，故障排除……</p></li>
<li><p>产品经理：“你明白吧，这里向右划可以出菜单，然后需要一个闪烁的动画，还有，我想这个tab可以拉下来，你懂吧？ 设计师：“别废话，把你要抄的产品给我看下。”</p></li>
<li><p>百度研发的无人驾驶汽车，你会发现有些地方你是去不了的。腾讯研发的无人驾驶汽车，你会发现很多地方你要去是要黄钻会员的。当然，谷歌研发的无人驾驶汽车，你会发现查无此车。</p></li>
<li><p>话说昨天是周日，程序猿跟产品经理一起看电视。每个节目看到一半程序猿就换台，看到一半就换台，几次之后产品经理终于忍无可忍的咆哮：老子刚看出点意思你就换、刚看出点意思你就换，到底还让不让人看啦？！程序猿淡定的盯着电视道：你半路改需求的时候我可没吱过声！</p></li>
<li><p>“为什么删除手机上的图标的时候它们会抖？” “它们怕被删除呗。” “那为什么电话短信之类系统自带的删不掉的也在抖呢？” “那是它们在得瑟…”</p></li>
<li><p>有时候觉得，电脑就像一个高贵冷艳的妹纸。</p></li>
</ol>


<p>400，是她冷冰冰地说：“我听不懂你在说什么”；</p>

<p>401，是她无情地转身：“我不认识你，别说那些奇怪的话”；</p>

<p>403，是她残酷的拒绝：“我听懂你的话，也认出你的脸，可我不爱你”；</p>

<p>404，是她紧闭心门：“我这儿没有你想要的东西”；</p>

<p>503，是“呵呵我去洗澡”。</p>

<ol>
<li><p>问：为何软件正在占领全世界，而程序员得不到尊重？答曰：遍身罗绮者，不是养蚕人。</p></li>
<li><p>她来例假了肚子疼，他坐着她旁边，看了她一眼，拿出手机玩游戏，她看在眼里，心里凉了半截。两分钟后，她实在坐不下去了，正准备离开，只见他默默地递过来他的小米手机说：拿去捂着。</p></li>
<li><p>惊闻微软要裁员1.8万人。他们就不能让这些员工们“在后台运行”吗？</p></li>
<li><p>今天看到我同事在笔记本电脑上实现“滑动解锁”！真的，看到我当场就震精了，异常碉堡……你知道吗？！他的电脑开机解锁密码是“ASDFGHJKL;’”，然后唰得一下过去最后一个键落在回车上，就，就解锁了！</p></li>
<li><p>骗子网站太特么多了，你一打开，必定跳出一个很下流的游戏广告！——但这还不是最关键的，关键是如果你忍不住点击进入游戏之后，就会发现这些下流的元素全都不见了！这也太没有职业道德了吧！</p></li>
<li><p>最近发现自己陷入了一种状态，叫开机迷失。开电脑前，该做什么清清楚楚。但只要一登录，随手开个网页，刷下新闻微博甚至仅仅是音乐网站，然后再回过神来， 已经到了深夜，要做的事一项没做。而最痛苦的是，在睡前闭眼的时候，整个被浪费的白天和那些被耽误的正事，总会掺杂着负罪感，无比清晰地浮现。</p></li>
<li><p>我要设计一个新的智能机应用程序叫做&#8221;惊慌&#8221;，只要你一说 老婆 这两个字, 它就会关闭所有网页, 隐藏所有跟女性的聊天以及怪怪的文件夹, 并且把我老婆的照片设为墙纸。</p></li>
<li><p>我从苹果手机的背面知道了一个好地方叫做加利福尼亚，据说那里有阳光和沙滩，还有Google和Tesla。据说那里的人经常讨论怎么创业，而不是怎么移民。我虽然在中国，但也去过那里，不是在梦中，而是通过VPN。</p></li>
<li><p>边上工位的妹纸叫柳依依，她的爸爸也是位程序员，依依的大姐叫玲玲，二姐叫玲依，三姐叫依玲。</p></li>
</ol>


<p>整理自网络</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为自己的应用配备上 3D Touch 功能]]></title>
    <link href="http://www.superqq.com/blog/2015/10/31/app-touch-3d-function/"/>
    <updated>2015-10-31T10:35:24+08:00</updated>
    <id>http://www.superqq.com/blog/2015/10/31/app-touch-3d-function</id>
    <content type="html"><![CDATA[<p>随着 iPhone 6s 以及 iPhone 6s Plus 的发布，开发者们现在就可以为自己的应用配备上 3D Touch 功能了，从而给界面交互方式开启一个新的维度。</p>

<p>正如苹果所言，开发者可以通过非常简单的 API 来使用 3D Touch ，从根本上来说，也就是 UITouch 的一个简单的新属性。</p>

<pre><code>override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) {
     guard let touch = touches.first else { return }
     if traitCollection.forceTouchCapability == .Available {
        println("Touch pressure is \(touch.force), maximum possible force is \(touch.maximumPossibleForce)")
     }
}
</code></pre>

<p>这个新的 API 可以让应用发挥出巨大的潜力，比如说游戏中的额外控制选项、绘图应用中的细粒度(fine-grained)控制，甚至是用来替代我们在 iOS 设备中使用过的长按操作(tap-and-hold)的极佳选择。</p>

<p>除了 UITouch 中新增的 API 外，苹果还为应用提供了两个用来增加3D Touch 功能的类集：UIPreviewAction 和 UIApplicationShortcutItem。</p>

<p>UIPreviewAction允许开发者在用户使用 3D Touch 功能触控一个 UI 元素的时候，快速地在一个新的预览窗口中显示某些内容。这种快速浏览应用特定内容的方式真的非常棒，比如说我们可以快速预览邮件信息、照片，甚至是网页内容，而无需弹出一个完整的视图控制器。</p>

<p>UIApplicationShortcutItem对象能够让 iOS 主屏幕激活一项令人惊叹的新特性。当用户使用 3D Touch 按下某个应用的图标时，一个选项列表就会被弹出，允许用户快速跳转至应用的特定部分，或者执行某项应用内的功能。</p>

<p><img src="http://images.90159.com/10/touch.jpg" alt="touch" /></p>

<p>总而言之，3D Touch 的引入给 iOS 设备解锁了一个全新的交互方式，并且将会给接下来的 iOS 应用带来新一代的创新。关于3D Touch 的实例代码和相关信息可以在苹果开发者网站的3D Touch网页上找到，祝你好运！</p>

<p>作者：Tim Oliver
@TimOliverAU — iComics创始人</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[五个案例让你明白GCD死锁]]></title>
    <link href="http://www.superqq.com/blog/2015/10/16/five-case-know-gcd/"/>
    <updated>2015-10-16T20:29:42+08:00</updated>
    <id>http://www.superqq.com/blog/2015/10/16/five-case-know-gcd</id>
    <content type="html"><![CDATA[<pre><code>作者：brighttj（@saitjr

网址：http://www.brighttj.com/ios/ios-gcd-deadlock.html
</code></pre>

<p>死锁一直都是在使用多线程时，需要注意的一个问题。以前对同步、异步，串行、并行只有一个模糊的概念，想想也是时候整理一下了。再看看之前的博客，已经很久没有干货了【说得好像之前有干货一样】，所以，这篇博客，我尽最大努力，也借鉴了很多其他博客中的例子，来讲解GCD死锁问题。</p>

<p>环境信息：</p>

<p>Mac OS X 10.10.5</p>

<p>Xcode 6.4</p>

<p>iOS  8.4</p>

<h2>串行与并行</h2>

<p>在使用GCD的时候，我们会把需要处理的任务放到Block中，然后将任务追加到相应的队列里面，这个队列，叫做Dispatch Queue。然而，存在于两种Dispatch Queue，一种是要等待上一个执行完，再执行下一个的Serial Dispatch Queue，这叫做串行队列；另一种，则是不需要上一个执行完，就能执行下一个的Concurrent Dispatch Queue，叫做并行队列。这两种，均遵循FIFO原则。</p>

<pre><code>举一个简单的例子，在三个任务中输出1、2、3，串行队列输出是有序的1、2、3，但是并行队列的先后顺序就不一定了。
</code></pre>

<p>那么，并行队列又是怎么在执行呢？</p>

<p>虽然可以同时多个任务的处理，但是并行队列的处理量，还是要根据当前系统状态来。如果当前系统状态最多处理2个任务，那么1、2会排在前面，3什么时候操作，就看1或者2谁先完成，然后3接在后面。</p>

<p>串行和并行就简单说到这里，关于它们的技术点其实还有很多，可以自行了解。</p>

<h2>同步与异步</h2>

<p>串行与并行针对的是队列，而同步与异步，针对的则是线程。最大的区别在于，同步线程要阻塞当前线程，必须要等待同步线程中的任务执行完，返回以后，才能继续执行下一任务；而异步线程则是不用等待。</p>

<p>仅凭这几句话还是很难理解，所以之后准备了很多案例，可以边分析边理解。</p>

<!--more-->


<h2>GCD API</h2>

<p>GCD API很多，这里仅介绍本文用到的。</p>

<ol>
<li><p>系统标准提供的两个队列</p>

<pre><code> // 全局队列，也是一个并行队列

 dispatch_get_global_queue 

 // 主队列，在主线程中运行，因为主线程只有一个，所以这是一个串行队列

 dispatch_get_main_queue 
</code></pre></li>
<li><p>除此之外，还可以自己生成队列</p>

<pre><code> // 从DISPATCH_QUEUE_SERIAL看出，这是串行队列

 dispatch_queue_create("com.demo.serialQueue", DISPATCH_QUEUE_SERIAL) 

 // 同理，这是一个并行队列

 dispatch_queue_create("com.demo.concurrentQueue", DISPATCH_QUEUE_CONCURRENT) 
</code></pre></li>
</ol>


<p>接下来是同步与异步线程的创建：</p>

<pre><code>dispatch_sync(..., ^(block)) // 同步线程

dispatch_async(..., ^(block)) // 异步线程
</code></pre>

<h2>案例与分析</h2>

<p>假设你已经基本了解了上面提到的知识，接下来进入案例讲解阶段。</p>

<h2>案例一：</h2>

<pre><code>NSLog(@"1"); // 任务1

dispatch_sync(dispatch_get_main_queue(), ^{

    NSLog(@"2"); // 任务2

});

NSLog(@"3"); // 任务3
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1
</code></pre>

<p>分析：</p>

<pre><code>dispatch_sync表示是一个同步线程；

dispatch_get_main_queue表示运行在主线程中的主队列；

任务2是同步线程的任务。
</code></pre>

<p>首先执行任务1，这是肯定没问题的，只是接下来，程序遇到了同步线程，那么它会进入等待，等待任务2执行完，然后执行任务3。但这是队列，有任务来，当然会将任务加到队尾，然后遵循FIFO原则执行任务。那么，现在任务2就会被加到最后，任务3排在了任务2前面，问题来了：</p>

<pre><code>任务3要等任务2执行完才能执行，任务2由排在任务3后面，意味着任务2要在任务3执行完才能执行，所以他们进入了互相等待的局面。【既然这样，那干脆就卡在这里吧】这就是死锁。
</code></pre>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-1.png" alt="deadlock" /></p>

<h2>案例二：</h2>

<pre><code>NSLog(@"1"); // 任务1

dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{

    NSLog(@"2"); // 任务2

});

NSLog(@"3"); // 任务3
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1

2

3
</code></pre>

<p>分析：</p>

<p>首先执行任务1，接下来会遇到一个同步线程，程序会进入等待。等待任务2执行完成以后，才能继续执行任务3。从dispatch_get_global_queue可以看出，任务2被加入到了全局的并行队列中，当并行队列执行完任务2以后，返回到主队列，继续执行任务3。</p>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-2.png" alt="2" /></p>

<h2>案例三：</h2>

<pre><code>dispatch_queue_t queue = dispatch_queue_create("com.demo.serialQueue", DISPATCH_QUEUE_SERIAL);

NSLog(@"1"); // 任务1

dispatch_async(queue, ^{

    NSLog(@"2"); // 任务2

    dispatch_sync(queue, ^{  

        NSLog(@"3"); // 任务3

    });

    NSLog(@"4"); // 任务4

});

NSLog(@"5"); // 任务5
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1

5

2

// 5和2的顺序不一定
</code></pre>

<p>分析：</p>

<p>这个案例没有使用系统提供的串行或并行队列，而是自己通过dispatch_queue_create函数创建了一个DISPATCH_QUEUE_SERIAL的串行队列。</p>

<pre><code>执行任务1；

遇到异步线程，将【任务2、同步线程、任务4】加入串行队列中。因为是异步线程，所以在主线程中的任务5不必等待异步线程中的所有任务完成；

因为任务5不必等待，所以2和5的输出顺序不能确定；

任务2执行完以后，遇到同步线程，这时，将任务3加入串行队列；

又因为任务4比任务3早加入串行队列，所以，任务3要等待任务4完成以后，才能执行。但是任务3所在的同步线程会阻塞，所以任务4必须等任务3执行完以后再执行。这就又陷入了无限的等待中，造成死锁。
</code></pre>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-3.png" alt="3" /></p>

<h2>案例四：</h2>

<pre><code>NSLog(@"1"); // 任务1

dispatch_async(dispatch_get_global_queue(0, 0), ^{

    NSLog(@"2"); // 任务2

    dispatch_sync(dispatch_get_main_queue(), ^{

        NSLog(@"3"); // 任务3

    });

    NSLog(@"4"); // 任务4

});

NSLog(@"5"); // 任务5
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1

2

5

3

4

// 5和2的顺序不一定
</code></pre>

<p>分析：</p>

<p>首先，将【任务1、异步线程、任务5】加入Main Queue中，异步线程中的任务是：【任务2、同步线程、任务4】。</p>

<p>所以，先执行任务1，然后将异步线程中的任务加入到Global Queue中，因为异步线程，所以任务5不用等待，结果就是2和5的输出顺序不一定。</p>

<p>然后再看异步线程中的任务执行顺序。任务2执行完以后，遇到同步线程。将同步线程中的任务加入到Main Queue中，这时加入的任务3在任务5的后面。</p>

<p>当任务3执行完以后，没有了阻塞，程序继续执行任务4。</p>

<p>从以上的分析来看，得到的几个结果：1最先执行；2和5顺序不一定；4一定在3后面。</p>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-4.png" alt="4" /></p>

<h2>案例五：</h2>

<pre><code>dispatch_async(dispatch_get_global_queue(0, 0), ^{

    NSLog(@"1"); // 任务1

    dispatch_sync(dispatch_get_main_queue(), ^{

        NSLog(@"2"); // 任务2

    });

    NSLog(@"3"); // 任务3

});

NSLog(@"4"); // 任务4

while (1) {

}

NSLog(@"5"); // 任务5
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1

4

// 1和4的顺序不一定
</code></pre>

<p>分析：</p>

<p>和上面几个案例的分析类似，先来看看都有哪些任务加入了Main Queue：【异步线程、任务4、死循环、任务5】。</p>

<p>在加入到Global Queue异步线程中的任务有：【任务1、同步线程、任务3】。</p>

<p>第一个就是异步线程，任务4不用等待，所以结果任务1和任务4顺序不一定。</p>

<p>任务4完成后，程序进入死循环，Main Queue阻塞。但是加入到Global Queue的异步线程不受影响，继续执行任务1后面的同步线程。</p>

<p>同步线程中，将任务2加入到了主线程，并且，任务3等待任务2完成以后才能执行。这时的主线程，已经被死循环阻塞了。所以任务2无法执行，当然任务3也无法执行，在死循环后的任务5也不会执行。</p>

<p>最终，只能得到1和4顺序不定的结果。</p>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-5.png" alt="5" /></p>

<h2>参考</h2>

<pre><code>http://www.jianshu.com/p/0b0d9b1f1f19

http://www.cnblogs.com/tangbinblog/p/4133481.html
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有关 XcodeGhost 的问题和解答]]></title>
    <link href="http://www.superqq.com/blog/2015/09/24/apple-xcodeghost-answer/"/>
    <updated>2015-09-24T00:09:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/09/24/apple-xcodeghost-answer</id>
    <content type="html"><![CDATA[<p><strong>我听说了由 XcodeGhost 开发的恶意 app — 这是怎么回事？</strong></p>

<p>我们一直建议开发者使用由我们提供的免费、安全的工具，包括 Xcode，从而确保他们为 App Store 的用户创造出安全的 app。一些开发者下载了已被恶意软件感染的盗版 Xcode，由此开发的 app 也同样受到感染。</p>

<p>Apple 特意使用诸如 Gatekeeper 等技术，以防止安装从非 App Store 渠道下载的应用程序，和 / 或安装包括 Xcode 在内的未签名的应用程序。当开发者为了能安装类似 XcodeGhost 等恶意程序时，这些保护措施会被刻意地禁用。</p>

<p>作为 Apple 向开发者提供的业界先进工具之一，以下措施可以确保软件未被篡改：</p>

<pre><code>Xcode app 有 Apple 的代码签名。
从 Mac App Store 下载 Xcode 时，开发者的电脑系统自动对 Xcode 的代码签名会进行检查和验证。
从 Apple Developer Program 网站下载 Xcode 时，只要 Gatekeeper 没有被禁用，默认开发者的电脑系统对 Xcode 代码签名自动进行检查和验证。
</code></pre>

<h3>为什么开发者会不顾用户的安全下载盗版软件？</h3>

<p>为了更快下载我们的开发者工具，开发者有时会从其他非 Apple 站点搜寻。</p>

<h3>这会对我有什么影响吗？如何得知我的设备是否受到了影响？</h3>

<p>我们目前没有任何信息表明这些恶意软件与任何恶意事件相关，也没有信息表明这些软件被使用在传播任何个人身份信息的用途上。</p>

<p>我们目前没有看到任何客户个人身份信息受到影响，而且代码无法通过用户身份请求来获取 iCloud 或其他服务的密码。</p>

<p>只要一经发现这些 app 有可能通过恶意代码开发，我们就对其进行下架处理。开发者们正在快速更新他们的 app，以便用户使用。</p>

<!--more-->


<p>恶意代码只能提供一些基本信息，比如 app 和一般系统信息。</p>

<h3>从 Apps Store 下载 app 是否安全？</h3>

<p>我们已将由该盗版软件开发的 apps 从 App Store 中撤下，并拦截了通过该恶意软件开发的新 app 进入 App Store。</p>

<p>我们正与开发者紧密协作，以确保受到影响的 app 尽快回到 App Store 供用户使用。</p>

<p>我们将在支持页面上列出受此影响的前 25 个 apps，方便用户验证他们是否已将这些 app 更新到了最新版本。</p>

<p>用户还将会收到更多信息，以便了解他们下载的某 app 是否会存在问题。一旦开发者更新了他们的 app，用户可以通过在设备上运行更新解决存在的问题。</p>

<p>我们正努力让中国的开发者可以用更快的速度下载 Xcode 测试版本。开发者也可以通过 developer.apple.com 列出的步骤来验证他们的 Xcode 是否被篡改过。</p>

<h2>XcodeGhost Q&amp;A</h2>

<p><strong>I’ve heard about malicious apps created by XcodeGhost — what does this mean?</strong></p>

<p>We always recommend developers using the free, secure tools we provide them — including Xcode — to ensure they’re creating the most secure apps for App Store customers. Some developers downloaded counterfeit versions of Xcode that have been infected with malware and created apps that were just as infected.</p>

<p>Apple incorporates technologies like Gatekeeper expressly to prevent non-App Store and/or unsigned versions of programs, including Xcode, from being installed. Those protections had to have been deliberately disabled by the developer for something like XcodeGhost to successfully install.</p>

<p>As part of providing developers the industry&rsquo;s most advanced tools, Apple provides developers the following checks to ensure software is untampered:</p>

<pre><code>The Xcode app is code-signed by Apple.
When you download Xcode from the Mac App Store the code signature for Xcode is automatically checked and validated by your system.
When you download Xcode from the Apple Developer Program web site, the code signature for Xcode is automatically checked and validated by your system by default as long as Gatekeeper is not disabled.
</code></pre>

<h3>Why would a developer put customers at risk by downloading counterfeit software?</h3>

<p>Sometimes developers search for our tools on other, non-Apple sites in an effort to find faster downloads of developer tools.</p>

<h3>How does this affect me? How do I know if my device has been compromised?</h3>

<p>We have no information to suggest that the malware has been used to do anything malicious or that this exploit would have delivered any personally identifiable information had it been used.</p>

<p>We’re not aware of personally identifiable customer data being impacted and the code also did not have the ability to request customer credentials to gain iCloud and other service passwords.</p>

<p>As soon as we recognized these apps were using potentially malicious code we took them down. Developers are quickly updating their apps for users.</p>

<p>Malicious code could only have been able to deliver some general information such as the apps and general system information.</p>

<h3>Is it safe for me to download apps from App Store?</h3>

<p>We have removed the apps from the App Store that we know have been created with this counterfeit software and are blocking submissions of new apps that contain this malware from entering the App Store.</p>

<p>We’re working closely with developers to get impacted apps back on the App Store as quickly as possible for customers to enjoy.</p>

<p>A list of the top 25 most popular apps impacted will be listed soon so users can easily verify if they have downloaded the latest versions of these apps. After the top 25 impacted apps, the number of impacted users drops significantly.</p>

<p>Customers will be receiving more information letting them know if they’ve downloaded an app/apps that could have been compromised. Once a developer updates their app, that will fix the issue on the user’s device once they apply that update.</p>

<p>We’re working to make it faster for developers in China to download Xcode betas. To verify that their version of Xcode has not been altered, they can take the following steps posted at &lt;developer.apple.com>.</p>

<p>文章来自：<a href="http://www.apple.com/cn/xcodeghost/">http://www.apple.com/cn/xcodeghost/</a></p>
]]></content>
  </entry>
  
</feed>
