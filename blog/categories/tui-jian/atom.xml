<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 推荐 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/tui-jian/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-08-22T00:49:39+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS开发征稿启示（打赏归作者所有）]]></title>
    <link href="http://www.superqq.com/blog/2015/08/22/development-ios-reward/"/>
    <updated>2015-08-22T00:45:26+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/22/development-ios-reward</id>
    <content type="html"><![CDATA[<h2>iOS开发订阅用户突破10000人</h2>

<p>首先，非常感谢您的支持和一路陪伴！经过一年多的发展，iOS开发（iOSDevTip）微信公众号的订阅用户越来越多，已经超过10000人。这是一件好事，也是对iOS开发公众号价值的体现。</p>

<p>这一年多的时间里，我每天都在为寻求一篇好的iOS开发文章而努力。这个过程有快乐也有艰辛。每天做一件事，说起来不难，真要坚持下来，不是那么容易的一件事情。我说这些，并不是要证明自己有多厉害。为了寻求好的文章，我会经常阅读大量的博文，上各大程序员门户网站。有时，会因为发现一篇好的文章而庆幸不已；有时，也会因为找不到文章而心里焦急。</p>

<p>后来，我建立了自己的博客<a href="http://www.superqq.com/">刚刚在线</a>：www.superqq.com 。有时间，我就会写一些技术文章分享在上面。也会把文章同步到iOS开发公众号上。</p>

<p>随着订阅用户的增多，大家对文章内容的需求也越来越高。由于我一个人的力量毕竟有限，可能无法满足所有人的需求。订阅iOS开发的用户不乏一些大牛，所以我想发动大家的力量，一起来为优质的iOS开发文章而努力。</p>

<h2>毕洪博投稿文章情况</h2>

<p>七夕那天，作者毕洪博投稿<a href="http://www.superqq.com/blog/2015/08/21/sina-animation/"> 一句代码添加新浪弹出框动画 </a>得到了不错的反响，我把主数据给大家看看：</p>

<pre><code>图文阅读：1695
原文阅读：19   
转发+收藏：193
文章发布日期：2015-08-20
评论人数：5
赞赏人数：3
赞赏金额：9元
</code></pre>

<p>从阅读量上来看，还是挺不错的。虽然赞赏金额不多吧，但也算是有一点点回报。七夕那天夜里，我找到作者毕洪博给他发了一个红包。哈哈！</p>

<p>如果您是一名iOS开发者，如果您有自己的博客，如果您喜欢分享，那就快行动吧！把您的优秀文章投稿给我，我将会把您的文章推送在iOS开发微信公众号上，分享给更多的iOS开发者。</p>

<h2>投稿方式</h2>

<pre><code>投稿邮箱：worldligang@163.com
个人微信：chinaligang
投稿格式：markdown格式
博主联盟群：364679270
</code></pre>

<p>因为微信上面不方便阅读代码，但是支持markdown语法转换。所以投稿的时候，最好是markdown格式的。投稿之后，请记得加我的个人微信，以便我将打赏的钱转账给您。如果你有自己的博客，欢迎加入博主联盟群。</p>

<h2>版权申明</h2>

<ul>
<li><p>微信公众号规定打赏必须是原创文章，所以希望您能将你的文章在微信公众平台的发表权「独家代理」iOS开发（ iOSDevTip ） 微信公众号。这样我就可以对您的文章申明原创和开通打赏功能。文章的版权依然归您所有，你可以将文章发布在你的博客、微博上。</p></li>
<li><p>为了证明我得到您的授权，您需要在您的文章底部加上如下申明：</p>

<p>  版权声明：我已将本文在微信公众平台的发表权「独家代理」给 iOS开发（ iOSDevTip ） 微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p>  <img src="http://images.90159.com/icon/iOSDevTip.jpg" alt="iOSDevTip" /></p></li>
</ul>


<p>申明markdown格式为：</p>

<pre><code>    版权声明：我已将本文在微信公众平台的发表权「独家代理」给 iOS开发（ iOSDevTip ） 微信公众号。扫下方二维码即可关注「iOS 开发」：

    ![iOSDevTip](http://images.90159.com/icon/iOSDevTip.jpg)    
</code></pre>

<p>如果对投稿有什么疑问，欢迎加我微信：chinaligang，详细了解一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一句代码添加新浪弹出框动画]]></title>
    <link href="http://www.superqq.com/blog/2015/08/21/sina-animation/"/>
    <updated>2015-08-21T11:16:07+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/21/sina-animation</id>
    <content type="html"><![CDATA[<p>新浪微博中的“加号按钮”点击后的弹出动画很有意思，每当一个人孤单寂寞冷的时候总会不停的点这个动画，终于忍不住自己撸了一个。废话不多说，直接上效果图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation1.gif" alt="演示1" /></p>

<p>首先说一下通过这个动画制作过程给大家分享的技术问题：
1.背景的毛玻璃效果
2.弹性动画
3.动画进行时对用户交互的处理
4.<code>UIControl</code> 的 <code>event</code> 类型</p>

<h2>一、背景的毛玻璃效果</h2>

<p>对新浪微博中弹出动画背景的思路分析：</p>

<p>  新浪的背景动画效果是有一个透明渐变的过程，并且最终渐变停止之后显示的是一个带有毛玻璃（半透明模糊）效果的视图。我的模仿思路是当准备要弹出动画的时候对整个视图进行截屏操作，将截屏后的图片进行毛玻璃效果渲染，然后在视图上加一个背景 <code>UIImageView</code> 来显示这张图片，然后通过 <code>alpha</code> 动画来由透明逐渐渐变出来。</p>

<h3>1.对视图进行截屏：</h3>

<pre><code>    UIGraphics BeginImageContextWithOptions(size, NO, scale);
    [view.layer renderInContext:UIGraphicsGetCurrentContext()];
    UIImage * image = UIGraphicsGetImageFromCurrentImageContext();
</code></pre>

<h3>2.截屏后加上毛玻璃效果：</h3>

<p>制作毛玻璃效果有三种选择，一是 <code>iOS8</code> 后推出的 <code>UIBlurEffect</code> 和 <code>UIVisualEffectView</code> 来直接显示一个带有毛玻璃效果的 <code>View</code> 不过这种方式并不能直接生成一张带有毛玻璃效果的图片，而且它的模糊程度设置方法非常有限只有那几个枚举类型，无法满足需求。</p>

<p>第二种是通过 <code>CoreImage</code> 添加滤镜的方式来实现毛玻璃效果，不过这种方式有个缺点如果滤镜使用频繁会对主线程产生影响，如果我不断频繁的重复动画效果就必须要做判断看滤镜是否正在起作用，否则会经常出现崩溃和内存泄漏问题。</p>

<p>第三种我们使用苹果13年 <code>WWDC</code> 上发布的官方 <code>sample</code> 一个 <code>UIImage</code> 的分类 <code>UIImage+ImageEffects.h</code> ,它不但可以制作毛玻璃效果图片，而且可以调整模糊程度和颜色渲染。下面给出代码：</p>

<pre><code>    image = [image bhb_applyBlurWithRadius:15 
                                 tintColor:tintColor 
                     saturationDeltaFactor:1 
                                 maskImage:nil];//因为OC没有命名空间，避免你的程序中使用到了这个分类导致冲突，我加了前缀
</code></pre>

<p>最终的显示效果很不错，我将模糊程度尽量的调节到与新浪微博一致了，不过在这个过程中，我发现当我频繁的进行弹出操作时，内存会不断攀升如下图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation3.png" alt="演示3" />
内存暴增的原因肯定是因为刚才的截图或者毛玻璃效果导致的，我们来用 <code>Instruments</code> 的 <code>Allocations</code> 来进行内存分析，找出元凶。
Xcode -> Product -> Profile -> Allocations， 开启之后我们来使用右下角的 <code>Mark generation</code>（内存快照功能，进一步了解请移步[这片文章][1]）
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation4.png" alt="演示4" />
在弹出 <code>View</code> 和移除 <code>View</code> 的两个时间点加 <code>Mark generation</code>。
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation5.png" alt="演示5" />
可以观察到，两个时间点竟然相差了4.31M，这是一个相当恐怖的数字，怪不得我点击几次弹出功能之后内存会暴增，让我们继续跟踪：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation6.png" alt="演示6" />
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation7.png" alt="演示7" />
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation8.png" alt="演示8" />
跟踪到最后，我们发现大部分未释放的内存来自于绘图和位图的创建，回想我们当初做的截图操作，图片上下文开启后并没有进行关闭操作，所以在程序不断截图的过程中开启了无数的图片上下文而且不会被释放，添加下面这句关键的代码就可以解决问题（NC的我竟然连这个都忘了加-.-）：</p>

<pre><code>        UIGraphicsEndImageContext();
</code></pre>

<h2>二、弹性动画</h2>

<p>新浪动画中，按钮弹出的动画为弹性效果，按钮到达最终位置后不会直接停止，而是做类似弹簧的一种阻尼运动，要实现这种动画也很简单 <code>iOS7</code> 后苹果非常给力的添加了 <code>spring</code> 弹性动画的快速创建方式：</p>

<pre><code>    [UIView animateWithDuration:(NSTimeInterval) 
                          delay:(NSTimeInterval) 
         usingSpringWithDamping:(CGFloat) 
          initialSpringVelocity:(CGFloat) 
                        options:(UIViewAnimationOptions) 
                     animations:^{} 
                     completion:^(BOOL finished) {}];
</code></pre>

<p>通过对 <code>Damping</code> 阻力和 <code>Velocity</code> 初速度的设置可以实现弹性动画动画效果如下图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/threeballs.gif" alt="摘自MotionDesign" /></p>

<p>当然实现弹性动画还可以使用[Jonathan Willing][2]大大的 <code>JNWSpringAnimation</code> ,你可以像使用 <code>CABasicAnimation</code> 一样轻松的使用它，通过改变关键的3个属性 <code>Damping</code> 阻力， <code>stiffness</code> 硬直, <code>mass</code> 质量来改变弹性动画的效果代码如下：</p>

<pre><code>    JNWSpringAnimation *scale = [JNWSpringAnimation
    animationWithKeyPath:@"transform.translation.x"];
    scale.damping = 7;
    scale.stiffness = 7;
    scale.mass = 1;

    scale.fromValue = @(0);
    scale.toValue = @(400);

    [redBall.layer addAnimation:scale forKey:scale.keyPath];
    redBall.transform = CGAffineTransformMakeTranslation(400, 0);
</code></pre>

<p>关键的三个属性对动画的影响如下图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/jnwdemo.gif" alt="摘自MotionDesign" /></p>

<p>为了减轻项目对第三方框架的依赖，我使用了 <code>iOS7</code> 原生的 <code>spring</code> 动画，如果你想要兼容以前版本，替换成 <code>JNWSpringAnimation</code> 即可。回到新浪动画的制作，动画是6个按钮按照顺序依次出现和消失，并且点击 <code>more</code> 按钮后可以向左平移到第二屏幕，并且在第二屏幕点击 <code>叉号</code> 按钮动画会加在第二屏幕的6个按钮上。
效果如图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation2.gif" alt="演示2" /></p>

<p>对此我使用了一个 <code>UIScrollView</code> 来承载这些按钮，并声明2个数组用来保存所有的按钮和正在显示的按钮（在屏幕上，并且需要做动画）:</p>

<pre><code>    @property (nonatomic,strong) NSMutableArray * visableArray;//屏幕显示的按钮数组
    @property (nonatomic,strong) NSMutableArray * itemsArray;//所有按钮的数组
</code></pre>

<p>这样我在给这些按钮加动画的时候就不会浪费性能，只把动画加在当前显示在屏幕的按钮上。动画依次按照一定的时间差来执行，解决的办法我是用的 <code>GCD</code> :</p>

<pre><code>    [self.visableArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        BHBCustomBtn * btn = obj;
        CGFloat x = btn.frame.origin.x;
        CGFloat y = btn.frame.origin.y;
        CGFloat width = btn.frame.size.width;
        CGFloat height = btn.frame.size.height;
        btn.frame = CGRectMake(x, [UIScreen mainScreen].bounds.size.height + y - self.frame.origin.y, width, height);
        btn.alpha = 0.0;
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(idx * 0.03 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:0.35 delay:0 usingSpringWithDamping:0.85 initialSpringVelocity:25 options:UIViewAnimationOptionCurveEaseIn animations:^{
                btn.alpha = 1;
                btn.frame = CGRectMake(x, y, width, height);
            } completion:^(BOOL finished) {
                if ([btn isEqual:[self.visableArray lastObject]]) {
                    self.superview.superview.userInteractionEnabled = YES;
                }
            }];
        });
    }];
</code></pre>

<p>这样按钮就会依次以弹性动画的形式弹动出来了，是不是很简单，对于动画结束后所作的处理我将在下一节中说明。</p>

<h2>三、动画进行时对用户交互的处理</h2>

<p>动画过程中，处理用户交互的问题相当关键，视图动画中默认自动停止响应用户交互，因此当按钮进行弹性动画时，触摸它并不会生成任何事件。
但是当你触摸加号按钮的时候，会再次进行弹出框动画，这时就会弹出两个弹出框，这是我们不希望看到的，我们可以将加号按钮的 <code>enable</code> 属性设置为 <code>YES</code> 但是这样做我们要在封装的视图内部获取外部的加号按钮，这一点违背了封装性原则，并不是一个好的设计。所以我在所有按钮的弹性动画开始时，设置：</p>

<pre><code>    self.superview.superview.userInteractionEnabled = NO;
</code></pre>

<p>注意视图的层级关系，我所设计的 <code>BHBPopView</code> 内部装着一个 <code>UIScrollView</code>，而它上面放着这些按钮，所以你要找到父视图的父视图才能够统一屏蔽用户的交互行为，当所有的按钮弹性动画结束时，也就是 <code>visableArray</code> 数组最后一个按钮动画结束时，我们恢复用户的交互：</p>

<pre><code>    self.superview.superview.userInteractionEnabled = YES;
</code></pre>

<p>这样当动画进行过程中，屏蔽了用户的交互，避免发生一些意外的情况。</p>

<h2>四、<code>UIControl</code> 的 <code>event</code> 类型</h2>

<p>注意到新浪动画里面按钮有一个放大效果，并且当你手指放上去的时候放大，手指稍微挪动，便恢复原始大小。让我们先来看一下动画：</p>

<p><img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation9.gif" alt="演示9" /></p>

<p>要实现这个效果只需要做一个形变动画就可以了，关键是我们如何控制它放大和恢复大小。
思路如下：按钮是继承自 <code>UIControl</code> ，<code>UIControl</code> 有不同的事件状态：</p>

<pre><code>    UIControlEventTouchDown           = 1 &lt;&lt;  0,      // 手指落在按钮的一瞬间触发
    UIControlEventTouchDownRepeat     = 1 &lt;&lt;  1,      // 多点触碰的时候，当第二根以上的手指触摸瞬间出发
    UIControlEventTouchDragInside     = 1 &lt;&lt;  2,      // 手指在视图范围内拖动触发
    UIControlEventTouchDragOutside    = 1 &lt;&lt;  3,      // 手指在视图范围外拖动触发
    UIControlEventTouchDragEnter      = 1 &lt;&lt;  4,      // 手指从视图外拖动到视图内时触发
    UIControlEventTouchDragExit       = 1 &lt;&lt;  5,      // 手指从视图内部拖动到视图外时触发
    UIControlEventTouchUpInside       = 1 &lt;&lt;  6,      // 手指在视图内部抬起时触发
    UIControlEventTouchUpOutside      = 1 &lt;&lt;  7,      // 手指在视图外部抬起时触发
    UIControlEventTouchCancel         = 1 &lt;&lt;  8,      // 取消事件，放上了太多手指或者被上锁或者电话呼叫打断。

    UIControlEventValueChanged        = 1 &lt;&lt; 12,      // 当视图的值发生改变时，发送通知。

    UIControlEventEditingDidBegin     = 1 &lt;&lt; 16,     // UITextField
    UIControlEventEditingChanged      = 1 &lt;&lt; 17,
    UIControlEventEditingDidEnd       = 1 &lt;&lt; 18,
    UIControlEventEditingDidEndOnExit = 1 &lt;&lt; 19,     // 'return key' ending editing

    UIControlEventAllTouchEvents      = 0x00000FFF,  // for touch events
    UIControlEventAllEditingEvents    = 0x000F0000,  // for UITextField
    UIControlEventApplicationReserved = 0x0F000000,  // range available for application use
    UIControlEventSystemReserved      = 0xF0000000,  // range reserved for internal framework use
    UIControlEventAllEvents           = 0xFFFFFFFF
</code></pre>

<p>我们所用到的事件是 <code>TouchDown</code> 和 <code>DragInside</code>，手指放上去触发 <code>TouchDown</code> 放大视图，在视图内部移动 <code>DragInside</code> 时恢复视图，注意按钮的作用范围是整个矩形区域包含了图片和文字，当你的手指移出图片的时候并非一定会移出按钮作用范围，所以依然会触发 <code>TouchUpInsite</code> 事件，这时候我们需要做一个属性来记录用户拖拽之后取消按钮的 <code>TouchUpInsite</code> 执行。</p>

<pre><code>    @property (nonatomic,assign) BOOL btnCanceled;
</code></pre>

<p>这样我们就可以实现动画效果了，具体代码如下：</p>

<pre><code>    //处理按钮有效的点击事件，当前按钮放大消失，其他按钮缩小消失，回调点击事件
    [btn addTarget:self action:@selector(didClickBtn:) forControlEvents:UIControlEventTouchUpInside];
    //处理手指按下事件，放大按钮
    [btn addTarget:self action:@selector(didTouchBtn:) forControlEvents:UIControlEventTouchDown];
    //处理手指拖动事件，恢复按钮大小
    [btn addTarget:self action:@selector(didCancelBtn:) forControlEvents:UIControlEventTouchDragInside];
</code></pre>

<h2>总结：</h2>

<p>制作类似新浪微博这种弹出框动画，我的思路是先分析逻辑，这些特效都由哪些组成，毛玻璃背景，加顶部一个 <code>logo</code> ，加中间 <code>UIScrollView</code>和上面的很多按钮,加底部工具条。研究透彻动画的执行顺序，动画执行结果有哪些分支。然后针对特效中的难点，比如毛玻璃，按钮弹性动画等等进行逐一研究攻破，最后将这些组件整合在一起变成一个好玩的动画，最后不要忘了动画的内存和性能测试。这次我模仿的新浪微博动画弹性效果并不是太理想，比起新浪原生来说不是特别一致，也希望有兴趣的你来给我一些建议优化它。最终在你的项目中加入我的弹出框动画真的只需要一句话哦：</p>

<pre><code>    /**
    *  直接显示一个popView在某个view上
    *
    *  @param view       父view
    *  @param imageArray 图标数组
    *  @param titles     标题数组
    *  @param block      回调
    *  @return pop视图
    */
    + (BHB_INSTANCETYPE)showToView:(UIView *)view andImages:(NSArray *)imageArray andTitles:(NSArray *)titles andSelectBlock:(DidSelectItemBlock)block;
    /**
    *  如果显示一个带more功能的，请使用此方法
    *
    *  @param view  父view
    *  @param array BHBItem类型的集合
    *  @param block 回调
    *  @return pop视图
    */
    + (BHB_INSTANCETYPE)showToView:(UIView *)view withItems:(NSArray *)array andSelectBlock:(DidSelectItemBlock)block;
</code></pre>

<p>hexo出点问题修复到下半夜啊（升级到3.0太蛋疼了），现在脑子晕晕的，明天还要去新公司入职，动画中还有很多细节我不能一一分享了，欢迎大家来搞我的<a href="https://github.com/bb-coder/BHBPopView">Demo</a></p>

<p>good luck!</p>

<p>本文由<a href="http://www.90159.com/">程序员头条</a>管理员毕洪博原创文章，转载务必注明出处。</p>

<p>版权声明：我已将本文在微信公众平台的发表权「独家代理」给 iOS开发（ iOSDevTip ） 微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://images.90159.com/icon/iOSDevTip.jpg" alt="iOSDevTip" /></p>

<p>原文链接：<a href="http://bihongbo.com/2015/08/19/sinaAnimation/">http://bihongbo.com/2015/08/19/sinaAnimation/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[环形渐变进度条实现]]></title>
    <link href="http://www.superqq.com/blog/2015/08/12/realization-circular-gradient-progress/"/>
    <updated>2015-08-12T01:12:05+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/12/realization-circular-gradient-progress</id>
    <content type="html"><![CDATA[<p>之前有人在找渐变进度条的效果，闲来无事就顺手写了一个，然后画了视图层级，方便讲解。</p>

<p>环境信息：</p>

<p>Mac OS X 10.10.3</p>

<p>Xcode 6.3.1</p>

<p>iOS 8.3</p>

<p>效果图：</p>

<p><img src="http://images.90159.com/08/result.gif" alt="1" /></p>

<p>源码下载地址：<a href="https://github.com/saitjr/LoopProgressDemo.git">LoopProgressDemo</a></p>

<p>正文</p>

<h2>一、视图层级</h2>

<p>首先需要搞定的就是视图层级关系。可以看到，</p>

<pre><code>1. 背景是有透明度的蓝色(blueView)

2. 需要一个从绿-&gt;黄-&gt;红的渐变色，那个这里我采用的是Layer(colorLayer)

3. blueView和colorLayer他们的表现状态都是环形的，所以还需要环形的遮罩

4. 蓝色的环并没有变，而渐变色的环却在时刻变化，所以需要两个遮罩，一个给蓝色(blueMaskLayer)，一个给渐变色(colorMaskLayer)
</code></pre>

<p>从上面的分析可以看出，现在需要几个变量以及他们的关系如下：</p>

<pre><code>[viewController.view addSubView:blueView];
[blueView.layer addSubLayer:colorLayer];
colorLayer.mask = colorMaskLayer;
blueView.layer.mask = blueMaskLayer;
</code></pre>

<p>视图层级图如下：</p>

<p><img src="http://images.90159.com/08/ios-implement-loop-progress-1.png" alt="1" /></p>

<h2>二、根据视图层级来实现</h2>

<p>搞清楚了层级，接着就应该逐个实现了。</p>

<ol>
<li>有透明度的蓝色视图blueView</li>
</ol>


<p>ViewController.m</p>

<p>BlueView *blueView = [[BlueView alloc] initWithFrame:CGRectMake(0, 0, 300, 300)];
blueView.center = self.view.center;
blueView.backgroundColor = [UIColor blueColor]; // 我这里没有给透明度
[self.view addSubView:blueView];</p>

<ol>
<li>渐变图层colorLayer</li>
</ol>


<p>因为系统没有提供根据路径渐变的实现方法，所以只能采用曲线救国的方式来画。那么我所使用的方法是：在左边画一个从下往上为绿->黄的渐变Layer（leftLayer），然后右边画一个从下往上为红->黄的渐变Layer（rightLayer）。</p>

<p>效果图如下：</p>

<p><img src="http://images.90159.com/08/ios-implement-loop-progress-2.png" alt="1" /></p>

<p>渐变色</p>

<p>但是这种方式效果不是很好，因为黄绿色和橘红色的分界太明显，所以最好设置一个渐变的范围。</p>

<p>效果图如下：</p>

<p><img src="http://images.90159.com/08/ios-implement-loop-progress-3.png" alt="1" /></p>

<p>设置渐变范围的渐变色</p>

<p>实现代码：</p>

<p>BlueView.m</p>

<pre><code>- (void)setupColorLayer {
    self.colorLayer = [CAShapeLayer layer];
    self.colorLayer.frame = self.bounds;
    [self.layer addSublayer:self.colorLayer];

    CAGradientLayer *leftLayer = [CAGradientLayer layer];
    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);
    // 分段设置渐变色
    leftLayer.locations = @[@0.3, @0.9, @1];
    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];
    [self.colorLayer addSublayer:leftLayer];

    CAGradientLayer *rightLayer = [CAGradientLayer layer];
    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);
    rightLayer.locations = @[@0.3, @0.9, @1];
    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];
    [self.colorLayer addSublayer:rightLayer];
}
</code></pre>

<ol>
<li>渐变图层的环形遮罩colorMaskLayer</li>
</ol>


<p>因为渐变图层环形遮罩和蓝色视图的环形遮罩样式都是一样的，所以可以将环形遮罩的创建代码封装出来：</p>

<p>BlueView.m</p>

<pre><code>- (CAShapeLayer *)generateMaskLayer {

    CAShapeLayer *layer = [CAShapeLayer layer];
    layer.frame = self.bounds;

    // 创建一个圆心为父视图中点的圆，半径为父视图宽的2/5，起始角度是从-240°到60°
    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(self.bounds.size.width / 2, self.bounds.size.height / 2) radius:self.bounds.size.width / 2.5 startAngle:-3 / 4 * M_PI endAngle:1 / 3 * M_PI clockwise:YES];
    layer.lineWidth = 20;
    layer.path = path.CGPath;
    layer.fillColor = [UIColor clearColor].CGColor; // 填充色为透明（不设置为黑色）
    layer.strokeColor = [UIColor blackColor].CGColor; // 随便设置一个边框颜色
    layer.lineCap = kCALineCapRound; // 设置线为圆角
    return layer;
}
</code></pre>

<p>设置渐变色环形遮罩层</p>

<p>BlueView.m</p>

<pre><code>- (void)setupColorMaskLayer {

    CAShapeLayer *layer = [self generateMaskLayer];
    layer.lineWidth = 20.5; // 渐变遮罩线宽较大，防止蓝色遮罩有边露出来
    self.colorLayer.mask = layer;

    self.colorMaskLayer = [CAShapeLayer layer];
    self.colorMaskLayer = layer;
}
</code></pre>

<ol>
<li>blueView的环形遮罩blueMaskLayer</li>
</ol>


<p>BlueView.m</p>

<pre><code>- (void)setupBlueMaskLayer {

    CAShapeLayer *layer = [self generateMaskLayer];
    self.layer.mask = layer;
    self.blueMaskLayer = layer;
}
</code></pre>

<ol>
<li>设置百分比</li>
</ol>


<p>设置渐变色所占的百分比，其实就是改变colorMaskLayer的范围，系统提供了一个方法可以直接根据百分比来修改。</p>

<pre><code>self.colorMaskLayer.strokeEnd = 0.5;
</code></pre>

<p>到此，整个效果就已经完成了，接下来说一下回弹动画。</p>

<h2>三、设置回弹动画</h2>

<p>我所使用的是pop库中的POPSpringAnimation，这个效果比较Q弹，加在进度条上刚好。要加动画，只需要把上面的修改strokeEnd的代码换成一下方法就可以了：</p>

<pre><code>- (void)animationWithStrokeEnd:(CGFloat)strokeEnd {

    POPSpringAnimation *strokeAnimation = [POPSpringAnimation animationWithPropertyNamed:kPOPShapeLayerStrokeEnd];
    strokeAnimation.toValue = @(strokeEnd);
    strokeAnimation.springBounciness = 12.f;
    strokeAnimation.removedOnCompletion = NO;
    [self.colorMaskLayer pop_addAnimation:strokeAnimation forKey:@"layerStrokeAnimation"];
}
</code></pre>

<p>来源：<a href="http://www.brighttj.com/ios/ios-implement-loop-progress.html">http://www.brighttj.com/ios/ios-implement-loop-progress.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[彩色TabBar切换动画实现]]></title>
    <link href="http://www.superqq.com/blog/2015/08/11/color-tabbar-switch-animation/"/>
    <updated>2015-08-11T00:38:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/11/color-tabbar-switch-animation</id>
    <content type="html"><![CDATA[<p>无意间看到一个彩色TabBar切换的设计图，感觉很不错，有空就把他实现了。
环境信息
Mac OS X 10.10.4
Xcode 6.4
iOS 8.4
效果图：</p>

<p><img src="http://images.90159.com/08/1.1TabBar-1.gif" alt="1.1TabBar-1.gif" /></p>

<p>源码下载地址：
<a href="https://github.com/saitjr/TColorfulTabBar.git">https://github.com/saitjr/TColorfulTabBar.git</a></p>

<h2>一、实现分析</h2>

<p>看到这个彩色切换效果的时候，我第一个反应就是在TabBar上有一个彩色的View，然后每个色块的显示都是通过mask来显示的。最终，我的具体实现也是根据这个思路来的。</p>

<h4>1. 设计思想</h4>

<p>为了减少侵入性（耦合），我采取的是继承UITabBar来实现，所以要集成的时候，只需要将系统的TabBar换成我写的TColorfulTabBar就可以了。</p>

<p><img src="http://images.90159.com/08/1.2TabBar-2.png" alt="1.2TabBar-2.png" /></p>

<h4>2. 视图层级图</h4>

<h2>二、效果实现</h2>

<h4>1. 添加彩色视图colorfulView</h4>

<p>TColorfulTabBar.m</p>

<pre><code>- (void)setupColorView {

    // 初始化彩色视图，并将它加在tabbar上
    UIView *colorView = [[UIView alloc] initWithFrame:self.bounds];
    [self addSubview:colorView];
    self.colorfulView = colorView;

    // 彩色视图的五种颜色，这是一个UIColor数组，
    NSArray *colors = self.itemColors;
    CGFloat itemWidth = self.bounds.size.width / self.itemCount;

    for (int i = 0; i &lt; self.itemCount; i ++) {

        UIView *view = [[UIView alloc] initWithFrame:CGRectMake(itemWidth * i, 0, itemWidth, self.bounds.size.height)]; 
        view.backgroundColor = colors[i]; 
        [self.colorfulView addSubview:view]; 
    } 
}
</code></pre>

<h4>2. 添加彩色视图的遮罩colorfulMaskView</h4>

<p>之所以这里的遮罩使用的是UIView而不是CAShapeLayer或者CALayer，原因如下：</p>

<ul>
<li>遮罩是矩形，没必要使用路径，所以不用CAShapeLayer</li>
<li>通过设计图可以看到，在位移动画之前，有一个遮罩单向变宽（向左或向右）的效果。如果使用CALayer，那么改变bounds的时候，是双向改变，想要单向就必须加锚点，太麻烦</li>
<li>如果使用UIView，那么向右变宽只需要x不变，width变长就行；向左变宽只需要x-value，width+value就行，要方便的多</li>
<li>最后一点就是在做动画的时候，Layer要用到CABaseAnimation，然而UIView使用UIView的Animation就行</li>
</ul>


<p>在设置遮罩的时候，将colorfulMaskView的layer设置为colorfulView的mask就可以了。
代码实现如下：
TColorfulTabBar.m</p>

<pre><code>- (void)setupMaskLayer {

    // 获取每个item的宽度
    CGFloat itemWidth = self.bounds.size.width / self.itemCount;

    // 初始化colorMaskView，并将colorMaskView的layer设置成彩色视图的遮罩
    UIView *colorMaskView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, itemWidth, self.bounds.size.height)];
    colorMaskView.backgroundColor = [UIColor blackColor];
    self.colorfulMaskView = colorMaskView;
    self.colorfulView.layer.mask = self.colorfulMaskView.layer;
}
</code></pre>

<h4>3. 设置代理，获取当前点击的下标</h4>

<p>UITabBar并没有获取点击下标的接口，但是UITabBarDelegate有，这个协议默认被UITabBarController遵守。为了降低耦合性，采用UITabBar自己获取下标，所以，需要UITabBar自己实现自己的delegate。
<strong>值得注意的是，不能在UITabBar的初始化方法中去设置self.delegate = self，因为即使设置了，也会被UITabBarController覆盖。最终解决方案是当UITabBar加载到父视图上是，在修改delegate为self。</strong></p>

<pre><code>- (void)didMoveToSuperview {
    [super didMoveToSuperview];
    self.delegate = self;
}
</code></pre>

<p>因为每次的移动位置与方向都和上次的下标与这次的下标有关，所以需要使用到属性来记录这两个下标的值。
    - (void)tabBar:(UITabBar <em>)tabBar didSelectItem:(UITabBarItem </em>)item {</p>

<pre><code>    NSInteger index = [self.items indexOfObject:item];
    self.fromeIndex = self.toIndex;
    self.toIndex = index;
    // 拿到下标以后执行动画
    [self animation];
}
</code></pre>

<h4>4. 移动遮罩，显示不同的色块</h4>

<p>在做动画的时候，需要考虑到效果的平滑性。整个动画有两个动画组成，一个是宽度放大的动画，一个是缩小到原来大小和位移动画。整个动画是EaseInOut的效果，所以拆开来看，就应该第一个动画EaseIn，第二个动画EaseOut。
一图胜千言：</p>

<p><img src="http://images.90159.com/08/1.3TabBar-3.png" alt="1.3TabBar-3.png" /></p>

<pre><code>- (void)animation {

    CGFloat itemWidth = self.bounds.size.width / self.itemCount;
    // 为了效果看起来更平滑，所以根据两次下标的差值来计算需要放大的距离
    CGFloat extraWidth = ABS(self.toIndex - self.fromeIndex) * itemWidth / 4;

    // 放大的大小
    CGRect scaleFrame = CGRectMake(self.colorfulMaskView.x, 0, itemWidth + extraWidth, self.bounds.size.height);
    // 最终大的大小与位置
    CGRect toFrame = CGRectMake(self.toIndex * itemWidth, 0, itemWidth, self.bounds.size.height);

    // 如果是向左移动，那修改x轴的坐标
    if (self.fromeIndex &gt; self.toIndex) {

        scaleFrame = CGRectMake(self.colorfulMaskView.x - extraWidth, 0, itemWidth + extraWidth, self.bounds.size.height);
    }

    // 两个动画加起来是一个EaseInOut的效果，所以第一个动画就应该是EaseIn，第二个动画是EaseOut
    // 先进行放大
    [UIView animateWithDuration:ANIMATION_DURATION delay:0 options:UIViewAnimationOptionCurveEaseIn animations:^{

        self.colorfulMaskView.frame = scaleFrame;
    } completion:^(BOOL finished) {

        // 再进行缩小和位移
        [UIView animateWithDuration:ANIMATION_DURATION delay:0 options:UIViewAnimationOptionCurveEaseOut animations:^{

            self.colorfulMaskView.frame = toFrame;
        } completion:NULL];
    }];
}
</code></pre>

<p>原文:<a href="http://www.brighttj.com/ios/ios-colorful-tabbar-implement.html">http://www.brighttj.com/ios/ios-colorful-tabbar-implement.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一次对MKMapView的性能优化]]></title>
    <link href="http://www.superqq.com/blog/2015/08/09/performance-optimization-of-mkmapview/"/>
    <updated>2015-08-09T13:18:21+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/09/performance-optimization-of-mkmapview</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近做的项目主要是LBS这块 主打成员定位功能 我们的UI设计是这样的</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-1.png" alt="Pic-MK-1" /></p>

<p>乍一看上去是挺好挺美观的 不同的人会显示不同的头像 可是当人扎堆的时候 问题就来了</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-2.png" alt="Pic-MK-2" /></p>

<p>当人多的时候(例如上图所示) 地图滑动起来就能感觉到明显顿卡 那种不流畅感能折磨死人 所以 自然我们要解决这个问题(等等 先不要吐槽为什么不用地图聚合 因为这已经是地图放到最大了 聚合不适合这次的问题讨论)</p>

<h2>分析</h2>

<p>首先看下我是怎么实现这个annotationView的 由于这个annotationsView是异形的(也就是无法通过设置圆角直接得到) 而且里面的图片还因用户而异 所以解决方案就是使用layer.mask来进行遮罩 代码如下</p>

<pre><code>@implementation MMAnnotationView

- (instancetype)initWithAnnotation:(id&lt;MKAnnotation&gt;)annotation reuseIdentifier:(NSString *)reuseIdentifier
{
    self = [super initWithAnnotation:annotation reuseIdentifier:reuseIdentifier];
    if ( self )
    {
        self.frame = CGRectMake(0, 0, TRACK_ANNOTATION_SIZE.width, TRACK_ANNOTATION_SIZE.height);
        self.centerOffset = CGPointMake(0, -(TRACK_ANNOTATION_SIZE.height-3)/2);
        self.canShowCallout = NO;

        self.avatarView = [[UIImageView alloc] initWithFrame:self.bounds];
        [self addSubview:self.avatarView];
        self.avatarView.contentMode = UIViewContentModeScaleAspectFill;

        CAShapeLayer *shapelayer = [CAShapeLayer layer];
        shapelayer.frame = self.bounds;
        shapelayer.path = self.framePath.CGPath;
        self.avatarView.layer.mask = shapelayer;

        self.layer.shadowPath = self.framePath.CGPath;
        self.layer.shadowRadius = 1.0f;
        self.layer.shadowColor = [UIColor colorWithHex:0x666666FF].CGColor;
        self.layer.shadowOpacity = 1.0f;
        self.layer.shadowOffset = CGSizeMake(0, 0);
        self.layer.masksToBounds = NO;
    }
    return self;
}

//mask路径
- (UIBezierPath *)framePath
{
    if ( !_framePath )
    {
        CGFloat arrowWidth = 14;

        CGMutablePathRef path = CGPathCreateMutable();

        CGRect rectangle = CGRectInset(CGRectMake(0, 0, CGRectGetWidth(self.bounds), CGRectGetWidth(self.bounds)), 3,3);

        CGPoint p[3] = {
        {CGRectGetMidX(self.bounds)-arrowWidth/2, CGRectGetWidth(self.bounds)-6},
        {CGRectGetMidX(self.bounds)+arrowWidth/2, CGRectGetWidth(self.bounds)-6},
        {CGRectGetMidX(self.bounds), CGRectGetHeight(self.bounds)-4}
        };

        CGPathAddRoundedRect(path, NULL, rectangle, 5, 5);
        CGPathAddLines(path, NULL, p, 3);

        CGPathCloseSubpath(path);

        _framePath = [UIBezierPath bezierPathWithCGPath:path];

        CGPathRelease(path);
    }

    return _framePath;
}
</code></pre>

<p>我用代码生成了形状路径 并以此生成了layer的mask和shadowPath
使用时 只要直接用SDWebImage设置头像就行了</p>

<pre><code>[annotationView.avatarView sd_setImageWithURL:[NSURL URLWithString:avatarURL] placeholderImage:placeHolderImage];
</code></pre>

<p>接下来用工具分析一下问题出来哪 分析性能当然是选择Instrments(用法在这里就不做介绍了) 打开Core Animation 然后运行程序 滑动地图 可以看到性能分析如下</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-3.jpg" alt="Pic-MK-3" /></p>

<p>原来平均帧数只有不到30帧 这离我们的目标60帧差得实在太远</p>

<p>再使用Debug Option来深入分析一下</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-4.png" alt="Pic-MK-4" /></p>

<p>由于MKMapView的原因 这里我们主要关心这几个选项</p>

<ul>
<li>Color Blended Layers</li>
<li>Color Misaligned Images</li>
<li>Color Offscreen-Rendered Yellow</li>
</ul>


<p>分别打开这几个选项 结果如下</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-5.png" alt="Pic-MK-5" /></p>

<p>可以看到</p>

<ul>
<li>Color Blended Layers没有问题 不过这也是正常的 由于使用了mask 没有透明的地方</li>
<li>Color Misaligned Images除了默认头像外全中 这是因为服务器上的图片大小跟显示的大小不一致 导致缩放 而默认头像则是一致的 所以没问题</li>
<li>Color Offscreen-Rendered Yellow全中 由于使用了mask 导致大量的离屏渲染 这也是性能下降的主要原因</li>
</ul>


<h2>解决</h2>

<p>问题的原因找到了 那么接下来该如何解决呢?</p>

<ul>
<li>首先mask是肯定不能用了</li>
<li><p>其次下载下来的图片我们要预处理成实际大小
那么 直接把下载下来的图片合成为我们要显示的最终结果不就ok了吗? 试试看</p>

<pre><code>  - (void)loadAnnotationImageWithURL:(NSString*)url imageView:(UIImageView*)imageView
  {
      //将合成后的图片缓存起来
      NSString *annoImageURL = url;
      NSString *annoImageCacheURL = [annoImageURL stringByAppendingString:@"cache"];

      UIImage *cacheImage = [[SDImageCache sharedImageCache] imageFromDiskCacheForKey:annoImageCacheURL];
      if ( cacheImage )
      {
          //LLLog(@"hit cache");
          imageView.image = cacheImage;
      }
      else
      {
          //LLLog(@"no cache");
          [imageView sd_setImageWithURL:[NSURL URLWithString:annoImageURL]
          placeholderImage:placeHolderImage
          completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {
          if (!error)
          {
              UIImage *annoImage = [image annotationImage];
              imageView.image = annoImage;

              [[SDImageCache sharedImageCache] storeImage:annoImage forKey:annoImageCacheURL];
              }
          }];
      }
  }

  @implementation UIImage (LJC)
  - (UIImage*) annotationImage
  {
      static UIView *snapshotView = nil;
      static UIImageView *imageView = nil;

      if ( !snapshotView )
      {
          snapshotView = [UIView new];
          snapshotView.frame = CGRectMake(0, 0, TRACK_ANNOTATION_SIZE.width, TRACK_ANNOTATION_SIZE.height);

          imageView = [UIImageView new];
          [snapshotView addSubview:imageView];
          imageView.clipsToBounds = YES;
          imageView.frame = snapshotView.bounds;
          imageView.contentMode = UIViewContentModeScaleAspectFill;

          CGFloat arrowWidth = 14;

          CGMutablePathRef path = CGPathCreateMutable();

          CGRect rectangle = CGRectInset(CGRectMake(0, 0, CGRectGetWidth(imageView.bounds), CGRectGetWidth(imageView.bounds)), 3,3);

          CGPoint p[3] = {
              {CGRectGetMidX(imageView.bounds)-arrowWidth/2, CGRectGetWidth(imageView.bounds)-6},
              {CGRectGetMidX(imageView.bounds)+arrowWidth/2, CGRectGetWidth(imageView.bounds)-6},
              {CGRectGetMidX(imageView.bounds), CGRectGetHeight(imageView.bounds)-4}
          };

          CGPathAddRoundedRect(path, NULL, rectangle, 5, 5);
          CGPathAddLines(path, NULL, p, 3);

          CGPathCloseSubpath(path);

          CAShapeLayer *shapelayer = [CAShapeLayer layer];
          shapelayer.frame = imageView.bounds;
          shapelayer.path = path;

          imageView.layer.mask = shapelayer;

          snapshotView.layer.shadowPath = path;
          snapshotView.layer.shadowRadius = 1.0f;
          snapshotView.layer.shadowColor = [UIColor colorWithHex:0x666666FF].CGColor;
          snapshotView.layer.shadowOpacity = 1.0f;
          snapshotView.layer.shadowOffset = CGSizeMake(0, 0);

          CGPathRelease(path);
      }

      imageView.image = self;

      UIGraphicsBeginImageContextWithOptions(TRACK_ANNOTATION_SIZE, NO, 0);

      [snapshotView.layer renderInContext:UIGraphicsGetCurrentContext()];

      UIImage *copied = UIGraphicsGetImageFromCurrentImageContext();
      UIGraphicsEndImageContext();

      return copied;
  }
  @end
</code></pre></li>
</ul>


<p>然后使用的时候 只要简单的如下调用就OK了</p>

<pre><code>[self loadAnnotationImageWithURL:avatarURL imageView:annotationView.avatarView];
</code></pre>

<p>看看修改之后的Instruments表现如何</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-6.png" alt="Pic-MK-6" /></p>

<ul>
<li>Color Blended Layers全中 这也是无可避免的 因为显示的就是一张带透明度的图 但是由于地图的特殊性(头像的位置变化间隔较长 所以不会经常引发合成 也没有动画) 所以这里也不是问题</li>
<li>Color Misaligned Images没问题了 因为头像已被缩放成了相同大小</li>
<li>Color Offscreen-Rendered Yellow没问题了 因为只是简单的显示了一张图片 而并没有需要离屏渲染的东西了</li>
</ul>


<p>再来看下帧数情况</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-7.jpg" alt="Pic-MK-7" /></p>

<p>Oh-Yeah~ 不光帧数达到了我们的目标60帧(由于还有业务逻辑线程在后台跑 所以没有那么的稳定) 就连平均运行耗时都下降了不少 就算地图上再多显示几十个人 也不成问题了</p>

<p>原文连接：<a href="http://adad184.com/2015/07/13/improve-performance-with-mkmapview/">http://adad184.com/2015/07/13/improve-performance-with-mkmapview/</a></p>
]]></content>
  </entry>
  
</feed>
