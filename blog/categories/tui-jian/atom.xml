<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 推荐 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/tui-jian/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2016-03-08T21:36:05+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C和Swift混编的一些经验]]></title>
    <link href="http://www.superqq.com/blog/2016/03/07/objective-c-swift-study/"/>
    <updated>2016-03-07T22:38:41+08:00</updated>
    <id>http://www.superqq.com/blog/2016/03/07/objective-c-swift-study</id>
    <content type="html"><![CDATA[<blockquote><p>阿里云iOS客户端2.1.0版本中开始尝试使用Swift来写新的业务，磕磕绊绊总算是发布了新版，总结一下开发过程中得到的经验和踩过的坑吧。</p></blockquote>

<h2>CocoaPods</h2>

<p>使用Swift作为主要的开发语言，很难避免引入Swift编写的库。2.1.0版本引入了SwiftyJSON和Charts这两个Swift写的库，分别用于处理JSON数据和画监控图。</p>

<p>苹果要求使用Swift写的库，必须通过动态链接库引入，其实这一点我也是不太理解的，因为静态库也是可以依赖动态库的符号的，不存在导入多个Swift动态库的问题。允许App使用自带的动态库从iOS8才开始支持，因此必须将App支持的iOS版本升到iOS8。阿里云iOS客户端iOS7的用户不到4%，所以放弃了对iOS7的支持。</p>

<p>Cocoapods支持将依赖的组件编译成动态库，只需要在Podfile顶部加上&#8221;use_frameworks!&ldquo;。开启这个选项之后，所有以源码引入的pod都会编译成动态链接库，而以fake framework引入的pod仍然会编译到主App里面。动态库都放在App里面的Frameworks目录，可以看到Swift相关的动态库也都拷贝进来了，所以支持Swift会导致包变大。我没有记下2.0.0版本的大小，导致没法对比2.1.0放大了多少，这是一个失误。</p>

<pre><code>[~/Library/Developer/Xcode/Archives/2015-12-17/CloudConsoleApp 15-12-17 下午9.24.xcarchive/Products/Applications/CloudConsoleApp.app/Frameworks]$ tree
.
├── Charts.framework
│   ├── Charts
│   ├── Info.plist
│   └── _CodeSignature
│       └── CodeResources
├── EAIntroView.framework
│   ├── EAIntroView
│   ├── Info.plist
│   └── _CodeSignature
│       └── CodeResources
├── FMDB.framework
│   ├── FMDB
│   ├── Info.plist
│   └── _CodeSignature
│       └── CodeResources
├── FTCoreText.framework
│   ├── FTCoreText
│   ├── Info.plist
│   └── _CodeSignature
│       └── CodeResources
├── JSBadgeView.framework
│   ├── Info.plist
│   ├── JSBadgeView
│   ├── JSBadgeView.bundle
│   └── _CodeSignature
│       └── CodeResources
├── MBProgressHUD.framework
│   ├── Info.plist
│   ├── MBProgressHUD
│   └── _CodeSignature
│       └── CodeResources
├── MFSideMenu.framework
│   ├── Info.plist
│   ├── MFSideMenu
│   └── _CodeSignature
│       └── CodeResources
├── PFormanceKit.framework
│   ├── Info.plist
│   ├── PFormanceKit
│   └── _CodeSignature
│       └── CodeResources
├── Reachability.framework
│   ├── Info.plist
│   ├── Reachability
│   └── _CodeSignature
│       └── CodeResources
├── RegexKitLite.framework
│   ├── Info.plist
│   ├── RegexKitLite
│   └── _CodeSignature
│       └── CodeResources
├── SSZipArchive.framework
│   ├── Info.plist
│   ├── SSZipArchive
│   └── _CodeSignature
│       └── CodeResources
├── SnapKit.framework
│   ├── Info.plist
│   ├── SnapKit
│   └── _CodeSignature
│       └── CodeResources
├── SwiftyJSON.framework
│   ├── Info.plist
│   ├── SwiftyJSON
│   └── _CodeSignature
│       └── CodeResources
├── libswiftContacts.dylib
├── libswiftCore.dylib
├── libswiftCoreData.dylib
├── libswiftCoreGraphics.dylib
├── libswiftCoreImage.dylib
├── libswiftDarwin.dylib
├── libswiftDispatch.dylib
├── libswiftFoundation.dylib
├── libswiftObjectiveC.dylib
└── libswiftUIKit.dylib

27 directories, 49 files

$ file Charts 
Charts: Mach-O universal binary with 2 architectures
Charts (for architecture armv7):    Mach-O dynamically linked shared library arm
Charts (for architecture arm64):    Mach-O 64-bit dynamically linked shared library
</code></pre>

<p>因为fake framework和源代码pod分别会编译成静态库和动态库，这样会导致一个问题，就是如果源码pod又依赖fake framework，那就没办法了。CocoaPods发现这种情况会提示下面这个错误。</p>

<pre><code>target has transitive dependencies that include static binaries: (xxx.framework, xxx.framework)
</code></pre>

<p>pod install时会把静态库编译到App里面，源码编译成的动态库没法依赖它。最终的解决方案只能是CocoaPods对fake framework和源码pod一视同仁，都编译成动态库，这样彼此才能依赖。不知道CocoaPods什么时候会支持这样。</p>

<h2>混编</h2>

<ul>
<li>Swift使用Objective-C</li>
</ul>


<p>这种情况占绝大多数。只需要在CloudConsoleApp-Bridging-Header.h这个头文件中包含相关的头文件就行。pod组件另外一种引入的方式是通过@import引入。比如SDWebImage可以通过下面两种方式引入。</p>

<pre><code>//在Bridging头文件包含下面这个头文件
#import &lt;SDWebImage/UIImageView+WebCache.h&gt;

//另外一种办法，在Swift文件中引入。
import SDWebImage
</code></pre>

<p>Objective-C写的类和方法都会被改成Swift的使用方式，下面是两个很典型的例子。使用的时候需要尝试一下才能找到翻译的Swift方法。</p>

<pre><code>//Objective-C
titleLabel.lineBreakMode = NSLineBreakByWordWrapping;
titleLabel.numberOfLines = 0;

//Swift
cell.nameLabel?.lineBreakMode = .ByWordWrapping //全写是 NSLineBreakMode.ByWordWrapping
cell.nameLabel?.numberOfLines = 0

//Objective-C
UIImage *image = [UIImage imageNamed:@"abc"];

//Swift
let image = UIImage(named: "abc")
</code></pre>

<ul>
<li>Objective-C使用Swift</li>
</ul>


<p>Xcode会生成一个虚拟的头文件CloudConsoleApp-Swift.h，在工程里面是找不到这个头文件的，但是可以包含，并且跳转进去。这个文件里面包含了所有从Swift导出来的符号，比如下面这个view controller就是用Swift写的。可以看出来Objectivew-C看到的名称跟Swift源码里面的名称是一样的，但是Swift会对类做demangling，变成了_TtC15CloudConsoleApp31YWSResourceDetailViewController这样的，跟C++有点类似。</p>

<pre><code>SWIFT_CLASS("_TtC15CloudConsoleApp31YWSResourceDetailViewController")
@interface YWSResourceDetailViewController : UIPageViewController
@property (nonatomic, strong) NSArray * __nonnull vcs;
@property (nonatomic, copy) NSString * __null_unspecified pluginId;
@property (nonatomic, strong) YWSSegmentedControl * __nonnull segmentedControl;
@property (nonatomic, strong) YWSInstanceListViewController * __nonnull instanceListViewController;
@property (nonatomic, strong) YWSMetricConcernedViewController * __nonnull metricConcernedViewController;
@property (nonatomic, weak) IBOutlet UIBarButtonItem * __null_unspecified addMetricBarButton;
- (void)viewDidLoad;
- (void)initSegmentedControl;
- (void)indexChanged:(id __nonnull)sender;
- (void)onNavigationBack:(id __nonnull)sender;
- (void)prepareForSegue:(UIStoryboardSegue * __nonnull)segue sender:(id __nullable)sender;
- (nonnull instancetype)initWithTransitionStyle:(UIPageViewControllerTransitionStyle)style navigationOrientation:(UIPageViewControllerNavigationOrientation)navigationOrientation options:(NSDictionary&lt;NSString *, id&gt; * __nullable)options OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * __nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end
</code></pre>

<h2>Swift的优缺点</h2>

<p>这个项目刚起步，用Swift的经验尚浅，所以都是一些比较浅薄的理解，后面有更深刻的理解再补上。</p>

<h3>优点</h3>

<ul>
<li>代码简洁。类的声明和实现在一个文件中。</li>
<li>统一对属性和方法的调用，都用.。</li>
<li>如果不加额外的访问控制，所有的符号都是整个项目可见，无需考虑头文件的问题。</li>
<li><p>字符串处理太方便了。</p>

<p>  //字符串比较和拼接实在是太方便了
  let foo = &ldquo;abc&rdquo;
  let bar = &ldquo;abc&rdquo;</p>

<p>  if foo == bar {
      //blablabla
  }</p>

<p>  print(&ldquo;====(foo)+(bar)&rdquo;)</p></li>
<li><p>语言上支持延迟加载。</p>

<p>  lazy var imageView : UIImageView = {
      var imageView = UIImageView(image: UIImage(named: &ldquo;empty_hint&rdquo;))
      imageView.contentMode = .ScaleAspectFit</p>

<pre><code>  return imageView
</code></pre>

<p>  }()</p>

<p>  lazy var infoLabel : UILabel = {
      var infoLabel = UILabel()
      infoLabel.lineBreakMode = .ByWordWrapping //支持换行
      infoLabel.numberOfLines = 0</p>

<pre><code>  return infoLabel
</code></pre>

<p>  }()</p>

<p>  lazy var button : UIButton = {
      var button = UIButton()
      button.titleLabel?.font = UIFont.systemFontOfSize(15)
      button.setTitleColor(UIColor.darkGrayColor(), forState: .Normal)
      button.setBackgroundImage(UIImage(named: &ldquo;buy_instance_hint_button&rdquo;), forState: .Normal)
      button.hidden = true</p>

<pre><code>  return button
</code></pre>

<p>  }()</p></li>
<li><p>多返回值。比如下面这个函数，如果使用Objective-C写还是比较麻烦的。</p>

<p>  //将 &ldquo;创建中&amp;#FA8C35&rdquo; 翻译成对应的 &ldquo;(字符串对象, 颜色对象)&rdquo;
  func YWSTranslateRichText (str : String) -> (text : String, color : UIColor) {
      let statusArray = str.componentsSeparatedByString(&ldquo;&amp;&rdquo;)</p>

<pre><code>  if statusArray.count == 0 {
      return ("", UIColor.lightGrayColor())
  }

  if statusArray.count == 1 {
      return (statusArray[0], UIColor.lightGrayColor())
  }

  return (statusArray[0], UIColor.fromHexString(statusArray[1]))
</code></pre>

<p>  }</p>

<p>  //使用方式如下
  let (text, color) = YWSTranslateRichText(instanceStatusConf)</p></li>
<li><p>支持字符串作为枚举值。</p>

<p>  enum YWSECSInstanceStatus : String {
      case Starting = &ldquo;Starting&rdquo;
      case Running = &ldquo;Running&rdquo;
      case Stopping = &ldquo;Stopping&rdquo;
      case Stopped = &ldquo;Stopped&rdquo;
  }</p>

<p>  //使用方法
  cell.ECSInstanceStatus = YWSECSInstanceStatus(rawValue: instanceStatus!)</p>

<p>  //转换成字符串
  textDetailLabel.text = YWSECSInstanceStatus.Starting.rawValue</p></li>
<li><p>selector类型实现了 StringLiteralConvertible，使用起来更加简单。</p>

<p>  self.button.addTarget(self, action: &ldquo;introduceResources:&rdquo;, forControlEvents: .TouchUpInside)</p></li>
<li><p>不再需要引入libextobjc这个Pod，因为Swift支持更方便的用法。在block开始的时候，在数组里面weak所有要用到的对象。</p>

<p>  inputViewController.finishBlock = { [weak inputViewController, weak cell, weak self] () -> Void in
  }</p></li>
<li><p>函数支持默认参数。比如下面这个函数，有五个参数，其中三个有默认参数，用户需要设置的参数只有两个。</p>

<p>  convenience init(text: String, textColor: UIColor = UIColor.whiteColor(), bgColor: UIColor, font: UIFont = UIFont.systemFontOfSize(10), inset: UIEdgeInsets = UIEdgeInsetsMake(0, 3, 0, 3)) {
      //blabla
  }</p>

<p>  lazy var vipLabel : YWSInsetsTextLabel! = YWSInsetsTextLabel(text: &ldquo;vip&rdquo;, bgColor: UIColor.orangeColor())</p></li>
<li><p>通过减少动态性，使用vtable替换原有的objc_msgSend，获取更高的性能。新增了final、private等关键字，编译器可以对代码做更多优化，提升性能并减少内存的使用。比如final方法不用放入虚表中，节省内存；跳转时不用查表，性能更佳；private的类如果发现有方法只在本文件中使用，可以直接内联，提高性能。</p></li>
<li><p>在Playground工程里面练习Swift编程非常之方便，尤其是测试VFL语句的时候。</p></li>
</ul>


<p><img src="http://upload-images.jianshu.io/upload_images/1376176-76d2627719e67fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<h2>缺点</h2>

<ul>
<li>Optional让人头疼，大量的?和!，没处理好很容易导致崩溃。</li>
<li>强类型和Optional，给JSON解释带来了灾难。</li>
<li><p>目前Xcode不支持对Swift写的代码做重构。</p></li>
<li><p>Build Settings里面设置Treat Warnings as Errors对Swift代码无效。</p></li>
</ul>


<h2>坑</h2>

<p>用private修饰的类，如果使用KVC来给属性设置值，编译不会报错，运行时也不会报错，但就是设置不上。去掉private就好了。</p>

<h2>crash分析</h2>

<p>手解crash可以看到具体崩溃代码的行号。</p>

<pre><code>$ symbolicatecrash ~/Downloads/034dc058c5d4ff1f717ec7a05d4d55b8 CloudConsoleApp.app.dSYM

Exception Type:  SIGTRAP
Exception Codes: #0 at 0x1001c09b4
Crashed Thread:  0

Thread 0 Crashed:
0   CloudConsoleApp                     0x00000001001c09b4 YWSInstanceListViewController.goToBuyPage() -&gt; () (YWSInstanceListViewController.swift:701)
1   CloudConsoleApp                     0x00000001001c92cc specialized YWSInstanceListViewController.introduceResources(AnyObject) -&gt; () (YWSInstanceListViewController.swift:689)
2   CloudConsoleApp                     0x00000001001c029c @objc YWSInstanceListViewController.introduceResources(AnyObject) -&gt; () (YWSInstanceListViewController.swift:0)
3   UIKit                               0x000000018601be50 0x185fd0000 + 310864
4   UIKit                               0x000000018601bdcc 0x185fd0000 + 310732
5   UIKit                               0x0000000186003a88 0x185fd0000 + 211592
6   UIKit                               0x000000018601b6e4 0x185fd0000 + 308964
7   UIKit                               0x000000018601b314 0x185fd0000 + 307988
8   UIKit                               0x0000000186013e30 0x185fd0000 + 278064
9   UIKit                               0x0000000185fe44cc 0x185fd0000 + 83148
10  UIKit                               0x0000000185fe2794 0x185fd0000 + 75668
11  CoreFoundation                      0x00000001812a8efc 0x1811cc000 + 904956
12  CoreFoundation                      0x00000001812a8990 0x1811cc000 + 903568
13  CoreFoundation                      0x00000001812a6690 0x1811cc000 + 894608
14  CoreFoundation                      0x00000001811d5680 0x1811cc000 + 38528
15  GraphicsServices                    0x00000001826e4088 0x1826d8000 + 49288
16  UIKit                               0x000000018604cd90 0x185fd0000 + 511376
17  CloudConsoleApp                     0x000000010014b4e0 main (main.m:16)
18  libdyld.dylib                       0x0000000180d768b8 0x180d74000 + 10424

//不过我对着这行代码分析了好久，实在想不出来崩溃的原因。没有任何crash提示信息。
//这个版本Swift代码只有这样一个crash
//后面再看看新crash会不会也是这样
self.resourceType = YWSXXX.shareInstance().getXXXByXXX(self.XXX.pluginId)
</code></pre>

<p>实际证明Swift的crash信息非常不准确，能知道崩溃的文件和函数，行号不准确，也不会输出Application Specific Information。比如下面这个crash。</p>

<pre><code>Incident Identifier: 54087A46-D37D-454B-9305-22ED5420B58B
CrashReporter Key:   TODO
Hardware Model:      iPhone6,2
Process:             CloudConsoleApp [696]
Path:                /var/mobile/Containers/Bundle/Application/E8E24C8B-A47B-425E-863F-A871F273FCA2/CloudConsoleApp.app/CloudConsoleApp
Identifier:          com.aliyun.wstudio.amc.AliyunMobileApp
Version:             2.2.0 (2169)
Code Type:           ARM-64
Parent Process:      ??? [1]

Date/Time:           2016-01-25 10:44:56 +0000
OS Version:          iPhone OS 9.2.1 (13D15)
Report Version:      104

Exception Type:  SIGTRAP
Exception Codes: #0 at 0x100139e80
Triggered by Thread:  0

Thread 0 Crashed:
0   CloudConsoleApp                 0x0000000100139e80 __TFC15CloudConsoleApp24YWSTouchIDViewController14viewWillAppearfS0_FSbT_ (in CloudConsoleApp) + 1304
1   CloudConsoleApp                 0x0000000100139eb0 __TToFC15CloudConsoleApp24YWSTouchIDViewController14viewWillAppearfS0_FSbT_ (in CloudConsoleApp) + 44
2   UIKit                           0x000000018722c74c 0x0000000187200000 + 182092
3   UIKit                           0x000000018722c4c0 0x0000000187200000 + 181440
4   UIKit                           0x00000001872d3130 0x0000000187200000 + 864560
5   UIKit                           0x00000001872d2a6c 0x0000000187200000 + 862828
6   UIKit                           0x00000001872d2694 0x0000000187200000 + 861844
7   UIKit                           0x00000001872d25fc 0x0000000187200000 + 861692
8   UIKit                           0x000000018720f778 0x0000000187200000 + 63352
9   QuartzCore                      0x0000000184c1eb2c 0x0000000184c10000 + 60204
10  QuartzCore                      0x0000000184c19738 0x0000000184c10000 + 38712
11  QuartzCore                      0x0000000184c195f8 0x0000000184c10000 + 38392
12  QuartzCore                      0x0000000184c18c94 0x0000000184c10000 + 35988
13  QuartzCore                      0x0000000184c189dc 0x0000000184c10000 + 35292
14  QuartzCore                      0x0000000184c120cc 0x0000000184c10000 + 8396
15  CoreFoundation                  0x00000001824d8588 0x00000001823fc000 + 902536
16  CoreFoundation                  0x00000001824d632c 0x00000001823fc000 + 893740
17  CoreFoundation                  0x00000001824d675c 0x00000001823fc000 + 894812
18  CoreFoundation                  0x0000000182405680 0x00000001823fc000 + 38528
19  GraphicsServices                0x0000000183914088 0x0000000183908000 + 49288
20  UIKit                           0x000000018727cd90 0x0000000187200000 + 511376
21  CloudConsoleApp                 0x000000010007f988 main (in CloudConsoleApp) (main.m:16)
22  libdyld.dylib                   0x0000000181fa68b8 0x0000000181fa4000 + 10424

//确实崩溃在viewWillAppear函数中，但是是97行的 as! 导致的，在crash信息里面这两个重要的信息没有暴露出来。
override func viewWillAppear(animated: Bool) {
    super.viewWillAppear(animated)

    //let urlString = YWSXXX.sharedInstance().get("userIcon") as! String

    //因为2.1.0重构过登录模块，新的登录模块才会保存 userIcon 这个值
    //所以2.2.0覆盖2.1.0之前的版本用 as! 会崩溃，这里改成 as? 了
    if let urlString = YWSXXX.sharedInstance().get("userIcon") as? String {
    }
}
</code></pre>

<h2>总结</h2>

<p>Swift 2.1版本已经非常稳定，苹果将其开源，也表明对Swift的质量和可靠性有足够的信心。开源社区开始涌现一批优秀的Swift库，比如Charts，这个画图的组件很不错。StackOverflow的答案中很多人会同时提供Objective-C和Swift两个版本。目前来看唯一美中不足的问题就是解出来的crash没有Objective-C那么直观了，很多时候都得靠猜。</p>

<pre><code>文／阿呆少爷（简书作者）
原文链接：http://www.jianshu.com/p/a5e6e574145b
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[女程序员做了个梦，众网友的神回复]]></title>
    <link href="http://www.superqq.com/blog/2016/03/01/female-coder-dream-reply/"/>
    <updated>2016-03-01T23:16:18+08:00</updated>
    <id>http://www.superqq.com/blog/2016/03/01/female-coder-dream-reply</id>
    <content type="html"><![CDATA[<p>女程序员发的一条微博：</p>

<p>“昨晚梦见男朋友和别的女人在逛街，梦里我的第一反应就是查源代码，结果调试半天查不出来为什么显示的那个女人不是我，最后含泪把那个女人注释掉了，再一运行就是我男朋友自己逛街了。”
众网友的神回复：</p>

<p>1、把那个女人的指针指向你即可； (:з」∠)</p>

<p>2、谁让你把男朋友设成public的？；Σ(っ °Д °;)っ</p>

<p>3、加个断点看看那女人是谁； (ಡωಡ)</p>

<p>4、心真软，就应该把他的接口屏蔽掉； (눈_눈)</p>

<p>5、Protected逛街(youOnly)； (ง•̀_•́)ง</p>

<p>6、设计问题，应该采用单例模式； (๑•́ωก̀๑)</p>

<p>7、没做回归测试； ヽ( ￣д￣;)ノ</p>

<p>8、标准做法是做个断言； (๑•̀ㅂ•́) ✧</p>

<p>9、注释掉了，逛街的参数不用改吗？； (＠￣ー￣＠)</p>

<p>10、最后含泪把那个女人给注释掉了，再一运行就是我男朋友自己逛街了—>很明显是变量名作用域的问题，改个名就行了(๑•̀ㅂ•́) ✧</p>

<p>11、还可以有个多线程的算法，把你的优先级设成99，一个idle线程的优先级设成50，把那个女人的优先级设成49。酱紫就永远都调度不到啦 (๑•́ωก̀๑)</p>

<p>12、那也没关系，那就老调用那个女人。。。你BF放在那里不动。。。养着 (ಡωಡ)</p>

<p>13、上绝招，用goto，做个死循环，让他们逛死 (๑•̀ㅂ•́) ✧</p>

<p>14、善心点，别goto了，调用exit函数结束进程吧，冤冤相报何时了啊 ヽ( ￣д￣;)ノ</p>

<p>15、查一下Log，仅仅只有逛街吗？ԅ(¯ㅂ¯ԅ)</p>

<pre><code>来自：http://www.wtoutiao.com/p/Xa51bf.html
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XMPP客户端登录开发详解]]></title>
    <link href="http://www.superqq.com/blog/2016/01/31/xmpp-client-login-dev/"/>
    <updated>2016-01-31T20:28:20+08:00</updated>
    <id>http://www.superqq.com/blog/2016/01/31/xmpp-client-login-dev</id>
    <content type="html"><![CDATA[<p>由上篇文章将了如何在MAC本地搭建一个Openfire服务器，今天我们就要着手使用 XMPPFramework来开发 基于XMPP 协议的即时通讯IOS 客户端系统。今天主要看登录功能开发，可能有人会质疑，我们都没有开发注册功能，怎么开发登录功能。注册账号我们有捷径，服务器都在本地，当然很好做了。另外就是通过MAC 自带的客户端 Messages 进行注册。</p>

<p>首先，我们需要搭建起来IOS 的工程，并且将XMPPFramework 引入到我们的工程中来,当然我们可以使用源码 直接导入，也可以使用cocoapods来进行依赖。本文直接使用源码来进行开发。由于在Github上的源码有一些问题，所以大家可以来<a href="https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient/ThirdTools/XMPPFrameworkio">https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient/ThirdTools/XMPPFrameworkio</a>下载相关的XMPPFramework相关的代码。</p>

<p>下载关于XMPPFramework的代码之后,我们需要做的是 创建一个工程，然后将源代码导入到我们的工程中去。当然直接导入并且编译会出现libxml找不到的问题。我们需要在工程中导入libxml2.tbd(ios 9之后的名称) 以及 libresolv.9.tbd(ios 9之后的后缀)。然后在Build Setting的Head search 中加上 头文件的链接地址</p>

<pre><code>${SDKROOT}/usr/include/libxml2
</code></pre>

<p>这之后，重新编译工程即可编译成功。后面，我们需要做的就是开发登录功能了，在开始之前，我们还是先看一下怎么注册一个账号吧；登录Openfire后台，创建一个用户。</p>

<p>通过在浏览器中输入 (前提 是 openfire服务器以及mysql服务器都已经启动了)</p>

<pre><code>127.0.0.1:9090     
</code></pre>

<p>进入如下界面</p>

<p><img src="http://images.90159.com/1601/1.png" alt="1" /></p>

<p>点击左上角用户/组 进入用户管理界面</p>

<p><img src="http://images.90159.com/1601/2.png" alt="2" /></p>

<p>然后点击 左侧 导航栏中的新建用户 填写好用户信息就可以了。</p>

<p><img src="http://images.90159.com/1601/3.png" alt="3" /></p>

<p>到这边基本上用户注册环节 已经结束了。</p>

<p>开发 登录功能，基本上包括 登录界面的开发、XMPP登录逻辑的开发。登录界面我们可以 随便搭建一个登录界面就可以了。我今天主要是说一下 XMPP登录部分。</p>

<p>首先，创建关于XMPPLoginManager类，实现XMPPStreamDelegate，我定义了自己的一个宏，表示使用的Openfire服务器的地址 以及 端口号</p>

<pre><code>#define LocalOpenfire 1

#if LocalOpenfire

#define HOST_NAME @"127.0.0.1"
#define HOST_PORT 5222
#define CONNECT_IDENTIFIER @"@"

#endif

#define TIME_OUT 20
</code></pre>

<p>然后 定义XMPPStream、XMPPReconnect实例，并且初始化</p>

<pre><code>- (void)initXMPPStream {
    self.loginXmppStream = [[XMPPStream alloc] init];
    [self.loginXmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];
}

- (void)initXMPPReconnect {
    self.loginReconnectManager = [[XMPPReconnect alloc] init];
    [self.loginReconnectManager activate:self.loginXmppStream];
    // You can also optionally add delegates to the module.
    [self.loginReconnectManager addDelegate:self delegateQueue:dispatch_get_main_queue()];
}
</code></pre>

<p>定义 Login按钮点击之后的点击事件调用 XMPPLoginManager中的如下方法进行连接：</p>

<pre><code>#pragma mark -- connect xmpp method for login viewController
- (void)connectXMPPServer:(NSString *)userName password:(NSString *)password {
    self.userName = userName;
    self.password = password;

    NSString *myJid = [NSString stringWithFormat:@"%@%@%@", userName, CONNECT_IDENTIFIER, HOST_NAME];
    self.loginXmppStream.myJID = [XMPPJID jidWithString:myJid];

    self.loginXmppStream.hostName = HOST_NAME;
    self.loginXmppStream.hostPort = HOST_PORT;

    NSError *connectError = nil;
    [self.loginXmppStream connectWithTimeout:TIME_OUT error:&amp;connectError];

    if (connectError) {
        NSLog(@"%@", connectError);
        [self.loginDelegate loginXMPPConnectError:connectError];
    }
}
</code></pre>

<p>后面就是处理XMPPStream的各种回调就可以了</p>

<pre><code>#pragma mark -- xmppstream delegate
//连接xmpp成功之后,使用密码认证
- (void)xmppStreamDidConnect:(XMPPStream *)sender {

    NSError *authError = nil;
    [self.loginXmppStream authenticateWithPassword:self.password error:&amp;authError];

    if (authError) {
        NSLog(@"%@", authError);
        [self.loginDelegate loginXMPPDidNotAuthenticate];
    }
}

//认证通过之后的处理
- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender {
    NSLog(@"%@", @"认证通过");
    [self.loginDelegate loginXMPPDidAuthenticate];
}

//连接服务器的超时处理
- (void)xmppStreamConnectDidTimeout:(XMPPStream *)sender {
    NSLog(@"连接超时");
    [self.loginDelegate loginXMPPConnectDidTimeout];
}

//认证没有通过处理
- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(DDXMLElement *)error {
    NSLog(@"认证失败");
    [self.loginDelegate loginXMPPDidNotAuthenticate];
}
</code></pre>

<p>基本上这样就可以登录了，登录成功之后，可以跳转到相应的界面。提一下我们 能看到的XMPP交互流程 包括：</p>

<p>1、XMPP 使用用户名去连接服务器；</p>

<p>2、XMPP 连接成功之后，通过密码去服务器认证</p>

<p>3、认证成功之后，处理自己想处理的一下事情。</p>

<p>但其实XMPP 报文交互包括好几步，我就从别人那边摘录一点交互细节过来，就不自己一个个的抓包看了。</p>

<pre><code>C1: 客户端初始化流给服务器 

&lt;stream:stream to="127.0.0.1" xmlns="jabber:client" 
xmlns:stream="http://etherx.jabber.org/streams" version="1.0"&gt; S1: 服务器向客户端发送流标签作为应答: 
&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;stream:stream 
xmlns:stream="http://etherx.jabber.org/streams" xmlns="jabber:client" from="192.168.1.185" id="fb0cfcad" xml:lang="en" version="1.0"&gt; 

S2: 发送 STARTTLS范围 

&lt;stream:features&gt; 
&lt;starttls xmlns="urn:ietf:params:xml:ns: xmpp-tls"&gt;&lt;/starttls&gt; &lt;mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt; 
&lt;mechanism&gt;PLAIN&lt;/mechanism&gt; &lt;mechanism&gt;CRAM-MD5&lt;/mechanism&gt; &lt;mechanism&gt;ANONYMOUS&lt;/mechanism&gt; &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt; &lt;mechanism&gt;JIVE-SHAREDSECRET&lt;/mechanism&gt; &lt;/mechanisms&gt; 
&lt;compression xmlns="http://jabber.org/features/compress"&gt; 
&lt;method&gt;zlib&lt;/method&gt; &lt;/compression&gt; 
&lt;auth xmlns="http://jabber.org/features/iq-auth"/&gt; 
&lt;register xmlns="http://jabber.org/features/iq-register"/&gt; &lt;/stream:features&gt;  

C2:客户端发送 STARTTLS 命令给服务器: 

&lt;starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt; 

S3:服务器通知客户端可以继续进行: 

&lt;proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt; 

C3：TLS 握手成功, 客户端初始化一个新的流给服务器

&lt;stream:stream to="192.168.1.185" xmlns="jabber:client" 
xmlns:stream="http://etherx.jabber.org/streams" version="1.0"&gt;  

S4：服务器通知客户端可用的验证机制: 

&lt;?xml version='1.0' encoding='UTF-8'?&gt; 
&lt;stream:stream xmlns:stream="http://etherx.jabber.org/streams" 
xmlns="jabber:client" from="192.168.1.185" id="ad6f53e8" xml:lang="en" version="1.0"&gt; &lt;stream:features&gt; 
&lt;mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt; &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt; &lt;mechanism&gt;PLAIN&lt;/mechanism&gt; 
&lt;mechanism&gt;ANONYMOUS&lt;/mechanism&gt; &lt;mechanism&gt;CRAM-MD5&lt;/mechanism&gt; &lt;/mechanisms&gt; 
&lt;compression xmlns="http://jabber.org/features/compress"&gt; &lt;method&gt;zlib&lt;/method&gt; &lt;/compression&gt; 
&lt;auth xmlns="http://jabber.org/features/iq-auth"/&gt; 
&lt;register xmlns="http://jabber.org/features/iq-register"/&gt; &lt;/stream:features&gt; 

C4: 客户端选择一个验证机制: 

&lt;auth mechanism="DIGEST-MD5" xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;&lt;/auth&gt; 

S5:服务器发送一个 [BASE64] 编码的挑战给客户端: 

&lt;challenge xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;cmVhbG09IjE5Mi4xNjguMS4xODUiLG5vbmNlPSJlcEJaZlBxU1p0WGlLYzBqdGpwT0I1a01HMHdiY0hsUmNhOE52ZE9SIixxb3A9ImF1dGgiLGNoYXJzZXQ9dXRmLTgsYWxnb3JpdGhtPW1kNS1zZXNz&lt;/challenge&gt;  C5:客户端发送一个[BASE64]编码的回应这个挑战: 
&lt;response xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;Y2hhcnNldD11dGYtOCx1c2VybmFtZT0iYWRtaW4iLHJlYWxtPSIxOTIuMTY4LjEuMTg1Iixub25jZT0iZXBCWmZQcVNadFhpS2MwanRqcE9CNWtNRzB3YmNIbFJjYThOdmRPUiIsbmM9MDAwMDAwMDEsY25vbmNlPSJMNDJ1SE1XK2piemh6N1hzdWRndHN1V1VIT2hNZmFLVUJpcU5iR1p2IixkaWdlc3QtdXJpPSJ4bXBwLzE5Mi4xNjguMS4xODUiLG1heGJ1Zj02NTUzNixyZXNwb25zZT1hN2JhMWZlOThiMDc2ZjUzZWUzNTczM2Q5NDMwODJlYSxxb3A9YXV0aCxhdXRoemlkPSJhZG1pbiI=&lt;/response&gt; 

S6:服务器通知客户端验证成功 

&lt;success xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;cnNwYXV0aD0yNDZlZDcyOTQ3ZjVhYzFiNWQ2ZDc4ZTkxM2QzMmFjMQ==&lt;/success&gt; 

C6客户端初始化一个新流给服务器： 

&lt;stream:stream to="192.168.1.185" xmlns="jabber:client" 
xmlns:stream="http://etherx.jabber.org/streams" version="1.0"&gt;
</code></pre>

<p>基本上XMPP的登录细节就已经清楚了。后面我们看一下 注册相关的模块 以及 联系人请求模块的开发。如果想获取源码的话，请转到<a href="https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient">https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient</a></p>

<pre><code>本文作者：Terry 专注于技术开发；打滚于IOS 技术领域，偶尔也会迈出脚步探索其他领域
地址：http://www.terrylmay.com/terrylmay.github.io/2016/01/31/XMPP%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%99%BB%E5%BD%95%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[半年的iOS代码生活]]></title>
    <link href="http://www.superqq.com/blog/2015/12/10/ios-code-life-half-year/"/>
    <updated>2015-12-10T21:16:24+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/10/ios-code-life-half-year</id>
    <content type="html"><![CDATA[<p>在高考大军中拼杀过，也在大学校园中荒芜过，曾经低迷消沉，也常满怀壮志…… 但是最多的还是被称为小伙子以及自称为iOS工程师！博主就是这种喜闻乐见的这类人，实习一年后在2015年的毕业季顺利拿到了自己向往的一家创业公司的offer，也许相比很多毕业季的同学职场上顺利许多，但当深夜来临，显示器熄灭后望着荧幕出神的时候，毕业季我错过了很多也许一辈子都不会再相见的同学们的合影。半年里真正领略到了企业项目的开发的艰辛，以及团队协作的魅力，有太多太多的要说，终将其汇成一句话：哥加班半年后终于回来了！</p>

<p><img src="http://daiweilai.github.io/img/post/2015-11-11-pic1.png" alt="1" /></p>

<p>半年时间，反正撸啊撸段位已经是万劫不复了，iOS9一发布加班的觉悟早有了，潜伏的XCodeGhost也被拎出来了，各种被脱裤的同行大佬们也是尿了一地，哥也被吓了一哆嗦，赶忙修改了1024的账号密码…… 2015年就是伴随这些琐事发展着，但是博主作为一个初入职场半年的工作总结当然不会是简单地流水账。</p>

<p>我知道你们都惦记着什么是1024，1024就是，呵呵，就是一款妈妈都说好玩的游戏啊~。</p>

<h2>学习</h2>

<pre><code>干挨踢的学会学习远比你死背一个功能的代码来的有用。
</code></pre>

<p>在iOS学习中去尝试体会Cocoa模式，多留意Cocoa中的框架的类，他们的命名都有规范，相似抽象的对象会有相似的方法或者写法，比如：Mutable的类可能都有addXX、appendXX方法，Set、Array类型的类可能都会有enumerateXX的遍历方法……，又比如一个类的功能如果注重过程的话，苹果会选择使用delegate的方式，注重结果的话则会使用block ，学会总结比较、触类旁通、举一反三！</p>

<p>如果你能做到对Cocoa模式很熟悉的话，那么最新的3DTouch功能直接看类的头文件就会用了。</p>

<p>并且，第三方优秀的、热门的库都会遵循这一套编写规范，所以使用起来或者修改起来也才能够游刃有余！除了<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>之流除外。。</p>

<pre><code>学习时候看一本书远没有敲一个项目来的有效果。
</code></pre>

<p>看书的时候总是会犯一个毛病，就是一看就懂，一写就懵。所以学习技术，我更推荐的是实践检真知！敲出来的代码才是学习到的，因为你在电脑前，你遇到不懂的你可以立刻Google，看到感兴趣的新类可以直接option+左键查看文档或者command+左键直接摆出头文件一览无遗！</p>

<p>当然<a href="https://developer.apple.com/wwdc/">WWDC</a>别忘了看看，这是iOS最前沿的技术教学，即使听不懂也没关系，把音频外放，同事问你：哇，你听得懂呀。你微微一笑答道：听不懂。留下认真聆听却似享受的一道背影给同事，那可是满满的逼格。。呵呵，其实不然，视频中有大量PPT，有关键字，拿出来Google一番，再敲打一番，肯定你心中会觉得不虚此举哈，这样也锻炼了英文水平，这样的一波绝逼不亏呀。</p>

<p>说到英文，这个是技术进阶的基础，不要畏惧，刚开始看一篇英文文档可能花费你一天的时间，但是这才是第一手资料！国内译者的水平毕竟参差不齐，谬误在所难免，而且二手的资料，对于充满处女情结的你能接受么？能忍么？所以百度还是用来搜搜绯闻、床照之流就好，技术索引真不是它的强项，搜出来的东西都是deprecated的，实在浪费感情。</p>

<p><a href="http://nshipster.com/">NSHipster</a>、<a href="https://www.objc.io/">Objc.io</a> ……都是不错的去处，大量的紧巴巴的干货，他们都有中文版，但是最新的资料的中文版还是会相对滞后。</p>

<p>再一个就是大婶们的博客，一天不读都浑身难受！</p>

<p>之前拜阅<a href="http://blog.devtang.com/">唐巧Boy</a>的新书的时候，有一个博客列表非常不错，强势插入我的Feedly列表，我自己也有一些关注的大婶也加入了列表当中，这里给出分享OPML拿去玩。</p>

<p>沙龙、研讨什么的可以适当参加，看看荧幕外的世界，不要老说没有搞iOS的姑娘。</p>

<h2>团队</h2>

<p>讲一个故事：从前有个产品经理，他修改了3次需求，第二天他死了。</p>

<p>博主只想说的是，若不是博主心慈，我想我公司的产品经理已经死完后投胎又死一百次了。</p>

<p>我们都知道项目完成的水平直接由团队中是否有高效的协作而决定，也许有很多程序员长期的孤高冷艳惯了，他们说自己不需要团队！自己一个人就可以搞定一切，自己是UI、UE、产品、编码、测试甚至后端一条龙拿下，但是你将没有女朋友！！！</p>

<p>团队协作远比个人的英雄主义更有魅力，个人认为！</p>

<p>当下的快速迭代的大环境下，企业级开发下英雄主义是不太可取也不太可行的，所以融入团队，学会交流是工作顺利进展的保证；</p>

<p>当然团队协作中是否高效是否愉快就需要交流技巧了，每个人都有自恋的情节，即使是自己的工作技能也是如此，所以世界上存在着各种鄙视链</p>

<p><img src="http://daiweilai.github.io/img/post/2015-11-11-pic2.jpg" alt="2" /></p>

<p>举一个简单地例子吧</p>

<p>公司常见撕逼的三个部门：研发部、产品部、市场部</p>

<p>研发的看不起产品、市场，觉得他们都不懂技术，只是天马行空，遇到Bug还大惊小怪……</p>

<p>产品的觉得自己的设计是天才的设定，参考了社会伦理学，色彩心理学，严格的人体工学设计……反驳自己的都是傻逼……</p>

<p>市场的觉得自己深入客户，自己才是最了解这个产品市场的，所产品应该按自己的市场为导向，颜色不对，字体客户肯定不喜欢，改改改……</p>

<p>在排除消极因素，投机倒把的极个别人存在，团队中的成员还是希望共同的目标能够完美的实现的，也就是说其实我们的“争吵”也是为了更好的产品，但是“争吵”的度确实很难把握，难免就因为工作却伤了私下的感情，这也是离职中众多原因之一，频繁的离职却会使得你的职业生涯成长增加时间成本，所以更好的工作方式是“学会交流”。</p>

<p>“学会交流”不单单是工作中用到，这也是我们的一生的学问！</p>

<p>例如有时候，产品部门不是很负责任的频繁变更需求，这可苦了研发的成员，你便可以玩笑似的给他讲一个故事：从前有个产品经理，他修改了3次需求……，我想这样的诙谐即会是的工作氛围愉悦许多也可能让产品的同事知道自己不负责任行为的影响。</p>

<p>但是需求变更，这个是研发一直要面对课题，所以你必须学会“预置性开发”，预置性包括使用一些优秀的设计模式的使用降低模块间的耦合，增加系统维护的灵活性，也可以有类似Placeholder的编码技巧，来随时应对不期而遇的需求变更，具体的做法，这也许需要另开一篇博文来讲述。</p>

<h2>健康</h2>

<p>如果还没有升职加薪，当上总经理，出任CTO，迎娶白富美，走向人生巅峰。却出师未捷身先死，这个都不太好玩，身边的同事以及博主自己都有或多或少的职业病产生了，博主躬亲力行地验证了一个道理：樯橹灰飞烟灭！别说撸代码还真的很带感，根本停不下来，所以最后颈椎，肩膀就是各种不适。说多都是泪，不过后来博主秉承了国人”先污染后治理”的方针，总算把身子调过来了，秘笈如下：</p>

<ul>
<li>练此功，不强制自宫</li>
<li>好吧，这才是第一条，”不可久坐”x循环3次！！很重要，久坐流入脑子的血液会增加，从而造成下肢浮肿。由于久坐只限于局部肌肉活动，缺乏全身较大肌群动作，时间一长，久不动作的肌肉会逐步萎缩，机能衰退，还会使心、肺的后备能力降低，不能适应肌肉活动对血液循环和氧气供应的要求，一动就会心跳气急。肌肉长期不活动，热量消耗少，会加重脂肪和糖的代谢障碍，导致身体过分肥胖、动脉硬化及糖尿病。而且久坐一般皮肤质量较差，长时间静坐，受压血液流通不畅，易引起臂部瘙痒和隐痛，伏案工作者更甚，长期下去易导致颈椎炎，肩周炎，腰椎突出，脊柱变弯……我编不下去了，就问你怕不怕！！！所以多起身活动往非技术部走走，不然就会生病的哟(认不出雌性生物了)。</li>
<li>坐姿</li>
</ul>


<p><img src="http://daiweilai.github.io/img/post/2015-11-11-pic3.jpg" alt="3" /></p>

<ul>
<li>尝试全键盘操作，多记记几个快捷键世界就安静了，反正博主的magic mouse干电池已扣，什么你的是最新款的鼠标没干电池？那为了你的健康着想拿给博主用吧，可减少手腕以及肩膀劳损的风险。这里分享一个Mac屏幕效率工具SizeUp 可减少鼠标的使用！</li>
<li>运动运动运动！不要在被人黑了，老是被黑码农，油头垢面，肾虚患者……有意思么？我们是改变世界的工程师！不要再穿拖鞋上班了！！大家薪水都不低，穿得体面点吧。你可以和博主一样帅的。</li>
<li>努力陪伴回你身边一直陪伴着你的人，那使你的精神最远是最佳的状态！什么？那就多打打电话给你妈妈吧，那是最美的人。</li>
</ul>


<h2>追求</h2>

<p>不要担心30岁要转行，不要认为30K就是终点，不要一天工作30个小时。保持初心。</p>

<pre><code>O ever youthful,O ever weeping.
</code></pre>

<h2>后记</h2>

<p>博主新开了一个博客系统，托管在了Github.io上，喜闻乐见的Jekll加借鉴<del>(抄袭)</del>的精美主题构建而成，反正样子应该还看得过去，如果有朋友有兴趣想了解iOS程序员为何日撸万行代码？数百奇巧淫技如何施展？无数干货为何频频送出？究竟编译器背后又隐藏着什么？这一切的背后是技术与生活的碰撞还是高效与投机的权衡？我真TM编不下去了，欢迎前往 [任意门]围观。</p>

<p>严肃地，如果你刚开始学习iOS开发或许可以从博主这里得到一些半干货。</p>

<p>生活愉快！</p>

<blockquote><p>来自戴伟来的投稿</p>

<p>博客地址：<a href="http://daiweilai.github.io/">http://daiweilai.github.io/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于启用 HTTPS 的一些经验分享]]></title>
    <link href="http://www.superqq.com/blog/2015/12/08/some-experiences-https/"/>
    <updated>2015-12-08T21:54:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/08/some-experiences-https</id>
    <content type="html"><![CDATA[<p><img src="http://images.90159.com/12/https.jpg" alt="https" /></p>

<p>随着国内网络环境的持续恶化，各种篡改和劫持层出不穷，越来越多的网站选择了全站 HTTPS。HTTPS 通过 TLS 层和证书机制提供了内容加密、身份认证和数据完整性三大功能，可以有效防止数据被查看或篡改，以及防止中间人冒充。本文分享一些启用 HTTPS 过程中的经验，重点是如何与一些新出的安全规范配合使用。至于 HTTPS 的部署及优化，之前写过很多，本文不重复了。</p>

<h2>理解 Mixed Content</h2>

<p>HTTPS 网页中加载的 HTTP 资源被称之为 Mixed Content(混合内容)，不同浏览器对 Mixed Content 有不一样的处理规则。</p>

<h2>早期的 IE</h2>

<p>早期的 IE 在发现 Mixed Content 请求时，会弹出「是否只查看安全传送的网页内容?」这样一个模态对话框，一旦用户选择「是」，所有 Mixed Content 资源都不会加载;选择「否」，所有资源都加载。</p>

<h2>比较新的 IE</h2>

<p>比较新的 IE 将模态对话框改为页面底部的提示条，没有之前那么干扰用户。而且默认会加载图片类 Mixed Content，其它如 JavaScript、CSS 等资源还是会根据用户选择来决定是否加载。</p>

<h2>现代浏览器</h2>

<p>现代浏览器(Chrome、Firefox、Safari、Microsoft Edge)，基本上都遵守了 W3C 的 Mixed Content 规范，将 Mixed Content 分为Optionally-blockable 和 Blockable 两类：</p>

<p>Optionally-blockable 类 Mixed Content 包含那些危险较小，即使被中间人篡改也无大碍的资源。现代浏览器默认会加载这类资源，同时会在控制台打印警告信息。这类资源包括：</p>

<pre><code>通过  标签加载的图片(包括 SVG 图片);

通过 &lt;img&gt; 标签加载的图片（包括 SVG 图片）；

通过 &lt;video&gt; / &lt;audio&gt; 和 &lt;source&gt; 标签加载的视频或音频；

预读的（Prefetched）资源；
</code></pre>

<h2>预读的(Prefetched)资源;</h2>

<p>除此之外所有的 Mixed Content 都是 Blockable，浏览器必须禁止加载这类资源。所以现代浏览器中，对于 HTTPS 页面中的 JavaScript、CSS 等 HTTP 资源，一律不加载，直接在控制台打印错误信息。</p>

<h2>移动浏览器</h2>

<p>前面所说都是桌面浏览器的行为，移动端情况比较复杂，当前大部分移动浏览器默认都允许加载 Mixed Content。也就是说，对于移动浏览器来说，HTTPS 中的 HTTP 资源，无论是图片还是 JavaScript、CSS，默认都会加载。</p>

<p>一般选择了全站 HTTPS，就要避免出现 Mixed Content，页面所有资源请求都走 HTTPS 协议才能保证所有平台所有浏览器下都没有问题。</p>

<h2>合理使用 CSP</h2>

<p>CSP，全称是 Content Security Policy，它有非常多的指令，用来实现各种各样与页面内容安全相关的功能。</p>

<pre><code>block-all-mixed-content
</code></pre>

<p>前面说过，对于 HTTPS 中的图片等 Optionally-blockable 类 HTTP 资源，现代浏览器默认会加载。图片类资源被劫持，通常不会有太大的问题，但也有一些风险，例如很多网页按钮是用图片实现的，中间人把这些图片改掉，也会干扰用户使用。</p>

<p>通过 CSP 的 block-all-mixed-content 指令，可以让页面进入对混合内容的严格检测(Strict Mixed Content Checking)模式。在这种模式下，所有非 HTTPS 资源都不允许加载。跟其它所有 CSP 规则一样，可以通过以下两种方式启用这个指令：</p>

<h2>HTTP 响应头方式：</h2>

<pre><code>Content-Security-Policy: block-all-mixed-content 
</code></pre>

<p><meta>标签方式：</p>

<pre><code>&lt;meta http-equiv="Content-Security-Policy" content="block-all-mixed-content"&gt; 


upgrade-insecure-requests
</code></pre>

<p>历史悠久的大站在往 HTTPS 迁移的过程中，工作量往往非常巨大，尤其是将所有资源都替换为 HTTPS 这一步，很容易产生疏漏。即使所有代码都确认没有问题，很可能某些从数据库读取的字段中还存在 HTTP 链接。</p>

<p>而通过 upgrade-insecure-requests 这个 CSP 指令，可以让浏览器帮忙做这个转换。启用这个策略后，有两个变化：</p>

<pre><code>页面所有 HTTP 资源，会被替换为 HTTPS 地址再发起请求;

页面所有站内链接，点击后会被替换为 HTTPS 地址再跳转;
</code></pre>

<p>跟其它所有 CSP 规则一样，这个指令也有两种方式来启用，具体格式请参考上一节。需要注意的是 upgrade-insecure-requests 只替换协议部分，所以只适用于 HTTP/HTTPS 域名和路径完全一致的场景。</p>

<h2>合理使用 HSTS</h2>

<p>在网站全站 HTTPS 后，如果用户手动敲入网站的 HTTP 地址，或者从其它地方点击了网站的 HTTP 链接，依赖于服务端 301/302 跳转才能使用 HTTPS 服务。而第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>

<h2>HSTS 基本使用</h2>

<p>这个问题可以通过 HSTS(HTTP Strict Transport Security，RFC6797)来解决。HSTS 是一个响应头，格式如下：</p>

<pre><code>Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload] 
</code></pre>

<p>max-age，单位是秒，用来告诉浏览器在指定时间内，这个网站必须通过 HTTPS 协议来访问。也就是对于这个网站的 HTTP 地址，浏览器需要先在本地替换为 HTTPS 之后再发送请求。</p>

<p>includeSubDomains，可选参数，如果指定这个参数，表明这个网站所有子域名也必须通过 HTTPS 协议来访问。</p>

<p>preload，可选参数，后面再介绍它的作用。</p>

<p>HSTS 这个响应头只能用于 HTTPS 响应;网站必须使用默认的 443 端口;必须使用域名，不能是 IP。而且启用 HSTS 之后，一旦网站证书错误，用户无法选择忽略。</p>

<p>HSTS Preload List</p>

<p>可以看到 HSTS 可以很好的解决 HTTPS 降级攻击，但是对于 HSTS 生效前的首次 HTTP 请求，依然无法避免被劫持。浏览器厂商们为了解决这个问题，提出了 HSTS Preload List 方案：内置一份列表，对于列表中的域名，即使用户之前没有访问过，也会使用 HTTPS 协议;列表可以定期更新。</p>

<p>目前这个 Preload List 由 Google Chrome 维护，Chrome、Firefox、Safari、IE 11 和 Microsoft Edge 都在使用。如果要想把自己的域名加进这个列表，首先需要满足以下条件：</p>

<pre><code>拥有合法的证书(如果使用 SHA-1 证书，过期时间必须早于 2016 年);

将所有 HTTP 流量重定向到 HTTPS;

确保所有子域名都启用了 HTTPS;

输出 HSTS 响应头：

max-age 不能低于 18 周(10886400 秒);

必须指定 includeSubdomains 参数;

必须指定 preload 参数;
</code></pre>

<p>即便满足了上述所有条件，也不一定能进入 HSTS Preload Lis。通过 Chrome 的 chrome://net-internals/#hsts 工具，可以查询某个网站是否在 Preload List 之中，还可以手动把某个域名加到本机 Preload List。</p>

<p>对于 HSTS 以及 HSTS Preload List，我的建议是只要你不能确保永远提供 HTTPS 服务，就不要启用。因为一旦 HSTS 生效，你再想把网站重定向为 HTTP，之前的老用户会被无限重定向，唯一的办法是换新域名。</p>

<h2>CDN 安全</h2>

<p>对于大站来说，全站迁移到 HTTPS 后还是得用 CDN，只是必须选择支持 HTTPS 的 CDN 了。如果使用第三方 CDN，安全方面有一些需要考虑的地方。</p>

<h2>合理使用 SRI</h2>

<p>HTTPS 可以防止数据在传输中被篡改，合法的证书也可以起到验证服务器身份的作用，但是如果 CDN 服务器被入侵，导致静态文件在服务器上被篡改，HTTPS 也无能为力。</p>

<p>W3C 的 SRI(Subresource Integrity)规范可以用来解决这个问题。SRI 通过在页面引用资源时指定资源的摘要签名，来实现让浏览器验证资源是否被篡改的目的。只要页面不被篡改，SRI 策略就是可靠的。</p>

<p>SRI 并不是 HTTPS 专用，但如果主页面被劫持，攻击者可以轻松去掉资源摘要，从而失去浏览器的 SRI 校验机制。</p>

<h2>了解 Keyless SSL</h2>

<p>另外一个问题是，在使用第三方 CDN 的 HTTPS 服务时，如果要使用自己的域名，需要把对应的证书私钥给第三方，这也是一件风险很高的事情。</p>

<p>CloudFlare 公司针对这种场景研发了 Keyless SSL 技术。你可以不把证书私钥给第三方，改为提供一台实时计算的 Key Server 即可。CDN 要用到私钥时，通过加密通道将必要的参数传给 Key Server，由 Key Server 算出结果并返回即可。整个过程中，私钥都保管在自己的 Key Server 之中，不会暴露给第三方。</p>

<p>CloudFlare 的这套机制已经开源，如需了解详情，可以查看他们官方博客的这篇文章：Keyless SSL: The Nitty Gritty Technical Details。</p>

<p>好了，本文先就写到这里，需要注意的是本文提到的 CSP、HSTS 以及 SRI 等策略都只有最新的浏览器才支持，详细的支持度可以去 CanIUse 查。切换到 HTTPS 之后，在性能优化上有很多新工作要做，这部分内容我在之前的博客中写过很多，这里不再重复，只说最重要的一点：既然都 HTTPS 了，赶紧上 HTTP/2 才是正道。</p>

<p>内容来源：Jerry Qu的小站</p>
]]></content>
  </entry>
  
</feed>
