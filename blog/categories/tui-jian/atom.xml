<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 推荐 | 刚刚在线]]></title>
  <link href="http://www.superqq.com/blog/categories/tui-jian/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-12-05T20:08:36+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[为自己的应用配备上 3D Touch 功能]]></title>
    <link href="http://www.superqq.com/blog/2015/10/31/app-touch-3d-function/"/>
    <updated>2015-10-31T10:35:24+08:00</updated>
    <id>http://www.superqq.com/blog/2015/10/31/app-touch-3d-function</id>
    <content type="html"><![CDATA[<p>随着 iPhone 6s 以及 iPhone 6s Plus 的发布，开发者们现在就可以为自己的应用配备上 3D Touch 功能了，从而给界面交互方式开启一个新的维度。</p>

<p>正如苹果所言，开发者可以通过非常简单的 API 来使用 3D Touch ，从根本上来说，也就是 UITouch 的一个简单的新属性。</p>

<pre><code>override func touchesBegan(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?) {
     guard let touch = touches.first else { return }
     if traitCollection.forceTouchCapability == .Available {
        println("Touch pressure is \(touch.force), maximum possible force is \(touch.maximumPossibleForce)")
     }
}
</code></pre>

<p>这个新的 API 可以让应用发挥出巨大的潜力，比如说游戏中的额外控制选项、绘图应用中的细粒度(fine-grained)控制，甚至是用来替代我们在 iOS 设备中使用过的长按操作(tap-and-hold)的极佳选择。</p>

<p>除了 UITouch 中新增的 API 外，苹果还为应用提供了两个用来增加3D Touch 功能的类集：UIPreviewAction 和 UIApplicationShortcutItem。</p>

<p>UIPreviewAction允许开发者在用户使用 3D Touch 功能触控一个 UI 元素的时候，快速地在一个新的预览窗口中显示某些内容。这种快速浏览应用特定内容的方式真的非常棒，比如说我们可以快速预览邮件信息、照片，甚至是网页内容，而无需弹出一个完整的视图控制器。</p>

<p>UIApplicationShortcutItem对象能够让 iOS 主屏幕激活一项令人惊叹的新特性。当用户使用 3D Touch 按下某个应用的图标时，一个选项列表就会被弹出，允许用户快速跳转至应用的特定部分，或者执行某项应用内的功能。</p>

<p><img src="http://images.90159.com/10/touch.jpg" alt="touch" /></p>

<p>总而言之，3D Touch 的引入给 iOS 设备解锁了一个全新的交互方式，并且将会给接下来的 iOS 应用带来新一代的创新。关于3D Touch 的实例代码和相关信息可以在苹果开发者网站的3D Touch网页上找到，祝你好运！</p>

<p>作者：Tim Oliver
@TimOliverAU — iComics创始人</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[五个案例让你明白GCD死锁]]></title>
    <link href="http://www.superqq.com/blog/2015/10/16/five-case-know-gcd/"/>
    <updated>2015-10-16T20:29:42+08:00</updated>
    <id>http://www.superqq.com/blog/2015/10/16/five-case-know-gcd</id>
    <content type="html"><![CDATA[<pre><code>作者：brighttj（@saitjr

网址：http://www.brighttj.com/ios/ios-gcd-deadlock.html
</code></pre>

<p>死锁一直都是在使用多线程时，需要注意的一个问题。以前对同步、异步，串行、并行只有一个模糊的概念，想想也是时候整理一下了。再看看之前的博客，已经很久没有干货了【说得好像之前有干货一样】，所以，这篇博客，我尽最大努力，也借鉴了很多其他博客中的例子，来讲解GCD死锁问题。</p>

<p>环境信息：</p>

<p>Mac OS X 10.10.5</p>

<p>Xcode 6.4</p>

<p>iOS  8.4</p>

<h2>串行与并行</h2>

<p>在使用GCD的时候，我们会把需要处理的任务放到Block中，然后将任务追加到相应的队列里面，这个队列，叫做Dispatch Queue。然而，存在于两种Dispatch Queue，一种是要等待上一个执行完，再执行下一个的Serial Dispatch Queue，这叫做串行队列；另一种，则是不需要上一个执行完，就能执行下一个的Concurrent Dispatch Queue，叫做并行队列。这两种，均遵循FIFO原则。</p>

<pre><code>举一个简单的例子，在三个任务中输出1、2、3，串行队列输出是有序的1、2、3，但是并行队列的先后顺序就不一定了。
</code></pre>

<p>那么，并行队列又是怎么在执行呢？</p>

<p>虽然可以同时多个任务的处理，但是并行队列的处理量，还是要根据当前系统状态来。如果当前系统状态最多处理2个任务，那么1、2会排在前面，3什么时候操作，就看1或者2谁先完成，然后3接在后面。</p>

<p>串行和并行就简单说到这里，关于它们的技术点其实还有很多，可以自行了解。</p>

<h2>同步与异步</h2>

<p>串行与并行针对的是队列，而同步与异步，针对的则是线程。最大的区别在于，同步线程要阻塞当前线程，必须要等待同步线程中的任务执行完，返回以后，才能继续执行下一任务；而异步线程则是不用等待。</p>

<p>仅凭这几句话还是很难理解，所以之后准备了很多案例，可以边分析边理解。</p>

<!--more-->


<h2>GCD API</h2>

<p>GCD API很多，这里仅介绍本文用到的。</p>

<ol>
<li><p>系统标准提供的两个队列</p>

<pre><code> // 全局队列，也是一个并行队列

 dispatch_get_global_queue 

 // 主队列，在主线程中运行，因为主线程只有一个，所以这是一个串行队列

 dispatch_get_main_queue 
</code></pre></li>
<li><p>除此之外，还可以自己生成队列</p>

<pre><code> // 从DISPATCH_QUEUE_SERIAL看出，这是串行队列

 dispatch_queue_create("com.demo.serialQueue", DISPATCH_QUEUE_SERIAL) 

 // 同理，这是一个并行队列

 dispatch_queue_create("com.demo.concurrentQueue", DISPATCH_QUEUE_CONCURRENT) 
</code></pre></li>
</ol>


<p>接下来是同步与异步线程的创建：</p>

<pre><code>dispatch_sync(..., ^(block)) // 同步线程

dispatch_async(..., ^(block)) // 异步线程
</code></pre>

<h2>案例与分析</h2>

<p>假设你已经基本了解了上面提到的知识，接下来进入案例讲解阶段。</p>

<h2>案例一：</h2>

<pre><code>NSLog(@"1"); // 任务1

dispatch_sync(dispatch_get_main_queue(), ^{

    NSLog(@"2"); // 任务2

});

NSLog(@"3"); // 任务3
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1
</code></pre>

<p>分析：</p>

<pre><code>dispatch_sync表示是一个同步线程；

dispatch_get_main_queue表示运行在主线程中的主队列；

任务2是同步线程的任务。
</code></pre>

<p>首先执行任务1，这是肯定没问题的，只是接下来，程序遇到了同步线程，那么它会进入等待，等待任务2执行完，然后执行任务3。但这是队列，有任务来，当然会将任务加到队尾，然后遵循FIFO原则执行任务。那么，现在任务2就会被加到最后，任务3排在了任务2前面，问题来了：</p>

<pre><code>任务3要等任务2执行完才能执行，任务2由排在任务3后面，意味着任务2要在任务3执行完才能执行，所以他们进入了互相等待的局面。【既然这样，那干脆就卡在这里吧】这就是死锁。
</code></pre>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-1.png" alt="deadlock" /></p>

<h2>案例二：</h2>

<pre><code>NSLog(@"1"); // 任务1

dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{

    NSLog(@"2"); // 任务2

});

NSLog(@"3"); // 任务3
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1

2

3
</code></pre>

<p>分析：</p>

<p>首先执行任务1，接下来会遇到一个同步线程，程序会进入等待。等待任务2执行完成以后，才能继续执行任务3。从dispatch_get_global_queue可以看出，任务2被加入到了全局的并行队列中，当并行队列执行完任务2以后，返回到主队列，继续执行任务3。</p>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-2.png" alt="2" /></p>

<h2>案例三：</h2>

<pre><code>dispatch_queue_t queue = dispatch_queue_create("com.demo.serialQueue", DISPATCH_QUEUE_SERIAL);

NSLog(@"1"); // 任务1

dispatch_async(queue, ^{

    NSLog(@"2"); // 任务2

    dispatch_sync(queue, ^{  

        NSLog(@"3"); // 任务3

    });

    NSLog(@"4"); // 任务4

});

NSLog(@"5"); // 任务5
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1

5

2

// 5和2的顺序不一定
</code></pre>

<p>分析：</p>

<p>这个案例没有使用系统提供的串行或并行队列，而是自己通过dispatch_queue_create函数创建了一个DISPATCH_QUEUE_SERIAL的串行队列。</p>

<pre><code>执行任务1；

遇到异步线程，将【任务2、同步线程、任务4】加入串行队列中。因为是异步线程，所以在主线程中的任务5不必等待异步线程中的所有任务完成；

因为任务5不必等待，所以2和5的输出顺序不能确定；

任务2执行完以后，遇到同步线程，这时，将任务3加入串行队列；

又因为任务4比任务3早加入串行队列，所以，任务3要等待任务4完成以后，才能执行。但是任务3所在的同步线程会阻塞，所以任务4必须等任务3执行完以后再执行。这就又陷入了无限的等待中，造成死锁。
</code></pre>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-3.png" alt="3" /></p>

<h2>案例四：</h2>

<pre><code>NSLog(@"1"); // 任务1

dispatch_async(dispatch_get_global_queue(0, 0), ^{

    NSLog(@"2"); // 任务2

    dispatch_sync(dispatch_get_main_queue(), ^{

        NSLog(@"3"); // 任务3

    });

    NSLog(@"4"); // 任务4

});

NSLog(@"5"); // 任务5
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1

2

5

3

4

// 5和2的顺序不一定
</code></pre>

<p>分析：</p>

<p>首先，将【任务1、异步线程、任务5】加入Main Queue中，异步线程中的任务是：【任务2、同步线程、任务4】。</p>

<p>所以，先执行任务1，然后将异步线程中的任务加入到Global Queue中，因为异步线程，所以任务5不用等待，结果就是2和5的输出顺序不一定。</p>

<p>然后再看异步线程中的任务执行顺序。任务2执行完以后，遇到同步线程。将同步线程中的任务加入到Main Queue中，这时加入的任务3在任务5的后面。</p>

<p>当任务3执行完以后，没有了阻塞，程序继续执行任务4。</p>

<p>从以上的分析来看，得到的几个结果：1最先执行；2和5顺序不一定；4一定在3后面。</p>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-4.png" alt="4" /></p>

<h2>案例五：</h2>

<pre><code>dispatch_async(dispatch_get_global_queue(0, 0), ^{

    NSLog(@"1"); // 任务1

    dispatch_sync(dispatch_get_main_queue(), ^{

        NSLog(@"2"); // 任务2

    });

    NSLog(@"3"); // 任务3

});

NSLog(@"4"); // 任务4

while (1) {

}

NSLog(@"5"); // 任务5
</code></pre>

<p>结果，控制台输出：</p>

<pre><code>1

4

// 1和4的顺序不一定
</code></pre>

<p>分析：</p>

<p>和上面几个案例的分析类似，先来看看都有哪些任务加入了Main Queue：【异步线程、任务4、死循环、任务5】。</p>

<p>在加入到Global Queue异步线程中的任务有：【任务1、同步线程、任务3】。</p>

<p>第一个就是异步线程，任务4不用等待，所以结果任务1和任务4顺序不一定。</p>

<p>任务4完成后，程序进入死循环，Main Queue阻塞。但是加入到Global Queue的异步线程不受影响，继续执行任务1后面的同步线程。</p>

<p>同步线程中，将任务2加入到了主线程，并且，任务3等待任务2完成以后才能执行。这时的主线程，已经被死循环阻塞了。所以任务2无法执行，当然任务3也无法执行，在死循环后的任务5也不会执行。</p>

<p>最终，只能得到1和4顺序不定的结果。</p>

<p><img src="http://www.brighttj.com/wp-content/uploads/2015/09/gcd-deadlock-5.png" alt="5" /></p>

<h2>参考</h2>

<pre><code>http://www.jianshu.com/p/0b0d9b1f1f19

http://www.cnblogs.com/tangbinblog/p/4133481.html
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有关 XcodeGhost 的问题和解答]]></title>
    <link href="http://www.superqq.com/blog/2015/09/24/apple-xcodeghost-answer/"/>
    <updated>2015-09-24T00:09:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/09/24/apple-xcodeghost-answer</id>
    <content type="html"><![CDATA[<p><strong>我听说了由 XcodeGhost 开发的恶意 app — 这是怎么回事？</strong></p>

<p>我们一直建议开发者使用由我们提供的免费、安全的工具，包括 Xcode，从而确保他们为 App Store 的用户创造出安全的 app。一些开发者下载了已被恶意软件感染的盗版 Xcode，由此开发的 app 也同样受到感染。</p>

<p>Apple 特意使用诸如 Gatekeeper 等技术，以防止安装从非 App Store 渠道下载的应用程序，和 / 或安装包括 Xcode 在内的未签名的应用程序。当开发者为了能安装类似 XcodeGhost 等恶意程序时，这些保护措施会被刻意地禁用。</p>

<p>作为 Apple 向开发者提供的业界先进工具之一，以下措施可以确保软件未被篡改：</p>

<pre><code>Xcode app 有 Apple 的代码签名。
从 Mac App Store 下载 Xcode 时，开发者的电脑系统自动对 Xcode 的代码签名会进行检查和验证。
从 Apple Developer Program 网站下载 Xcode 时，只要 Gatekeeper 没有被禁用，默认开发者的电脑系统对 Xcode 代码签名自动进行检查和验证。
</code></pre>

<h3>为什么开发者会不顾用户的安全下载盗版软件？</h3>

<p>为了更快下载我们的开发者工具，开发者有时会从其他非 Apple 站点搜寻。</p>

<h3>这会对我有什么影响吗？如何得知我的设备是否受到了影响？</h3>

<p>我们目前没有任何信息表明这些恶意软件与任何恶意事件相关，也没有信息表明这些软件被使用在传播任何个人身份信息的用途上。</p>

<p>我们目前没有看到任何客户个人身份信息受到影响，而且代码无法通过用户身份请求来获取 iCloud 或其他服务的密码。</p>

<p>只要一经发现这些 app 有可能通过恶意代码开发，我们就对其进行下架处理。开发者们正在快速更新他们的 app，以便用户使用。</p>

<!--more-->


<p>恶意代码只能提供一些基本信息，比如 app 和一般系统信息。</p>

<h3>从 Apps Store 下载 app 是否安全？</h3>

<p>我们已将由该盗版软件开发的 apps 从 App Store 中撤下，并拦截了通过该恶意软件开发的新 app 进入 App Store。</p>

<p>我们正与开发者紧密协作，以确保受到影响的 app 尽快回到 App Store 供用户使用。</p>

<p>我们将在支持页面上列出受此影响的前 25 个 apps，方便用户验证他们是否已将这些 app 更新到了最新版本。</p>

<p>用户还将会收到更多信息，以便了解他们下载的某 app 是否会存在问题。一旦开发者更新了他们的 app，用户可以通过在设备上运行更新解决存在的问题。</p>

<p>我们正努力让中国的开发者可以用更快的速度下载 Xcode 测试版本。开发者也可以通过 developer.apple.com 列出的步骤来验证他们的 Xcode 是否被篡改过。</p>

<h2>XcodeGhost Q&amp;A</h2>

<p><strong>I’ve heard about malicious apps created by XcodeGhost — what does this mean?</strong></p>

<p>We always recommend developers using the free, secure tools we provide them — including Xcode — to ensure they’re creating the most secure apps for App Store customers. Some developers downloaded counterfeit versions of Xcode that have been infected with malware and created apps that were just as infected.</p>

<p>Apple incorporates technologies like Gatekeeper expressly to prevent non-App Store and/or unsigned versions of programs, including Xcode, from being installed. Those protections had to have been deliberately disabled by the developer for something like XcodeGhost to successfully install.</p>

<p>As part of providing developers the industry&rsquo;s most advanced tools, Apple provides developers the following checks to ensure software is untampered:</p>

<pre><code>The Xcode app is code-signed by Apple.
When you download Xcode from the Mac App Store the code signature for Xcode is automatically checked and validated by your system.
When you download Xcode from the Apple Developer Program web site, the code signature for Xcode is automatically checked and validated by your system by default as long as Gatekeeper is not disabled.
</code></pre>

<h3>Why would a developer put customers at risk by downloading counterfeit software?</h3>

<p>Sometimes developers search for our tools on other, non-Apple sites in an effort to find faster downloads of developer tools.</p>

<h3>How does this affect me? How do I know if my device has been compromised?</h3>

<p>We have no information to suggest that the malware has been used to do anything malicious or that this exploit would have delivered any personally identifiable information had it been used.</p>

<p>We’re not aware of personally identifiable customer data being impacted and the code also did not have the ability to request customer credentials to gain iCloud and other service passwords.</p>

<p>As soon as we recognized these apps were using potentially malicious code we took them down. Developers are quickly updating their apps for users.</p>

<p>Malicious code could only have been able to deliver some general information such as the apps and general system information.</p>

<h3>Is it safe for me to download apps from App Store?</h3>

<p>We have removed the apps from the App Store that we know have been created with this counterfeit software and are blocking submissions of new apps that contain this malware from entering the App Store.</p>

<p>We’re working closely with developers to get impacted apps back on the App Store as quickly as possible for customers to enjoy.</p>

<p>A list of the top 25 most popular apps impacted will be listed soon so users can easily verify if they have downloaded the latest versions of these apps. After the top 25 impacted apps, the number of impacted users drops significantly.</p>

<p>Customers will be receiving more information letting them know if they’ve downloaded an app/apps that could have been compromised. Once a developer updates their app, that will fix the issue on the user’s device once they apply that update.</p>

<p>We’re working to make it faster for developers in China to download Xcode betas. To verify that their version of Xcode has not been altered, they can take the following steps posted at &lt;developer.apple.com>.</p>

<p>文章来自：<a href="http://www.apple.com/cn/xcodeghost/">http://www.apple.com/cn/xcodeghost/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVFoundation和 GPUImage初探]]></title>
    <link href="http://www.superqq.com/blog/2015/08/24/avfoundation-gpuimage-find/"/>
    <updated>2015-08-24T11:21:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/24/avfoundation-gpuimage-find</id>
    <content type="html"><![CDATA[<p>文章来自：<a href="http://vonglo.me/2014/08/24/AVFoundation%E5%92%8C-GPUImage%E5%88%9D%E6%8E%A2/" target="_blank" title=“AVFoundation和 GPUImage初探”>AVFoundation和 GPUImage初探</a></p>

<p>最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。</p>

<h3>AVFoundation的一些基本概念</h3>

<p>根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。</p>

<p><img src="http://images.90159.com/08/frameworksBlockDiagram_2x.png" alt="1" /></p>

<h4>相关类</h4>

<ul>
<li><code>AVAsset</code></li>
<li><code>AVAssetTrack</code></li>
<li><code>AVComposition</code></li>
<li><code>AVVideoComposition</code></li>
<li><code>AVAudioMix</code></li>
<li><code>AVMutableAudioMixInputParameter</code></li>
<li><code>AVMutableVideoCompositionInstrution</code></li>
<li><code>AVMutableVideoCompositionLayerInstrution</code></li>
</ul>


<p>简单的播放可以使用MPMoviePlayerController或者MPMovieViewController就行,简单的录
制可以直接使用UIImagePickerController。同样简单的声音播放直接使用AVAudioPlayer，简单的录制直接使用AVAduioRecorder。如果你想要有更多的操作，可使用各种复杂的方式来控制播放，比如在同一时刻为同一个asset的不同片段使用不同的分辨率渲染，playitem来管理asset的呈现状态和方式,playitemtrack管理asset中的轨道（track）状态。</p>

<!--more-->


<p>在AVFoudation框架中最核心的类就是AVAsset，他是由一系列的媒体数据组成的，包括但不限于:时间、大小(size)、标题、字幕等。其中每一个单独的媒体数据称为轨道(track)。同样剪辑操作中，AVMutableComposition是一个核心类。</p>

<p><img src="http://images.90159.com/08/asset-track.png" alt="4" /></p>

<p>这里又一个重要的东西就是CMTime,它是一个结构体，定义如下:</p>

<p>typedef struct
{
    CMTimeValue    value;      <br/>
    CMTimeScale    timescale;  <br/>
    CMTimeFlags    flags;      <br/>
    CMTimeEpoch    epoch;      <br/>
} CMTime;
通常时间是等于value/timescale的，所以两个有相同时间的CMTime它们的timescale并不一定相同。关于更多CMTime的内容可以看<a href="https://developer.apple.com/library/ios/documentation/CoreMedia/Reference/CMTime/Reference/reference.html#//apple_ref/doc/uid/TP40009748">这里</a>。</p>

<h3>进阶</h3>

<h4>视频的录制</h4>

<p>这里用的是系统原生录制,关于录制通常用到的几个类就是AVCaptureDevice、
AVCaptureSession、AVCaptureDeviceInput、AVCaptureOutput,同样，来看一张图。</p>

<p><img src="http://images.90159.com/08/capture.png" alt="2" /></p>

<p>一般来说，如果你想修改视频的相关信息，如拍摄地点等，可以拿到output的metadata来修改。大致代码如下:</p>

<pre><code>NSMutableArray *array = [output.metadta mutableCopy];
AVMutableMetadataItem *item = [[AVMutableMetadataItem alloc] init];
item.keyspace = ...;
item.key = ...;
item.value = ...;
[array addObject:item];
output.metadata = array;
</code></pre>

<p>如果录制时候想要得到指定的视频size必须先指定分辨率，像这样</p>

<pre><code>if ([session canSetSessionPreset:AVCaptureSessionPreset640x480]){ 

    session.sessionPreset = AVCaptureSessionPreset640x480;
}
else {
    //设置失败
}
</code></pre>

<p>切换摄像头或其他输入源必须在beginConfiguration和commitConfiguration之间来处理，大致是这样</p>

<pre><code>[session beginConfiguration];
//移除某个输入源
//再添加某个输入源
//再为新添加的输入源进行必要的相关设置
//...其他操作
[session commitConfiguration];
</code></pre>

<p>如果想对实时视频帧进行相关的渲染操作,通过 setSampleBufferDelegate:queue:方法来为output设置代理，同时必须指定queue，代理方法将会在这些queue上面被调用。可以在自己的类里面实现AVCaptureVideoDataOutput的协议方法,通过实现
captureOutput:didOutputSampleBuffer:fromConnection:来拿到视频的每一帧，默认情况下这些视频帧会被用最有效的格式来输出到output,当然也可以在拍摄之前就为output进行相关设置。</p>

<pre><code>AVCaptureVideoDataOutput *videoDataOutput = [AVCaptureVideoDataOutput new];
NSDictionary *newSettings =@{ (NSString *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) };
videoDataOutput.videoSettings = newSettings;
</code></pre>

<p>说了这么多，感觉很虚，还是直接上代码，将以上部分衔接起来</p>

<pre><code>//自定义方法，小演示只添加了视频，没有添加声音，添加声音类似
- (void)yourCustomMethodName{
    AVCaptureSession *session = [[AVCaptureSession alloc] init];
    if ([session canSetSessionPreset:AVCaptureSessionPreset640x480]){ 

            session.sessionPreset = AVCaptureSessionPreset640x480;
        }
        else {
            //设置失败
        }
    AVCaptureDevice *device =
            [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];

    NSError *error = nil;
    AVCaptureDeviceInput *input =
            [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error];
    if (!input) {
        // Handle the error appropriately.
    }
    if(session canAddInput:input){
        [session addInput:input];
    }
    AVCaptureVideoDataOutput *output = [[AVCaptureVideoDataOutput alloc] init];
    if(session canAddOutput:output){
        [session addOutput:output];
    }
    output.videoSettings =@{ (NSString *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) };
    //设置帧率(FPS),每秒15帧
    output.minFrameDuration = CMTimeMake(1, 15);
    dispatch_queue_t queue = dispatch_queue_create("CustomQueue", NULL);
    [output setSampleBufferDelegate:self queue:queue];
    dispatch_release(queue)
    NSString *mediaType = AVMediaTypeVideo;

 //用来显示录制的实时画面
    AVCaptureVideoPreviewLayer *captureVideoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:session];
    [self.view.layer addSublayer:captureVideoPreviewLayer];

    //用户是否允许启用摄像头
    [AVCaptureDevice requestAccessForMediaType:mediaType completionHandler:^(BOOL granted) {
        if (granted)
        {
            //Granted access to mediaType
            [self setDeviceAuthorized:YES];
            [session startRunning];
        }
        else
        {
            //Not granted access to mediaType
            dispatch_async(dispatch_get_main_queue(), ^{
            [[[UIAlertView alloc] initWithTitle:@"AVCam!"
                                        message:@"AVCam doesn't have permission to use Camera, please change privacy settings"
                                       delegate:self
                              cancelButtonTitle:@"OK"
                              otherButtonTitles:nil] show];
                    [self setDeviceAuthorized:NO];
            });
        }
    }];
}

//协议方法,获取每一帧，将每一帧转换成图片，你也可以进行其他的渲染操作
- (void)captureOutput:(AVCaptureOutput *)captureOutput
         didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer
         fromConnection:(AVCaptureConnection *)connection {

    UIImage *image = imageFromSampleBuffer(sampleBuffer);
}
</code></pre>

<p>上面演示了如何取得每一帧实时画面,如果想要直接存成视频可使用AVCaptureMovieFileOutput,如下</p>

<pre><code>AVCaptureMovieFileOutput *movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];
NSURL *fileURL = ...;    //存放位置
//指定代理
[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:delete];
//也可以为其指定outputSettings
同样代理必须实现协议方法captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:,
</code></pre>

<p>当然还有其他各种具体的设置，如对焦、曝光、闪光灯以及白平衡等等均可以通过KVO来设置，每次设置前都加一个判断，是否支持指定模式,在这里不做详细叙述了,这里你可以看到<a href="https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/04_MediaCapture.html#//apple_ref/doc/uid/TP40010188-CH5-SW14">更多</a>。</p>

<h4>视频的剪辑</h4>

<p>视频的剪辑包括但不限于:裁剪、旋转(改变transform)、添加水印、添加字幕、合并等。关于剪辑，无非就是取出视频中的轨道(视频和音频),然后对轨道进行一系列的操作变可以得到各种想要的效果。首先我们先来看下面一张图</p>

<p><img src="http://images.90159.com/08/composition.png" alt="3" /></p>

<p>AVMutableComposition是整个视频剪辑过程中的一个核心，下面着重讲解这个类。AVMutableComposition和AVAsset一样含有多个视/音频轨道，但是更重要的是，它可以将多个AVAssetTrack合并到一起，比如在视频合并时，可以直接将多段视频拼接到一个轨道(AVMutableCompositonTrcak)，音频也一样。通过借助AVMutableVideoComposition和AVMutableAudioMix来设置每一段的视/音频的属性，从而达到想要的视听效果，比如视频切换处的淡入淡出，声音的渐变，字幕等等。
关于上图的解释:首先通过将asset里面的轨道加载到composition的各轨道，然后通过audioMix和videoComposition对某个轨道进行对应操作,设置其相关属性。其中要用到的具体方法可以参见<a href="https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/03_Editing.html#//apple_ref/doc/uid/TP40010188-CH8-SW1">这里</a>。</p>

<p>其中图中1，2，3用到的方法为</p>

<pre><code>[1]
[mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid]
[2]
[AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack];`
[3]
[AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack]
</code></pre>

<p>关于视频的剪辑的代码可以参见苹果给出的官方<a href="https://developer.apple.com/library/ios/samplecode/AVSimpleEditoriOS/Introduction/Intro.html#//apple_ref/doc/uid/DTS40012797">Demo</a>以及Raywendrich上的两篇文章<a href="http://www.raywenderlich.com/13418/how-to-play-record-edit-videos-in-ios">1</a>,<a href="http://www.raywenderlich.com/30200/avfoundation-tutorial-adding-overlays-and-animations-to-videos">2</a>。</p>

<h3>GPUImage</h3>

<p>什么?!你没听说过GPUImage?!那你赶紧去看看它的<a href="https://github.com/BradLarson/GPUImage/blob/master/README.md#overview">相关介绍</a>。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>

<h4>分段录制</h4>

<p>在使用GPUImageVideoCamera来录制的时候,可能需要分段录制,在GPUImage给出的视频录制Demo中直接只是录制一次，然而有时候需求可能是要录制多次，如果此时按照Demo的方法每次录制都要创建一个movieWriter,这样子的话每次都会在重新创建movieWriter并将它设置为videoCamera的audioEncodingTarget时候，界面都会卡顿一下，这是什么原因呢？因为videoCamera默认是不录制声音的，而每次创建movieWriter的时候都用到了movieWriter.hasAudioTrack = YES;,吊用这个之后videoCamera会自动去添加声音输入源,准备一些数据，所以这个过程会导致界面卡顿一下？这该怎么办呢？如果你有进到videoCamera的头文件去看的话你会发现这么一个方法和它的注释</p>

<pre><code>//Add audio capture to the session. Adding inputs and outputs freezes 
//the capture session momentarily, so you can use this method to add 
//the audio inputs and outputs early, if you’re going to set the 
//audioEncodingTarget later. Returns YES is the audio inputs and 
//outputs were added, or NO if they had already been added.

-(BOOL)addAudioInputsAndOutputs;
</code></pre>

<p>注释的大意是:录制的时候添加声音,添加输入源和输出源会暂时会使录制暂时卡住,所以在要使用声音的情况下要先调用该方法来防止录制被卡住。这不刚好就解决了上面的这个问题吗？所以问题就迎刃而解了,因为没看到这个,走了不少弯路,浪费了好长时间。</p>

<p>关于分段录制,可能有这么一个需求就是所有片段都是存于一个文件中而不是录制完成后将各段合并到一个视频文件中。这两个东西或许会帮到你<a href="http://blog.csdn.net/whf727/article/details/18702643">分段录制的实现</a>,<a href="https://github.com/leanlyne/GPUImageExtend">GPUImageExtend</a>。前者是基于系统的分段录制的实现,后者是GPUImageMoiveWriter的一个子类。</p>

<h4>所见即所得</h4>

<p>在录制的时候,使用GPUImageView来显示,因为给GPUImageView设置的大小是320*320的,如果不设置它的填充模式(fillMode)它是默认使用kGPUImageFillModePreserveAspectRatio即保持长宽比,其余空白处使用背景色填充,如果要设置成方形就得使用kGPUImageFillModePreserveAspectRatioAndFill,但是这个时候问题又来了假设你是用的录制分辨率是960x540,显示的画面则只会显示中间的540x540的画面,这个时候如果movieWriter的size设置为540x540,则最后保存的视频是失真的因为960被压到了540，整个画面变扁了。这个时候有两种解决方案</p>

<ul>
<li>1.使用GPUImageCropFilter,通过设置其cropRegion来裁出中间540x540部分。关于cropRegion要注意它是一个CGRect,它对坐标系做了一个归一化处理,所以让所有的取值都在0.0~1.0范围内,比如960x540裁剪至中间540x540部分则cropRegion为(0,((960-540)/2)/960,1,540/960)</li>
<li>2.改变videoComposition的perferTransfom使其只显示中间的540x540。
这样就完成了所见即所得。</li>
</ul>


<p>关于GPUImage的实时滤镜添加或给已存在的视频添加滤镜,Demo都给出了详细过程,依葫芦画瓢即可。有一点要注意的是,在一些操作完成的时候注意removeTarget,还有就是在使用movieFile来播放已存在视频并添加滤镜的时候是没有声音的,这是这个库的一个缺陷,Github上有人提了这个<a href="https://github.com/BradLarson/GPUImage/issues/458">issue</a>和<a href="https://gist.github.com/pgodino/3819907">一些解决办法</a>。同时在用movieFile处理视频的时候在切换滤镜的时候最好先cancelProcessing不然会有黑屏或卡顿现象出现。同样如果你是用老版本的GPUImage的时候,可能会遇到第一帧是红色的现象,有人提出这个issue后,作者修复了这个bug,切换到最新版的时候就不会有这种情况发生。发生这种情况的原因是视频掉帧,导致音频和视频不同步。</p>

<h3>总结</h3>

<p>AVFoundation还是有很多东西去做深层次的挖掘,GPUImage也是一样,有了这个强大的库,解决一些事情节省了大量时间。这次仅仅是一个小小的尝试,对于很多东西都是浅尝则止,文中难免会有错误,欢迎在评论中指正。如果你在使用GPUImage和AVFoundation有什么好的心得或者对一些问题有相应的解决方案,不妨在评论中分享一下。</p>

<hr />

<p>版权声明：我已将本文在微信公众平台的发表权「独家代理」给 iOS开发（ iOSDevTip ） 微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://images.90159.com/icon/iOSDevTip.jpg" alt="iOSDevTip" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一句代码添加新浪弹出框动画]]></title>
    <link href="http://www.superqq.com/blog/2015/08/21/sina-animation/"/>
    <updated>2015-08-21T11:16:07+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/21/sina-animation</id>
    <content type="html"><![CDATA[<p>新浪微博中的“加号按钮”点击后的弹出动画很有意思，每当一个人孤单寂寞冷的时候总会不停的点这个动画，终于忍不住自己撸了一个。废话不多说，直接上效果图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation1.gif" alt="演示1" /></p>

<p>首先说一下通过这个动画制作过程给大家分享的技术问题：
1.背景的毛玻璃效果
2.弹性动画
3.动画进行时对用户交互的处理
4.<code>UIControl</code> 的 <code>event</code> 类型</p>

<h2>一、背景的毛玻璃效果</h2>

<p>对新浪微博中弹出动画背景的思路分析：</p>

<p>  新浪的背景动画效果是有一个透明渐变的过程，并且最终渐变停止之后显示的是一个带有毛玻璃（半透明模糊）效果的视图。我的模仿思路是当准备要弹出动画的时候对整个视图进行截屏操作，将截屏后的图片进行毛玻璃效果渲染，然后在视图上加一个背景 <code>UIImageView</code> 来显示这张图片，然后通过 <code>alpha</code> 动画来由透明逐渐渐变出来。</p>

<h3>1.对视图进行截屏：</h3>

<pre><code>    UIGraphics BeginImageContextWithOptions(size, NO, scale);
    [view.layer renderInContext:UIGraphicsGetCurrentContext()];
    UIImage * image = UIGraphicsGetImageFromCurrentImageContext();
</code></pre>

<h3>2.截屏后加上毛玻璃效果：</h3>

<p>制作毛玻璃效果有三种选择，一是 <code>iOS8</code> 后推出的 <code>UIBlurEffect</code> 和 <code>UIVisualEffectView</code> 来直接显示一个带有毛玻璃效果的 <code>View</code> 不过这种方式并不能直接生成一张带有毛玻璃效果的图片，而且它的模糊程度设置方法非常有限只有那几个枚举类型，无法满足需求。</p>

<p>第二种是通过 <code>CoreImage</code> 添加滤镜的方式来实现毛玻璃效果，不过这种方式有个缺点如果滤镜使用频繁会对主线程产生影响，如果我不断频繁的重复动画效果就必须要做判断看滤镜是否正在起作用，否则会经常出现崩溃和内存泄漏问题。</p>

<p>第三种我们使用苹果13年 <code>WWDC</code> 上发布的官方 <code>sample</code> 一个 <code>UIImage</code> 的分类 <code>UIImage+ImageEffects.h</code> ,它不但可以制作毛玻璃效果图片，而且可以调整模糊程度和颜色渲染。下面给出代码：</p>

<pre><code>    image = [image bhb_applyBlurWithRadius:15 
                                 tintColor:tintColor 
                     saturationDeltaFactor:1 
                                 maskImage:nil];//因为OC没有命名空间，避免你的程序中使用到了这个分类导致冲突，我加了前缀
</code></pre>

<!--more-->


<p>最终的显示效果很不错，我将模糊程度尽量的调节到与新浪微博一致了，不过在这个过程中，我发现当我频繁的进行弹出操作时，内存会不断攀升如下图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation3.png" alt="演示3" />
内存暴增的原因肯定是因为刚才的截图或者毛玻璃效果导致的，我们来用 <code>Instruments</code> 的 <code>Allocations</code> 来进行内存分析，找出元凶。
Xcode -> Product -> Profile -> Allocations， 开启之后我们来使用右下角的 <code>Mark generation</code>（内存快照功能，进一步了解请移步[这片文章][1]）
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation4.png" alt="演示4" />
在弹出 <code>View</code> 和移除 <code>View</code> 的两个时间点加 <code>Mark generation</code>。
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation5.png" alt="演示5" />
可以观察到，两个时间点竟然相差了4.31M，这是一个相当恐怖的数字，怪不得我点击几次弹出功能之后内存会暴增，让我们继续跟踪：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation6.png" alt="演示6" />
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation7.png" alt="演示7" />
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation8.png" alt="演示8" />
跟踪到最后，我们发现大部分未释放的内存来自于绘图和位图的创建，回想我们当初做的截图操作，图片上下文开启后并没有进行关闭操作，所以在程序不断截图的过程中开启了无数的图片上下文而且不会被释放，添加下面这句关键的代码就可以解决问题（NC的我竟然连这个都忘了加-.-）：</p>

<pre><code>        UIGraphicsEndImageContext();
</code></pre>

<h2>二、弹性动画</h2>

<p>新浪动画中，按钮弹出的动画为弹性效果，按钮到达最终位置后不会直接停止，而是做类似弹簧的一种阻尼运动，要实现这种动画也很简单 <code>iOS7</code> 后苹果非常给力的添加了 <code>spring</code> 弹性动画的快速创建方式：</p>

<pre><code>    [UIView animateWithDuration:(NSTimeInterval) 
                          delay:(NSTimeInterval) 
         usingSpringWithDamping:(CGFloat) 
          initialSpringVelocity:(CGFloat) 
                        options:(UIViewAnimationOptions) 
                     animations:^{} 
                     completion:^(BOOL finished) {}];
</code></pre>

<p>通过对 <code>Damping</code> 阻力和 <code>Velocity</code> 初速度的设置可以实现弹性动画动画效果如下图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/threeballs.gif" alt="摘自MotionDesign" /></p>

<p>当然实现弹性动画还可以使用[Jonathan Willing][2]大大的 <code>JNWSpringAnimation</code> ,你可以像使用 <code>CABasicAnimation</code> 一样轻松的使用它，通过改变关键的3个属性 <code>Damping</code> 阻力， <code>stiffness</code> 硬直, <code>mass</code> 质量来改变弹性动画的效果代码如下：</p>

<pre><code>    JNWSpringAnimation *scale = [JNWSpringAnimation
    animationWithKeyPath:@"transform.translation.x"];
    scale.damping = 7;
    scale.stiffness = 7;
    scale.mass = 1;

    scale.fromValue = @(0);
    scale.toValue = @(400);

    [redBall.layer addAnimation:scale forKey:scale.keyPath];
    redBall.transform = CGAffineTransformMakeTranslation(400, 0);
</code></pre>

<p>关键的三个属性对动画的影响如下图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/jnwdemo.gif" alt="摘自MotionDesign" /></p>

<p>为了减轻项目对第三方框架的依赖，我使用了 <code>iOS7</code> 原生的 <code>spring</code> 动画，如果你想要兼容以前版本，替换成 <code>JNWSpringAnimation</code> 即可。回到新浪动画的制作，动画是6个按钮按照顺序依次出现和消失，并且点击 <code>more</code> 按钮后可以向左平移到第二屏幕，并且在第二屏幕点击 <code>叉号</code> 按钮动画会加在第二屏幕的6个按钮上。
效果如图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation2.gif" alt="演示2" /></p>

<p>对此我使用了一个 <code>UIScrollView</code> 来承载这些按钮，并声明2个数组用来保存所有的按钮和正在显示的按钮（在屏幕上，并且需要做动画）:</p>

<pre><code>    @property (nonatomic,strong) NSMutableArray * visableArray;//屏幕显示的按钮数组
    @property (nonatomic,strong) NSMutableArray * itemsArray;//所有按钮的数组
</code></pre>

<p>这样我在给这些按钮加动画的时候就不会浪费性能，只把动画加在当前显示在屏幕的按钮上。动画依次按照一定的时间差来执行，解决的办法我是用的 <code>GCD</code> :</p>

<pre><code>    [self.visableArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        BHBCustomBtn * btn = obj;
        CGFloat x = btn.frame.origin.x;
        CGFloat y = btn.frame.origin.y;
        CGFloat width = btn.frame.size.width;
        CGFloat height = btn.frame.size.height;
        btn.frame = CGRectMake(x, [UIScreen mainScreen].bounds.size.height + y - self.frame.origin.y, width, height);
        btn.alpha = 0.0;
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(idx * 0.03 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:0.35 delay:0 usingSpringWithDamping:0.85 initialSpringVelocity:25 options:UIViewAnimationOptionCurveEaseIn animations:^{
                btn.alpha = 1;
                btn.frame = CGRectMake(x, y, width, height);
            } completion:^(BOOL finished) {
                if ([btn isEqual:[self.visableArray lastObject]]) {
                    self.superview.superview.userInteractionEnabled = YES;
                }
            }];
        });
    }];
</code></pre>

<p>这样按钮就会依次以弹性动画的形式弹动出来了，是不是很简单，对于动画结束后所作的处理我将在下一节中说明。</p>

<h2>三、动画进行时对用户交互的处理</h2>

<p>动画过程中，处理用户交互的问题相当关键，视图动画中默认自动停止响应用户交互，因此当按钮进行弹性动画时，触摸它并不会生成任何事件。
但是当你触摸加号按钮的时候，会再次进行弹出框动画，这时就会弹出两个弹出框，这是我们不希望看到的，我们可以将加号按钮的 <code>enable</code> 属性设置为 <code>YES</code> 但是这样做我们要在封装的视图内部获取外部的加号按钮，这一点违背了封装性原则，并不是一个好的设计。所以我在所有按钮的弹性动画开始时，设置：</p>

<pre><code>    self.superview.superview.userInteractionEnabled = NO;
</code></pre>

<p>注意视图的层级关系，我所设计的 <code>BHBPopView</code> 内部装着一个 <code>UIScrollView</code>，而它上面放着这些按钮，所以你要找到父视图的父视图才能够统一屏蔽用户的交互行为，当所有的按钮弹性动画结束时，也就是 <code>visableArray</code> 数组最后一个按钮动画结束时，我们恢复用户的交互：</p>

<pre><code>    self.superview.superview.userInteractionEnabled = YES;
</code></pre>

<p>这样当动画进行过程中，屏蔽了用户的交互，避免发生一些意外的情况。</p>

<h2>四、<code>UIControl</code> 的 <code>event</code> 类型</h2>

<p>注意到新浪动画里面按钮有一个放大效果，并且当你手指放上去的时候放大，手指稍微挪动，便恢复原始大小。让我们先来看一下动画：</p>

<p><img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation9.gif" alt="演示9" /></p>

<p>要实现这个效果只需要做一个形变动画就可以了，关键是我们如何控制它放大和恢复大小。
思路如下：按钮是继承自 <code>UIControl</code> ，<code>UIControl</code> 有不同的事件状态：</p>

<pre><code>    UIControlEventTouchDown           = 1 &lt;&lt;  0,      // 手指落在按钮的一瞬间触发
    UIControlEventTouchDownRepeat     = 1 &lt;&lt;  1,      // 多点触碰的时候，当第二根以上的手指触摸瞬间出发
    UIControlEventTouchDragInside     = 1 &lt;&lt;  2,      // 手指在视图范围内拖动触发
    UIControlEventTouchDragOutside    = 1 &lt;&lt;  3,      // 手指在视图范围外拖动触发
    UIControlEventTouchDragEnter      = 1 &lt;&lt;  4,      // 手指从视图外拖动到视图内时触发
    UIControlEventTouchDragExit       = 1 &lt;&lt;  5,      // 手指从视图内部拖动到视图外时触发
    UIControlEventTouchUpInside       = 1 &lt;&lt;  6,      // 手指在视图内部抬起时触发
    UIControlEventTouchUpOutside      = 1 &lt;&lt;  7,      // 手指在视图外部抬起时触发
    UIControlEventTouchCancel         = 1 &lt;&lt;  8,      // 取消事件，放上了太多手指或者被上锁或者电话呼叫打断。

    UIControlEventValueChanged        = 1 &lt;&lt; 12,      // 当视图的值发生改变时，发送通知。

    UIControlEventEditingDidBegin     = 1 &lt;&lt; 16,     // UITextField
    UIControlEventEditingChanged      = 1 &lt;&lt; 17,
    UIControlEventEditingDidEnd       = 1 &lt;&lt; 18,
    UIControlEventEditingDidEndOnExit = 1 &lt;&lt; 19,     // 'return key' ending editing

    UIControlEventAllTouchEvents      = 0x00000FFF,  // for touch events
    UIControlEventAllEditingEvents    = 0x000F0000,  // for UITextField
    UIControlEventApplicationReserved = 0x0F000000,  // range available for application use
    UIControlEventSystemReserved      = 0xF0000000,  // range reserved for internal framework use
    UIControlEventAllEvents           = 0xFFFFFFFF
</code></pre>

<p>我们所用到的事件是 <code>TouchDown</code> 和 <code>DragInside</code>，手指放上去触发 <code>TouchDown</code> 放大视图，在视图内部移动 <code>DragInside</code> 时恢复视图，注意按钮的作用范围是整个矩形区域包含了图片和文字，当你的手指移出图片的时候并非一定会移出按钮作用范围，所以依然会触发 <code>TouchUpInsite</code> 事件，这时候我们需要做一个属性来记录用户拖拽之后取消按钮的 <code>TouchUpInsite</code> 执行。</p>

<pre><code>    @property (nonatomic,assign) BOOL btnCanceled;
</code></pre>

<p>这样我们就可以实现动画效果了，具体代码如下：</p>

<pre><code>    //处理按钮有效的点击事件，当前按钮放大消失，其他按钮缩小消失，回调点击事件
    [btn addTarget:self action:@selector(didClickBtn:) forControlEvents:UIControlEventTouchUpInside];
    //处理手指按下事件，放大按钮
    [btn addTarget:self action:@selector(didTouchBtn:) forControlEvents:UIControlEventTouchDown];
    //处理手指拖动事件，恢复按钮大小
    [btn addTarget:self action:@selector(didCancelBtn:) forControlEvents:UIControlEventTouchDragInside];
</code></pre>

<h2>总结：</h2>

<p>制作类似新浪微博这种弹出框动画，我的思路是先分析逻辑，这些特效都由哪些组成，毛玻璃背景，加顶部一个 <code>logo</code> ，加中间 <code>UIScrollView</code>和上面的很多按钮,加底部工具条。研究透彻动画的执行顺序，动画执行结果有哪些分支。然后针对特效中的难点，比如毛玻璃，按钮弹性动画等等进行逐一研究攻破，最后将这些组件整合在一起变成一个好玩的动画，最后不要忘了动画的内存和性能测试。这次我模仿的新浪微博动画弹性效果并不是太理想，比起新浪原生来说不是特别一致，也希望有兴趣的你来给我一些建议优化它。最终在你的项目中加入我的弹出框动画真的只需要一句话哦：</p>

<pre><code>    /**
    *  直接显示一个popView在某个view上
    *
    *  @param view       父view
    *  @param imageArray 图标数组
    *  @param titles     标题数组
    *  @param block      回调
    *  @return pop视图
    */
    + (BHB_INSTANCETYPE)showToView:(UIView *)view andImages:(NSArray *)imageArray andTitles:(NSArray *)titles andSelectBlock:(DidSelectItemBlock)block;
    /**
    *  如果显示一个带more功能的，请使用此方法
    *
    *  @param view  父view
    *  @param array BHBItem类型的集合
    *  @param block 回调
    *  @return pop视图
    */
    + (BHB_INSTANCETYPE)showToView:(UIView *)view withItems:(NSArray *)array andSelectBlock:(DidSelectItemBlock)block;
</code></pre>

<p>hexo出点问题修复到下半夜啊（升级到3.0太蛋疼了），现在脑子晕晕的，明天还要去新公司入职，动画中还有很多细节我不能一一分享了，欢迎大家来搞我的<a href="https://github.com/bb-coder/BHBPopView">Demo</a></p>

<p>good luck!</p>

<p>本文由<a href="http://www.90159.com/">程序员头条</a>管理员毕洪博原创文章，转载务必注明出处。</p>

<p>版权声明：我已将本文在微信公众平台的发表权「独家代理」给 iOS开发（ iOSDevTip ） 微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://images.90159.com/icon/iOSDevTip.jpg" alt="iOSDevTip" /></p>

<p>原文链接：<a href="http://bihongbo.com/2015/08/19/sinaAnimation/">http://bihongbo.com/2015/08/19/sinaAnimation/</a></p>
]]></content>
  </entry>
  
</feed>
