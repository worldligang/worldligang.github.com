<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刚刚在线]]></title>
  <link href="http://www.superqq.com/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-06-16T21:20:52+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Decorator – 装饰器模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/"/>
    <updated>2015-06-16T07:44:51+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>123<strong>装饰器模式</strong>可以在不修改代码的情况下灵活的为一对象添加行为和职责。当你要修改一个被其它类包含的类的行为时，它可以代替子类化方法。</p>

<p>在 Object-C 里有两个种非常常见的实现模式：分类(Category)和委托(Delegation)。</p>

<h3>分类 Category</h3>

<p><a href="http://www.superqq.com/blog/2015/01/15/objective-cxiang-guan-categoryde-shou-ji/">分类</a>是一种非常强大的机制，它允许你在一个已存在的类里添加新方法，而不需要去为他添加一个子类。新方法在编译的时候添加，它能像这个类的扩展方法一样正常执行。一个装饰器跟类的定义稍微有点不同的就是，因为装饰器不能被实例化，它只是一个扩展。</p>

<pre><code>提示：除了你自己类的扩展，你还可在任何 Cocoa 类里的扩展添加方法。
</code></pre>

<h3>如何使用分类</h3>

<p>现在你有一个 Album 对象，你需要把它显示在一个表单视图里(table view)：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-category1.png" alt="1" /></p>

<p>专辑的标题从哪里来？Album 只是一个模型对象，它才不会去关心你如果去显示这些数据。为了这些，你需要给 Album 类添加一些额外的代码，但是请不要直接修改这个类。</p>

<p>你现在就需要为 Album 添加一个分类 (category) 的扩展；它将定义一个新地方法用来返回一个数据结构，这个数据结构可以很容易的被 UITableViews 使用。</p>

<p>这个数据结构看起来如下：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/delegate2-480x67.png" alt="2" /></p>

<p>为 Album 添加一个分类，导航 File\New\File… 选择 Object-C category 模版─不要习惯的去选择 Object-C class，在 Category 后面输入 TableRepresentation，Category to 后面输入 Album。</p>

<pre><code>提示：你有没有注意这个新文件的名字？Album+TableRepresentation 说明它是 Album 类的一个扩展。这个习惯很重要，因为第一这很容易读，第二防止你或者其他人创建的分类跟其冲突。
</code></pre>

<p>打开 Album+TableRepresentation，加入下面的方法原型：</p>

<pre><code>- (NSDictionary*)tr_tableRepresentation;
</code></pre>

<p>注意，这是一个 tr_ 开头的方法名，就像是这个分类名字的缩写一样：TableRepresentation。其次，这个习惯会避免这个方法跟其它方法重名！</p>

<pre><code>提示：如果分类 (Category) 声明的一个方法跟原始类的一个方法重名，或者跟同类里的的另一个分类名字重复（或者是它的父类），当它在运行的时候，它就不知道要执行哪个方法。如果是在你自己类的分类里，它不太可能出现大的问题，但是如果一个标准 Cocoa 或者 Cocoa Touch 类里面添加这个分类的方法，就可能会引起严重的问题。
</code></pre>

<p>打开 Album+TableRepersentation.m 文件添加下面的方法：</p>

<pre><code>- (NSDictionary*)tr_TableRepersentation
{
    return @{@"titles":@[@"Artist", @"Album", @"Genre", @"Year"],
            @"values":@[self.artist, self.title, self.genre, self.year]};
};
</code></pre>

<p>考虑一会，为什么这种模式如些强大：</p>

<ul>
<li>你能够直接使用 Album 的属性。</li>
<li>你已经添加在 Album 类里，但它并不是它的子类。如果子类需要，你同样也可以这样做。</li>
<li>这样一个简单的添加，Album 类的数据返回一个 UITableView 可用的数据结构，但并不需要修改 Album 的代码。</li>
</ul>


<p>苹果在基础类里大量的使用了分类设计模式。去看看他们是怎么做的，打开 NSString.h。找到 @interface NSString，你将会看到这个类定义了三个分类：NSStringExtensionMethods, NSExtendedStringPropertyListParsing 和 NSStingDeprecated。在代码片里，分类将帮助你保持方法的组织性和分离必。</p>

<h3>委托 Delegation</h3>

<p>另外一种装饰器的设计模式是，委托 (Delegation)，它是一种机制，一个对象代表另外一个对象或者其相互合作。例子，当你使用 UITableView 的时候，其中一个方法是你必需要执行的，tableView:numberOfRowsInSection:。</p>

<p>你可能并不期望 UITableView 知道每个 section 中有多少行，这是程序的特性。因此，计算每个 section 有多少行的工作就交给了 UITableView 的委托 (delegate)。它允许 UITableView 类不依赖它显示的数据。</p>

<p>当你创建了一个新的 UITableView 的时候，这里有一个类似的解释：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/delegate-480x252.png" alt="3" /></p>

<p>UITableView 对象的工作就是显示一个表单视图。然而，最终它都需要一些它信息，它并不拥有这些信息。然后，它会转向它的委托，发送一个添加信息的消息。在 Object-C 中实现委托模式，一个类可以通过协议 (protocol) 来声明一个可选和必选的方法。稍后，在这个教程你将覆盖一个协议 (protocols)。</p>

<p>它看起来比子类更容易，覆盖需要的方法，但是考虑如果是单类的话你只能创建子类。如果你想一个对象委托两个或者多个对象的时候，子类化的方法是不能实现的。</p>

<pre><code>提示：这是一个很重要的模式。苹果在 UIKit 类中大量的使用了此方法：UITableView, UITextView, UITextField, UIWebView, UIAlert, UIActionSheet, UICollectionView, UIPickerView, UIGestureRecognizer, UIScrollView。这个列表还可以有很多。
</code></pre>

<h3>如何使用委托模式</h3>

<p>打开 ViewController.m，在顶部引入如下文件</p>

<pre><code>#import "LibraryAPI.h"
#import "Album+TableRepresentation.h"
</code></pre>

<p>现在，在类的扩展里的添加一些私有变量，它们看起来如下：</p>

<pre><code>@interface ViewController (){
    UITableView *dataTable;
    NSArray *allAlbums;
    NSDictionary *currentAlbumData;
    int currentAlbumIndex;
}
@end
</code></pre>

<p>现在，替换类扩展里的 @interface 这一行，完成后如下：</p>

<pre><code>@interface ViewController () &lt;UITableViewDataSoure, UITableViewDelegate&gt; {
</code></pre>

<p>这就是如何设置一个正确的委托─把它相象成允许一个委托来履行一个方法的合同。这里，表明 ViewController 将会遵照 UITableViewDataSource 和 UITableViewDelegate 协议。这种方法下 UITableView 必须执行它自己的委托方法。</p>

<p>下面，用下面的代码替换 viewDidLoad:</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // 1
    self.view.backgroundColor = [UIColor colorWithRed:0.76f green:0.81f blue:0.87f alpha:1];
    currentAlbumIndex = 0;

    //2
    allAlbums = [[LibraryAPI sharedInstance] getAlbums];

    // 3
    // the uitableview that presents the album data
    dataTable = [[UITableView alloc] initWithFrame:CGRectMake(0, 120, self.view.frame.size.width, self.view.frame.size.height-120) style:UITableViewStyleGrouped];
    dataTable.delegate = self;
    dataTable.dataSource = self;
    dataTable.backgroundView = nil;
    [self.view addSubview:dataTable];
}
</code></pre>

<p>这里分析下上面的代码：</p>

<ol>
<li>把背景色改为漂亮的深蓝色。</li>
<li>从 API 获取一个列表，它包含所有的专辑数据。不能直接使用 PersistencyManager。</li>
<li>创建一个 UITableView。你声明了视图控制器是 UITableView delegate/data source；因此，UITableView 将会提供视图控制器需要的所有信息。</li>
</ol>


<p>现在，在 ViewController.m 里面添加如下方法：</p>

<pre><code>- (void)showDataForAlbumAtIndex:(int)albumIndex{
    // defensive code: make sure the requested index is lower than the amount of albums
    if (albumIndex &lt; allAlbums.count) {
        // fetch the album
        Album *album = allAlbums[albumIndex];
        // save the albums data to present it later in the tableview
        currentAlbumData = [album tr_tableRepresentation];
    } else {
        currentAlbumData = nil;
    }

    // we have the data we need, let's refresh our tableview
    [dataTable reloaddata];
}
</code></pre>

<p>showDataForAlbumAtIndex: 从专辑数组中取出需要的专辑数据。当你需要显示新数据的时候，你只需要重载数据 (relaodData)。这是因为 UITableView 需要请求它的委托代理，像有多少 sections 将会在表单视图中显示，每个 section 中有多少行，每行看起来是什么样的。</p>

<p>在 viewDidLoad 中添加下面代码</p>

<pre><code>[self showDataForAlbumAtIndex:currentAlbumIndex];
</code></pre>

<p>当程序运行的时候它会加载当前的专辑信息。由于 currentAlbumIndex 的预设值为 0，所以会显示收藏中的第一张专辑信息。</p>

<p>构建并运行你的项目，你的程序会崩溃掉，在控制台会输入如下的异常：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/2013-09-01_15-57-32-700x112.png" alt="4" /></p>

<p>出现什么问题了？你已经声明了 ViewController 中的 UItableView 的委托(delegate)和数据源(data source)。但是在这种情况下，你必需执行所有的必需方法─包含 tableView:numberOfRowsInsection:─你现在还没有它。</p>

<p>在 ViewContrller.m 的 @implementation 和 @end 的任何地方添加如下代码：</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return [currentAlbumData[@"titles"] count];
}

- (UITableViewCell*)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"];
    if (!cell) {
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:@"cell"];
    }

    cell.textLabel.text = currentAlbumData[@"titles"][indexPath.row];
    cell.detailTextLabel.text = currentAlbumData[@"values"][indexPath.row];

    return cell;
}
</code></pre>

<p>tableView:numberOfRowsIndexSection: 返回表单视图显示的行数，匹配数据结构中标题的数目。</p>

<p>tableView:cellForRowAtIndexPath: 创建并返回一个带标题和信息的 cell。</p>

<p>现在构建并运行你的项目。你的程序开始运行并显示出下图的界面：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage1.png" alt="5" /></p>

<p>这目前为止事情看起来很不错。但是如果你回过去看第一张图片的时候，你会发现在屏幕的顶端有一个可以水平滚动的视图，用于切换专辑。它只是简单的水平滚动，为什么不做一个可以重复使用的视图来代替它呢。</p>

<p><img src="%E8%BF%99%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E4%BA%8B%E6%83%85%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E4%B8%8D%E9%94%99%E3%80%82%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%9B%9E%E8%BF%87%E5%8E%BB%E7%9C%8B%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0%E5%9C%A8%E5%B1%8F%E5%B9%95%E7%9A%84%E9%A1%B6%E7%AB%AF%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%A7%86%E5%9B%BE%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%88%87%E6%8D%A2%E4%B8%93%E8%BE%91%E3%80%82%E5%AE%83%E5%8F%AA%E6%98%AF%E7%AE%80%E5%8D%95%E7%9A%84%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%86%E5%9B%BE%E6%9D%A5%E4%BB%A3%E6%9B%BF%E5%AE%83%E5%91%A2%E3%80%82" alt="6" /></p>

<p>这个可以重复使用的视图 (view)，它所有的内容都由另一个对象来管理：委托 (delegate)。这个水平滚动区域需要声明一个方法，一个为滚动区域工作的代理工具，就像 UITableView 代理方法如何工作一样。当我讨论下一个设计模式时将会实施它。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Facade – 外观模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/"/>
    <updated>2015-06-15T10:06:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi</id>
    <content type="html"><![CDATA[<p>目前你有 PersistencyManager 来在本地存储专辑数据，HTTPClient 处理远程通信。项目中其它的类跟这些逻辑都没关。</p>

<p>执行这个<a href="http://www.superqq.com/blog/2015/03/21/dan-li-mo-shi-de-xie-fa/">模式</a>，只有 LibraryAPI 来保存 PersistencyManager 和 HTTPClient 的实例。之后，LibraryAPI 将会公开一个简单的 API 来访问这些服务。</p>

<pre><code>提示：通常，单例存在 app 的整个生命周期。不需一直使用很多指针指向其它对象，因为她们直到程序关闭后才会被释放。   
</code></pre>

<p>这个设计就像下图：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-facade-uml-480x71.png" alt="icon" /></p>

<p>LibraryAPI 将会公开给其它代码，但是它隐藏了 APP 中 HTTPClient 和 PersistencyManager 的复杂部分。</p>

<p>打开 LibraryAPI.h，在顶部引入面文件：</p>

<pre><code>#import "Album.h"
</code></pre>

<p>接下来，在 LibraryAPI.h下面添加如下方法：</p>

<pre><code>- (NSArray*)getAlbums;
- (void)addAlbum:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></pre>

<p>现在，这些方法都公开给了其它类。</p>

<p>在 LibraryAPI.m 文件引入如下两个文件：</p>

<pre><code>#import "PersistencyManager.h"
#import "HTTPClient.h"
</code></pre>

<p>只有在这个地方你才会需要引入这些类。记住：你的 API 将会是你「复杂」系统的唯一的接入点。</p>

<p>现在添加一些私有属性在你的类的扩展里（在 @implementation 上面）</p>

<pre><code>@interface LibraryAPI () {
    PersistencyManager *persistencyManager;
    HTTPClient *httpClient;
    BOOL isOnline;
}
@end
</code></pre>

<p>isOnline 用来判断，如果专辑列表数据发生变化是否能够更新到服务器，例如添加或者删除专辑。</p>

<p>你现在需要在 init 方法中初始化这些变量，在 LibraryAPI.m 中添加下面代码：</p>

<pre><code>- (id)init
{
    self = [super init];
    if (self) {
        persistencyManager = [[PersistencyManager alloc] init];
        httpClient = [[HTTPClient alloc] init];
        isOnline = NO;
    }
    return self;
}
</code></pre>

<p>这个 HTTP 客户端在这里并不真正的工作，它只是在外观设计里面起一个示范用法的作用，所以 isOnline 永远是 NO 了。</p>

<p>接下来，在 LibraryAPI.m 里面添加下面三个方法：</p>

<pre><code>- (NSArray*)getAlbums
{
    return [persistencyManager getAlbums];
}

- (void)addAlbum:(Album*)album atIndex:(int)index
{
    [persistencyManager addAlbum:album atIndex:index];
    if (isOnline)
    {
        [httpClient postRequest:@"/api/addAlbum" body:[album description]];
    }
}

- (void)deleteAlbumAtIndex:(int)index
{
    [persistencyManager deleteAlbumAtIndex:index];
    if (isOnline)
    {
        [httpClient postRequest:@"/api/deleteAlbum" body:[@(index) description]];
    }
}
</code></pre>

<p>看一下 addAlbum:atIndex:。这个类首先更新本地数据，如果联网，它再更新远端服务器。这就是外观设计的长处；当一些系统外的类添加了一个新专辑，它不知道─也不需要知道─复杂的内部系统。</p>

<pre><code>提示：当在你的子系统里设计一个外观类的时候，记住没有任何东西可能阻止客户访问这些「隐藏」类。要多写些防御性的代码，不要想当然的认为所有客户都会用同样的方式使用你的外观类。
</code></pre>

<p>运行你的程序，你会看一个黑底空白内容的屏幕，像下面这样：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/2013-09-01_12-08-44-211x320.png" alt="icon1" /></p>

<p>你需要在屏幕上显示一些专辑数据─这就需要使用到下面一个设计模式：装饰器 (Decorator)。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Singleton – 单例模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/"/>
    <updated>2015-06-13T08:21:55+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi</id>
    <content type="html"><![CDATA[<p><a href="http://www.superqq.com/blog/2015/03/21/dan-li-mo-shi-de-xie-fa/">单例设计模式</a>确切的说就是一个类只有一个实例，有一个全局的接口来访问这个实例。当第一次载入的时候，它通常使用延时加载的方法创建单一实例。</p>

<pre><code>提示：苹果大量的使用了这种方法。例子：[NSUserDefaults standerUserDefaults], [UIApplication sharedApplication], [UIScreen mainScreen], [NSFileManager defaultManager] 都返回一个单一对象。
</code></pre>

<p>你可能想知道你为什么要关心一个类有多个的实例。代码和内存都很便宜，不是吗？</p>

<p>在一些情况下，一个类只有一个实例是有意义的。例如，这里没有必要有多个登录实例，除非你一次想写入多个日志文件。或者，一个全局的配置类文件：它可以很容易的很安全的执行一个公共资源，这样的一个配置文件，要比同时修改多个配置类文件好很多。</p>

<h3>如何使用单例模式</h3>

<p>请看下面的图片</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/08/singleton.png" alt="icon" /></p>

<p>上面的图片显示的是一个登录类，它有一个属性（这个单一实例），有两个方法：sharedInstance 和 init。</p>

<p>首先一个客户端(client)发送 sharedInstance 信息，但是属性 instance 还没有初始化，所以你要先给这个类创建一个实例。</p>

<p>然后你调用 sharedInstance，instance 会马上返回初始化的值。这个逻辑最终只会返回一个实例。</p>

<p>你需要执行这个模式来创建单例类来管理所有的专辑数据。</p>

<p>你需要注意在项目里有一个叫 API 文件夹，给你的 APP 提供服务的所有类都需要放在这里。在这个文件夹里用 iOS\Cocoa Touch\Object-C class 创建一个新类。类的名字叫 LibraryAPI，子类选择 NSObject。</p>

<p>打开 LibraryAPI.h 文件用下面的代码替换里面的内容：</p>

<pre><code>@interface LibraryAPI: NSObject
+ (LibraryAPI*)sharedInstance;
@end
</code></pre>

<p>现在打开 LibraryAPI.m 文件，在 @implentation 后面添加如下方法：</p>

<pre><code>+ (LibraryAPI*)sharedInstance 
{
    // 1
    static LibraryAPI *_sharedInstance = nil;

    // 2 
    static dispatch_once_t oncePredicate; 

    // 3
    dispatch_once(&amp;nocePredicate, ^{
        _sharedInstance = [[LibraryAPI alloc] init];
    });
    return _sharedInstance;
}
</code></pre>

<p>在这个短方法中做了这些事情：</p>

<ul>
<li>在这个类中，声明一个静态变量来保存这个实例，保证它是一个全局可用的变量。</li>
<li>声明一个静态这是 dispatch_one_t，确保这些初始化代码只能被执行一次。</li>
<li>使用 Grand Central Dispatch（GCD）执行一个 block 来初始化 LibraryAPI 实例。这是单例设计模式的关键所在：一个类只能被实例化一次。</li>
</ul>


<p>接下来执行 sharedInstance，在 dispatch_once block 里的代码是不会被执行的（当它已经被执行过一次后），它会返回之前创建的 LibraryAPI 实例。</p>

<pre><code>提示：想了解更多关于 GCD 和使用它，请点击这里的教程 Multithreading and Grand Central Dispatch，如何使用 Blocks 在这里。
</code></pre>

<p>你现在有一个单例对象来管理专辑了。下一步就是创建一个类用来保存你的专辑数据了。</p>

<p>用 iOS\Cocoa Touch\Object-C class 在 API 文件夹下创建一个新的类，名字叫 PersistencyManager，子类选择 NSObject。</p>

<p>打开 PersistencyManager.h，在顶部引入面文件：</p>

<pre><code>#import "Album.h"
</code></pre>

<p>然后在 @interface 后面加入下面代码：</p>

<pre><code>- (NSArray *)getAlbums;
- (void)addAlbums:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></pre>

<p>上面的三个方法都需要跟专辑的数据相结合。</p>

<p>打开 PersistencyManager.m，在 @implementation 上面添加如下代码：</p>

<pre><code>@interface PersistencyManager () {
    NSMutableArray *albums;
}
</code></pre>

<p>上面的代码是给类添加了一个扩展，这是另一种给类添加私有方法和私有属性的方法，类外面的成员是看不到这些的。这里，你声明了一个 NSMutableArray 来保存专辑的数据。这是一个可变数组，你可以很容易的添加和删除专辑。</p>

<p>现在在 @implementation 下面添加实现代码：</p>

<pre><code>- (id)init {
    self = [super init];
    if (self) {
        albums = [NSMutableArray arrayWithArray:@[[[Album alloc] initWithTitle:@"Best of Bowie" artist:@"David Bowie" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png" year:@"1992"],
        [[Album alloc] initWithTitle:@"It's My Life" artist:@"No Doubt" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png" year:@"2003"],
                [[Album alloc] initWithTitle:@"Nothing Like The Sun" artist:@"Sting" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png" year:@"1999"],
            [[Album alloc] initWithTitle:@"Staring at the Sun" artist:@"U2" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png" year:@"2000"],
                [[Album alloc] initWithTitle:@"American Pie" artist:@"Madonna" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png" year:@"2000"]]];
    }
    return self;
}
</code></pre>

<p>在 init 里你在数组中加入了 5 张专辑。如果上面的专辑你不喜欢，你可以随意替换成你喜欢的。:]</p>

<p>现存在 PersistencyManager.m 添加下面三个方法：</p>

<pre><code>- (NSArray*)getAlbums
{
        return albums;
}

- (void)addAlbum:(Album*)album atIndex:(int)index
{
        if (albums.count &gt;= index)
            [albums insertObject:album atIndex:index];
        else
        [albums addObject:album];
}

- (void)deleteAlbumAtIndex:(int)index
{
        [albums removeObjectAtIndex:index];
}
</code></pre>

<p>这些方法是获取，添加，删除专辑。</p>

<p>Build 你的项目，确保所有的代码都能正确编译。</p>

<p>现在，你也许想知道为什么会有一个 PersistencyManager 类，因为它都不是单例类。不要着急，接下来第二步，外观设计模式(Facade design patten) 将会探讨 LibraryAPI 和 PersistencyManager 之间的关系。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：MVC – 设计模式中的国王]]></title>
    <link href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/"/>
    <updated>2015-06-11T13:41:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang</id>
    <content type="html"><![CDATA[<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/07/mvcking.png" alt="icon" /></p>

<p>模型(Model) 视图(View) 控制器(Controller) (<a href="http://www.superqq.com/blog/2014/11/10/qian-xi-mvche-shuo-mei-de-guo-cheng/">MVC</a>) 是 Cocoa 中的一种行为模块，并且也是所有 Cocoa 设计模式中使用最多的。在程序中按照它们的角色来分类这些对象并且鼓励你的基础代码也按照这个来划分。</p>

<p>这三种角色是：</p>

<ul>
<li>模型：这是一种暂时保存你程序数据和定义如何操作它的对象。一个例子，在你的程序中 Album 类就是一个模型。</li>
<li>视图：这种对象是控制模型里的数据如何显示出来的，用户也可操作这些对象；事实上，包含所有的 UIView 和他们的子类。在你的程序中视图是 AlbumView 类。</li>
<li>控制器：控制器是一个中介者协调所有的工作。他使数据从模型传出来然后显示在视图上，监听事件，在必要的时候操作数据。你能猜到哪个类你的控制器吗？对了，它就是 ViewController。</li>
</ul>


<p>在你的程序中一个好的设计模式的实现意味者所有的对象都在这些群组中。</p>

<p>下图很好的描述了视图和模型之间的通信过程：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/07/mvc0.png" alt="icon" /></p>

<p>当有数据发生改变的时候模型通知控制器，然后控制器更新视图数据。 反过来，当用户在视图执行一些操作后，视图会通知控制器，如果有需要或是要取回请求数据，控制器也会更新模型或者。</p>

<p>你可能想我为什么不能丢掉控制器，在同一个类里实现视图和模型，这样看起来更简单。</p>

<p>归根结底，这是为是分离代码和提高代码的可重用性。理想状态下视图应该完全从模型中分离出来。如果视图不依赖一个特殊的模型来实现，那么另外一个模型就可以重复利用这个视图显示一些其它不同的数据。</p>

<p>举一个例子，在将来某一天你想在你的音乐库中加入一些电影或者一些书，你可以继续使用原来的 AlbumView 视图来显示这个电影或者图书对象。此外，如果你想创建一个新项目，这个项目中的一些东西跟音乐专辑有关，你可以很简单的拿来重用 Album 类，因为它不依赖于其它任何视图。这就是 MVC 的精髓所在。</p>

<h3>如何使用 MVC 模式</h3>

<p>首先，你要保证在你的项目中任何一个类都有一个控制器，一个模型，一个视图，一个类中的函数不能有两种作用。到目前为至，你已经完成了一项很棒的工作，创建了一个 Album 类和一个 AlbumView 类。</p>

<p>第二步，根据这些方法的作用你应该创建三个文件夹，来存放不同类别的代码，每种类型一个文件夹。</p>

<p>在菜单上选择 File\New\Group (或者按 Command+Option+N) ，创建名称为 Model，重复上面的动作，创建 View 和 Controller 文件夹。</p>

<p>现在拖动 Album.h 和 Album.m 文件到 Model 文件夹。拖动 AlbumView.h 和 AlbumView.m 文件到 View 文件夹，最后拖动 ViewController.h 和 ViewController.m 文件到 Controller 文件夹中。</p>

<p>现在，项目文件的结构目录应该是这个样子的：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/07/mvc2-255x320.png" alt="icon" /></p>

<p>如果没有其它的文件漂在外面，你的项目看起来已经非常棒了。显然你还可能有其它的文件夹和类，但是你程序的核心内容应该包含在这三个分类中。</p>

<p>现在你的文件已经组织好了，你需要从其它地方获取专辑数据了。你需要创建一个 API 类用来管理你的代码的数据来源 — 现在是机会开始讨论下一个设计模式了 — 单例模式(The Singleton Pattern)。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：开篇]]></title>
    <link href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/"/>
    <updated>2015-06-10T15:10:13+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.raywenderlich.com/46988/ios-design-patterns">iOS Design Patterns</a></p>

<p>原文作者：Eli Ganem</p>

<blockquote><p>有些专业词汇很难翻译准确，就不翻译了。如果英文阅读没有障碍，还是鼓励大家都读原作。</p></blockquote>

<p>iOS 设计模式 – 你大概经常听过这样的术语，但是你知道它的真正意思吗？虽然大部分开发者都同意设计模式很重要，但是关于这方面的文章却很少，开发者在写代码的时候，有时候并不会去花很多时间去考虑设计模式。</p>

<p>设计模式的功能是在软件设计当中是解决一些重复的公共问题。他们是一些模板来帮助你更容易的书写代码和复用你的代码。他们还可能帮助你创建低耦合的代码，你可以很轻松的修改和替换其中的组件。</p>

<p>如果你已经很熟习设计模式了，我这里有一些好的建议。首先，你已经使用了大量由 Cocoa 创建 iOS 设计模式，同时最好的练习就是去使用她们。第二，这个教程将带给你全面了解所有最新的 iOS 设计模式，她们一般都是由 Cocoa 编写的。</p>

<p>这个教程被分成几个小节。在每一个小节里， 你都能在下面读到说明：</p>

<ul>
<li>什么是设计模式</li>
<li>为什么你应该用她</li>
<li>怎么用，在哪里用，在使用当中如何注意一些常见的陷阱</li>
</ul>


<p>在这个教程中，你将要创建一个音乐库的 APP，它能够显示你的音乐专辑和一些相关信息。</p>

<p>在开发这个 APP 的过程当中，你将会了解到很多常见的 Cocoa 设计模式。</p>

<ul>
<li>创建 (Creational)：单例 (Singleton)和抽象工厂 (Abstract Factory)</li>
<li>结构 (Structural)：MVC，装饰器 (Decorator)，适配器 （Adapter)，外观 (Facade)和复合器 (Composite)</li>
<li>行为 (Behavioral)：观察者 (Observer)，备忘录 (Memento)，责任链 (Chain of Responsibility)和命令 (Command)</li>
</ul>


<p>不要被带偏了，这只是一篇理论文章；你将会在你的音乐 APP 中使用很多的设计模式。在这个教程的最后，你的 APP 看来应该是像这个样子的：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/07/finalapp-180x320.png" alt="icon" /></p>

<h3>入门指南</h3>

<p>下载 <a href="http://cdn2.raywenderlich.com/wp-content/uploads/2013/07/BlueLibrary-Starter.zip" target="_blank" title="启动项目">启动项目</a>，从 ZIP 文件中提取文件，用 Xcode 打开 BlueLibrary.xcodeproj。</p>

<p>这没有多少文件，仅仅只有一个默认的 ViewController 文件和一个空的可执行的简单 HTTP 客户端。</p>

<pre><code>提示：你知道吗，当你创建一个新的 Xcode 项目的时候，你的代码已经使用被设计模式？MVC，代理，协议，单例模式 ─ 这些你都能免费得到！:]
</code></pre>

<p>在你开始研究第一个设计模式时，你必须创建两个类用于存储和显示专集数据。</p>

<p>从”File\New\File…”（或者使用快捷键 Command + N）。选择 iOS > Cocoa Touch，然后选择 Objective-C class 后点击 Next。设置类的名称为 Album，子类为 NSObject。点击 Next 创建。</p>

<p>打开 Album.h 文件，在 @interface 和 @end 这间添加下面的属性和方法原型：</p>

<pre><code>@propery (nonatomic, copy, readonly) NSString *title, *artist, * genre, *coverUrl, *year;
- (id)initWithTitle:(NSString *)title artist:(NSString *)artist coverUrl:(NSString *)coverUrl year:(NSString *)year;
</code></pre>

<p>注意这里的所有属性都是 readonly，Album 对象被创建后是不能够被修改的。</p>

<p>这个方法是用来初始化对象的。当你创建一个新专辑时，需要提供专辑名称，作者，封面 URL 和年份。</p>

<p>现在打开 Album.m 文件然后在 @implementation 和 @end 之间加入如下代码：</p>

<pre><code>- (id)initWithTitle:(NSString*)title artist:(NSString*)artist coverUrl:(NSString*)coverUrl
{
    self = [super init];
    _title = title;
    _artist = artist;
    _coverUrl = coverUrl;
    _year = year;
    _genre = @"Pop";
    return self;
}
</code></pre>

<p>这里没有什么复杂的，只是一个简单的创建 Album 实例的初始化方法。</p>

<p>现次从菜单 File\New\File 选择中 Cocoa Touch，然后选择 Object-C class，点击 Next。设置类的名称为 AlbumView，子类为 UIView。点击 Next 创建文件。</p>

<pre><code>提示：如果你会使用快捷键，创建这些会更容易，Command+N 创建新文件，Command+Option+N 创建新的文件夹，Command+B 创建新项目，Command+R 运行项目。
</code></pre>

<p>打开 AlbumView.h，在 @interface 和 @end 中 添加一个方法原型</p>

<pre><code>- (id)initWithFrame:(CGRect)fram albumCover:(NSString*)albumCover;
</code></pre>

<p>现在打开 AlbumView.m 文件，用下面代码替换 @implementaton 后面的所有代码：</p>

<pre><code>@implementation AlbumView
{
    UIImageView *coverImage;
    UIActivityIndicatorView *indicator;
}

- (id)initWithFrame:(CGRect)frame albumCover:(NSString*)albumCover
{
    self = [super initWithFrame:frame];
    if (self) {
        self.backgroundColor = [UIColor blackColor];
        // the coverImage has a 5 pixels margin from its frame
        coverImage = [[UIImageView alloc] initWithFrame:CGRectMake(5, 5, frame.size.width-10, frame.size.height-10)];
        [self addSubview:coverImage];

        indicator = [[UIActivityIndicatorView alloc] init];
        indicator.center = self.center;
        indicator.activityIndicatorViewStyle = UIActivityIndicatorViewStyleWhiteLarge;
        [indicator startAnimating];
        [self addSubview:indicator];
        }
    return self;
}

@end
</code></pre>

<p>第一个需要注意的地方是 coverImage 是一个实例变量。这个变量代表专集的封面图片。第二个变量是一个提示器，在封面图片开始下载的时候提示用户正在下载。</p>

<p>在初始化的过程中你需要设置背景为黑色，创建一个比封面图片大 5px 的图片视图，再创建和添加一个活动指示器。</p>

<pre><code>提示：为什么私有变量定义在执行文件而不是定义在接口文件？这是因为其它外部类不需要知道 AlbumView 类里的这些变量，这些变量只会在这个类的内部方法中使用到。如果你要开发一些库或者框架给别的开发者使用，遵守这个习俗是非常重要的。
</code></pre>

<p>Build 你的项目确保所有代码都能构运行。没有问题？你的第一个设计模式已经准备好了。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SDWebImage加载图片缓存图片]]></title>
    <link href="http://www.superqq.com/blog/2015/06/09/sdwebimagejia-zai-tu-pian-huan-cun-tu-pian/"/>
    <updated>2015-06-09T17:47:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/09/sdwebimagejia-zai-tu-pian-huan-cun-tu-pian</id>
    <content type="html"><![CDATA[<ul>
<li>关注公众号iOS开发：<strong>iOSDevTip</strong> 获取更多源代码。</li>
</ul>


<p> <a href="https://github.com/rs/SDWebImage.git"target="_blank"title="源代码">源代码</a></p>

<h1> Web Image</h1>

<p><a href="https://travis-ci.org/rs/SDWebImage"><img src="http://img.shields.io/travis/rs/SDWebImage/master.svg?style=flat" alt="Build Status" /></a>
<a href="http://cocoadocs.org/docsets/SDWebImage/"><img src="http://img.shields.io/cocoapods/v/SDWebImage.svg?style=flat" alt="Pod Version" /></a>
<a href="http://cocoadocs.org/docsets/SDWebImage/"><img src="http://img.shields.io/cocoapods/p/SDWebImage.svg?style=flat" alt="Pod Platform" /></a>
<a href="https://www.apache.org/licenses/LICENSE-2.0.html"><img src="http://img.shields.io/cocoapods/l/SDWebImage.svg?style=flat" alt="Pod License" /></a>
<a href="https://www.versioneye.com/objective-c/sdwebimage/3.3"><img src="https://www.versioneye.com/objective-c/sdwebimage/3.3/badge.svg?style=flat" alt="Dependency Status" /></a>
<a href="https://www.versioneye.com/objective-c/sdwebimage/references"><img src="https://www.versioneye.com/objective-c/sdwebimage/reference_badge.svg?style=flat" alt="Reference Status" /></a>
<a href="https://github.com/rs/SDWebImage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible" /></a></p>

<p>This library provides a category for UIImageView with support for remote images coming from the web.</p>

<p>It provides:</p>

<ul>
<li>An UIImageView category adding web image and cache management to the Cocoa Touch framework</li>
<li>An asynchronous image downloader</li>
<li>An asynchronous memory + disk image caching with automatic cache expiration handling</li>
<li>Animated GIF support</li>
<li>WebP format support</li>
<li>A background image decompression</li>
<li>A guarantee that the same URL won&rsquo;t be downloaded several times</li>
<li>A guarantee that bogus URLs won&rsquo;t be retried again and again</li>
<li>A guarantee that main thread will never be blocked</li>
<li>Performances!</li>
<li>Use GCD and ARC</li>
<li>Arm64 support</li>
</ul>


<p>NOTE: The version 3.0 of SDWebImage isn&rsquo;t fully backward compatible with 2.0 and requires iOS 5.1.1
minimum deployement version. If you need iOS &lt; 5.0 support, please use the last <a href="https://github.com/rs/SDWebImage/tree/2.0-compat">2.0 version</a>.</p>

<p><a href="https://github.com/rs/SDWebImage/wiki/How-is-SDWebImage-better-than-X%3F">How is SDWebImage better than X?</a></p>

<h2>Who Use It</h2>

<p>Find out <a href="https://github.com/rs/SDWebImage/wiki/Who-Uses-SDWebImage">who uses SDWebImage</a> and add your app to the list.</p>

<h2>How To Use</h2>

<p>API documentation is available at <a href="http://cocoadocs.org/docsets/SDWebImage/">CocoaDocs - SDWebImage</a></p>

<h3>Using UIImageView+WebCache category with UITableView</h3>

<p>Just #import the UIImageView+WebCache.h header, and call the sd_setImageWithURL:placeholderImage:
method from the tableView:cellForRowAtIndexPath: UITableViewDataSource method. Everything will be
handled for you, from async downloads to caching management.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#import &lt;SDWebImage/UIImageView+WebCache.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="bp">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nl">tableView</span><span class="p">:(</span><span class="bp">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="n">tableView</span> <span class="nl">cellForRowAtIndexPath</span><span class="p">:(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="n">indexPath</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">MyIdentifier</span> <span class="o">=</span> <span class="s">@&quot;MyIdentifier&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UITableViewCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableView</span> <span class="nl">dequeueReusableCellWithIdentifier</span><span class="p">:</span><span class="n">MyIdentifier</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">cell</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">cell</span> <span class="o">=</span> <span class="p">[[[</span><span class="bp">UITableViewCell</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithStyle</span><span class="p">:</span><span class="n">UITableViewCellStyleDefault</span>
</span><span class='line'>                                       <span class="nl">reuseIdentifier</span><span class="p">:</span><span class="n">MyIdentifier</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Here we use the new provided sd_setImageWithURL: method to load the web image</span>
</span><span class='line'>    <span class="p">[</span><span class="n">cell</span><span class="p">.</span><span class="n">imageView</span> <span class="nl">sd_setImageWithURL</span><span class="p">:[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span><span class="p">]</span>
</span><span class='line'>                      <span class="nl">placeholderImage</span><span class="p">:[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;placeholder.png&quot;</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">textLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@&quot;My Text&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Using blocks</h3>

<p>With blocks, you can be notified about the image download progress and whenever the image retrival
has completed with success or not:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// Here we use the new provided sd_setImageWithURL: method to load the web image</span>
</span><span class='line'><span class="p">[</span><span class="n">cell</span><span class="p">.</span><span class="n">imageView</span> <span class="nl">sd_setImageWithURL</span><span class="p">:[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span><span class="p">]</span>
</span><span class='line'>                      <span class="nl">placeholderImage</span><span class="p">:[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;placeholder.png&quot;</span><span class="p">]</span>
</span><span class='line'>                             <span class="nl">completed</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">,</span> <span class="n">SDImageCacheType</span> <span class="n">cacheType</span><span class="p">,</span> <span class="bp">NSURL</span> <span class="o">*</span><span class="n">imageURL</span><span class="p">)</span> <span class="p">{...</span> <span class="n">completion</span> <span class="n">code</span> <span class="n">here</span> <span class="p">...}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note: neither your success nor failure block will be call if your image request is canceled before completion.</p>

<h3>Using SDWebImageManager</h3>

<p>The SDWebImageManager is the class behind the UIImageView+WebCache category. It ties the
asynchronous downloader with the image cache store. You can use this class directly to benefit
from web image downloading with caching in another context than a UIView (ie: with Cocoa).</p>

<p>Here is a simple example of how to use SDWebImageManager:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">SDWebImageManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[</span><span class="n">SDWebImageManager</span> <span class="n">sharedManager</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">manager</span> <span class="nl">downloadImageWithURL</span><span class="p">:</span><span class="n">imageURL</span>
</span><span class='line'>                      <span class="nl">options</span><span class="p">:</span><span class="mi">0</span>
</span><span class='line'>                     <span class="nl">progress</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSInteger</span> <span class="n">receivedSize</span><span class="p">,</span> <span class="bp">NSInteger</span> <span class="n">expectedSize</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                         <span class="c1">// progression tracking code</span>
</span><span class='line'>                     <span class="p">}</span>
</span><span class='line'>                     <span class="nl">completed</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">,</span> <span class="n">SDImageCacheType</span> <span class="n">cacheType</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">finished</span><span class="p">,</span> <span class="bp">NSURL</span> <span class="o">*</span><span class="n">imageURL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                         <span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                             <span class="c1">// do something with image</span>
</span><span class='line'>                         <span class="p">}</span>
</span><span class='line'>                     <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Using Asynchronous Image Downloader Independently</h3>

<p>It&rsquo;s also possible to use the async image downloader independently:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">[</span><span class="n">SDWebImageDownloader</span><span class="p">.</span><span class="n">sharedDownloader</span> <span class="nl">downloadImageWithURL</span><span class="p">:</span><span class="n">imageURL</span>
</span><span class='line'>                                                    <span class="nl">options</span><span class="p">:</span><span class="mi">0</span>
</span><span class='line'>                                                   <span class="nl">progress</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSInteger</span> <span class="n">receivedSize</span><span class="p">,</span> <span class="bp">NSInteger</span> <span class="n">expectedSize</span><span class="p">)</span>
</span><span class='line'>                                                   <span class="p">{</span>
</span><span class='line'>                                                       <span class="c1">// progression tracking code</span>
</span><span class='line'>                                                   <span class="p">}</span>
</span><span class='line'>                                                   <span class="nl">completed</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span>
</span><span class='line'>                                                   <span class="p">{</span>
</span><span class='line'>                                                       <span class="k">if</span> <span class="p">(</span><span class="n">image</span> <span class="o">&amp;&amp;</span> <span class="n">finished</span><span class="p">)</span>
</span><span class='line'>                                                       <span class="p">{</span>
</span><span class='line'>                                                           <span class="c1">// do something with image</span>
</span><span class='line'>                                                       <span class="p">}</span>
</span><span class='line'>                                                   <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Using Asynchronous Image Caching Independently</h3>

<p>It is also possible to use the async based image cache store independently. SDImageCache
maintains a memory cache and an optional disk cache. Disk cache write operations are performed
asynchronous so it doesn&rsquo;t add unnecessary latency to the UI.</p>

<p>The SDImageCache class provides a singleton instance for convenience but you can create your own
instance if you want to create separated cache namespace.</p>

<p>To lookup the cache, you use the <code>queryDiskCacheForKey:done:</code> method. If the method returns nil, it means the cache
doesn&rsquo;t currently own the image. You are thus responsible for generating and caching it. The cache
key is an application unique identifier for the image to cache. It is generally the absolute URL of
the image.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">SDImageCache</span> <span class="o">*</span><span class="n">imageCache</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SDImageCache</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithNamespace</span><span class="p">:</span><span class="s">@&quot;myNamespace&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">imageCache</span> <span class="nl">queryDiskCacheForKey</span><span class="p">:</span><span class="n">myCacheKey</span> <span class="nl">done</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// image is not nil if image was found</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>By default SDImageCache will lookup the disk cache if an image can&rsquo;t be found in the memory cache.
You can prevent this from happening by calling the alternative method <code>imageFromMemoryCacheForKey:</code>.</p>

<p>To store an image into the cache, you use the storeImage:forKey: method:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">[[</span><span class="n">SDImageCache</span> <span class="n">sharedImageCache</span><span class="p">]</span> <span class="nl">storeImage</span><span class="p">:</span><span class="n">myImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">myCacheKey</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>By default, the image will be stored in memory cache as well as on disk cache (asynchronously). If
you want only the memory cache, use the alternative method storeImage:forKey:toDisk: with a negative
third argument.</p>

<h3>Using cache key filter</h3>

<p>Sometime, you may not want to use the image URL as cache key because part of the URL is dynamic
(i.e.: for access control purpose). SDWebImageManager provides a way to set a cache key filter that
takes the NSURL as input, and output a cache key NSString.</p>

<p>The following example sets a filter in the application delegate that will remove any query-string from
the URL before to use it as a cache key:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">SDWebImageManager</span><span class="p">.</span><span class="n">sharedManager</span><span class="p">.</span><span class="n">cacheKeyFilter</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">url</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSURL</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithScheme</span><span class="p">:</span><span class="n">url</span><span class="p">.</span><span class="n">scheme</span> <span class="nl">host</span><span class="p">:</span><span class="n">url</span><span class="p">.</span><span class="n">host</span> <span class="nl">path</span><span class="p">:</span><span class="n">url</span><span class="p">.</span><span class="n">path</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">[</span><span class="n">url</span> <span class="n">absoluteString</span><span class="p">];</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Your app init code...</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Common Problems</h2>

<h3>Using dynamic image size with UITableViewCell</h3>

<p>UITableView determines the size of the image by the first image set for a cell. If your remote images
don&rsquo;t have the same size as your placeholder image, you may experience strange anamorphic scaling issue.
The following article gives a way to workaround this issue:</p>

<p><a href="http://www.wrichards.com/blog/2011/11/sdwebimage-fixed-width-cell-images/">http://www.wrichards.com/blog/2011/11/sdwebimage-fixed-width-cell-images/</a></p>

<h3>Handle image refresh</h3>

<p>SDWebImage does very aggressive caching by default. It ignores all kind of caching control header returned by the HTTP server and cache the returned images with no time restriction. It implies your images URLs are static URLs pointing to images that never change. If the pointed image happen to change, some parts of the URL should change accordingly.</p>

<p>If you don&rsquo;t control the image server you&rsquo;re using, you may not be able to change the URL when its content is updated. This is the case for Facebook avatar URLs for instance. In such case, you may use the <code>SDWebImageRefreshCached</code> flag. This will slightly degrade the performance but will respect the HTTP caching control headers:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">[</span><span class="n">imageView</span> <span class="nl">sd_setImageWithURL</span><span class="p">:[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;https://graph.facebook.com/olivier.poitrey/picture&quot;</span><span class="p">]</span>
</span><span class='line'>                 <span class="nl">placeholderImage</span><span class="p">:[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;avatar-placeholder.png&quot;</span><span class="p">]</span>
</span><span class='line'>                          <span class="nl">options</span><span class="p">:</span><span class="n">SDWebImageRefreshCached</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Add a progress indicator</h3>

<p>See this category: <a href="https://github.com/JJSaccolo/UIActivityIndicator-for-SDWebImage">https://github.com/JJSaccolo/UIActivityIndicator-for-SDWebImage</a></p>

<h2>Installation</h2>

<p>There are three ways to use SDWebImage in your project:
- using Cocoapods
- copying all the files into your project
- importing the project as a static library</p>

<h3>Installation with CocoaPods</h3>

<p><a href="http://cocoapods.org/">CocoaPods</a> is a dependency manager for Objective-C, which automates and simplifies the process of using 3rd-party libraries in your projects. See the <a href="http://cocoapods.org/#get_started">Get Started</a> section for more details.</p>

<h4>Podfile</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="nl">platform</span> <span class="p">:</span><span class="n">ios</span><span class="p">,</span> <span class="err">&#39;</span><span class="mf">6.1</span><span class="err">&#39;</span>
</span><span class='line'><span class="n">pod</span> <span class="err">&#39;</span><span class="n">SDWebImage</span><span class="err">&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="o">~&gt;</span><span class="mf">3.7</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Installation with Carthage (iOS 8+)</h3>

<p><a href="https://github.com/Carthage/Carthage">Carthage</a> is a lightweight dependency manager for Swift and Objective-C. It leverages CocoaTouch modules and ins less invasive than CocoaPods.</p>

<p>To install with carthage, follow the instruction on <a href="https://github.com/Carthage/Carthage">Carthage</a></p>

<h4>Cartfile</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">github</span> <span class="s">&quot;rs/SDWebImage&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Usage</h4>

<p>Swift</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">import</span> <span class="n">WebImage</span>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">@</span><span class="n">import</span> <span class="n">WebImage</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Installation by cloning the repository</h3>

<p>In order to gain access to all the files from the repository, you should clone it.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">git</span> <span class="n">clone</span> <span class="o">--</span><span class="n">recursive</span> <span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/rs/SDWebImage.git</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Add the SDWebImage project to your project</h3>

<ul>
<li>Download and unzip the last version of the framework from the <a href="https://github.com/rs/SDWebImage/releases">download page</a></li>
<li>Right-click on the project navigator and select &ldquo;Add Files to &#8220;Your Project&rdquo;:</li>
<li>In the dialog, select SDWebImage.framework:</li>
<li>Check the &ldquo;Copy items into destination group&rsquo;s folder (if needed)&rdquo; checkbox</li>
</ul>


<h3>Add dependencies</h3>

<ul>
<li>In you application project app’s target settings, find the &ldquo;Build Phases&rdquo; section and open the &ldquo;Link Binary With Libraries&rdquo; block:</li>
<li>Click the &ldquo;+&rdquo; button again and select the &ldquo;ImageIO.framework&rdquo;, this is needed by the progressive download feature:</li>
</ul>


<h3>Add Linker Flag</h3>

<p>Open the &ldquo;Build Settings&rdquo; tab, in the &ldquo;Linking&rdquo; section, locate the &ldquo;Other Linker Flags&rdquo; setting and add the &ldquo;-ObjC&rdquo; flag:</p>

<p><img src="http://dl.dropbox.com/u/123346/SDWebImage/10_other_linker_flags.jpg" alt="Other Linker Flags" /></p>

<p>Alternatively, if this causes compilation problems with frameworks that extend optional libraries, such as Parse,  RestKit or opencv2, instead of the -ObjC flag use:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span><span class="nf">force_load</span> <span class="n">SDWebImage</span><span class="p">.</span><span class="n">framework</span><span class="o">/</span><span class="n">Versions</span><span class="o">/</span><span class="n">Current</span><span class="o">/</span><span class="n">SDWebImage</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you&rsquo;re using Cocoa Pods and have any frameworks that extend optional libraries, such as Parsen RestKit or opencv2, instead of the -ObjC flag use:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span><span class="nf">force_load</span> <span class="err">$</span><span class="p">(</span><span class="n">TARGET_BUILD_DIR</span><span class="p">)</span><span class="o">/</span><span class="n">libPods</span><span class="p">.</span><span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Import headers in your source files</h3>

<p>In the source files where you need to use the library, import the header file:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#import &lt;SDWebImage/UIImageView+WebCache.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Build Project</h3>

<p>At this point your workspace should build without error. If you are having problem, post to the Issue and the
community can help you solve it.</p>

<h2>Future Enhancements</h2>

<ul>
<li>LRU memory cache cleanup instead of reset on memory warning</li>
</ul>


<h2>Licenses</h2>

<p>All source code is licensed under the <a href="https://raw.github.com/rs/SDWebImage/master/LICENSE">MIT License</a>.</p>

<p><strong>更多源代码：</strong></p>

<p><a href="http://www.superqq.com/blog/2015/01/15/objective-cxiang-guan-categoryde-shou-ji/">Objective-C相关Category的收集</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/paperfold-for-ios/">PaperFold-for-iOS</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/dkcirclebutton/">DKCircleButton</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/twittercover/">TwitterCover</a></p>

<p><a href="http://www.superqq.com/blog/2015/01/07/hackernews/">HackerNews</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS KVC详细讲解]]></title>
    <link href="http://www.superqq.com/blog/2015/06/06/ios-kvcxiang-xi-jiang-jie/"/>
    <updated>2015-06-06T09:20:27+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/06/ios-kvcxiang-xi-jiang-jie</id>
    <content type="html"><![CDATA[<blockquote><p>欢迎大家提供面试题目，我们一起来讲解，以备不时之需。</p></blockquote>

<h2>什么是KVC？</h2>

<p>KVC即<strong>NSKeyValueCoding</strong>，就是键-值编码的意思。一个非正式的 Protocol，是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。</p>

<p>以上就是KVC的理论，面试时，如实回答就可以啦！</p>

<h2>使用KVC说明</h2>

<ul>
<li>KVC间接修改对象属性时，会自动判断对象属性的类型，完成相应的转换。</li>
<li>KVC按键值路径取值时，如果对象不包含指定的键值，那么就会自动进入对象内部，查找对象属性。</li>
<li>KVC可以嵌套按照键值路径取值。</li>
</ul>


<h2>KVC和KVO有什么区别？</h2>

<p>上一篇文章我们讲了<a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">iOS KVO概述</a>，有兴趣的可以看看。面试过程中，面试官问：KVC和KVO有什么区别？</p>

<p>听到这个问题真的很（dan）疼，真特么想回一句，我怎么知道什么区别？当然，如果你像这么回答，面试估计到此结束啦。</p>

<p>那KVC和KVO到底有什么区别呢？</p>

<p>KVO是建立在KVC之上的，KVO能够观察一个对象的KVC key-path值的变化。</p>

<p>iOS面试汇总：</p>

<p><a href="http://www.superqq.com/blog/2015/06/04/mian-shi-guan-wen-xian-zai-gong-zi-shi-duo-shao-gai-zen-yao-hui-da/">面试官问现在工资是多少该怎么回答?</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">iOS KVO概述</a></p>

<ul>
<li>关注公众号iOS开发：<strong>iOSDevTip</strong> 获取更多面试技巧。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS KVO概述]]></title>
    <link href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/"/>
    <updated>2015-06-05T11:06:59+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian</id>
    <content type="html"><![CDATA[<blockquote><p>面试中经常会被问到：什么是KVO？这个问题既然出现概率这么大，那么我们就来详细讲一讲到底什么是KVO。下次再有面试官问你的时候，你就可以娓娓道来，以彰显高逼格</p></blockquote>

<h2>概述</h2>

<p>问：什么是KVO？</p>

<p>答：KVO是Key-Value Observing的缩写。它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。</p>

<p>如果你能这样回答，面试官一定不会说你错的，这就是KVO的原理。但是如果你能说出KVO的好处，那一定能赢得面试官的刮目相看。比如：</p>

<ul>
<li>使用KVO最直接的好处就是可以减少代码量。</li>
<li>KVO是<strong>观察者</strong>设计模式中的一种，有利于业务逻辑于视图控制之间的解耦。</li>
</ul>


<p>更深刻的了解KVO，你可以动手写一个小demo思路如下：</p>

<ul>
<li>定义一个对象People，分别有name和age属性</li>
<li>监听People的age属性</li>
<li>定义一个UIButton，在button的点击方法里面，去改变People的age。</li>
<li>你就可以收到age改变时发出来的通知</li>
<li>在对象销毁的时候，移除通知。</li>
</ul>


<p>iOS面试汇总：</p>

<p><a href="http://www.superqq.com/blog/2015/06/04/mian-shi-guan-wen-xian-zai-gong-zi-shi-duo-shao-gai-zen-yao-hui-da/">面试官问现在工资是多少该怎么回答?</a></p>

<ul>
<li>关注公众号iOS开发：<strong>iOSDevTip</strong> 获取更多面试技巧。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试官问现在工资是多少该怎么回答?]]></title>
    <link href="http://www.superqq.com/blog/2015/06/04/mian-shi-guan-wen-xian-zai-gong-zi-shi-duo-shao-gai-zen-yao-hui-da/"/>
    <updated>2015-06-04T10:36:30+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/04/mian-shi-guan-wen-xian-zai-gong-zi-shi-duo-shao-gai-zen-yao-hui-da</id>
    <content type="html"><![CDATA[<p>经常面试别人，也被别人面试的人来答。</p>

<p>面试官有此问，一是打听市场价，二是盘算以怎样的代价可以挖动你;猎头有此问，也许会帮你，也许会坑你。你回答的目的，是帮自己争取到最有利的薪资和福利。</p>

<p>　　</p>

<p>非常关键的一点，大家应该留意：问你的人具体是谁?</p>

<p>　　初面面试官(HR 部门的人，可能是招聘主管或经理人力资源总监、HRBP*)：他们在最初的用意往往是想打听市场行情，在用人部门确定后，往往是想能省点就省一点，到底也算自己的业绩呢;</p>

<p>　　</p>

<p>终面面试官(用人部门主管或经理、总监，直至公司老总、副总等)：他们比 HR 单纯一些，只要在部门预算之内，还能用得起，就愿意挑最好的人用;</p>

<p>　　</p>

<p>猎头顾问：虽然她们不是面试官，但可帮你可坑你，情况复杂，我放在后面讲。</p>

<p>　　</p>

<p>*HRBP 在大型外企很厉害哦，如果面试遇到，敬请留心。</p>

<p>　　</p>

<h3>下面根据不同的场合，我提一些建议：</h3>

<p>　　</p>

<p>如果你是通过直接应聘走到面试环节</p>

<p>　　</p>

<p>有的雇主会进行薪资验证(税单、劳动合同、原公司盖章的薪资证明)，有的不会。即使你已知不会，我建议你也不要虚报，说谎会有麻烦;应对大体上可分两种：</p>

<p>　　</p>

<p>实话实说：可展开各项福利和软硬环境、前景等等，不是光是薪资。这种回答很稳妥，如果对方要你，不出意外的话，开给你的薪水会按市价适当加成(我的了解，大致范围在 15%~35%)。</p>

<p>　　</p>

<p>拒不回答：我说过，你和面试官在合同签订之前是完全平等的所以，问是他的权利，拒绝或回答也是你的权利。需要提醒的是，你可以强势，但不能生硬，而且应以其他的有效反馈或者引导来替代。我举三个例子：</p>

<p>　　</p>

<p>1、我以自己为例，曾经有一场和总经理的面试，结尾是这样的：</p>

<p>　　&ndash; 你现在的薪水是多少?</p>

<p>　　&ndash; 很低，不好意思说。因为之前公司给我出学费念了书，签了两年 service contract，前后被拴了四年，工资被压低了。</p>

<p>　　&ndash; 那你为什么觉得我该付给你很多薪水?</p>

<p>　　&ndash; 因为工作性质改变了，也因为我改变了。</p>

<p>　　&ndash; 那你有什么要求吗?</p>

<p>　　&ndash; 我只请您考虑一件事：北京租房真是不便宜，所以我搬家过来需要一定决心。</p>

<p>　　</p>

<p>结果，一周后，我看到 offer 上的数字，是我当时在上海工作的 4 倍。</p>

<p>　　</p>

<p>2、以我朋友为例，他前几年在职时也曾经四处面试，他也经常被问这个问题，大多是电话面试时 HR 来问，“因为他们看得很死，最多就只肯给你涨 30%，要看之前的薪水。”而他本人在原公司的薪酬是最低的一档(同等学历，同等经验，同等职位的比较结果)，如果就死死地盯着这不公平的基数，加 30%实在嫌少。我教他一个办法，你直接告诉她你的期望薪水，因为你认为你给她公司创造的价值高过这个 20 倍(不要说约数，说数字，而且你要确实分析过，有信心对此数字负责)，如果她认为不值得，请她不要聘用你。</p>

<p>　　</p>

<p>他当时觉得很有用。当然，后来的四五次面试中他用了没有我不得而知，但他现在的公司在入职时给了他 50%的涨幅。</p>

<p>　　</p>

<p>补充:看到有人说&#8221;排名第一的说涨幅超过 50%，这个一般来说肯定不是高端岗位，从 3000-6000，涨幅 100%呢，也不难吧。&#8221;于是想简单介绍我这个朋友的情况，那时候他是某 500 强的中国区总部的财务部经理(部门总监最得力的下属)，留英硕士，DBA 在读(也是公司出的学费)，最后进入的是竞争对手的亚太区总部的战略部(偏财务方向)，两年后升任该部门总经理(没办法，他们就这么叫)。可能您做的客户比较高端，这些都不算啥了。下次请多提供点具体信息，我们可以取长补短，请务必@我哦。</p>

<p>　　</p>

<p>这种拒绝正面回答的对策，适用于你目前薪酬低于平均薪酬的水平时。因为面试官无法判断到底多少，只能取行业平均值来推测，然后结合你的面试表现来决定，相对来说，结果对你最为公平。</p>

<p>　　</p>

<p>当然，采取这种策略本身就需要一定的底气，如果你给面试官的印象是在畏畏缩缩地回避，那基本就是前功尽弃，你还不如老老实实招了吧。</p>

<p>　　</p>

<h3>如果你是通过猎头公司走到面试环节</h3>

<p>　　</p>

<h3>目前分三种情况：</h3>

<p>　　</p>

<p>对于此空缺职位，猎头公司只要给你提供候选人，雇主进行面试了，即便不满意也要付钱。这种猎头公司，在欧洲和北美能见到，而且仅仅在招聘 C-Suites(CEO,COO,CFO)，MD 这个级别的高管时才会出马，只要您是合适的人才，后面包满意哦，亲;唉，你我是这辈子遇不上喽。</p>

<p>　　</p>

<p>对于此空缺职位，猎头公司拿的是浮动报酬(比如，候选人三个月的薪水)，那她是希望帮你的，因为只要还在客户的预算内，每多帮你争取 1 块钱的月薪，猎头公司就多赚 3 块钱，而猎头顾问本人就多一份提成(比例不详，但一般都是拿提成的)。目前，对于多数中小客户，猎头都是以这样的形式取得报酬。这种时候，你可以尽量试探客户的预算，包括其他候选人的情况(对于面试废了的候选人，她们会很合作地榨取一切情报以利于下一位可能成功的候选人)。</p>

<p>　　</p>

<p>对于此空缺职位，猎头公司拿的是固定报酬(无论招到的人多少薪水，猎头公司报酬不变)，那她会倾向于压低你的薪水，因为每压低 1 块钱，她为客户节约的价值就体现出来了，而能和猎头顾问谈这样合同的公司，基本都是 500 强中的强势公司，很可能和该猎头公司有长期合作，甚至全球合同。这时候你就有点无奈了，她们一般不会有耐心听你的陈述和理由，反而会以自己公司成功入职的平均涨幅来打压你，并且和雇主企业沆瀣一气来对付候选人。</p>

<p>　　</p>

<p>不幸的是，近三四年，随着经济的低迷，招聘活动的减少(喂，别老怨别人，你不是也不敢轻易跳槽了吗)，第三种情况正越来越多;而猎头公司为了生存，正被迫接受这种方式;再不客气地讲，猎头公司的人员素质近几年也在下滑，Michael Page, Robert Walters 等从早先的非欧美名校、对口专业(细分至对应各行业)不招，到国外留学即可，到现在的国内 985 即可，顾问们根本无法承担深度挖掘候选人潜力、提升自己业绩和谈判能力等重担，公司也只能顺水推舟了。</p>

<p>　　</p>

<p>通常，猎头公司在第一次给你电话时，就会问你这个问题。(这也好理解：万一她的客户提供的薪酬还不如你现在的高，那她后面不是白费工夫吗?)问完之后，有一半的可能性会马上告诉雇主。</p>

<p>　　</p>

<p>那我怎么办呢，能在猎头公司那里虚报吗?我依然不建议你这样做，说谎话总有麻烦的。</p>

<p>　　</p>

<p>但是，我可以按自己的经验来告诉你风险等级是怎样的。如果面对 Michael Page，Robert Walters 这样程度的猎头，你万一穿帮，后面麻烦不小(虽然他们在中国也不如原先高大上了，但是人家还是有一样东西叫做全球共享数据库&hellip;&hellip;);Randstad 反正也乱得很，没空管你;本土中小猎头你看着办，反正一锤子买卖。自己的经历有限，不一定准确，欢迎各位知友批评补充。</p>

<p>　　</p>

<p>你唯一能做的，就是利用猎头在雇主面前的专业性(其实我看她们多数真不太懂什么业务，对行业知识往往一知半解，但是很无奈，人家比你懂得如何打动雇主)，在猎头面前强调自己相对其他候选人的优势和价值，让她们写入推荐报告中了。</p>

<p>　　</p>

<h3>&ndash; 下面是我的吐槽时间 &ndash;</h3>

<p>　　</p>

<p>顺便说一句，有人认为进行薪资验证的公司往往“招聘制度成熟”。这种想法不能说错，毕竟可以保障公司不吃大亏，不少外企都是这么做的。但我认为，这是人力资源部无能而推诿责任的表现，是大公司病的一种典型表现：</p>

<p>　　</p>

<p>你作为 HR，简历看过了、人也见过了，却无法作出独立判断他值多少钱;</p>

<p>　　</p>

<p>你不了解该职位的市场价，所以一定要依据前公司的薪水来定现在的薪水;</p>

<p>　　</p>

<p>你不想负责任，所以用人部门要的话，你就相应地加成来挖人，潜台词是“谁让你看中他了呢，我这就按你的意思办;这样还挖不成，那肯定是预算不够”;</p>

<p>　　</p>

<p>判断失误可能打击你在公司的专业形象;不谙市场价格可能是种失职;HR 加薪挖人有如 Sales 降价促销般容易——那公司要你来做什么?</p>

<p>来源：知乎 作者：显微无间</p>

<ul>
<li>关注公众号iOS开发：<strong>iOSDevTip</strong> 获取更多面试技巧。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac下.gitconfig配置别名alias]]></title>
    <link href="http://www.superqq.com/blog/2015/05/29/macxia-dot-gitconfigpei-zhi-bie-ming-alias/"/>
    <updated>2015-05-29T13:01:00+08:00</updated>
    <id>http://www.superqq.com/blog/2015/05/29/macxia-dot-gitconfigpei-zhi-bie-ming-alias</id>
    <content type="html"><![CDATA[<p>在多人协作开发时，一般用git来进行代码管理。git有一些命令如：git pull 、 git push等等，这些命令可以设置alias，也就是缩写。如：git pull 是 git pl， git push 是 git ps。可以根据个人习惯进行修改。</p>

<p>修改别名alias步骤如下：</p>

<h4>1,进入根目录</h4>

<pre><code>$ cd
</code></pre>

<h4>2,查看根目录下面的文件</h4>

<pre><code>$ ls -la
</code></pre>

<p>查看一下有没有.gitconfig文件。</p>

<h4>3，编辑.gitconfig</h4>

<pre><code>$ vi .gitconfig
</code></pre>

<p>添加如下：</p>

<pre><code>[alias]
co = checkout
ci = commit
st = status
pl = pull
ps = push
dt = difftool
l = log --stat
cp = cherry-pick
ca = commit -a
b = branch
</code></pre>

<p>具体可以根据个人习惯进行添加修改。</p>

<blockquote><p>关注公众号iOS开发：iOSDevTip</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS协议里面可以定义成员变量和属性吗？]]></title>
    <link href="http://www.superqq.com/blog/2015/05/22/iosxie-yi-li-mian-ke-yi-ding-yi-cheng-yuan-bian-liang-he-shu-xing-ma-%3F/"/>
    <updated>2015-05-22T11:08:18+08:00</updated>
    <id>http://www.superqq.com/blog/2015/05/22/iosxie-yi-li-mian-ke-yi-ding-yi-cheng-yuan-bian-liang-he-shu-xing-ma-?</id>
    <content type="html"><![CDATA[<blockquote><p>关注iOS开发：iOSDevTip</p></blockquote>

<p>在CSDN上看到有人提的问题，觉得很有价值，先看代码：</p>

<pre><code>@protocol CAMediaTiming

/* The begin time of the object, in relation to its parent object, if
 * applicable. Defaults to 0. */

@property CFTimeInterval beginTime;

/* The basic duration of the object. Defaults to 0. */

@property CFTimeInterval duration;

/* The rate of the layer. Used to scale parent time to local time, e.g.
 * if rate is 2, local time progresses twice as fast as parent time.
 * Defaults to 1. */

@property float speed;

/* Additional offset in active local time. i.e. to convert from parent
 * time tp to active local time t: t = (tp - begin) * speed + offset.
 * One use of this is to "pause" a layer by setting `speed' to zero and
 * `offset' to a suitable value. Defaults to 0. */

@property CFTimeInterval timeOffset;

/* The repeat count of the object. May be fractional. Defaults to 0. */

@property float repeatCount;

/* The repeat duration of the object. Defaults to 0. */

@property CFTimeInterval repeatDuration;

/* When true, the object plays backwards after playing forwards. Defaults
 * to NO. */

@property BOOL autoreverses;

/* Defines how the timed object behaves outside its active duration.
 * Local time may be clamped to either end of the active duration, or
 * the element may be removed from the presentation. The legal values
 * are `backwards', `forwards', `both' and `removed'. Defaults to
 * `removed'. */

@property(copy) NSString *fillMode;

@end
</code></pre>

<h3>问题：</h3>

<p>上面那个协议时苹果自带的，为什么里面定义了成员变量呢？</p>

<h3>网友回答：</h3>

<p>这只是在头文件中声明，编译器是不会自动生成实例变量的，也就是说你可以用一个对象去实现这个协议，但是你不自己存储的话实例变量的话，访问同样会崩溃：
self.fillModel = @&ldquo;test&rdquo;; // unrecognized selector</p>

<h3>追问</h3>

<p>你好，也就是说我需要这样：</p>

<pre><code>@interface MyClass : NSObject &lt; CAMediaTiming &gt;
@property CFTimeInterval beginTime;
@end
</code></pre>

<p>这样才可以么？
也就是@protocol能声明，不能定义变量么？</p>

<h3>网友回答</h3>

<p>协议声明出来的是方法，虽然看起来是属性，其实只有 getter、setter 这两个方法，内部是没有实例变量的，并且你不能去重定义它，只能在 getter、setter 里处理
​</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS地图定位使用几个小功能]]></title>
    <link href="http://www.superqq.com/blog/2015/05/14/iosdi-tu-ding-wei-shi-yong-xiao-ji-qiao/"/>
    <updated>2015-05-14T10:16:30+08:00</updated>
    <id>http://www.superqq.com/blog/2015/05/14/iosdi-tu-ding-wei-shi-yong-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<p>iOS系统自带的定位服务可以实现很多需求。比如：获取当前经纬度，获取当前位置信息等等。</p>

<h4>获取当前经纬度</h4>

<p>首先导入#import &lt;CoreLocation/CoreLocation.h>，定义CLLocationManager的实例，实现CLLocationManagerDelegate。</p>

<pre><code>@interface ViewController ()&lt;CLLocationManagerDelegate&gt;
{
    CLLocationManager *_locationManager;
}

@end
</code></pre>

<p>开始定位的方法：</p>

<pre><code>- (void)startLocating
{
    if([CLLocationManager locationServicesEnabled])
    {
        _locationManager = [[CLLocationManager alloc] init];
        //设置定位的精度
        [_locationManager setDesiredAccuracy:kCLLocationAccuracyBest];
        _locationManager.distanceFilter = 100.0f;
        _locationManager.delegate = self;
        if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt; 8.0)
        {
            [_locationManager requestAlwaysAuthorization];
            [_locationManager requestWhenInUseAuthorization];
        }
        //开始实时定位
        [_locationManager startUpdatingLocation];
    }
}
</code></pre>

<p>实现代理方法：</p>

<pre><code>-(void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status
{
    NSLog(@"Longitude = %f", manager.location.coordinate.longitude);
    NSLog(@"Latitude = %f", manager.location.coordinate.latitude);
    [_locationManager stopUpdatingLocation];
}
</code></pre>

<h4>获取当前位置信息</h4>

<p>在上面的代理方法中</p>

<pre><code>-(void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status
{
    NSLog(@"Longitude = %f", manager.location.coordinate.longitude);
    NSLog(@"Latitude = %f", manager.location.coordinate.latitude);
    [_locationManager stopUpdatingLocation];

    CLGeocoder * geoCoder = [[CLGeocoder alloc] init];
    [geoCoder reverseGeocodeLocation:manager.location completionHandler:^(NSArray *placemarks, NSError *error) {
        for (CLPlacemark * placemark in placemarks) {
            NSDictionary *test = [placemark addressDictionary];
            //  Country(国家)  State(城市)  SubLocality(区)
            NSLog(@"%@", [test objectForKey:@"Country"]);
            NSLog(@"%@", [test objectForKey:@"State"]);
            NSLog(@"%@", [test objectForKey:@"SubLocality"]);
            NSLog(@"%@", [test objectForKey:@"Street"]);
        }
    }];

}
</code></pre>

<p>这样就很简单获取了当前位置的详细信息。</p>

<h4>获取某一个地点的经纬度</h4>

<pre><code>- (void)getLongitudeAndLatitudeWithCity:(NSString *)city
{
    //city可以为中文
    NSString *oreillyAddress = city;
    CLGeocoder *myGeocoder = [[CLGeocoder alloc] init];
    [myGeocoder geocodeAddressString:oreillyAddress completionHandler:^(NSArray *placemarks, NSError *error) {
        if ([placemarks count] &gt; 0 &amp;&amp; error == nil)
        {
            NSLog(@"Found %lu placemark(s).", (unsigned long)[placemarks count]);
            CLPlacemark *firstPlacemark = [placemarks objectAtIndex:0];
            NSLog(@"Longitude = %f", firstPlacemark.location.coordinate.longitude);
            NSLog(@"Latitude = %f", firstPlacemark.location.coordinate.latitude);
        }
        else if ([placemarks count] == 0 &amp;&amp; error == nil)
        {
            NSLog(@"Found no placemarks.");
        }
        else if (error != nil)
        {
            NSLog(@"An error occurred = %@", error);
        }
    }];
}
</code></pre>

<h4>计算两个地点之间的距离</h4>

<pre><code>- (double)distanceByLongitude:(double)longitude1 latitude:(double)latitude1 longitude:(double)longitude2 latitude:(double)latitude2{
    CLLocation* curLocation = [[CLLocation alloc] initWithLatitude:latitude1 longitude:longitude1];
    CLLocation* otherLocation = [[CLLocation alloc] initWithLatitude:latitude2 longitude:longitude2];
    double distance  = [curLocation distanceFromLocation:otherLocation];//单位是m
    return distance;
}
</code></pre>

<p>首先我们可以用上面的getLongitudeAndLatitudeWithCity方法获取某一个地点的经纬度。比如我们获取北京和上海的经纬度分别为：北京Longitude = 116.405285，Latitude = 39.904989 上海Longitude = 121.472644， Latitude = 31.231706, 那么北京和上海之间的距离就是：</p>

<pre><code>double distance = [self distanceByLongitude:116.405285 latitude:39.904989 longitude:121.472644 latitude:31.231706];
NSLog(@"Latitude = %f", distance);
</code></pre>

<p>计算的是大概的距离，可能没有那么精准。输入结果为：</p>

<pre><code>distance = 1066449.749194
</code></pre>

<p>代码下载地址:<a href="https://github.com/worldligang/MapDistanceMaster.git"target="_blank"title="MapDistanceMaster">MapDistanceMaster</a></p>

<p>更多iOS技术请关注微信iOS开发</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS调用系统发短信功能详解]]></title>
    <link href="http://www.superqq.com/blog/2015/04/25/iosdiao-yong-xi-tong-fa-duan-xin-gong-neng-xiang-jie/"/>
    <updated>2015-04-25T11:36:33+08:00</updated>
    <id>http://www.superqq.com/blog/2015/04/25/iosdiao-yong-xi-tong-fa-duan-xin-gong-neng-xiang-jie</id>
    <content type="html"><![CDATA[<p>iOS调用系统的发短信功能可以分为两种：1，程序外调用系统发短信。2，程序内调用系统发短信。第二种的好处是用户发短信之后还可以回到app。这对app来说非常重要。</p>

<h3>程序外调用系统发短信</h3>

<p>这个方法其实很简单，直接调用openURL即可：</p>

<pre><code>[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@"sms://13888888888"]];
</code></pre>

<h3>程序内调用系统发短信</h3>

<h5>1）导入MessageUI.framework，并引入头文件：</h5>

<pre><code>#import &lt;MessageUI/MessageUI.h&gt;
</code></pre>

<h5>2）实现代理方法MFMessageComposeViewControllerDelegate</h5>

<pre><code>    -(void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result
{
    [self dismissViewControllerAnimated:YES completion:nil];
    switch (result) {
        case MessageComposeResultSent:
            //信息传送成功

            break;
        case MessageComposeResultFailed:
            //信息传送失败

            break;
        case MessageComposeResultCancelled:
            //信息被用户取消传送

            break;
        default:
            break;
    }
}
</code></pre>

<h5>3）发送短信</h5>

<pre><code>    -(void)showMessageView:(NSArray *)phones title:(NSString *)title body:(NSString *)body
{
    if( [MFMessageComposeViewController canSendText] )
    {
        MFMessageComposeViewController * controller = [[MFMessageComposeViewController alloc] init];
        controller.recipients = phones;
        controller.navigationBar.tintColor = [UIColor redColor];
        controller.body = body;
        controller.messageComposeDelegate = self;
        [self presentViewController:controller animated:YES completion:nil];
        [[[[controller viewControllers] lastObject] navigationItem] setTitle:title];//修改短信界面标题
    }
    else
    {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"提示信息"
                                                        message:@"该设备不支持短信功能"
                                                       delegate:nil
                                              cancelButtonTitle:@"确定"
                                              otherButtonTitles:nil, nil];
        [alert show];
    }
}
</code></pre>

<p>参数phones：发短信的手机号码的数组，数组中是一个即单发,多个即群发。</p>

<h5>4）调用发短信的方法</h5>

<pre><code>    [self showMessageView:[NSArray arrayWithObjects:@"13888888888",@"13999999999", nil] title:@"test" body:@"你是土豪么，么么哒"];
</code></pre>

<p>我的微信iOS开发：iOSDevTip</p>

<p>代码下载地址:<a href="https://github.com/worldligang/SendMsgMaster.git"target="_blank"title="SendMsgMaster">SendMsgMaster</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hitTest和pointInside如何响应用户点击事件]]></title>
    <link href="http://www.superqq.com/blog/2015/04/23/iosyong-hu-dian-ji-shi-jian-chu-li/"/>
    <updated>2015-04-23T16:05:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/04/23/iosyong-hu-dian-ji-shi-jian-chu-li</id>
    <content type="html"><![CDATA[<h3>处理机制</h3>

<p>iOS事件处理，首先应该是找到能处理点击事件的视图，然后在找到的这个视图里处理这个点击事件。</p>

<p>处理原理如下：</p>

<p>• 当用户点击屏幕时，会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中</p>

<p>• UIApplication会从事件队列中取出最前面的事件进行分发以便处理，通常，先发送事件给应用程序的主窗口(UIWindow)</p>

<p>• 主窗口会调用hitTest:withEvent:方法在视图(UIView)层次结构中找到一个最合适的UIView来处理触摸事件</p>

<p>(hitTest:withEvent:其实是UIView的一个方法，UIWindow继承自UIView，因此主窗口UIWindow也是属于视图的一种)</p>

<p>• hitTest:withEvent:方法大致处理流程是这样的：</p>

<p>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内：</p>

<p>▶ 若pointInside:withEvent:方法返回NO，说明触摸点不在当前视图内，则当前视图的hitTest:withEvent:返回nil</p>

<p>▶ 若pointInside:withEvent:方法返回YES，说明触摸点在当前视图内，则遍历当前视图的所有子视图(subviews)，调用子视图的hitTest:withEvent:方法重复前面的步骤，子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历，直到有子视图的hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕：</p>

<p>▷ 若第一次有子视图的hitTest:withEvent:方法返回非空对象,则当前视图的hitTest:withEvent:方法就返回此对象，处理结束</p>

<p>▷ 若所有子视图的hitTest:withEvent:方法都返回nil，则当前视图的hitTest:withEvent:方法返回当前视图自身(self)</p>

<p>• 最终，这个触摸事件交给主窗口的hitTest:withEvent:方法返回的视图对象去处理。我的微信号iOS开发：iOSDevTip</p>

<h3>案列分析</h3>

<p>在UIViewController的self.view上加载一个LGFirstView</p>

<p>LGFirstView上面有一个UIButton我们叫它buttonFirst</p>

<p>然后，self.view上加载一个LGSecondView，刚好盖在LGFirstView上面</p>

<p>LGSecondView上面也有一个UIButton我们叫它buttonSecond</p>

<h5>正常情况下：</h5>

<p>用户点击LGSecondView（点击的点不在buttonSecond上，但是在buttonFirst撒很难过吗），事件处理流程如下：</p>

<p>1）调用UIWindow的hitTest:withEvent:方法，hitTest:withEvent:方法会调用pointInside:withEvent:方法。此时pointInside:withEvent:返回YES，说明触摸事件在UIWindow上面。</p>

<p>2）去遍历UIWindow上面的子视图，也就是self.view。同样也是调用self.view的hitTest:withEvent:方法，hitTest:withEvent:方法会调用pointInside:withEvent:方法。此时pointInside:withEvent:返回YES，说明触摸事件在self.view上面。</p>

<p>3）去遍历self.view上的子视图，也就是LGFirstView和LGSecondView。（注意：子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历）。</p>

<p>4）所以先调用LGSecondView的hitTest:withEvent:方法，hitTest:withEvent:方法会调用pointInside:withEvent:方法。此时pointInside:withEvent:返回YES，说明触摸事件在LGSecondView上面。（此时不会再去遍历LGFirstView，所以正如你所愿buttonFirst的点击事件也不会被调用）</p>

<p>5）还没有结束，接着回去遍历LGSecondView上的所有子视图，结果所有子视图的hitTest:withEvent:方法都返回nil，因为LGSecondView上面只有secondButton，而点击的点不在secondButton。</p>

<p>6）最终hitTest:withEvent:方法返回当前视图自身(self)，而LGSecondView没有事件要处理。整个过程结束。</p>

<h5>如果我们想让buttonFirst也响应点击事件怎么办？</h5>

<h5>方法一：</h5>

<p>我们在LGSecondView加入如下代码：</p>

<pre><code>#pragma mark - 方法一
-(id)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
    UIView *hitView = [super hitTest:point withEvent:event];
    if (hitView == self)
    {
        return nil;
    }
    else
    {
        return hitView;
    }
}
</code></pre>

<p>我们再来分析一下：</p>

<p>还是这个场景，用户点击LGSecondView（点击的点不在buttonSecond上，但是在buttonFirst撒很难过吗），事件处理流程如下：</p>

<p>1）调用UIWindow的hitTest:withEvent:方法，hitTest:withEvent:方法会调用pointInside:withEvent:方法。此时pointInside:withEvent:返回YES，说明触摸事件在UIWindow上面。</p>

<p>2）去遍历UIWindow上面的子视图，也就是self.view。同样也是调用self.view的hitTest:withEvent:方法，hitTest:withEvent:方法会调用pointInside:withEvent:方法。此时pointInside:withEvent:返回YES，说明触摸事件在self.view上面。</p>

<p>3）去遍历self.view上的子视图，也就是LGFirstView和LGSecondView。（注意：子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历）。</p>

<p>4）所以先调用LGSecondView的hitTest:withEvent:方法，hitTest:withEvent:方法会调用pointInside:withEvent:方法。此时pointInside:withEvent:返回YES，说明触摸事件在LGSecondView上面。</p>

<p>5)但是，注意了，这里有个但是， UIView *hitView = [super hitTest:point withEvent:event];就是这句代码发挥了作用。如果hitView是LGSecondView的话，就不处理点击事件。（这跟userInteractionEnabled=NO是不一样的，userInteractionEnabled=NO，LGSecondView上的buttonSecond也不会响应点击事件了。）</p>

<p>6)这个时候会去调用LGFirstView的hitTest:withEvent:方法，hitTest:withEvent:方法会调用pointInside:withEvent:方法。此时pointInside:withEvent:返回YES，说明触摸事件在LGFirstView上面。</p>

<p>7）再去遍历LGFirstView上面的子视图，也就是buttonFirst，调用buttonFirst的hitTest:withEvent:方法，hitTest:withEvent:方法会调用pointInside:withEvent:方法。此时pointInside:withEvent:返回YES，说明触摸事件在buttonFirst上面。</p>

<p>8）再去遍历buttonFirst上的所有子视图，结果所有子视图的hitTest:withEvent:方法都返回nil，说明点击就在buttonFirst，buttonFirst就用响应的点击方法。</p>

<h5>方法二</h5>

<p>在LGSecondView.m</p>

<pre><code>@interface LGSecondView ()

@property (nonatomic, strong) NSMutableArray *subControlsArray;

@end

@implementation LGSecondView


- (id)initWithFrame:(CGRect)frame
{
    if (self = [super initWithFrame:frame]) {
        self.subControlsArray = [NSMutableArray array];
    }
    return self;
}


#pragma mark - 方法二

- (void)addSubview:(UIView *)view{
    [super addSubview:view];
    if ([view isKindOfClass:[UIControl class]]) {
        [self.subControlsArray addObject:view];
    }
}

//set self not response action and self subviews response action
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;
{
    BOOL toNext = YES;
    for (UIView *view in _subControlsArray) {
        if (CGRectContainsPoint(view.frame, point)) {
            toNext = NO;
            break;
        }
    }
    return !toNext;
}
</code></pre>

<p>具体原理就不在累述了，大家自己推一下，也可以把你的思路写下来发给我。</p>

<p>还有很多方法也欢迎你把思路写下来发给我。我的微信号iOS开发：iOSDevTip</p>

<p>代码下载地址:<a href="https://github.com/worldligang/HitTestMaster.git"target="_blank"title="HitTestMaster">HitTestMaster</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVC中Model的设计]]></title>
    <link href="http://www.superqq.com/blog/2015/04/07/mvczhong-modelde-she-ji/"/>
    <updated>2015-04-07T09:56:12+08:00</updated>
    <id>http://www.superqq.com/blog/2015/04/07/mvczhong-modelde-she-ji</id>
    <content type="html"><![CDATA[<p>一般在定义ViewController的时候，都习惯定义一个BaseViewController作为基类（即父类）。这样做的好处是：把公共的属性提出来放在BaseViewController中，试代码结构更清晰。同样，设计Model的时候，也可以定义一个基类。</p>

<p>比如：有一个房子，房子里面有一个电视和许多个桌子。电视和桌子分别有价格和型号。</p>

<h3>定义基类LGObject</h3>

<p>LGObject.h：</p>

<pre><code> //
//  LGObject.h
//  LGAlertViewDemo
//
//  Created by apple on 15/4/6.
//  Copyright (c) 2015年 LiGang. All rights reserved.
//

#import &lt;Foundation/Foundation.h&gt;

@interface LGObject : NSObject

@property (readonly, nonatomic) id data;

- (id)initWithData:(id)data;
- (BOOL)isEmpty;

@end
</code></pre>

<p>LGObject.m：</p>

<pre><code>//
//  LGObject.m
//  LGAlertViewDemo
//
//  Created by apple on 15/4/6.
//  Copyright (c) 2015年 LiGang. All rights reserved.
//

#import "LGObject.h"

@implementation LGObject

- (id)initWithData:(id)data {
    self = [super init];
    if(self) {
        _data = nil;
        if(data != nil) _data = data;
    }
    return self;
}

- (BOOL)isEmpty
{
    return _data == nil ? YES : NO;
}

@end
</code></pre>

<h3>定义房子LGHouse、电视LGVideo、桌子LGDesk</h3>

<p>电视LGVideo、桌子LGDesk可以放在LGHouse里面。多个桌子需要定义一个数组：arrayDesk。</p>

<p>LGHouse.h：</p>

<pre><code>//
//  LGHouse.h
//  LGAlertViewDemo
//
//  Created by apple on 15/4/6.
//  Copyright (c) 2015年 LiGang. All rights reserved.
//

#import "LGObject.h"

@class LGVideo;
@class LGDesk;

@interface LGHouse : LGObject

@property (nonatomic, readonly) LGVideo  *video;     //电视
@property (nonatomic, readonly) NSArray  *arrayDesk; //桌子

@end

@interface LGVideo : LGObject

@property (nonatomic, assign)   float      money;//价格
@property (nonatomic, readonly) NSString  *type;//型号

@end

@interface LGDesk : LGObject

@property (nonatomic, assign)   float      money;//价格
@property (nonatomic, readonly) NSString  *type;//型号

@end
</code></pre>

<p>LGHouse.m：</p>

<pre><code>//
//  LGHouse.m
//  LGAlertViewDemo
//
//  Created by apple on 15/4/6.
//  Copyright (c) 2015年 LiGang. All rights reserved.
//

#import "LGHouse.h"

@implementation LGHouse

- (LGVideo *)video {
    return [[LGVideo alloc] initWithData:[self.data objectForKey:@"video"]];
}

- (NSArray *)arrayDesk {
    NSMutableArray *arrayDesk = [NSMutableArray array];
    for (NSDictionary *dickDesk in [self.data objectForKey:@"desks"]) {
        [arrayDesk addObject:[[LGDesk alloc] initWithData:dickDesk]];
    }
    return arrayDesk;
}

@end

@implementation LGVideo

- (float)money {
    return [[self.data objectForKey:@"money"] floatValue];
}

- (NSString *)type {
    return [self.data objectForKey:@"type"];
}

@end

@implementation LGDesk

- (float)money {
    return [[self.data objectForKey:@"money"] floatValue];
}

- (NSString *)type {
    return [self.data objectForKey:@"type"];
}

@end
</code></pre>

<p>以上是我对Model设计的简单理解，如果你有更好的想法，欢迎告诉我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之AsyncSocket使用教程]]></title>
    <link href="http://www.superqq.com/blog/2015/04/03/ioskai-fa-zhi-asyncsocketshi-yong-jiao-cheng/"/>
    <updated>2015-04-03T16:57:19+08:00</updated>
    <id>http://www.superqq.com/blog/2015/04/03/ioskai-fa-zhi-asyncsocketshi-yong-jiao-cheng</id>
    <content type="html"><![CDATA[<p>用socket可以实现像QQ那样发送即时消息的功能。客户端和服务端需要建立长连接，在长连接的情况下，发送消息。客户端可以发送心跳包来检测长连接。</p>

<p>在iOS开发中使用socket，一般都是用第三方库AsyncSocket，不得不承认这个库确实很强大。下载地址<a href="https://github.com/robbiehanson/CocoaAsyncSocket.git"target="_blank"title="CocoaAsyncSocket">CocoaAsyncSocket</a><br/>
。</p>

<p>使用AsyncSocket的时候可以做一层封装，根据需求提供几个接口出来。比如：连接、断开连接、发送消息等等。还有接受消息，接受到的消息可以通过通知、代理、block等传出去。</p>

<p>简单介绍一下对AsyncSocket使用.一般来说，一个用户只需要建立一个socket长连接，所以可以用单例类方便使用。</p>

<h3>定义单列类：LGSocketServe</h3>

<p>LGSocketServe.h</p>

<pre><code>//
//  LGSocketServe.h
//  AsyncSocketDemo
//
//  Created by ligang on 15/4/3.
//  Copyright (c) 2015年 ligang. All rights reserved.
//

#import &lt;Foundation/Foundation.h&gt;
#import "AsyncSocket.h"

@interface LGSocketServe : NSObject&lt;AsyncSocketDelegate&gt;

+ (LGSocketServe *)sharedSocketServe;


@end
</code></pre>

<p>LGSocketServe.m</p>

<pre><code>//
//  LGSocketServe.m
//  AsyncSocketDemo
//
//  Created by ligang on 15/4/3.
//  Copyright (c) 2015年 ligang. All rights reserved.
//

#import "LGSocketServe.h"

@implementation LGSocketServe


static LGSocketServe *socketServe = nil;

#pragma mark public static methods


+ (LGSocketServe *)sharedSocketServe {
    @synchronized(self) {
        if(socketServe == nil) {
            socketServe = [[[self class] alloc] init];
        }
    }
    return socketServe;
}


+(id)allocWithZone:(NSZone *)zone
{
    @synchronized(self)
    {
        if (socketServe == nil)
        {
            socketServe = [super allocWithZone:zone];
            return socketServe;
        }
    }
    return nil;
}   


@end
</code></pre>

<h3>建立socket长连接</h3>

<p>LGSocketServe.h</p>

<pre><code>@property (nonatomic, strong) AsyncSocket         *socket;       // socket

//  socket连接
- (void)startConnectSocket;
</code></pre>

<p>LGSocketServe.m</p>

<pre><code>//自己设定
#define HOST @"192.168.0.1"
#define PORT 8080

//设置连接超时
#define TIME_OUT 20

- (void)startConnectSocket
{
    self.socket = [[AsyncSocket alloc] initWithDelegate:self];
    [self.socket setRunLoopModes:[NSArray arrayWithObject:NSRunLoopCommonModes]];
    if ( ![self SocketOpen:HOST port:PORT] )
    {

    }

}

- (NSInteger)SocketOpen:(NSString*)addr port:(NSInteger)port
{

    if (![self.socket isConnected])
    {
        NSError *error = nil;
        [self.socket connectToHost:addr onPort:port withTimeout:TIME_OUT error:&amp;error];
    }

    return 0;
}
</code></pre>

<p>宏定义一下HOST、PORT、TIME_OUT，实现startConnectSocket方法。这个时候要设置一下AsyncSocket的代理AsyncSocketDelegate。当长连接成功之后会调用：</p>

<pre><code>- (void)onSocket:(AsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port
{
    //这是异步返回的连接成功，
    NSLog(@"didConnectToHost");
}
</code></pre>

<h3>心跳</h3>

<p>LGSocketServe.h</p>

<pre><code>@property (nonatomic, retain) NSTimer             *heartTimer;   // 心跳计时器
</code></pre>

<p>LGSocketServe.m</p>

<pre><code>- (void)onSocket:(AsyncSocket *)sock didConnectToHost:(NSString *)host port:(UInt16)port
{
    //这是异步返回的连接成功，
    NSLog(@"didConnectToHost");

    //通过定时器不断发送消息，来检测长连接
    self.heartTimer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(checkLongConnectByServe) userInfo:nil repeats:YES];
    [self.heartTimer fire];
}

// 心跳连接
-(void)checkLongConnectByServe{

    // 向服务器发送固定可是的消息，来检测长连接
    NSString *longConnect = @"connect is here";
    NSData   *data  = [longConnect dataUsingEncoding:NSUTF8StringEncoding];
    [self.socket writeData:data withTimeout:1 tag:1];
}
</code></pre>

<p>在连接成功的回调方法里，启动定时器，每隔2秒向服务器发送固定的消息来检测长连接。（这个根据服务器的需要就可以了）</p>

<h3>断开连接</h3>

<p>1，用户手动断开连接</p>

<p>LGSocketServe.h</p>

<pre><code>// 断开socket连接
-(void)cutOffSocket;
</code></pre>

<p>LGSocketServe.m</p>

<pre><code>-(void)cutOffSocket
{
    self.socket.userData = SocketOfflineByUser;
    [self.socket disconnect];
}
</code></pre>

<p>cutOffSocket是用户断开连接之后，不在尝试重新连接。</p>

<p>2，wifi断开，socket断开连接</p>

<p>LGSocketServe.m</p>

<pre><code>- (void)onSocket:(AsyncSocket *)sock willDisconnectWithError:(NSError *)err
{

    NSLog(@" willDisconnectWithError %ld   err = %@",sock.userData,[err description]);
    if (err.code == 57) {
        self.socket.userData = SocketOfflineByWifiCut;
    }

}
</code></pre>

<p>wifi断开之后，会回调onSocket:willDisconnectWithError:方法，err.code == 57，这个时候设置self.socket.userData = SocketOfflineByWifiCut。</p>

<h3>重新连接</h3>

<p>socket断开之后会回调：</p>

<p>LGSocketServe.m</p>

<pre><code>- (void)onSocketDidDisconnect:(AsyncSocket *)sock
{

    NSLog(@"7878 sorry the connect is failure %ld",sock.userData);

    if (sock.userData == SocketOfflineByServer) {
        // 服务器掉线，重连
        [self startConnectSocket];
    }
    else if (sock.userData == SocketOfflineByUser) {

        // 如果由用户断开，不进行重连
        return;
    }else if (sock.userData == SocketOfflineByWifiCut) {

        // wifi断开，不进行重连
        return;
    }

}
</code></pre>

<p>在onSocketDidDisconnect回调方法里面，会根据self.socket.userData来判断是否需要重新连接。</p>

<h3>发送消息</h3>

<p>LGSocketServe.h</p>

<pre><code>// 发送消息
- (void)sendMessage:(id)message;
</code></pre>

<p>LGSocketServe.m</p>

<pre><code>//设置写入超时 -1 表示不会使用超时
#define WRITE_TIME_OUT -1

- (void)sendMessage:(id)message
{
    //像服务器发送数据
    NSData *cmdData = [message dataUsingEncoding:NSUTF8StringEncoding];
    [self.socket writeData:cmdData withTimeout:WRITE_TIME_OUT tag:1];
}

//发送消息成功之后回调
- (void)onSocket:(AsyncSocket *)sock didWriteDataWithTag:(long)tag
{

}
</code></pre>

<p>发送消息成功之后会调用onSocket:didWriteDataWithTag:,在这个方法里可以进行读取消息。</p>

<h3>接受消息</h3>

<p>LGSocketServe.m</p>

<pre><code>//设置读取超时 -1 表示不会使用超时
#define READ_TIME_OUT -1

#define MAX_BUFFER 1024

//发送消息成功之后回调
- (void)onSocket:(AsyncSocket *)sock didWriteDataWithTag:(long)tag
{
    //读取消息
    [self.socket readDataWithTimeout:-1 buffer:nil bufferOffset:0 maxLength:MAX_BUFFER tag:0];
}

//接受消息成功之后回调
- (void)onSocket:(AsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag
{
    //服务端返回消息数据量比较大时，可能分多次返回。所以在读取消息的时候，设置MAX_BUFFER表示每次最多读取多少，当data.length &lt; MAX_BUFFER我们认为有可能是接受完一个完整的消息，然后才解析
    if( data.length &lt; MAX_BUFFER )
    {
        //收到结果解析...
        NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];
        NSLog(@"%@",dic);
        //解析出来的消息，可以通过通知、代理、block等传出去

    }


    [self.socket readDataWithTimeout:READ_TIME_OUT buffer:nil bufferOffset:0 maxLength:MAX_BUFFER tag:0];
</code></pre>

<p>接受消息后去解析，然后可以通过通知、代理、block等传出去。在onSocket:didReadData:withTag:回调方法里面需要不断读取消息，因为数据量比较大的话，服务器会分多次返回。所以我们需要定义一个MAX_BUFFER的宏，表示每次最多读取多少。当data.length &lt; MAX_BUFFER我们认为有可能是接受完一个完整的消息，然后才解析
。</p>

<h3>出错处理</h3>

<p>LGSocketServe.m</p>

<pre><code>- (void)onSocket:(AsyncSocket *)sock willDisconnectWithError:(NSError *)err
{
    NSData * unreadData = [sock unreadData]; // ** This gets the current buffer
    if(unreadData.length &gt; 0) {
        [self onSocket:sock didReadData:unreadData withTag:0]; // ** Return as much data that could be collected
    } else {

        NSLog(@" willDisconnectWithError %ld   err = %@",sock.userData,[err description]);
        if (err.code == 57) {
            self.socket.userData = SocketOfflineByWifiCut;
        }
    }

}
</code></pre>

<p>socket出错会回调onSocket:willDisconnectWithError:方法，可以通过unreadData来读取未来得及读取的buffer。</p>

<h3>使用</h3>

<p>导入#import &ldquo;LGSocketServe.h&rdquo;</p>

<pre><code> LGSocketServe *socketServe = [LGSocketServe sharedSocketServe];
//socket连接前先断开连接以免之前socket连接没有断开导致闪退
[socketServe cutOffSocket];
socketServe.socket.userData = SocketOfflineByServer;
[socketServe startConnectSocket];

//发送消息 @"hello world"只是举个列子，具体根据服务端的消息格式
[socketServe sendMessage:@"hello world"];
</code></pre>

<p>以上是AsyncSocket的简单使用，在实际开发过程中依然会碰到很多问题，欢迎加我的微信公众号iOS开发：iOSDevTip，一起讨论AsyncSocket中遇到的问题。</p>

<p>AsyncSocketDemo下载地址： <a href="https://github.com/worldligang/AsyncSocketDemo.git"target="_blank"title="CocoaAsyncSocket">AsyncSocketDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSSortDescriptor排序]]></title>
    <link href="http://www.superqq.com/blog/2015/03/27/nssortdescriptorpai-xu/"/>
    <updated>2015-03-27T19:01:45+08:00</updated>
    <id>http://www.superqq.com/blog/2015/03/27/nssortdescriptorpai-xu</id>
    <content type="html"><![CDATA[<p>NSSortDescriptor可以实现按照对象的属性进行排序。比如我们有一个对象（LGPeople）。LGPeople有两个属性分别是名字（name）和年龄（age）。现在我们要按照LGPeople的年龄（age）来进行排序。</p>

<p>代码如下：</p>

<pre><code>    //按年龄排序
    NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"_age" ascending:NO];
    NSArray *sortDescriptors = [NSArray arrayWithObjects:sortDescriptor, nil];
    [arrayPeople sortUsingDescriptors:sortDescriptors];
</code></pre>

<p>这样是按照年龄的降序进行排序。如果想升序的话将NO改为YES即可。如果是按照名字进行排序的话也很简单：</p>

<pre><code>    //按姓名排序
    NSSortDescriptor *sortDescriptorName = [[NSSortDescriptor alloc] initWithKey:@"_name" ascending:NO];
    NSArray *sortDescriptors = [NSArray arrayWithObjects:sortDescriptorName, nil];
    [arrayPeople sortUsingDescriptors:sortDescriptors];
</code></pre>

<p>也许我们还有一种需求：先按照年龄排序，再按名字进行排序。代码如下：</p>

<pre><code>    //按年龄和名字排序
    NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"_age" ascending:NO];
    NSSortDescriptor *sortDescriptorName = [[NSSortDescriptor alloc] initWithKey:@"_name" ascending:NO];
    NSArray *sortDescriptors = [NSArray arrayWithObjects:sortDescriptor, sortDescriptorName, nil];
    [_mutArrVideo sortUsingDescriptors:sortDescriptors];
</code></pre>

<p>这样相同年龄的情况下，就会按照名字进行排序。当然还可以设置两个以上的排序条件。</p>

<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自己动手实现一个队列LGQueue]]></title>
    <link href="http://www.superqq.com/blog/2015/03/24/zi-ji-dong-shou-chuang-jian-%5B%3F%5D-ge-dui-lie-lgqueue/"/>
    <updated>2015-03-24T17:13:39+08:00</updated>
    <id>http://www.superqq.com/blog/2015/03/24/zi-ji-dong-shou-chuang-jian-[?]-ge-dui-lie-lgqueue</id>
    <content type="html"><![CDATA[<p>iOS系统没有提供queue容器，如果想用，需要手动自己来写一个：</p>

<p>.h</p>

<pre><code>//
//  LGQueue.h
//  AntsSportApp
//
//  Created by ligang on 15/3/24.
//  Copyright (c) 2015年 ligang. All rights reserved.
//

#import &lt;Foundation/Foundation.h&gt;

@interface LGQueue : NSObject

@property (nonatomic, strong) NSMutableArray *queue;

@property (nonatomic, readonly) NSInteger count;

- (void)enterQueue:(id)object;
- (id)exitQueue;
- (void)clear;



@end
</code></pre>

<p>.m</p>

<pre><code>//
//  LGQueue.m
//  AntsSportApp
//
//  Created by ligang on 15/3/24.
//  Copyright (c) 2015年 ligang. All rights reserved.
//

#import "LGQueue.h"

@implementation LGQueue

- (id)init
{
    if ( self = [super init] ) {

        self.queue = [[NSMutableArray alloc] init];
        _count = 0;

    }
    return self;
}

- (void)enterQueue:(id)object
{
    [self.queue addObject:object];
    _count = self.queue.count;
}


- (id)exitQueue
{
    if ( self.queue.count == 0 )  return nil;

    id object = [self.queue objectAtIndex:0];
    [self.queue removeObjectAtIndex:0];
    _count = self.queue.count;

    return object;

}


- (void)clear
{
    [self.queue removeAllObjects];
    _count = 0;
}

@end
</code></pre>

<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单例模式的两种写法]]></title>
    <link href="http://www.superqq.com/blog/2015/03/21/dan-li-mo-shi-de-xie-fa/"/>
    <updated>2015-03-21T17:39:16+08:00</updated>
    <id>http://www.superqq.com/blog/2015/03/21/dan-li-mo-shi-de-xie-fa</id>
    <content type="html"><![CDATA[<p>单例模式是iOS开发中最常用的设计模式，iOS的单例模式有两种官方写法，如下：</p>

<h3>1，常用写法</h3>

<pre><code>#import "LGManagerCenter.h"

static LGManagerCenter *managerCenter;

@implementation LGManagerCenter

+(LGManagerCenter *)sharedManager{
    if(!managerCenter)
        managerCenter=[[self allocWithZone:NULL] init];
    return  managerCenter;
}

@end
</code></pre>

<h3>2,用GCD创建单例类</h3>

<pre><code>#import "LGManagerCenter.h"


@implementation LGManagerCenter


+(LGManagerCenter *)sharedManager{
    static dispatch_once_t predicate;
    static LGManagerCenter * managerCenter;
    dispatch_once(&amp;predicate, ^{
        managerCenter=[[LGManagerCenter alloc] init];
    });
    return managerCenter;
}

@end
</code></pre>

<p>其中dispatch_once函数只执行一次。</p>

<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统提供的dispatch方法]]></title>
    <link href="http://www.superqq.com/blog/2015/03/13/xi-tong-ti-gong-de-dispatchfang-fa/"/>
    <updated>2015-03-13T17:41:11+08:00</updated>
    <id>http://www.superqq.com/blog/2015/03/13/xi-tong-ti-gong-de-dispatchfang-fa</id>
    <content type="html"><![CDATA[<p>为了方便地使用GCD，苹果提供了一些方法方便我们将block放在主线程或后台线程执行，或者延后执行。使用的例子如下所示：</p>

<pre><code> //  后台执行：
 dispatch_async(dispatch_get_global_queue(0, 0), ^{
      // something
 });

 // 主线程执行：
 dispatch_async(dispatch_get_main_queue(), ^{
      // something
 });

 // 一次性执行：
 static dispatch_once_t onceToken;
 dispatch_once(&amp;onceToken, ^{
     // code to be executed once
 });

 // 延迟2秒执行：
 double delayInSeconds = 2.0;
 dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
     // code to be executed on the main queue after delay
 });
</code></pre>

<p>dispatch_queue_t也可以自己定义，如要自定义queue，可以用dispatch_queue_create方法，示例如下：</p>

<pre><code> // 自定义dispatch_queue_t
 dispatch_queue_t urls_queue = dispatch_queue_create("blog.devtang.com", NULL);
 dispatch_async(urls_queue, ^{  
　 　// your code 
 });
 dispatch_release(urls_queue);
</code></pre>

<p>另外，GCD还有一些高级用法，例如让后台两个线程并行执行，然后等两个线程都结束后，再汇总执行结果。这个可以用dispatch_group_t、dispatch_group_async、dispatch_group_notify来实现，示例如下：</p>

<pre><code> // 合并汇总结果
 dispatch_group_t group = dispatch_group_create();
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程一
 });
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
      // 并行执行的线程二
 });
 dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{
      // 汇总结果
 });
</code></pre>

<p>文章来自唐巧《iOS开发进阶》</p>

<p>更多iOS开发相关技术请关注iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
</feed>
