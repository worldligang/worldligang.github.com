<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刚刚在线]]></title>
  <link href="http://www.superqq.com/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-07-24T00:16:27+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSFileManager文件操作的十个小功能]]></title>
    <link href="http://www.superqq.com/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng/"/>
    <updated>2015-07-24T00:14:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng</id>
    <content type="html"><![CDATA[<p>NSFileManager是一个单列类，也是一个文件管理器。可以通过NSFileManager创建文件夹、创建文件、写文件、读文件内容等等基本功能。</p>

<p>下面将介绍NSFileManager文件操作的十个小功能。我们在Documents里面进行举例，首先是获取Documents的路径。这个在<a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a>已经详细讲解过了。获取Documents路径方法如下：</p>

<pre><code>- (NSString *)getDocumentsPath
{
    //获取Documents路径
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *path = [paths objectAtIndex:0];
    NSLog(@"path:%@", path);
    return path;
}
</code></pre>

<h3>创建文件夹</h3>

<pre><code>-(void)createDirectory{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSDirectory = [documentsPath stringByAppendingPathComponent:@"iOS"];
    BOOL isSuccess = [fileManager createDirectoryAtPath:iOSDirectory withIntermediateDirectories:YES attributes:nil error:nil];
    if (isSuccess) {
        NSLog(@"success");
    } else {
        NSLog(@"fail");
    }
}
</code></pre>

<h3>创建文件</h3>

<pre><code>-(void)createFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager createFileAtPath:iOSPath contents:nil attributes:nil];
    if (isSuccess) {
        NSLog(@"success");
    } else {
        NSLog(@"fail");
    }
}
</code></pre>

<h3>写文件</h3>

<pre><code>-(void)writeFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *content = @"我要写数据啦";
    BOOL isSuccess = [content writeToFile:iOSPath atomically:YES encoding:NSUTF8StringEncoding error:nil];
    if (isSuccess) {
        NSLog(@"write success");
    } else {
        NSLog(@"write fail");
    }
}
</code></pre>

<h3>读取文件内容</h3>

<pre><code>-(void)readFileContent{
    NSString *documentsPath =[self getDocumentsPath];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *content = [NSString stringWithContentsOfFile:iOSPath encoding:NSUTF8StringEncoding error:nil];
    NSLog(@"read success: %@",content);
}
</code></pre>

<h3>判断文件是否存在</h3>

<pre><code>- (BOOL)isSxistAtPath:(NSString *)filePath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:filePath];
    return isExist;
}
</code></pre>

<h3>计算文件大小</h3>

<pre><code>- (unsigned long long)fileSizeAtPath:(NSString *)filePath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:filePath];
    if (isExist){
        unsigned long long fileSize = [[fileManager attributesOfItemAtPath:filePath error:nil] fileSize];
        return fileSize;
    } else {
        NSLog(@"file is not exist");
        return 0;
    }
}
</code></pre>

<h3>计算整个文件夹中所有文件大小</h3>

<pre><code>- (unsigned long long)folderSizeAtPath:(NSString*)folderPath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:folderPath];
    if (isExist){
        NSEnumerator *childFileEnumerator = [[fileManager subpathsAtPath:folderPath] objectEnumerator];
        unsigned long long folderSize = 0;
        NSString *fileName = @"";
        while ((fileName = [childFileEnumerator nextObject]) != nil){
            NSString* fileAbsolutePath = [folderPath stringByAppendingPathComponent:fileName];
            folderSize += [self fileSizeAtPath:fileAbsolutePath];
        }
        return folderSize / (1024.0 * 1024.0);
    } else {
        NSLog(@"file is not exist");
        return 0;
    }
}
</code></pre>

<h3>删除文件</h3>

<pre><code>-(void)deleteFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager removeItemAtPath:iOSPath error:nil];
    if (isSuccess) {
        NSLog(@"delete success");
    }else{
        NSLog(@"delete fail");
    }
}
</code></pre>

<h3>移动文件</h3>

<pre><code>- (void)moveFileName
{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *filePath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *moveToPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager moveItemAtPath:filePath toPath:moveToPath error:nil];
    if (isSuccess) {
        NSLog(@"rename success");
    }else{
        NSLog(@"rename fail");
    }
}
</code></pre>

<h3>重命名</h3>

<pre><code>- (void)renameFileName
{
    //通过移动该文件对文件重命名
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *filePath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *moveToPath = [documentsPath stringByAppendingPathComponent:@"rename.txt"];
    BOOL isSuccess = [fileManager moveItemAtPath:filePath toPath:moveToPath error:nil];
    if (isSuccess) {
        NSLog(@"rename success");
    }else{
        NSLog(@"rename fail");
    }
}
</code></pre>

<p>以上文件操作代码都在<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>，可以直接通过git拉下来进行测试。关于NSFileManager的用法还有很多，一起接续探索吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何查看真机的沙盒（图文教程）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/23/ru-he-cha-kan-zhen-ji-de-sha-he-(tu-wen-jiao-cheng-)/"/>
    <updated>2015-07-23T00:29:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/23/ru-he-cha-kan-zhen-ji-de-sha-he-(tu-wen-jiao-cheng-)</id>
    <content type="html"><![CDATA[<p>在<a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a>，我们了解到如何查看模拟器的沙盒内容。直接在Finder->前往->前往文件夹里输入：</p>

<pre><code>/Users/ligang/Library/Application Support/iPhone Simulator/ 
</code></pre>

<p>这样就可以查看模拟器的沙盒内容。在平时开发中，我们应该大部分用的是真机测试。如果需要在沙盒里操作文件，那么我们可以通过观察真机沙盒的内容，来确定文件操作是否正确。</p>

<p>如果你已经知道如何查看真机的沙盒，请看看其他的文章吧，在这里<a href="zhannei.superqq.com">刚刚在线站内搜索</a>可以搜索到更多iOS开发相关的文章。接下来，通过图文的方式详细讲解如何查看真机沙盒。有兴趣的同学可以继续往下看。</p>

<h2>查看真机沙盒教程</h2>

<h3>打开Devices</h3>

<p>在xcode的上部导航栏里，选择window -> Devices</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox1.jpg" alt="realsandbox1.jpg" /></p>

<h3>找到目标APP</h3>

<p>我们拿<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>举例。界面如下图所示：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox2.jpg" alt="realsandbox2.jpg" /></p>

<h3>浏览沙盒目录结构</h3>

<h4>双击iOSStrongDemo</h4>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox3.jpg" alt="realsandbox3.jpg" /></p>

<h4>点击Show Container</h4>

<p>设置图标单击之后，如图所示：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox4.jpg" alt="realsandbox4.jpg" /></p>

<p>这样我们只能看到沙盒的目录结构。看不到实体文件。那么，我们下一步就是找到这个沙盒。</p>

<h3>Download Container保存到桌面</h3>

<p>如上图所示，有一个Download Container，选择之后，保存到桌面。</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox5.jpg" alt="realsandbox5.jpg" /></p>

<h3>右键显示包内容</h3>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox6.jpg" alt="realsandbox6.jpg" /></p>

<h3>查看沙盒目录</h3>

<p>AppDataInfo.plist是APP的配置文件：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox7.jpg" alt="realsandbox7.jpg" /></p>

<h3>打开AppData</h3>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox8.jpg" alt="realsandbox8.jpg" /></p>

<p>这就是APP的沙盒，在这里我们可以对文件进行增删查改操作。更多内容以后继续慢慢分享。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快快快！27个提升效率的iOS开源库推荐]]></title>
    <link href="http://www.superqq.com/blog/2015/07/22/kuai-kuai-kuai-!27ge-ti-sheng-xiao-lu-de-ioskai-yuan-ku-tui-jian/"/>
    <updated>2015-07-22T13:11:49+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/22/kuai-kuai-kuai-!27ge-ti-sheng-xiao-lu-de-ioskai-yuan-ku-tui-jian</id>
    <content type="html"><![CDATA[<blockquote><p>CSDN移动将持续为您优选移动开发的精华内容，共同探讨移动开发的技术热点话题，涵盖移动应用、开发工具、移动游戏及引擎、智能硬件、物联网等方方面面。如果您想投稿、参与内容翻译工作，或寻求近匠报道，请发送邮件至tangxy#csdn.net（请把#改成@）。</p></blockquote>

<p>我热爱开源，更喜爱那些花费宝贵的业余时间来创造奇迹的开发者们，感谢他们将自己辛苦劳动的成果无偿分享给大家。开源作者和贡献者们，你们太了不起了，感谢你们所付出的一切。</p>

<p>鉴于我是收集不全会死星人，这里我根据个人喜好选取了一些iOS的开源库。这些项目的顺序完全随机，每个都棒到爆。绝大多数支持CocoaPods，所以将它们添加到你的Xcode项目中只是小事一桩。</p>

<p>在本文末尾你可以找到一个长文慎入版本——一个只包含题目与项目链接的简单列表。如果你觉得这篇文章有用的话，请把它分享给其他做iOS开发的小伙伴们，好酒也怕巷子深。</p>

<h3>1. <a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" title=“DZNEmptyDataSet”>DZNEmptyDataSet</a></h3>

<p>DZNEmptyDataSet算是一个很标准的iOS内建方式，适合用来处理空的table view和collection view。默认情况下，如果你的table view为空，屏幕就为空，这样一来用户体验并不理想。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55adfe02a4a2f_middle.jpg" alt="1" /></p>

<p>使用这个库，你只需遵守一些协议，iOS就会自动将collection view处理完善，并将用户消息以合适美观的方式显示出来。每个iOS项目都可以自动处理，不用再一一费神。</p>

<h3>2. <a href="https://github.com/jivesoftware/PDTSimpleCalendar" target="_blank" title=“PDTSimpleCalendar”>PDTSimpleCalendar</a></h3>

<p>你的应用需要一个简单美观且正常运行的日历组件吗？现在有了——PDTSimpleCalendar也许可以算是iOS最棒的日历组件了。你可以在各个方面对它进行定制，无论是运行逻辑还是外观方面。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55adff269e028_middle.jpg" alt="2" /></p>

<h3>3. <a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" title=“MagicalRecord”>MagicalRecord</a></h3>

<p>他们都说：Core Data简洁易用。他们又说：很棒很好用噢。哈？真的吗，苹果？添加到各个项目中的大量样板数据完全不符合简洁而易用的标准。更别提添加、移除和更新那一大堆的entities、保存context、按不同环境创建不同的Core Data堆栈等等。当然，我很喜欢Core Data，但是苹果真的可以把它更好地简化一下——使用MagicalRecord方式。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0130e5bb0_middle.jpg" alt="3" /></p>

<p>MagicalRecord就像是给Core Data提供了一层外包装，隐藏掉所有不相关的东西。如果你曾经使用过active record模式（比如Ruby on Rails），你就知道了。倾情推荐，在应用中使用Core Data的童鞋们可一定要试试。</p>

<h3>4. <a href="https://github.com/ViccAlexander/Chameleon" target="_blank" title=“Chameleon”>Chameleon</a></h3>

<p>如果你已经看到这里了，我猜你更有可能是个程序猿，而不是设计狮。这里有个东东很适合你。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae02035ca71_middle.jpg" alt="4" /></p>

<p>Chameleon是一个iOS的色彩框架。它运用现代化flat color将UIColor扩展地非常美观。我们还可以通过它运用自定义颜色创建调色板。它还有很多功用，请浏览readme。如果你想要应用美观的话，一定要把这个库加到项目里。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0212f22c6_middle.jpg" alt="4-1" /></p>

<h3>5. <a href="https://github.com/Alamofire/Alamofire" target="_blank" title=“Alamofire”>Alamofire</a></h3>

<p>Alamofire是一个简洁的网络库，用Swift语言编写。你是否曾经使用过AFNetworking呢？Alamofire是它的小弟。更年轻更时尚，当然（AFNetworking是用Objective-C编写的）。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae024c07d47_middle.jpg" alt="5" /></p>

<p>如果你需要进行网络的相关工作，诸如下载、上传与获取JSONs等等的话，Alamofire正是你所需要的。GitHub上8000人次推荐，一定不会错。</p>

<h3>6. <a href="https://github.com/raulriera/TextFieldEffects" target="_blank" title=“TextFieldEffects”>TextFieldEffects</a></h3>

<p>你不觉得标准的UITextField有些枯燥么？我也这样想——来认识一下TextFieldEffects吧！废话不多说，只要看几个例子：</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae048484702.jpg" alt="6" /></p>

<p>是啊，都是些简单的dropin控制器。你甚至可以在storyboard中使用IBDesignables。</p>

<p>不幸地是：这个库不支持CocoaPods（如果你来自未来，而这一情况什么时候会改变的话，一定要在Twitter上告诉我），但是它支持Carthage。你只管从GitHub上下载项目，把它放入你的workspace就行了。</p>

<h3>7. <a href="https://github.com/BradLarson/GPUImage" target="_blank" title=“GPUImage”>GPUImage</a></h3>

<p>你曾经写过照相机应用吗？如果没有的话，很快你一定会遇到这个库的。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae04fe94fc8.jpg" alt="7" /></p>

<p>GPUImage为我们提供了一个GPU加速的照相机效果（同时支持照片与视频），而且处理速度飞快。在App Store中，使用这个库的应用数以百计。我有一个应用也用到了GPUImage。 它在GitHub上获得了8869个star，而且还在增长。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae053f548d5_middle.jpg" alt="7-1" /></p>

<h3>8. <a href="https://github.com/nicklockwood/iRate" target="_blank" title=“iRate”>iRate</a></h3>

<p>想要在App Store中获得更多评论的最佳方式是什么？想要回答这个问题，我缺乏切实数据，但如果必须猜一下的话，我会建议问问用户。也许这样做有点老套——大多开发者现在都有创建定制的应用内置alert。</p>

<p>但是如果你没有时间，或者不想从头实现的话，最好用一下iRata。这个就是iRata——一个小型库——你可以把它放入项目中，把问卷调查什么的都忘记吧，iRate会在恰当的时候为你解决这个问题。</p>

<h3>9. <a href="https://github.com/nihalahmed/GameCenterManager" target="_blank" title=“GameCenterManager”>GameCenterManager</a></h3>

<p>无论你喜不喜欢单例模式，管理一个GameCenter都比我们已知的其他相反模式要好很多。（你的游戏只有一个GameCenter，对吗？）</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae05bd3f99e_middle.jpg" alt="9" /></p>

<p>说实话，在iOS上管理GameCenter vanilla并不算难，但是有了这个库会更简单也更快。好上加好不是更好么。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae05c9cba37_middle.jpg" alt="9-1" /></p>

<p>我在我一个游戏中用到了这个，体验很好。</p>

<h3>10. <a href="https://github.com/pkluz/PKRevealController" target="_blank" title=“PKRevealController 2”>PKRevealController 2</a></h3>

<p>这个要注意，真的很棒！是我最喜爱的iOS控件之一。PKRevealController是一个可以滑动的侧边栏菜单（可向左、向右或者同时向两侧），只需手指轻轻一点（或者按一下按钮，但是这样滑动时不够炫酷）。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae067bd3b6b.jpg" alt="2" /></p>

<p>我试过一些可以提供这类控制的其他库，而PKRevealController是最棒的。安装简便，高度定制且对手势识别良好。可以当做一个标准控件用在iOS SDK中。</p>

<h3>11. <a href="https://github.com/slackhq/SlackTextViewController" target="_blank" title=“SlackTextViewController”>SlackTextViewController</a></h3>

<p>你曾经用过Slack iOS应用吗？如果你在较大的软件公司工作，也许会用过。对那些没用过的人呢？—?Slack令人激动。用到Slack的应用也是这样，尤其是用作极佳、定制的文本输入控制时。这时你有了一个现成可用在应用中的代码。</p>

<p>自适应文本区域？试一下。</p>

<p>手势识别、自动填充、多媒体合并？试一下。</p>

<p>快速drop-in解决方案？试一下。</p>

<p>其他还想要什么？</p>

<h3>12. <a href="https://github.com/romaonthego/RETableViewManager" target="_blank" title=“RETableViewManager”>RETableViewManager</a></h3>

<p>RETableViewManager可以帮助你进行动态创建与管理table views。它给我们提供了预定义cells（bool类型、文本、日期等等——请看下面的截图），但是你还可以创建自定义views，并与默认视图一同使用。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0702088ab_middle.jpg" alt="12" /></p>

<p>左侧截图显得非常古板！在storyboard中没有这个库的时候，你能做的就是这些了，但是有时候代码比可视化编辑器要好。</p>

<h3>13. <a href="https://github.com/nickoneill/PermissionScope" target="_blank" title=“PermissionScope”>PermissionScope</a></h3>

<p>用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—>更多活跃用户->更高的留存率->数据更好->下载率更高。墙裂推荐pod。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0733b6110_middle.jpg" alt="13" /></p>

<h3>14. <a href="https://github.com/TransitApp/SVProgressHUD" target="_blank" title=“SVProgressHUD”>SVProgressHUD</a></h3>

<p>这张图片在正常加载，无需等待太久或者刷新页面。这正是SVProgressHUD在你的应用中的表现。如果你需要定制化的等待提示器，这个就是了（也许是最好的）。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae077d15432.jpg" alt="14" /></p>

<h3>15. <a href="https://github.com/PrideChung/FontAwesomeKit" target="_blank" title=“FontAwesomeKit”>FontAwesomeKit</a></h3>

<p>Font Awesome很棒，有了它你可以很容易地给项目加字体，使用方式繁多。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae07a34b492_middle.jpg" alt="15" /></p>

<h3>16. <a href="https://github.com/SnapKit/SnapKit" target="_blank" title=“SnapKit”>SnapKit</a></h3>

<p>喜欢自动布局吗？当然喜欢！至少在storyboard中创建时会喜欢。 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae07ebf3c2c_middle.jpg" alt="16" /></p>

<h3>17. <a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" title=“MGSwipeTableCell”>MGSwipeTableCell</a></h3>

<p>这是另一个常见于很多应用中的UI组件，苹果应该考虑在标准的iOS SDK中加入一些类似的内容。Swipeable表格cell是这个pod的最佳描述，也是最好的。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0953304a9.jpg" alt="17" /></p>

<p>这只是其中三个动画类型，还有更多变化，请查看readme。</p>

<h3>18. <a href="https://github.com/Quick/Quick" target="_blank" title=“Quick”>Quick</a></h3>

<p>用于Swift中的单元测试（也可用于Objective-C），与Xcode整合在一起。如果你是Objective-C的粉丝，我建议用Specta代替这个，但是对Swift使用者来说，Quick是最佳选择。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0a6012068_middle.jpg" alt="18" /></p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0a767198e_middle.jpg" alt="181" /></p>

<h3>19. <a href="https://github.com/saturngod/IAPHelper" target="_blank" title=“IAPHelper”>IAPHelper</a></h3>

<p>应用内付费给我们提供了很多样本代码，而这个库丢掉了那些代码，将金钱交易相关的大多通用任务做了简单的封装。</p>

<h3>20. <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" title=“ReactiveCocoa”>ReactiveCocoa</a></h3>

<p>好吧，这是个小怪物。</p>

<p>ReactiveCocoa并不像列表中其他库一样，它不是小型的drop-in项目。ReactiveCocoa给我们带来了一个迥异的编程风格与结构，它是基于信号与数据流的。首先你需要忘掉已知的一切，才能理解它的工作方式。很有难度，但是价值不斐。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0acf1f0dc_middle.jpg" alt="20" /></p>

<p>在这里教ReactiveCocoa有点不合适，但是如果你感兴趣的话，我会提供一些好源：</p>

<ul>
<li><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank" title=“Getting Started with ReactiveCocoa”>Getting Started with ReactiveCocoa</a></li>
<li><a href="http://nshipster.com/reactivecocoa/" target="_blank" title=“Mattt Thompson：Reactive​Cocoa”>Mattt Thompson：Reactive​Cocoa</a></li>
<li><a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" title=“ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2”>ReactiveCocoa Tutorial – The Definitive Introduction: Part &frac12;</a></li>
</ul>


<p>注意：对我们iOS开发社区的朋友来说，这会是一个稍微有些技术含量的活儿。</p>

<h3>21. <a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" title=“SwiftyJSON”>SwiftyJSON</a></h3>

<p>使Swift的JSON解析变得简单。</p>

<h3>22. <a href="https://github.com/MengTo/Spring" target="_blank" title=“Spring”>Spring</a></h3>

<p>使动画在简单性、可链接性与声明性方面有所提高。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0dfe58b6c_middle.jpg" alt="22" /></p>

<h3>23. <a href="https://github.com/ArtSabintsev/FontBlaster" target="_blank" title=“FontBlaster”>FontBlaster</a></h3>

<p>载入定制字体时更简单。</p>

<h3>24. <a href="https://github.com/JanC/TAPromotee" target="_blank" title=“TAPromotee”>TAPromotee</a></h3>

<p>交叉推广应用是你可以免费实现的最佳市场推广策略之一。使用这个库做起来非常简单，不用都不可能——将TAPromotee加入你的podfile中，免费配置与享受更多下载吧。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0e81d6464_middle.jpg" alt="24" /></p>

<h3>25. <a href="https://github.com/contentful-labs/Concorde" target="_blank" title=“Concorde”>Concorde</a></h3>

<p>你在应用中载入了一堆jpeg吗？有了Concorde，你可以用更好的方式来解决，这是一个很大的进步。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae11e47390e.jpg" alt="25" /></p>

<h3>26. <a href="https://github.com/kishikawakatsumi/KeychainAccess" target="_blank" title=“KeychainAccess”>KeychainAccess</a></h3>

<p>管理Keychain接入的小助手。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0f198a4dc_middle.jpg" alt="26" /></p>

<h3>27. <a href="https://github.com/danielgindi/ios-charts" target="_blank" title=“iOS-charts”>iOS-charts</a></h3>

<p>最后一个，但绝不是最不重要的——iOS图表库！非常有用而且美观，这里我无需赘言。向下看，你就知道用它可以做什么了。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0f6715aec_middle.jpg" alt="27" /></p>

<p>没错，一切都变成了drop-in组件了（也许是“code-in组件）。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0f7ec6743_middle.jpg" alt="271" /></p>

<p>不幸的是，它还不支持CocoaPods，所以你得手动把它拽到你的Xcode workspace里面去。</p>

<p>超长慎入列表：</p>

<ol>
<li><a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" title=“DZNEmptyDataSet”>DZNEmptyDataSet</a>（UI，空表格视图解算器）</li>
<li><a href="https://github.com/jivesoftware/PDTSimpleCalendar" target="_blank" title=“PDTSimpleCalendar”>PDTSimpleCalendar</a>（UI，drop-in日历组件）</li>
<li><a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" title=“MagicalRecord”>MagicalRecord</a>（实施活跃记录模式的Core Data助手）</li>
<li><a href="https://github.com/ViccAlexander/Chameleon" target="_blank" title=“Chameleon”>Chameleon</a>（UI，色彩框架）</li>
<li><a href="https://github.com/Alamofire/Alamofire" target="_blank" title=“Alamofire”>Alamofire</a>（Swift 网络）</li>
<li><a href="https://github.com/raulriera/TextFieldEffects" target="_blank" title=“TextFieldEffects”>TextFieldEffects</a> （UI，自定义外观的文本区域）</li>
<li><a href="https://github.com/BradLarson/GPUImage" target="_blank" title=“GPUImage”>GPUImage</a>（快速图片处理）</li>
<li><a href="https://github.com/nicklockwood/iRate" target="_blank" title=“iRate”>iRate</a>（获取用户评价）</li>
<li><a href="https://github.com/nihalahmed/GameCenterManager" target="_blank" title=“GameCenterManager”>GameCenterManager</a>（快速管理游戏中心）</li>
<li><a href="https://github.com/pkluz/PKRevealController" target="_blank" title=“PKRevealController 2”>PKRevealController 2</a>（UI，滑动侧边栏菜单）</li>
<li><a href="https://github.com/slackhq/SlackTextViewController" target="_blank" title=“SlackTextViewController”>SlackTextViewController</a>（UI，高度可定制的自定义文本区域）</li>
<li><a href="https://github.com/romaonthego/RETableViewManager" target="_blank" title=“RETableViewManager”>RETableViewManager</a>（自动以代码创建表格视图）</li>
<li><a href="https://github.com/nickoneill/PermissionScope" target="_blank" title=“PermissionScope”>PermissionScope</a>（UI，预询问用户系统权限的友好体验）</li>
<li><a href="https://github.com/TransitApp/SVProgressHUD" target="_blank" title=“SVProgressHUD”>SVProgressHUD</a> （UI，自定义等待进度条）</li>
<li><a href="https://github.com/PrideChung/FontAwesomeKit" target="_blank" title=“FontAwesomeKit”>FontAwesomeKit</a> （快速添加Awesome字体）</li>
<li><a href="https://github.com/SnapKit/SnapKit" target="_blank" title=“SnapKit”>SnapKit</a>（在代码中快速自动布局）</li>
<li><a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" title=“MGSwipeTableCell”>MGSwipeTableCell</a> （UI，可滑动的表格视图cell）</li>
<li><a href="https://github.com/Quick/Quick" target="_blank" title=“Quick”>Quick</a>（Swift单元测试框架）</li>
<li><a href="https://github.com/saturngod/IAPHelper" target="_blank" title=“IAPHelper”>IAPHelper</a>（应用内购买助手封装）</li>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" title=“ReactiveCocoa”>ReactiveCocoa</a>（FRP框架）</li>
<li><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" title=“SwiftyJSON”>SwiftyJSON</a>（Swift JSON库）</li>
<li><a href="https://github.com/MengTo/Spring" target="_blank" title=“Spring”>Spring</a>（动画框架）</li>
<li><a href="https://github.com/ArtSabintsev/FontBlaster" target="_blank" title=“FontBlaster”>FontBlaster</a>（在应用中快速载入个性化字体）</li>
<li><a href="https://github.com/JanC/TAPromotee" target="_blank" title=“TAPromotee”>TAPromotee</a>（使用drop-in视图交叉推广应用）</li>
<li><a href="https://github.com/contentful-labs/Concorde" target="_blank" title=“Concorde”>Concorde</a>（下载解码渐进式jpeg）</li>
<li><a href="https://github.com/kishikawakatsumi/KeychainAccess" target="_blank" title=“KeychainAccess”>KeychainAccess</a>（简便管理keychain）</li>
<li><a href="https://github.com/danielgindi/ios-charts" target="_blank" title=“iOS-charts”>iOS-charts</a>（美观的图表库）</li>
</ol>


<p>文章来源：<a href="https://medium.com/app-coder-io/27-ios-open-source-libraries-to-skyrocket-your-development-301b67d3124c" target="_blank" title=“Medium”>Medium</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之获取沙盒路径]]></title>
    <link href="http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing/"/>
    <updated>2015-07-22T01:02:41+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing</id>
    <content type="html"><![CDATA[<p><a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a>详细讲解了沙盒的一些机制。在开发中，我们需要对沙盒进行操作，所以我们需要获取到沙盒路径。</p>

<p>沙盒里的文件夹包括Documents、Library、tmp。这三个文件夹的作用请点击<a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">这里</a>。接下来我们来讲解如何获取Documents、Library、tmp的路径。</p>

<h3>获取沙盒根目录</h3>

<p>获取沙盒根目录，直接调用NSHomeDirectory()：</p>

<pre><code>//获取沙盒根目录
NSString *directory = NSHomeDirectory();
NSLog(@"directory:%@", directory);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:40:16.185 iOSStrongDemo[1605:555658] directory:/var/mobile/Containers/Data/Application/F9418815-51A9-4A0A-A76C-6FD37C400928
</code></pre>

<p>这个是真机的路径，大家有时间的话可以看看模拟器的根目录路径。</p>

<h3>获取Documents路径</h3>

<p>获取Documents路径如下：</p>

<pre><code>//获取Documents路径
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *path = [paths objectAtIndex:0];
NSLog(@"path:%@", path);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:41:41.397 iOSStrongDemo[1613:556159] path:/var/mobile/Containers/Data/Application/A62B886B-A8F0-4215-B59D-1F505C3997BD/Documents
</code></pre>

<p>获取Documents文件夹目录,第一个参数是说明获取Doucments文件夹目录，第二个参数说明是在当前应用沙盒中获取。</p>

<h3>获取Library路径</h3>

<pre><code>//获取Library路径
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
NSString *path = [paths objectAtIndex:0];
NSLog(@"path：%@", path);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:43:15.803 iOSStrongDemo[1619:556638] /var/mobile/Containers/Data/Application/17300507-4643-4DE7-BC68-E13DB19C8D98/Library
</code></pre>

<h3>获取Caches路径</h3>

<pre><code>//获取Caches路径
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
NSString *path = [paths objectAtIndex:0];
NSLog(@"path：%@", path);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:44:31.383 iOSStrongDemo[1626:557083] path：/var/mobile/Containers/Data/Application/1E945B52-E29D-4041-A489-1AA1B11BB960/Library/Caches
</code></pre>

<h3>获取tmp路径</h3>

<pre><code>NSString *tmp = NSTemporaryDirectory();
NSLog(@"tmp：%@", tmp);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:46:07.846 iOSStrongDemo[1632:557537] tmp：/private/var/mobile/Containers/Data/Application/4BE02307-1CC5-47E8-BEA8-CEBB7ED5A402/tmp/
</code></pre>

<p>以上是iOS开发中获取沙盒路径的方法，也许还有更好的获取方法等待我们去发现。后面我们还会讲到关于在沙盒里进行读写文件操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[报错：failed to Get the Task for Process 1285（解决方案）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/21/bao-cuo-:process-launch-failed-failed-to-get-the-task-for-process-1285(jie-jue-fang-an-)/"/>
    <updated>2015-07-21T00:16:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/21/bao-cuo-:process-launch-failed-failed-to-get-the-task-for-process-1285(jie-jue-fang-an-)</id>
    <content type="html"><![CDATA[<h2>你遇到的问题别人也遇到过</h2>

<p>初接触iOS开发的童鞋估计会被真机调试搞的稀里糊涂的。在模拟器上运行什么问题没有，真机调试就会碰到各种各样的问题。</p>

<p>不用担心。记住：你碰到的问题别人肯定都已经碰到过了。我们不是有百度和谷歌嘛，把你的问题描述出来，一定有解决方案的。还可以在<a href="http://zhannei.superqq.com/">刚刚在线站内搜索</a>里搜索，说不定也能帮你解决不少问题呢。</p>

<p>我会经常把自己开发过程中碰到的调试问题，一一总结出来。一来是帮助自己在下一次碰到同样问题时，可以游刃有余。二来是帮助大家再碰到类似问题的时候，有一个参考的作用。</p>

<h2>failed to get the task for process 1285</h2>

<p>这一次碰到的问题是这样的：模拟器上运行正常。我在iPhone 6上运行，程序编译正常，但是跑起来之后，大概一两秒的时间，就闪退（代码是没有问题的）。这个时候，Xcode6.4弹出这样的提示：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/fixbug12850.jpg" alt="fixbug1285" /></p>

<pre><code>Could not launch “iOSStrongDemo”
process launch failed: failed to get the task for process 1285
</code></pre>

<h2>错误分析</h2>

<p>我看了一下Build Settings里的Code Signing配置，发现Provisioning Profile选择的是XC Ad Hoc: *。如下图所示：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/fixbug.jpg" alt="fixbug" /></p>

<p>Ad Hoc是用来实现发布前的用户测试的，也就是通过Ad Hoc将未发布的App给其他人提前使用。显然这是不对的，我们是要真机调试。</p>

<h2>解决方案</h2>

<p>解决方法很简单，将Provisioning Profile换成用开发证书创建的Provisioning Profile即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之沙盒机制（SandBox)]]></title>
    <link href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-(sandbox/"/>
    <updated>2015-07-20T00:36:13+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-(sandbox</id>
    <content type="html"><![CDATA[<p>iOS APP可以在自己的沙盒里读写文件，但是，不可以访问其他APP的沙盒。每一个APP都是一个信息孤岛，相互是不可以进行通信的，唯独可以通过<a href="http://www.superqq.com/blog/2015/07/14/xcode6-dot-4zhu-ce-url-schemebu-zou-xiang-jie/">URL Scheme</a>。沙盒里面的文件可以是照片、声音文件、文本、属性列表等。</p>

<h2>沙盒机制简介</h2>

<p><strong>沙盒简述：</strong></p>

<ol>
<li>每一个APP都有一个存储空间，就是沙盒。</li>
<li>APP之间不能相互通信。</li>
<li>沙盒根目录结构：Documents、Library、temp。</li>
</ol>


<p>简述一下Documents、Library、tmp的区别：</p>

<ol>
<li><strong>Documents：</strong>用于存储用户数据，iTunes备份和恢复的时候会包括此目录，所以，苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下。</li>
<li><strong>Library：</strong>包含两个子目录：Caches 和 Preferences。Caches用来存放用户需要换成的文件。Preferences是APP的偏好设置，可以通过NSUserDefaults来读取和设置。</li>
<li><strong>tmp：</strong> 用于存放临时文件，这个可以放一些当APP退出后不再需要的文件。</li>
</ol>


<h2>打开模拟器沙盒方法</h2>

<p><strong>方法一：前往文件夹打开</strong></p>

<pre><code>/Users/ligang/Library/Application Support/iPhone Simulator/ 
</code></pre>

<p>直接在Finder->前往->前往文件夹，输入上面的内容即可。记住将ligang换成你的电脑用户名。</p>

<p><strong>方法二：通过Finder一步步查找</strong></p>

<p>模拟器上的APP的沙盒实在用户目录下的资源库里面，但是资源库是隐藏文件夹。所以查看沙盒之前，现将隐藏文件夹显示出来。显示隐藏文件的命令：</p>

<pre><code>defaults write com.apple.finder AppleShowAllFiles -bool true
</code></pre>

<p>用心的童鞋会发现，隐藏隐藏文件的命令：</p>

<pre><code>defaults write com.apple.finder AppleShowAllFiles -bool false
</code></pre>

<p>查找步骤请看图：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/sandbox.jpg" alt="sandbox" /></p>

<p>关于沙盒机制（SandBox)的介绍大概就是这样，以后面试的时候万一碰到你就可以这么回答。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员头条：程序员关心的，才是头条！]]></title>
    <link href="http://www.superqq.com/blog/2015/07/19/cheng-xu-yuan-tou-tiao-:cheng-xu-yuan-guan-xin-de-,cai-shi-tou-tiao-!/"/>
    <updated>2015-07-19T10:19:17+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/19/cheng-xu-yuan-tou-tiao-:cheng-xu-yuan-guan-xin-de-,cai-shi-tou-tiao-!</id>
    <content type="html"><![CDATA[<p>看到这个标题，你是不是很熟悉。你肯定能想到今日头条。《今日头条》是一款会自动学习的资讯软件,它会聪明地分析你的兴趣爱好,自动为你推荐喜欢的内容,并且越用越懂你.你关心的,才是头条!</p>

<h2>我想做什么？</h2>

<p>也许你的手机上装的就有今日头条，我也装的有，但是不经常看。今天我不是来为今日头条代言的，我是想告诉大家我想做什么。</p>

<p>作为程序员，我们更关心的是高质量的技术文章。有时一篇优秀的文章，可以让我们技术得到提高，思维得到开拓。</p>

<p>如何找到优秀的技术文章，成为了摆在我们面前的问题。虽然，有很多程序员门户网站，但是想在上面找到一篇好的文章还是挺不容易的。</p>

<p>所以，我决定为大家挖掘优秀的文章。农夫山泉有句广告语：我不生产水,我只是大自然的搬运工。这句广告语也非常适合我即将要做的程序员头条。</p>

<h2>程序员头条简介</h2>

<p>网站名称：程序员头条；slogan：程序员关心的，才是头条！如果你有非常棒的slogan，请直接回复我。域名：<a href="wwww.90159.com">wwww.90159.com</a>，是不是觉得域名还不错，别忘了我之前炒过域名噢！</p>

<p>我希望程序员头条能成为高质量技术文章聚合网站。时间充裕的情况下，我还将推出程序员头条APP，方便大家手机阅读。</p>

<p>我每天将拿出1-2个小时的时间来找文章。当然，我一个人的力量是渺小的，我希望发动大家的力量，一起为发现优秀的技术文章而努力。具体投稿方式请往下看。</p>

<h2>投稿方式</h2>

<p>你可以将自己的优秀文章链接发给我，你也可以将你发现的优秀文章链接发给我。</p>

<ol>
<li><p>标题上一定要加上【投稿】二字，邮件太多，以免误删。</p></li>
<li><p>投稿邮箱： <strong>worldligang@163.com</strong></p></li>
</ol>


<p>凡是投稿过来的文章，我都会加上原文链接，来增加你的网站或博客的访问量。</p>

<h2>招聘一名小编</h2>

<p>期望：</p>

<ol>
<li>你有一颗积极向上心</li>
<li>你会用markdown</li>
<li>有较强的协调能力、应变能力和外联能力、做事有条理、工作效率高。</li>
</ol>


<p>如果你符合上述条件，请加入我们吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[禅与Objective-C编程艺术(译)]]></title>
    <link href="http://www.superqq.com/blog/2015/07/18/ios/"/>
    <updated>2015-07-18T23:15:26+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/18/ios</id>
    <content type="html"><![CDATA[<p>禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）</p>

<p>原文 <a href="https://github.com/objc-zen/objc-zen-book">https://github.com/objc-zen/objc-zen-book</a></p>

<p><img src="https://github.com/objc-zen/objc-zen-book/raw/master/images/zen-logo-thumb.png" alt="" /></p>

<h1>前言</h1>

<p>我们在 2013 年 11 月份开始写这本书，最初的目标是提供一份如何编写干净漂亮的 Objective-C 代码的指南：现在虽然有很多指南，但是它们都是有一些问题的。我们不想介绍一些死板的规定，我们想提供一个在开发者们之间写更一致的代码的途径。随时间的推移，这本书开始转向介绍如何设计和构建优秀的代码。</p>

<p>这本书的观点是代码不仅是可以编译的，同时应该是 “有效” 的。好的代码有一些特性：简明，自我解释，优秀的组织，良好的文档，良好的命名，优秀的设计以及可以被久经考验。
本书的一个理念是是代码的清晰性优先于性能，同时阐述为什么应该这么做。
虽然所有的代码都是 Objective-C 写的，但是一些主题是通用的，并且独立于编程语言。</p>

<h2>Swift</h2>

<p>在 2014 年 6 月 6 日，苹果发布了面向 iOS 和 Mac 开发的新语言： Swift。
这个新语言与 Objective-C 截然不同。所以，我们改变了写这本书的计划。我们决定发布这本书当前的状态，而不是继续书写我们原来计划写下去的主题。
Objective-C 没有消失，但是现在用一个慢慢失去关注的语言来继续写这本书并不是一个明智的选择。</p>

<h2>贡献给社区</h2>

<p>我们将这本书免费发布并且贡献给社区，因为我们希望提供给读者一些有价值的内容。如果你能学到至少一条最佳实践，我们的目的就达到了。</p>

<p>我们已经非常用心地打磨了这些文字，但是仍然可能有一些拼写或者其他错误。我们非常希望读者给我们一个反馈或者建议，以来改善本书。所以如果有什么问题的话，请联系我们。我们非常欢迎各种 pull-request。</p>

<h2>作者</h2>

<p><strong>Luca Bernardi</strong></p>

<ul>
<li><a href="http://lucabernardi.com">http://lucabernardi.com</a></li>
<li>@luka_bernardi</li>
<li><a href="http://github.com/lukabernardi">http://github.com/lukabernardi</a></li>
</ul>


<p><strong>Alberto De Bortoli</strong></p>

<ul>
<li><a href="http://albertodebortoli.com">http://albertodebortoli.com</a></li>
<li>@albertodebo</li>
<li><a href="http://github.com/albertodebortoli">http://github.com/albertodebortoli</a></li>
</ul>


<h2>关于中文翻译</h2>

<p>译者</p>

<p><strong>林翔宇</strong>
- <a href="http://linxiangyu.org">http://linxiangyu.org</a>
- <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#108;&#x69;&#x6e;&#120;&#105;&#x61;&#x6e;&#103;&#x79;&#x75;&#x40;&#110;&#x75;&#x70;&#116;&#x65;&#114;&#46;&#111;&#x72;&#x67;">&#x6c;&#105;&#110;&#x78;&#x69;&#x61;&#110;&#103;&#x79;&#x75;&#64;&#x6e;&#x75;&#112;&#x74;&#101;&#x72;&#x2e;&#x6f;&#114;&#103;</a>
- <a href="http://github.com/oa414">http://github.com/oa414</a></p>

<p><strong>庞博</strong>
- <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x62;&#x6f;&#x70;&#97;&#x6e;&#x67;&#64;&#x73;&#x6f;&#104;&#x75;&#45;&#105;&#x6e;&#x63;&#x2e;&#x63;&#x6f;&#x6d;">&#98;&#111;&#112;&#97;&#x6e;&#x67;&#64;&#x73;&#111;&#104;&#x75;&#45;&#x69;&#x6e;&#x63;&#46;&#99;&#x6f;&#109;</a>
- <a href="https://github.com/heistings">https://github.com/heistings</a></p>

<p>翻译已得到原作者许可，并且会在更加完善后申请合并到原文仓库。</p>

<p><strong>部分译文表达可能存在不妥之处，非常欢迎各种修订建议和校队。 请直接 fork 本仓库，在 README.md 文件中修改，并申请 pull request 到 <a href="https://github.com/oa414/objc-zen-book-cn/">https://github.com/oa414/objc-zen-book-cn/</a>。</strong></p>

<h1>条件语句</h1>

<p>为了避免错误，条件语句体应该总是被大括号包围，即使可以不这样做（比如，条件语句体只有一行内容）。可能的错误是：多加了第二行，并且误以为它是 if 语句体里面的。此外，更危险的是，如果把 if 语句体里的一行注释掉了，之后的一行代码会成为 if 语句里的代码。</p>

<p><strong>推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) {
</span><span class='line'>    return success;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error)
</span><span class='line'>    return success;</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) return success;</span></code></pre></td></tr></table></div></figure>


<p>在 2014年2月 苹果的 SSL/TLS 实现里面发现了知名的 <a href="https://gotofail.com/">goto fail</a> 错误。</p>

<p>代码在这里：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static OSStatus
</span><span class='line'>SSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa, SSLBuffer signedParams,
</span><span class='line'>                                 uint8_t *signature, UInt16 signatureLen)
</span><span class='line'>{
</span><span class='line'>  OSStatus        err;
</span><span class='line'>  ...
</span><span class='line'>
</span><span class='line'>  if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)
</span><span class='line'>    goto fail;
</span><span class='line'>  if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
</span><span class='line'>    goto fail;
</span><span class='line'>    goto fail;
</span><span class='line'>  if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)
</span><span class='line'>    goto fail;
</span><span class='line'>  ...
</span><span class='line'>
</span><span class='line'>fail:
</span><span class='line'>  SSLFreeBuffer(&signedHashes);
</span><span class='line'>  SSLFreeBuffer(&hashCtx);
</span><span class='line'>  return err;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>显而易见，这里有没有括号包围的2行连续的 <code>goto fail;</code> 。我们当然不希望写出上面的代码导致错误。</p>

<p>此外，在其他条件语句里面也应该按照这种风格统一，这样更便于检查。</p>

<h2>尤达表达式</h2>

<p>不要使用尤达表达式。尤达表达式是指，拿一个常量去和变量比较而不是拿变量去和常量比较。它就像是在表达 “蓝色是不是天空的颜色” 或者 “高个是不是这个男人的属性” 而不是  “天空是不是蓝的” 或者 “这个男人是不是高个子的”</p>

<p><img src="./images/yoda.png" alt="Yoda" /></p>

<p>（译者注：名字起源于星球大战中尤达大师的讲话方式，总是用倒装的语序）</p>

<p><strong>推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ([myValue isEqual:@42]) { ...</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ([@42 isEqual:myValue]) { ...</span></code></pre></td></tr></table></div></figure>


<h2>nil 和 BOOL 检查</h2>

<p>类似于 Yoda 表达式，nil 检查的方式也是存在争议的。一些 notous 库像这样检查对象是否为 nil：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (nil == myValue) { ...</span></code></pre></td></tr></table></div></figure>


<p>或许有人会提出这是错的，因为在 nil 作为一个常量的情况下，这样做就像 Yoda 表达式了。 但是一些程序员这么做的原因是为了避免调试的困难，看下面的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (myValue == nil) { ...</span></code></pre></td></tr></table></div></figure>


<p>如果程序员敲错成这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (myValue = nil) { ...</span></code></pre></td></tr></table></div></figure>


<p>这是合法的语句，但是即使你是一个丰富经验的程序员，即使盯着眼睛瞧上好多遍也很难调试出错误。但是如果把 nil 放在左边，因为它不能被赋值，所以就不会发生这样的错误。 如果程序员这样做，他/她就可以轻松检查出可能的原因，比一遍遍检查敲下的代码要好很多。</p>

<p>为了避免这些奇怪的问题，可以用感叹号来作为运算符。因为 nil 是 解释到 NO，所以没必要在条件语句里面把它和其他值比较。同时，不要直接把它和 <code>YES</code> 比较，因为 <code>YES</code> 的定义是 1， 而 <code>BOOL</code> 是 8 bit的，实际上是 char 类型。</p>

<p><strong>推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (someObject) { ...
</span><span class='line'>if (![someObject boolValue]) { ...
</span><span class='line'>if (!someObject) { ...</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (someObject == YES) { ... // Wrong
</span><span class='line'>if (myRawValue == YES) { ... // Never do this.
</span><span class='line'>if ([someObject boolValue] == NO) { ...</span></code></pre></td></tr></table></div></figure>


<p>同时这样也能提高一致性，以及提升可读性。</p>

<p>原文 <a href="https://github.com/objc-zen/objc-zen-book">https://github.com/objc-zen/objc-zen-book</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我这个站长是怎么炼成的]]></title>
    <link href="http://www.superqq.com/blog/2015/07/17/wo-zhe-ge-zhan-chang-shi-zen-yao-lian-cheng-de/"/>
    <updated>2015-07-17T23:16:16+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/17/wo-zhe-ge-zhan-chang-shi-zen-yao-lian-cheng-de</id>
    <content type="html"><![CDATA[<p>我是一个喜欢折腾的人，不喜欢就这么平平淡淡度过，但是想改变也不是那么容易的。现在的我已经成了一个彻头彻尾的程序员、白领，也许有人会羡慕这样的生活。但我却厌倦了，这并不是我所想要的人生。</p>

<h2>想改变没那么简单</h2>

<p>曾几何时，我也想有一份稳定的工作，就像现在一样。但是当我真正身处其中时，这样的生活、这样的工作显得是那么的廉价，让我没有一丝珍惜的意愿。</p>

<p>所以我想改变，这个想法从来没有停止过。</p>

<p>我一直是做iOS开发，平时没事总想倒腾个什么出来。做什么呢？想法很多，但很少付出行动，有的行动了，效果也一般，所以每次都不了了之。</p>

<h2>swift论坛起落</h2>

<p>2014年6月，苹果在WWDC大会上发布了swift语言。公司同事讨论激烈，有人提议做个论坛出来，肯定可以火起来的。</p>

<p>这一次说干就干。刚好我有服务器。光有服务器也不行，还需要有域名。我查了一下跟swift相关的域名，很多都被注册了，看来中国人真是够多的，抢注的这么快。最后我注册了<a href="http://www.iswifting.com/">www.iswifting.com</a></p>

<p>很快网站就被搭建起来了，这算是我踏入站长行列的第一步。</p>

<p>我非常认真地对待它，经常找一些优秀的文章。我也学着推广，在别的论坛里，QQ群里。每天也有一些人访问，注册会员也有几百人了。</p>

<p>尽管这样，我也看不到网站的前途在哪。刚好赶上服务器到期，我就放弃了这个论坛。虽然这个论坛没给我带来什么盈利，但是这次的站长经历着实让我过了一把瘾。</p>

<p>前段时间，我再次启用了这个域名<a href="http://www.iswifting.com/">www.iswifting.com</a>，做一个<a href="http://www.iswifting.com/">swift开发</a>，以后还会在这里分享一些关于swift的优秀文章。算是对上一个论坛的延续吧。</p>

<h2>刚刚在线正式上线</h2>

<p>论坛没了，又开始每天漫无目的的逛游。无意间我发现一个iOS开发的人叫唐巧，也许你也听说过。他有一个个人博客网站做的不错，<a href="http://blog.devtang.com/">唐巧的技术博客</a>，里面都是他自己写的iOS开发技术文章和一些琐事。</p>

<p>看一个网站好不好就看他的访问量多少，排名如何。我那个时候查的时候，他的博客就有上千UV。在中国排名也不错，有得公司官网可能就没有他的排名高。</p>

<p>虽然我的技术不如巧哥那么厉害，但是我也想在茫茫互联网中找到自己的一席之地。所以我也想做一个类似的网站。名字我都想好了，叫<a href="http://www.superqq.com/">刚刚在线</a>，刚好我手里有域名：www.superqq.com。这个域名还不错吧，偷偷的告诉你，我以前还做过域名的生意，赚了点儿小钱而已。</p>

<p>做个网站应该没什么难的吧，但是对于没做过网站的我来说，还真是个问题。我告诉自己不能退缩，要找方法。刚好公司有个同事之前弄过网站。</p>

<p>在公司同事的帮助下，很快我们用octopress把网站搭建起来了。而且这一切都是免费的，所以再也不会存在关闭的问题啦。我非常激动的在我的网站上发了一篇文章：<a href="http://www.superqq.com/blog/2014/09/26/ios/">刚刚在线正式上线</a> 。</p>

<p>我再一次踏入站长行列。这一次或许我能走的更远。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSString的八条实用技巧]]></title>
    <link href="http://www.superqq.com/blog/2015/07/16/nsstringde-ba-tiao-shi-yong-ji-qiao/"/>
    <updated>2015-07-16T23:07:57+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/16/nsstringde-ba-tiao-shi-yong-ji-qiao</id>
    <content type="html"><![CDATA[<p>有一篇文章写了：<a href="http://www.superqq.com/blog/2015/07/11/ioskai-fa-zhi-nsstringde-ji-tiao-shi-yong-ji-qiao/">iOS开发之NSString的几条实用技巧</a> ， 今天这篇，我们讲讲NSString的八条实用技巧。大家可以收藏起来，方便开发随时可以复制粘贴。</p>

<h2>0.首字母大写</h2>

<p>代码：</p>

<pre><code>//首字母大写
NSString *string = @"ligang";
NSLog(@"string: %@",[string capitalizedString]);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 23:06:11.652 iOSStrongDemo[10279:3062010] string: Ligang
</code></pre>

<h2>1.分割字符串</h2>

<p>代码：</p>

<pre><code>//分割字符串
NSString *string = @"This is a iOSDevTip";
NSArray *array = [string componentsSeparatedByString:@"a"];
NSString *string1 = [array objectAtIndex:0];
NSString *string2 = [array objectAtIndex:1];
NSLog(@"string1:%@  string2:%@",string1,string2);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:40:39.559 iOSStrongDemo[10165:3055448] string1:This is   string2: iOSDevTip
</code></pre>

<h2>2.追加字符串</h2>

<p>代码：</p>

<pre><code>//追加字符串
NSMutableString *string = [[NSMutableString alloc] initWithString:@"I Love "];
[string appendString:@"China"];
NSLog(@"string:%@",string);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:42:32.305 iOSStrongDemo[10189:3056410] string:I Love China
</code></pre>

<h2>3.插入字符串</h2>

<p>代码：</p>

<pre><code>//插入字符串
NSMutableString *string = [[NSMutableString alloc] initWithString:@"I China"];
[string insertString:@"Love " atIndex:2];
NSLog(@"string: %@",string);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:44:10.706 iOSStrongDemo[10206:3057014] string: I Love China
</code></pre>

<h2>4.删除字符串</h2>

<p>代码：</p>

<pre><code>//删除字符串
NSMutableString *string = [[NSMutableString alloc] initWithString:@"I love China"];
[string deleteCharactersInRange:NSMakeRange(2, 4)];
NSLog(@"String1: %@",string);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:46:58.437 iOSStrongDemo[10219:3057749] String1: I  China
</code></pre>

<h2>5.判断是否包含前后缀</h2>

<p>代码：</p>

<pre><code>//判断是否包含前后缀
NSString *string = @"I love China";
BOOL isHasI = [string hasPrefix:@"I"];
BOOL isHasChina = [string hasSuffix:@"China"];
</code></pre>

<h2>6.替换字符串</h2>

<p>代码：</p>

<pre><code>//替换字符串
NSString *string = @"I love China";
NSString *replaceString = [string stringByReplacingOccurrencesOfString:@"love" withString:@"like"];
NSLog(@"replaceString:  %@",replaceString);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:56:07.405 iOSStrongDemo[10236:3059503] replaceString:  I like China
</code></pre>

<h2>7.去除字符串首尾的空格和换行符</h2>

<p>代码：</p>

<pre><code>//去除字符串首尾的空格和换行符
NSString *string = @" I love China ";
NSString *text = [string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
NSLog(@"text:%@",text);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 23:00:47.845 iOSStrongDemo[10265:3061013] text:I love China
</code></pre>

<p>代码已经更新，demo下载地址：<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员：选对方向持续努力]]></title>
    <link href="http://www.superqq.com/blog/2015/07/16/cheng-xu-yuan-:xuan-dui-fang-xiang-chi-xu-nu-li/"/>
    <updated>2015-07-16T22:24:25+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/16/cheng-xu-yuan-:xuan-dui-fang-xiang-chi-xu-nu-li</id>
    <content type="html"><![CDATA[<p>今天下班的时候，乘电梯的空打开了一篇文章：一个人，2年时间，做了一个价值1亿美金的网站。文章写得很精彩，非常吸引我。不一会电梯就到了，我依然抱着手机边走边看。</p>

<p>到了我的小电动车旁边（公司离家不远，经常骑电动车上班），文章还没有看完。我就坐在电动车上，依然爱不释手的看着。边看边想：创始人真是太厉害了。</p>

<p>能够吸引我的文章不少，能够这么吸引我的文章不多。建议大家抽时间也看看这篇文章，或许能激发出你的灵感，成就一番事业也说不定。</p>

<h2>方向正确持续努力</h2>

<p>文章里说的网站是：<strong>viralnova.com</strong> 只有创始人一个是全职员工，其他两位是兼职的。网站成立大概两年时间，每天有200万独立访问用户，月入十万美金。世界排名376位。</p>

<p>看到这样的数据真的令人振奋，如果我有一个这样的网站，那就不用上班啦。这也不是没有可能。在国内也有个人做网站比较厉害的，比如说：<strong>卢松松</strong> 国内独立博客大牛。估计每个月也能赚不少钱吧。</p>

<p>不能只看到他们的成绩，更要了解他们背后两年如一日、六年如一日的坚持和努力。有想法的人也许很多，能够坚持将想法付出行动的人就不多了。所以成功者总是少数。选对方向持续努力也许就是成功不二法则。</p>

<p>作为一名程序员你的方向是什么呢？我们都应该这样问一下自己，不能每天漫无目的的坚持。马云不是说了嘛：梦想还是要有的，万一实现了呢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过URL Scheme传递参数]]></title>
    <link href="http://www.superqq.com/blog/2015/07/15/tong-guo-url-schemechuan-di-can-shu/"/>
    <updated>2015-07-15T22:50:21+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/15/tong-guo-url-schemechuan-di-can-shu</id>
    <content type="html"><![CDATA[<p>有这么一个段子特别火：实体店终于翻身了，他们用铁一样的事实告诉淘宝和京东，互联网+再牛逼也干不过实体店。你再便宜，你有试衣间吗？百年修得同船渡，千年修得优衣库。众里寻他千百度，三里屯优衣库。最美的不是下雨天，而是和你在试衣间。</p>

<p>优衣库火了，你的朋友圈有没有被优衣库刷屏呀？据说还有视频传出来，各种版本的。有人竟然从我要视频，我是给还是不给呢？不知道优衣库的童鞋，赶紧百度一下吧！</p>

<h2>这会是优衣库的炒作吗？</h2>

<p>优衣库事件让优衣库狠狠的火了一把。不禁发问：这会是优衣库的炒作吗？不得而知。事件一经各大媒体报道出来之后，优衣库立刻发出声明。此事和我们没有半毛钱关系。</p>

<p>如果这真是一次炒作。那么优衣库的营销未免太低俗了，这将会大大降低优衣库在消费者心里的地位。以后来优衣库的人可能不是买衣服而是约炮。</p>

<p>如果这不是一次炒作。那么，这段视频上传的目的是什么呢？是男女主角想借此出名吗？可能性不是特别高，借此出名有什么好的呢！真正的目的也许只有当事人心里最清楚。</p>

<p>我问了北京的朋友，是否知道优衣库事件。朋友说，何止知道，天天从那里路过。现在有很多人在那里合影呢，三里屯优衣库俨然成了一个景点。</p>

<p><strong>热点总是一时的，借此炒作的人或许已达成目的。</strong>作为一名iOS开发程序员，我们只能继续写代码，改变世界。</p>

<p>上一篇文章讲到：<a href="http://www.superqq.com/blog/2015/07/14/xcode6-dot-4zhu-ce-url-schemebu-zou-xiang-jie/">Xcode6.4注册URL Scheme步骤详解</a>，这一篇继续来看看URL Scheme传递参数。</p>

<h2>通过注册的URL Scheme向目标APP传递参数</h2>

<p>通过URL Scheme启动APP很简单就可以做到，但有时候我们想在启动APP的时候传递一些参数，这个时候我们就可以通过URL Scheme自定义URL来传递参数了。</p>

<p>昨天我们在AppDelegate调用了UIApplicationDelegate的代理方法：</p>

<pre><code>- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL*)url
{
    // 接受传过来的参数
    NSString *text = [[url host] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"打开啦"
                                           message:text
                                          delegate:nil
                                 cancelButtonTitle:@"OK"
                                 otherButtonTitles:nil];
    [alertView show];
    return YES;
}
</code></pre>

<p>我们来看看苹果给这个方法的注释：</p>

<pre><code>- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url;  // Will be deprecated at some point, please replace with application:openURL:sourceApplication:annotation:
</code></pre>

<p>这个方法在未来将被废弃，可以用application:openURL:sourceApplication:annotation:来代替。</p>

<h2>URL传参格式</h2>

<p>昨天我们在<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>注册的URL Scheme还记得是什么吗？你应该还有印象的就是iOS开发的ID：<strong>iOSDevTip</strong>。</p>

<p>假设我们想要传递两个参数分别是名字name和手机号phone，格式如下：</p>

<pre><code>iOSDevTip://?name=ligang&amp;phone=13888888888
</code></pre>

<p>有没有似曾相识的感觉。我们用get方式请求一个接口是不是就是这样的。</p>

<h2>被启动的APP处理传过来的参数</h2>

<pre><code>- (BOOL)application:(UIApplication *)application
        openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
         annotation:(id)annotation
{
    NSLog(@"sourceApplication: %@", sourceApplication);
    NSLog(@"URL scheme:%@", [url scheme]);
    NSLog(@"URL query: %@", [url query]);

    // 接受传过来的参数
    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"打开啦"
                                                        message:[url query]
                                                       delegate:nil
                                              cancelButtonTitle:@"OK"
                                              otherButtonTitles:nil];
    [alertView show];

    return YES;
}
</code></pre>

<p>当APP被启动是，会调用代理方法application:openURL:sourceApplication:annotation:。参数URL就是启动APP的URL，参数sourceApplication就是来源APP的Bundle ID。</p>

<p>我们依然通过Safari来测试，在Safari的地址栏中输入：iOSDevTip://?name=ligang&amp;phone=13888888888</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/scheme1.png" alt="scheme1" /></p>

<p>即可打开APP,看看参数是否传递过来：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/scheme2.png" alt="scheme2" /></p>

<p>最后我们看一下打印：</p>

<pre><code>2015-07-15 22:38:25.655 iOSStrongDemo[9983:2894855] sourceApplication: com.apple.mobilesafari
2015-07-15 22:38:28.664 iOSStrongDemo[9983:2894855] URL scheme:iosdevtip
2015-07-15 22:38:28.665 iOSStrongDemo[9983:2894855] URL query: name=ligang&amp;phone=13888888888
</code></pre>

<p>sourceApplication打印出来是com.apple.mobilesafari，从这里可以看出来，是从Safari启动我们的APP的。</p>

<p>我们虽然自定义了URL Scheme，但是我们不能阻止别人通过自定义的URL Scheme来打开我们的应用。怎么解决呢？</p>

<p>我们可以指定相应的sourceApplication，也就是相应的Bundle ID，通过Bundle ID来决定是否可以打开我们的APP：</p>

<pre><code>- (BOOL)application:(UIApplication *)application
        openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
         annotation:(id)annotation
{
    NSLog(@"sourceApplication: %@", sourceApplication);
    NSLog(@"URL scheme:%@", [url scheme]);
    NSLog(@"URL query: %@", [url query]);

    if ([sourceApplication isEqualToString:@"com.3Sixty.CallCustomURL"]){
        // 接受传过来的参数
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"打开啦"
                                                            message:[url query]
                                                           delegate:nil
                                                  cancelButtonTitle:@"OK"
                                                  otherButtonTitles:nil];
        [alertView show];

        return YES;
    }else{
        return NO;
    }

}
</code></pre>

<p>这样我们就可以通过Bundle ID来决定是否允许打开我们的APP，demo下载地址：<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode6.4注册URL Scheme步骤详解]]></title>
    <link href="http://www.superqq.com/blog/2015/07/14/xcode6-dot-4zhu-ce-url-schemebu-zou-xiang-jie/"/>
    <updated>2015-07-14T23:34:16+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/14/xcode6-dot-4zhu-ce-url-schemebu-zou-xiang-jie</id>
    <content type="html"><![CDATA[<p>好消息：微信团队邀请我的iOS开发（id：<strong>iOSDevTip</strong>）微信公众号开通赞赏功能，以后我就可以光明正大的通过文章要饭啦。你的赞赏就是我最大的动力。</p>

<p>这是今天下午15：30收到的邀请：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/zanshang.png" alt="zanshang1" /></p>

<h2>微信赞赏功能</h2>

<p>为什么推出赞赏功能？微信公众号自2012年推出以来，一直成爆发式的增长。微信推出赞赏功能最重要的目的就是为了鼓励原创，鼓励创新。</p>

<p>之前，原创功能、赞赏功能和评论功能是一起邀请开通的。现在微信团队分三次邀请。现在我的iOS开发公众号，已经被邀请开通了原创和赞赏功能，下一步争取开通评论功能。</p>

<p>如果开通评论功能，我就可以更方便的和大家交流。一经邀请，我会第一时间告诉大家的。好消息，大家也知道啦。接下来继续回到正题，我们来谈谈iOS中的URL Scheme。</p>

<h2>URL Scheme的作用</h2>

<p>我们都知道苹果手机中的APP都有一个沙盒，APP就是一个信息孤岛，相互是不可以进行通信的。但是iOS的APP可以注册自己的URL Scheme，URL Scheme是为方便app之间互相调用而设计的。我们可以通过系统的OpenURL来打开该app，并可以传递一些参数。</p>

<p>例如：你在Safari里输入www.alipay.com，就可以直接打开你的支付宝app，前提是你的手机装了<a href="http://www.superqq.com/blog/2015/07/10/zhi-fu-bao-he-wei-xin-zai-chao-xi-shang-shui-geng-sheng-%5B%3F%5D-chou/">支付宝</a>。如果你没有装支付宝，应该显示的是支付宝下载界面，点击会跳到AppStore的支付宝下载界面。</p>

<p>URL Scheme必须能唯一标识一个APP，如果你设置的URL Scheme与别的APP的URL Scheme冲突时，你的APP不一定会被启动起来。因为当你的APP在安装的时候，系统里面已经注册了你的URL Scheme。</p>

<p>一般情况下，是会调用先安装的app。但是iOS的系统app的URL Scheme肯定是最高的。所以我们定义URL Scheme的时候，尽量避开系统app已经定义过的URL Scheme。</p>

<h2>注册URL Scheme</h2>

<h3>1.在info.plist里添加URL types</h3>

<p>每一个项目里面都会有一个info.plist配置文件。找到info.plist，右键选择Add Row，然后选择URL types。如图所示：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/url1.jpg" alt="url1" /></p>

<h3>2.添加URL Schemes</h3>

<p>添加完URL types，点击展开。右键选择Add Row，添加URL Schemes：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/url2.jpg" alt="url2" /></p>

<h3>3.设置URL Schemes</h3>

<p>设置URL Schemes为iOSDevTip</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/url3.jpg" alt="url3" /></p>

<h3>4.设置URL Identifier</h3>

<p>URL Identifier是自定义的 URL scheme 的名字，一般采用反转域名的方法保证该名字的唯一性，比如 com.iOSStrongDemo.www</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/url4.jpg" alt="url4" /></p>

<h2>添加成功启动提示</h2>

<p>为了方便测试，我们在AppDelegate里面添加一个UIAlertView，当app被成功打开时，会提出提示：</p>

<pre><code>- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL*)url
{
    // 接受传过来的参数
    NSString *text = [[url host] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"打开啦"
                                           message:text
                                          delegate:nil
                                 cancelButtonTitle:@"OK"
                                 otherButtonTitles:nil];
    [alertView show];
    return YES;
}
</code></pre>

<h2>Safari启动自定义的URL Schemes APP</h2>

<p>既然已经配置好URL Schemes，那么我们可以来款速测试一下，我们设置的URL Schemes是否有效。打开Safari，在地址栏里输入：iOSDevTip://</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/url6.png" alt="url6" /></p>

<p>果然成功打开：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/url5.png" alt="url5" /></p>

<p>也可以在地址栏中输入：iOSDevTip://com.iOSStrongDemo.www。也是可以打开注册了URL Schemes的APP的。</p>

<h2>通过另一个APP启动注册了URL Schemes的APP</h2>

<pre><code> NSString *url = @"iOSDevTip://";
//    NSString *url = @"iOSDevTip://com.iOSStrongDemo.www";
if ([[UIApplication sharedApplication]
     canOpenURL:[NSURL URLWithString:url]])
{
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];
}
else
{
    NSLog(@"can not open URL scheme iOSDevTip");
}
</code></pre>

<p>打开注册iOSDevTip的APP格式为: URL Scheme://URL identifier，直接调用URL Scheme也可打开程序, URL identifier是可选的。</p>

<p>注册URL Scheme就是这么简单。下一篇会分享如何通过URL Scheme传递参数。demo下载地址：<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从app跳到设置界面]]></title>
    <link href="http://www.superqq.com/blog/2015/07/13/cong-apptiao-dao-she-zhi-jie-mian/"/>
    <updated>2015-07-13T23:50:45+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/13/cong-apptiao-dao-she-zhi-jie-mian</id>
    <content type="html"><![CDATA[<p>这次去郑州主要是参加大学同学的婚礼。匆匆而来，匆匆而回。时间安排的好紧，还没有来得及多看两眼我的大好中原。</p>

<p>来参加婚礼的还有其他几位同学，有的真是多年不见。见面之后相互虚寒一番，一起讨论讨论各自的近况。时间飞逝，让这样的相遇变得非常珍贵。</p>

<p>这次的婚礼，别有一番风味。</p>

<h2>第一次在教堂里参加婚礼</h2>

<p>我的这位同学，他是一位虔诚的基督徒，他们的婚礼也理所当然的在教堂举行。教堂是一个神圣庄严的地方，虽然我不是一名基督徒，但是我依然怀有一颗虔诚的心。</p>

<p>婚礼还是相当热闹的。有牧师为他们证婚，真的是很幸福。新娘也感动的眼泪都留下来了。</p>

<p>婚礼结束之后，抽空拉着另外一个同学，加上新郎，我们三兄弟合了一张影。这张照片可以发给大家欣赏一下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/hunli.png" alt="1" /></p>

<p>看到这张我不由得说一句：又长胖了！好吧，闲话就絮叨这里。今天给大家分享一个小功能：从app跳到设置界面。</p>

<h2>从app跳到设置界面</h2>

<p>直接上代码：</p>

<pre><code> NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString];
 if ([[UIApplication sharedApplication] canOpenURL:url]) {
     [[UIApplication sharedApplication] openURL:url];
 }
</code></pre>

<p>上面这段代码要在iOS 8以上的系统使用。一般做智能家居app的，需要到设置界面连接wifi，但是苹果没有提供这样的接口。所以可以退而求其次，跳到系统的设置界面。</p>

<p>想测试的童鞋请下载demo：<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>

<h2>回复关键词获取相应文章</h2>

<p>公众号iOS开发：<strong>iOSDevTip</strong>，已经发展一年多的时间，已经积累了很多优秀的文章。也许能帮到一些小忙。</p>

<p>我告诉大家，如何找到这些优秀的文章：</p>

<ol>
<li>查看历史消息</li>
<li>关键词回复，先回复“m”，获取目录。目录里面详细讲解了，哪些关键词对应哪些文章。</li>
</ol>


<p>有什么不懂得可以随时联系我，直接在后台回复就可以，也可以加我的微信：<strong>chinaligang</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS提交后申请加急审核]]></title>
    <link href="http://www.superqq.com/blog/2015/07/13/iosti-jiao-hou-shen-qing-jia-ji-shen-he/"/>
    <updated>2015-07-13T23:14:17+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/13/iosti-jiao-hou-shen-qing-jia-ji-shen-he</id>
    <content type="html"><![CDATA[<p>之前只是听过加急审核这回事，一直也没有用到过。昨天用了下果然很给力。昨天晚上将近8点（北京时间）提交应用，今天早上上班看了下已经通过了审核，而且可以在AppStore里下载到。</p>

<p>话说加急的原因比较悲催，年前一直在做老版本的更新（一直在改别人代码的bug），临过年一周多的时候说不改了，做新版本的。心里终于舒服些，开始
自己写新版本。2月7号上班到2月18号一直在做新版本。就在经理天天催，老板经常问进度的时候，实施那边说xxx那边20号要验收，验收不过要打官司
了……</p>

<p>然后开始悲催的继续找到以前别人的代码改bug，十几个，虽说难度不是很大，但是很不爽~</p>

<p>18号加班改完，19号给测试人员测试。然后我继续开始新版本。结果测试那一天了没消息，LZ很2的去找到测试去问测试完了吗？然后测试MM笑着和
我说，呀，忘了和你说了，没问题了。
括弧当时时间为下午6点左右，LZ当天正常下班时间是6点十几分。然后开始回来今天提交。话说提交速度那叫一个慢！没办法，启用米国VPN，速度快了很
多，看着进度条一点一点往前走，慢慢走，慢慢走……n久后走到头。然后上面文字提示说已经提交完毕，但是进度条又回到了初始位置是怎么回事
？！愤怒了！去iTunes connect里刷新状态提示等待提交
 = =！</p>

<p>好吧，重新提交 &ndash;> 然后卡那不动了 ~~ 这米国vpn也不好用啊还是库克那服务器的原因啊。。。。</p>

<p>唉，取消提交然后用Application Loader提交，打包、选择、上传，速度很慢但是一切还算是顺利。在忽上忽下、“动荡不定”的网速中终于提交成功。iTunes connect里刷新状态为等待审核。OK，终于提交了。</p>

<p>竟然扯了这么多~</p>

<p>下面进入正题。提交完成后进入加急审核页面。</p>

<p>链接：<a href="https://developer.apple.com/appstore/contact/appreviewteam/index.html">https://developer.apple.com/appstore/contact/appreviewteam/index.html</a></p>

<p>在i would like to里选择加急审核</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/jiaji1.png" alt="1" /></p>

<p>然后填写相关信息。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/jiaji2.png" alt="2" /></p>

<p>App Information里填写应用名称，ID填写9位数字ID。</p>

<p>继续</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/jiaji3.png" alt="3" /></p>

<p>选择原因，然后填写理由。</p>

<p>这里要注意的是理由一般是用户安全问题或者崩溃问题成功率会高一些（LZ写的是崩溃，不要说我是赶时间，苹果会不同意，以前版本确实有崩溃问题，只不过不多~ 这里我不多说了，你们懂的）</p>

<p>还有一点要注意的是，如果是崩溃问题，你最好写上操作步骤，让审核员去重现这个问题。</p>

<p>PS. 如果遇到非常时期或者人品不好遇到心情不好的审核员，请自行另行处理~</p>

<p>就到这里了，继续搬砖去了~</p>

<p>2014.5.10补充：</p>

<p>之前听别人说一年只有两次加急的机会。一直没有尝试过，所以也没法证明是否是真的。</p>

<p>昨天晚上（周五晚）由于销售要在周一的时候开始做大量推广，所以今年的第三次加急审核又开始了……</p>

<p>今天早上起床后还在担心应该是没有通过，但是AppStore查看了下，已经通过了审核。</p>

<p>说明之前一年只有两次加急审核的机会是不正确的。至于一年到底有多少次加急审核的机会，官方没有看到相关的说明，也不能确定次数是多少。</p>

<p>如果有看到相关文档或说明的童鞋，希望能和大家分享下~</p>

<p>2014.5.14补充：</p>

<p>第四次加急，从提交到通过大概过了两天的时间。</p>

<p>2015.6.2补充：</p>

<p>加急审核说明是可以写中文的。这里感谢 @第七只蚂蚁 提供宝贵的信息。</p>

<p>原文来自：<a href="http://blog.csdn.net/showhilllee/article/details/19541493">iOS提交后申请加急审核</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 中的 NSTimer]]></title>
    <link href="http://www.superqq.com/blog/2015/07/12/ios-zhong-de-nstimer/"/>
    <updated>2015-07-12T21:02:51+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/12/ios-zhong-de-nstimer</id>
    <content type="html"><![CDATA[<blockquote><p>之前的一篇文章：<a href="http://www.superqq.com/blog/2015/07/10/ioskai-fa-zhi-nstimershi-yong-chu-tan/">iOS开发之NSTimer使用初探</a> 讲的是比较基础的知识。今天给大家分享一篇来自Why的“iOS 中的 NSTimer”，讲的就比较深入一些。</p></blockquote>

<p>前阵子在整理公司项目的时候，发现老代码在使用 NSTimer 时出现了内存泄露。然后整理了一些 NSTimer 的相关内容。比较简单，各位见笑啦。</p>

<h2>NSTimer</h2>

<h3>fire</h3>

<p>我们先用 NSTimer 来做个简单的计时器，每隔5秒钟在控制台输出 Fire 。比较想当然的做法是这样的：</p>

<pre><code>@interface DetailViewController ()
@property (nonatomic, weak) NSTimer *timer;
@end

@implementation DetailViewController
- (IBAction)fireButtonPressed:(id)sender {
    _timer = [NSTimer scheduledTimerWithTimeInterval:3.0f
                                              target:self
                                            selector:@selector(timerFire:)
                                            userInfo:nil
                                             repeats:YES];
    [_timer fire];
}

-(void)timerFire:(id)userinfo {
    NSLog(@"Fire");
}
@end
</code></pre>

<p>运行之后确实在控制台每隔3秒钟输出一次 Fire ，然而当我们从这个界面跳转到其他界面的时候却发现：控制台还在源源不断的输出着 Fire 。看来 Timer 并没有停止。</p>

<h3>invalidate</h3>

<p>既然没有停止，那我们在 DemoViewController 的 dealloc 里加上 invalidate 的方法：</p>

<pre><code>-(void)dealloc {
    [_timer invalidate];
    NSLog(@"%@ dealloc", NSStringFromClass([self class]));
}
</code></pre>

<p>再次运行，还是没有停止。原因是 Timer 添加到 Runloop 的时候，会被 Runloop 强引用：</p>

<pre><code>Note in particular that run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop.
</code></pre>

<p>然后 Timer 又会有一个对 Target 的强引用（也就是 self ）：</p>

<pre><code>Target is the object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated.
</code></pre>

<p>也就是说 NSTimer 强引用了 self ，导致 self 一直不能被释放掉，所以也就走不到 self 的 dealloc 里。</p>

<p>既然如此，那我们可以再加个 invalidate 按钮：</p>

<pre><code>- (IBAction)invalidateButtonPressed:(id)sender {
    [_timer invalidate];
}
</code></pre>

<p>嗯这样就可以了。（在 SOF 上有人说该在 invalidate 之后执行 _timer = nil ，未能理解为什么，如果你知道原因可以告诉我：）</p>

<p>在 invalidate 方法的文档里还有这这样一段话：</p>

<pre><code>You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.
</code></pre>

<p>NSTimer 在哪个线程创建就要在哪个线程停止，否则会导致资源不能被正确的释放。看起来各种坑还不少。</p>

<h3>dealloc</h3>

<p>那么问题来了：如果我就是想让这个 NSTimer 一直输出，直到 DemoViewController 销毁了才停止，我该如何让它停止呢？</p>

<ol>
<li>NSTimer 被 Runloop 强引用了，如果要释放就要调用 invalidate 方法。</li>
<li>但是我想在 DemoViewController 的 dealloc 里调用 invalidate 方法，但是 self 被 NSTimer 强引用了。</li>
<li>所以我还是要释放 NSTimer 先，然而不调用 invalidate 方法就不能释放它。</li>
<li>然而你不进入到 dealloc 方法里我又不能调用 invalidate 方法。</li>
<li>嗯…</li>
</ol>


<p><img src="http://ww4.sinaimg.cn/large/61d238c7gw1ettf9re22uj20fu08owf3.jpg" alt="1" /></p>

<h2>HWWeakTimer</h2>

<h3>weakSelf</h3>

<p>问题的关键就在于 self 被 NSTimer 强引用了，如果我们能打破这个强引用问题自然而然就解决了。所以一个很简单的想法就是：weakSelf：</p>

<pre><code>__weak typeof(self) weakSelf = self;
_timer = [NSTimer scheduledTimerWithTimeInterval:3.0f
                                          target:weakSelf
                                        selector:@selector(timerFire:)
                                        userInfo:nil
                                         repeats:YES];
</code></pre>

<p>然而这并没有什么卵用，这里的 <strong>weak 和 </strong>strong 唯一的区别就是：如果在这两行代码执行的期间 self 被释放了， NSTimer 的 target 会变成 nil 。</p>

<h3>target</h3>

<p>既然没办法通过 __weak 把 self 抽离出来，我们可以造个假的 target 给 NSTimer 。这个假的 target 类似于一个中间的代理人，它做的唯一的工作就是挺身而出接下了 NSTimer 的强引用。类声明如下：</p>

<pre><code>@interface HWWeakTimerTarget : NSObject
@property (nonatomic, weak) id target;
@property (nonatomic, assign) SEL selector;
@property (nonatomic, weak) NSTimer* timer;
@end

@implementation HWWeakTimerTarget
- (void) fire:(NSTimer *)timer {
    if(self.target) {
        [self.target performSelector:self.selector withObject:timer.userInfo];
    } else {
        [self.timer invalidate];
    }
}
@end
</code></pre>

<p>然后我们再封装个假的 scheduledTimerWithTimeInterval 方法，但是在调用的时候已经偷梁换柱了：</p>

<pre><code>+ (NSTimer *) scheduledTimerWithTimeInterval:(NSTimeInterval)interval
                                      target:(id)aTarget
                                    selector:(SEL)aSelector
                                    userInfo:(id)userInfo
                                     repeats:(BOOL)repeats {
    HWWeakTimerTarget* timerTarget = [[HWWeakTimerTarget alloc] init];
    timerTarget.target = aTarget;
    timerTarget.selector = aSelector;
    timerTarget.timer = [NSTimer scheduledTimerWithTimeInterval:interval
                                                         target:timerTarget
                                                       selector:@selector(fire:)
                                                       userInfo:userInfo
                                                        repeats:repeats];
    return timerTarget.timer;
}
</code></pre>

<p>再次运行，问题解决。</p>

<h3>block</h3>

<p>如果能用 block 来调用 NSTimer 那岂不是更好了。我们可以这样来实现：</p>

<pre><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval
                                      block:(HWTimerHandler)block
                                   userInfo:(id)userInfo
                                    repeats:(BOOL)repeats {
    return [self scheduledTimerWithTimeInterval:interval
                                         target:self
                                       selector:@selector(_timerBlockInvoke:)
                                       userInfo:@[[block copy], userInfo]
                                        repeats:repeats];
}

+ (void)_timerBlockInvoke:(NSArray*)userInfo {
    HWTimerHandler block = userInfo[0];
    id info = userInfo[1];
    // or `!block ?: block();` @sunnyxx
    if (block) {
        block(info);
    }
}
</code></pre>

<p>这样我们就可以直接在 block 里写相关逻辑了：</p>

<pre><code>- (IBAction)fireButtonPressed:(id)sender {
    _timer = [HWWeakTimer scheduledTimerWithTimeInterval:3.0f block:^(id userInfo) {
        NSLog(@"%@", userInfo);
    } userInfo:@"Fire" repeats:YES];
    [_timer fire];
}
</code></pre>

<p>嗯就是这样。</p>

<h3>More</h3>

<p>把上面的的代码简单的封装到了 <a href="https://github.com/ChatGame/HWWeakTimer">HWWeakTimer</a> 中，欢迎试用。</p>

<p>参考文献:</p>

<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/">NStimer</a></li>
<li><a href="http://stackoverflow.com/questions/15170518/how-to-stop-invalidate-nstimer">How to stop/invalidate NStimer</a></li>
<li><a href="http://stackoverflow.com/questions/16821736/weak-reference-to-nstimer-target-to-prevent-retain-cycle">Weak Reference to NSTimer Target To Prevent Retain Cycle</a></li>
<li><a href="http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown">performSelector may cause a leak because its selector is unknown</a></li>
</ul>


<p>原文链接： <a href="http://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/?sukey=fc78a68049a14bb264852ae4e610e664d74bb6bf7a3e31be7aa2ac6c3e5a83ca566fa1c683d37c01e8569e560d873907" target="_blank" title=" iOS 中的 NSTimer "> iOS 中的 NSTimer </a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之NSString的几条实用技巧]]></title>
    <link href="http://www.superqq.com/blog/2015/07/11/ioskai-fa-zhi-nsstringde-ji-tiao-shi-yong-ji-qiao/"/>
    <updated>2015-07-11T22:57:21+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/11/ioskai-fa-zhi-nsstringde-ji-tiao-shi-yong-ji-qiao</id>
    <content type="html"><![CDATA[<p>这两天上海台风“灿鸿”来袭，又是刮风，又是下雨。这雨已经连下好多天了，再不出太阳人都发霉了。不过无论再怎么样，也不要让天气破坏了心情。</p>

<p>台风来了，刚好我要走了。周六一大早5点就爬起来，雨下的不小，风也特别大。我是7点多的动车。从我家过去大概需要一个半小时的时间。所以得提前起来，省的匆匆忙忙。</p>

<h2>使用Uber的感受</h2>

<p>我还一直担心，这天气可能连车都打不到。抱着尝试的心态，我打开了Uber，为什么打开的是Uber，而不是滴滴，也不是快的呢。因为我的Uber上还有优惠劵，而且还有一个重要的原因，Uber上面的人民优步，不仅价格比出租车便宜，而且服务态度那也是相当好的。</p>

<p>看来我的担心是多余的。我打开Uber点了打车，不到10s，就有司机抢单成功。我连目的地都没有来得及输入，这也是滴滴和快的不具备的。这一点我觉得真的比较人性。因为很多司机都是看距离抢单的，Uber这样做估计就是杜绝这样的事情发生。</p>

<p>我并不说给Uber打广告的，再说了Uber也没给我钱。我之前一直用的都是滴滴和快的。我说的都是事实，大家可以自己尝试尝试。</p>

<p>写这篇文章时，我刚到郑州，在同学安顿的宾馆里。虽然奔波了一天，有些疲惫。还是要给大家准备一些NSString的小技巧。希望你能把iOS开发：<strong>iOSDevTip</strong> 介绍给更多你身边的朋友，这就是对我最大的支持。</p>

<h2>NSString的几条小技巧</h2>

<h3>创建字符串</h3>

<p><strong>常量字符串</strong></p>

<pre><code>NSString *string = @"i am an iOSDevTip!";
</code></pre>

<p><strong>常用创建方法</strong></p>

<pre><code>NSString *string = [[NSString alloc] init];

string = @"i am an iOSDevTip too!";
</code></pre>

<p><strong>用initWithString创建字符串</strong></p>

<pre><code>NSString *string = [[NSString alloc] initWithString:@"iOSDevTip is here!"];
</code></pre>

<h3>格式化创建字符串</h3>

<p><strong>int格式化字符串</strong></p>

<pre><code>int age = 20;
NSString *personAge = [NSString stringWithFormat:@"this person age is %d",age];
</code></pre>

<p>既然int格式化字符串，那么float、double等，也可以格式化字符串。</p>

<p><strong>NSString格式化字符串</strong></p>

<pre><code>NSString *name = @"iOSDevTip";
NSString *personName = [NSString stringWithFormat:@"this person name is %@",name];
</code></pre>

<h3>字符串比较</h3>

<p><strong>isEqualToString方法比较</strong></p>

<pre><code>//比较字符串
NSString *stingOne = @"This is an iOSDevTip!";
NSString *stringTwo = @"This is an iOSDevTip!";
BOOL result = [stingOne isEqualToString:stringTwo];
</code></pre>

<p><strong>compare方法比较</strong></p>

<pre><code>BOOL result = [stingOne compare:stringTwo] == NSOrderedSame;
</code></pre>

<p>compare:方法返回值类型为NSComparisonResult。而NSComparisonResult有下面几个枚举值。</p>

<pre><code>typedef NS_ENUM(NSInteger, NSComparisonResult) {NSOrderedAscending = -1L, NSOrderedSame, NSOrderedDescending};
</code></pre>

<h3>字符串大小写转换</h3>

<p><strong>小写转大写</strong></p>

<pre><code> NSString *string = @"This is an iOSDevTip!";
[string lowercaseString];
</code></pre>

<p><strong>大写转小写</strong></p>

<pre><code>NSString *string = @"This is an iOSDevTip!";
[string uppercaseString];
</code></pre>

<h3>截取字符串</h3>

<p><strong>substringToIndex截取字符串</strong></p>

<pre><code>NSString *string = @"This is a operation string!";
NSString *subToString = [string substringToIndex:6];
</code></pre>

<p>截取的subToString为This i</p>

<p><strong>substringFromIndex截取字符串</strong></p>

<pre><code>NSString *subFromString = [string substringFromIndex:6];
</code></pre>

<p>截取的subFromString为s a operation string!</p>

<p><strong>substringWithRange截取字符串</strong></p>

<pre><code>NSString *rangeString = [string substringWithRange:NSMakeRange(6, 3)];
</code></pre>

<p>截取的rangeString为s a!</p>

<h3>判断字符串是否包含另一个字符串</h3>

<p><strong>rangeOfString判断</strong></p>

<pre><code>NSString *string1 = @"This is a iOSDevTip";
NSString *string2 = @"iOSDevTip";
NSRange range = [string1 rangeOfString:string2];
NSInteger location = range.location;
NSInteger leight = range.length;
NSString *logString = [[NSString alloc] initWithString:[NSString stringWithFormat:@"Location:%ld,Leight:%ld",location,leight]];
NSLog(@"logString:%@",logString);
</code></pre>

<p>打印出来：</p>

<pre><code>iOSStrongDemo[8837:2221170] logString:Location:10,Leight:9
</code></pre>

<p>如果Leight为0，说明不包含。还有更多关于NSString的用法，大家一起探索吧。代码下载地址：<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之NSTimer使用初探]]></title>
    <link href="http://www.superqq.com/blog/2015/07/10/ioskai-fa-zhi-nstimershi-yong-chu-tan/"/>
    <updated>2015-07-10T23:21:44+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/10/ioskai-fa-zhi-nstimershi-yong-chu-tan</id>
    <content type="html"><![CDATA[<p>这个周日，我的大学同学结婚。他们的婚礼选在郑州举办。他不是郑州的，他女朋友也不是郑州的。但是他们是在郑州相识相爱，最终走到一起的，所以他们选择在郑州举办婚礼。</p>

<p>这几年大家都在各自忙碌着，很少有见面的机会。不过经常会电话联系，相互了解一下情况。</p>

<p>作为兄弟，我打心底为他们高兴，为他们祝福。我也会到现场参加，估计现在我已经坐上开发郑州的动车了。</p>

<p>我喜欢走出去的感觉，很喜欢坐车，去各个地方，哪怕是路过。<strong>感觉走的越远，离心越近。</strong>辞职去旅行也许很快就可以实现。</p>

<p>最近我在改一个bug，在一个UIViewController上有一个定时器，在执行轮播图片。push到别的UIViewController的时候，暂停定时器（NSTimer）；pop回来的时候，开启定时器（NSTimer）。这个bug是：push到别的UIViewController暂定定时器（NSTimer），有时候有作用，有时候没有作用。</p>

<p>开始我以为是NSTimer运行的run loop有问题，最后发现是别的地方导致这个bug的。不过正好，我们来一起了解一下NSTimer。</p>

<h2>创建一个定时器（NSTimer）</h2>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(actionTimer:) userInfo:nil repeats:YES];
}

- (void)actionTimer:(NSTimer *)timer
{

}
</code></pre>

<p>NSTimer默认运行在default mode下，default mode几乎包括所有输入源(除NSConnection) NSDefaultRunLoopMode模式。</p>

<p>actionTimer方法会每隔1s中被调用一次。NSTimer使用起来是不是非常简单。这是NSTimer比较初级的应用。</p>

<h2>当主界面被滑动时NSTimer失效了</h2>

<p>主界面被滑动是什么意思呢？就是说主界面有UITableView或者UIScrollView，滑动UITableView或者UIScrollView。这个时候NSTimer失效了。</p>

<p>我们来写一个demo，在一个有UITableView的UIViewController上启动定时器，每1s数字加1，并将这个数字显示在UILabel上面.</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(actionTimer:) userInfo:nil repeats:YES];
}

- (void)actionTimer:(NSTimer *)timer
{
    self.number++;
    self.label.text = [NSString stringWithFormat:@"%d",self.number];
    NSLog(@"%d",self.number);
}
</code></pre>

<p>关于UITableView和UILabel的创建我省去了。详细的代码可以点击这里下载：<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>，iOSStrongDemo我会不断更新，大家在github上star一下。</p>

<p>这样当用户在拖动UITableView处于UITrackingRunLoopMode时，NSTimer就失效了，不能fire。self.label上的数字也就无法更新。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/timer1.gif" alt="nstimer1" /></p>

<h2>修改NSTimer的run loop</h2>

<p>解决方法就是将其加入到UITrackingRunLoopMode模式或NSRunLoopCommonModes模式中。</p>

<pre><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];
</code></pre>

<p>或者</p>

<pre><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre>

<p>NSRunLoopCommonModes：是一个模式集合，当绑定一个事件源到这个模式集合的时候就相当于绑定到了集合内的每一个模式。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/timer2.gif" alt="nstimer1" /></p>

<p>代码下载地址：：<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[支付宝和微信在抄袭上谁更胜一筹]]></title>
    <link href="http://www.superqq.com/blog/2015/07/10/zhi-fu-bao-he-wei-xin-zai-chao-xi-shang-shui-geng-sheng-%5B%3F%5D-chou/"/>
    <updated>2015-07-10T13:32:11+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/10/zhi-fu-bao-he-wei-xin-zai-chao-xi-shang-shui-geng-sheng-[?]-chou</id>
    <content type="html"><![CDATA[<p>支付宝最新版本9.0上线，立刻引发一场撕逼大战。支付宝指责微信抄袭，微信也不甘示弱。在我看来，支付宝和微信是相互抄袭。既然都是抄袭，何必以五十步笑百步呢，对吧。</p>

<p>来看一下网上疯转的一张图：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/zhifubao1.png" alt="zhifubao1" /></p>

<p>由上图，我们对支付宝和微信各自的抄袭能力和力度有了初步的了解。在抄袭方面，是支付宝厉害呢？还是微信更胜一筹？</p>

<h2>微信抄袭支付宝</h2>

<p>这个问题如果在支付宝9.0出来之前回答的话，肯定是归微信莫属。</p>

<p>在微信支付出来之前，微信的抄袭还是有所保留，每次都是一个功能一个功能的抄。</p>

<p>腾讯的抄袭能力是世人皆知的，更是让创业者们望而生畏。甚至网上有流传，投资人在投资一个项目的时候就会问，如果腾讯抄袭了怎么办？可想而知，腾讯内部的微创新团队干了多少抄袭的事儿。但是话说回来了，腾讯现在可是进步不少，不再是见什么抄什么，而是改为投资。比如说：京东、滴滴。</p>

<p>微信支付的推出，算是对支付宝比较大的一次抄袭，无论从界面还是功能上都比较相似。这一次，彻底扰乱了马云的阵脚。全球变暖，小企鹅不在南极好好呆着，竟然跑到家门口了。马云也放出狠话：把企鹅赶回南极老家去。</p>

<h2>支付宝抄袭微信</h2>

<p>回到我们的问题。在支付宝9.0推出之后，支付宝的抄袭能力真的是甩掉微信几条街。来看一张图：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/zhifubao2.png" alt="zhifubao2" /></p>

<p>支付宝9.0版本将原有的“服务窗”与“探索”板块，换成了“商家”和“朋友”。商家像不像大众点评？朋友像不像微信？简直是逼真了，无论从设计上，还是功能上都如出一辙。抄袭竟然这么光明正大。</p>

<p>蚂蚁金服支付事业群总裁樊治铭说，支付宝花了8年时间从一个工具变成一个应用，又用了两年从一个应用变成一个支付平台。如今，支付宝会贯穿到消费、生活、金融理财、沟通等各种真实生活的场景，成为以每个人为中心的一站式场景平台。</p>

<p>有个小插曲，昨天我拿支付宝的朋友资料设置界面，问我的同事，这是哪个app？得到的回答都是微信。我说不是，我的小伙伴们都惊呆了，我说这是支付宝，他们都震惊了。马云真的是要把小企鹅赶回南极老家的节奏啊。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/zhifubao3.png" alt="zhifubao3" /></p>

<h2>支付社交谁主沉浮？</h2>

<p>微信进军支付，支付宝进军社交。这场撕逼大战何时会分出胜负呢？你是支持支付宝，还是支持微信。请留下你的观点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用UIDataDetectorTypes自动检测电话、网址和邮箱]]></title>
    <link href="http://www.superqq.com/blog/2015/07/09/shi-yong-uidatadetectortypeszi-dong-jian-ce-dian-hua-,-wang-zhi-he-you-xiang/"/>
    <updated>2015-07-09T23:43:39+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/09/shi-yong-uidatadetectortypeszi-dong-jian-ce-dian-hua-,-wang-zhi-he-you-xiang</id>
    <content type="html"><![CDATA[<p>支付宝发布最新版本9.0，再一次引发一场撕逼大战。微信说支付宝抄袭了它，支付宝说微信一直都在抄袭自己。在我看来，微信和支付宝都抄袭了对方。对于大佬们的抄袭，我们也是司空见惯了。</p>

<p>支付宝这一次更新，真是赚足了眼球，估计这也是支付宝的推广策略。就是要造势，造势有利于品牌推广。传播速度可想而知，似乎一夜之间都在谈论支付宝和微信。</p>

<p>至于支付宝和微信谁能打过谁，我们拭目以待。</p>

<p>上一篇文章<a href="http://www.superqq.com/blog/2015/07/08/uiwebviewyong-fa-xiang-jie/">UIWebView用法详解及代码分享</a>里面提到：</p>

<pre><code>webView.dataDetectorTypes = UIDataDetectorTypePhoneNumber;//自动检测网页上的电话号码，单击可以拨打
</code></pre>

<p>接下来我们来简单讲一下，使用UIDataDetectorTypes自动检测电话、网址和邮箱。我们先来看看UIDataDetectorTypes有哪些枚举值。</p>

<h2>UIDataDetectorTypes的枚举值</h2>

<pre><code>typedef NS_OPTIONS(NSUInteger, UIDataDetectorTypes) {
    UIDataDetectorTypePhoneNumber   = 1 &lt;&lt; 0,          // Phone number detection
    UIDataDetectorTypeLink          = 1 &lt;&lt; 1,          // URL detection    
#if __IPHONE_4_0 &lt;= __IPHONE_OS_VERSION_MAX_ALLOWED
    UIDataDetectorTypeAddress       = 1 &lt;&lt; 2,          // Street address detection
    UIDataDetectorTypeCalendarEvent = 1 &lt;&lt; 3,          // Event detection
#endif    

    UIDataDetectorTypeNone          = 0,               // No detection at all
    UIDataDetectorTypeAll           = NSUIntegerMax    // All types
};
</code></pre>

<p>NS_OPTIONS一般用来定义位移相关操作的枚举值。UIDataDetectorTypeAddress，UIDataDetectorTypeCalendarEvent不在我们考虑的范围了。</p>

<p>UIWebView有dataDetectorTypes属性，UITextView也有dataDetectorTypes属性。我们来UITextView来举例。</p>

<h2>创建UITextView</h2>

<pre><code>UITextView *textView = [[UITextView alloc] initWithFrame:self.view.bounds];
textView.font = [UIFont systemFontOfSize:20];
textView.editable = NO;
textView.text = @"\r\n我的手机号不是： 13888888888 \r\n\r\n"
"我的博客刚刚在线网址： www.xxxxxx.com \r\n\r\n"
"我的邮箱： worldligang@163.com \r\n\r\n";
[self.view addSubview:textView];
</code></pre>

<p>运行起来看一下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/UIDataDetectorTypes1.jpeg" alt="UIDataDetectorTypes1" /></p>

<p>可以看出来就是一个简单的文本，电话号码，网址和邮箱都没有检测出来。下面我们来看看dataDetectorTypes作用。</p>

<h2>UIDataDetectorTypePhoneNumber检测电话</h2>

<pre><code>textView.dataDetectorTypes = UIDataDetectorTypePhoneNumber;
</code></pre>

<p>设置textView.dataDetectorTypes的属性，即可检测文本中的电话。效果如下所示：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/UIDataDetectorTypes2.jpeg" alt="UIDataDetectorTypes2" /></p>

<h2>UIDataDetectorTypeLink检测网址和邮箱</h2>

<pre><code>textView.dataDetectorTypes = UIDataDetectorTypeLink;
</code></pre>

<p>UIDataDetectorTypeLink检测网址和邮箱的。点击网址会跳转到相应的网页，点击邮箱可以调用系统的发邮件。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/UIDataDetectorTypes3.jpeg" alt="UIDataDetectorTypes3" /></p>

<h2>UIDataDetectorTypeAll检测电话、网址和邮箱</h2>

<pre><code>textView.dataDetectorTypes = UIDataDetectorTypeAll;
</code></pre>

<p>UIDataDetectorTypeAll可以检测检测电话、网址和邮箱。效果如下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/UIDataDetectorTypes4.jpeg" alt="UIDataDetectorTypes4" /></p>

<p>专门写了一个iOSStrongDemo以后都在这个iOSStrongDemo里面更新内容。下载地址：<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>
]]></content>
  </entry>
  
</feed>
