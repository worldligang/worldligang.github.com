<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刚刚在线]]></title>
  <link href="http://worldligang.github.io/atom.xml" rel="self"/>
  <link href="http://worldligang.github.io/"/>
  <updated>2014-12-31T15:32:06+08:00</updated>
  <id>http://worldligang.github.io/</id>
  <author>
    <name><![CDATA[刚刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ioskai Fa Zhong De Gcdduo Xian Cheng Tips]]></title>
    <link href="http://worldligang.github.io/blog/2014/12/27/ioskai-fa-zhong-de-gcdduo-xian-cheng-tips/"/>
    <updated>2014-12-27T00:00:00+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/12/27/ioskai-fa-zhong-de-gcdduo-xian-cheng-tips</id>
    <content type="html"><![CDATA[<hr />

<p>layout: post
title: &ldquo;iOS开发中的gcd多线程tips&rdquo;
date: 2014-12-27 16:48:27 +0800
comments: true
categories:</p>

<p>本篇文章会持续更新：</p>

<p><div class="entry-content"><h4>我们经常用到的：</h3></p>

<pre><code>dispatch_async(dispatch_get_global_queue(0, 0), ^{  
    // 处理耗时操作的代码块 

    //通知主线程刷新  
    dispatch_async(dispatch_get_main_queue(), ^{  
        //回调或者说是通知主线程刷新  
    });  

});  
</code></pre>

<p>其中main_queue是系统默认的串行队列，global_queue是系统默认的并行队列。</p>

<p><div class="entry-content"><h5>什么是串行队列（Serial）？</h3></p>

<p>创建任意个数的串行队列，每个队列依次执行添加的任务，一个队列同一时刻只能执行一个任务（串行），但是各个队列之间不影响，可以并发执行。每个队列中的任务运行在一个由各自串行队列维护的独立线程上，一个队列中只有一个线程。</p>

<p><div class="entry-content"><h5>什么是并行队列（Concurrent）？</h3></p>

<p>并行队列是不允许自己创建的，系统中存在三个不同优先级的并行队列。并行队列依旧按照任务添加的顺序启动任务，但是，后一个任务无须等待前一个任务执行完毕，而是启动第一个任务后，立即启动下一个任务。至于同一时刻允许同时运行多少个任务有系统决定。任务各自运行在并行队列为他们提供的独立线程上，并行队列中同时运行多少个任务，就必须维护多少个线程。</p>

<p>gcd中还有一个概念叫做主调度队列</p>

<p><div class="entry-content"><h5>主调度队列（main dispatch queue）</h3>
主调度队列中的任务运行在应用程序主线程上，所以，如果你要修改应用程序的界面，他是唯一的选择。</p>

<p>如下：</p>

<pre><code> dispatch_async(dispatch_get_main_queue(), ^{

        //跟新界面的操作

    });
</code></pre>

<p><div class="entry-content"><h4>只执行一次：</h3></p>

<pre><code>static dispatch_once_t onceToken;  
dispatch_once(&amp;onceToken, ^{  
    // 这里写的代码只会被执行一次
}); 
</code></pre>

<p>如果你收集有实用的关于gcd的用法，欢迎分享给我，直接在文章下面评论即可</p>

<p>我的微信公众号：</p>

<pre><code>iOSDevTip
</code></pre>

<p>转载请注明：<a href="http://www.superqq.com/blog/2014/12/27/ioskai-fa-zhong-de-gcdduo-xian-cheng-tips/">iOS开发中的gcd多线程tips</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7中实现模糊效果教程]]></title>
    <link href="http://worldligang.github.io/blog/2014/12/23/ios-7zhong-shi-xian-mo-hu-xiao-guo-jiao-cheng/"/>
    <updated>2014-12-23T16:21:21+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/12/23/ios-7zhong-shi-xian-mo-hu-xiao-guo-jiao-cheng</id>
    <content type="html"><![CDATA[<p></br></p>

<p>iOS开发微信公众号：</p>

<pre><code>iOSDevTip
</code></pre>

<p>本文译自<a href="http://www.raywenderlich.com/60968/ios-7-blur-effects-gpuimage">iOS 7 Blur Effects with GPUImage.</a></p>

<p>iOS 7在视觉方面有许多改变，其中非常吸引人的功能之一就是在整个系统中巧妙的使用了模糊效果。许多第三方应用程序已经采用了这样的设计细节，并以各种奇妙的和具有创造性的方式使用它。</p>

<p>本文将通过几种不同的技术来实现iOS 7中的模糊效果，当然，这一切都利用了一个名为<a href="https://github.com/BradLarson/GPUImage">GPUImage</a>的框架。</p>

<p>GPUImage是由<a href="www.sunsetlakesoftware.com/blog">Brad Larson</a>创建的，它利用GPU，使在图片和视频上应用不同的效果和滤镜变得非常的容易，同时它还拥有出色的性能，并且它的性能要比苹果内置的相关APIs出色。</p>

<p>注意：本文需要一台物理设备来编译并运行示例程序(在模拟器上无法使用)。同样还需要一个iOS开发者账号。如果你还没有开发者账号的 话，可以来<a href="https://developer.apple.com/">这里</a>注册一个。注册为开发者之后，会有许多福利哟，例如可以使用物理设备来 开发程序，提前获得苹果的相关测试版程序，以及大量的开发资源。</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/12/TutorialLogo-500x500.png"></p>

<p>iOS中利用GPUImage实现模糊效果</p>

<p>下面我们先来看看本文的目录结构：</p>

<pre><code>开始
为什么要是用模糊效果
    深度引导
    上下文
    关注度
添加静态的模糊效果
    创建截图Category
    利用断点测试截屏图片
    显示截屏图片
    设置contentsRect
    重置模糊滤镜
    对其背景图片
实时模糊
线程中简洁的分支
一些潜在的实时模糊方案
一个折中的方法——对视频实时模糊
    利用GPUImage对视频进行模糊处理
何去何从？
</code></pre>

<p><div class="entry-content"><h3>开始</h3></p>

<p>首先先来<a href="https://github.com/worldligang/Video-Blurring.git">这里</a>下载本文的starter工程，并将其解压出来。</p>

<p>用Xcode打开Video Blurring.xcodeproj，并将工程运行到设备中。此时看到程序的效果如下所示：
<img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/12/Start-700x394.png"></p>

<p>点击屏幕左上角的菜单(三条横纹)，可以看到界面中出现两个选项：录制视频和播放已有视频。</p>

<p>请注意，现在所有的用户界面都有一个灰色的背景，是不是感觉有点沉闷呢，本文我们就利用iOS 7中的模糊效果来替换掉这些沉闷的灰色背景。</p>

<p><div class="entry-content"><h3>为什么要是用模糊效果</h3></p>

<p>除了外观看起来很棒以外，模糊效果还可以让程序给用户带来3个重要的概念：深度引导、上下文和关注度。
<div class="entry-content"><h4>深度引导</h3></p>

<p>在用户界面上，模糊效果可以给用户提供一个深度引导效果，并且有利于用户对程序导航的理解。在之前的iOS版本中的深度引导效果是通过：三维斜面 (three-dimensional bevels)和有关泽的按钮(反映出一个模拟的光源)，而在iOS 7中是通过模糊和视差(<a href="http://en.wikipedia.org/wiki/Parallax">parallax</a>)来实现的。</p>

<p>这里说的视差效果，可以很明显的观察出来：在装有iOS 7的设备中，将设备从一侧倾斜至另一侧，会发现设备中的图标在移动(会独立于背景)。这样可以给用户做出一个提示：界面是由不同的层构成的，并且重要的界 面元素是在最前面的——这也涉及到下面将要介绍的一个概念：上下文。</p>

<p><div class="entry-content"><h4>上下文</h3></p>

<p>上下文可以让用户在程序内获得一种轴承的感觉。动画的过度效果就提供了一种非常优秀的上下文，当用户点击一个按钮时，在两个view之间利用动画效 果来切换画面(而不是直接显示一个新的view)，可以让用户知道新的view是从哪里出现的，并且可以让用户很容易知道如何回到上一个view。</p>

<p>模糊效果可以将上一个view当做背景显示出来，尽管上一个view已经失去焦点了，不过可以给用户提供更多的上下文：刚刚是在哪里。通知中心就是一个非常棒的例子：当拉下通知中心时，我们可以在背景中看到原来的view(即使现在正在处于通知中心界面)。</p>

<p><div class="entry-content"><h4>关注度</h3></p>

<p>让界面更加关注于某些选择项上，而移除不需要的内容，让用户可以更加快捷的进行导航。用户可以本能的忽略那些被模糊的界面元素，而将注意力集中到某些界面元素中。</p>

<p>通过本文，你将学到两种模糊类型的实现方法：静态模糊和动态模糊。静态模糊代表着快照的时间点，它并不能反映被模糊界面元素的变化。大多数情况下，使用静态模糊效果就足够了。相反，动态模糊则是对需要模糊的背景做出实时更新。</p>

<p>相信看到具体的效果才是最好的，下面我们就来看看模糊效果的具体实现吧！</p>

<p><div class="entry-content"><h3>添加静态的模糊效果</h3></p>

<p>创建一个静态模糊效果首先是将当前屏幕中的view转换为一幅图片。获得图片之后，只需要对图片做模糊处理就可以了。将view转换为一幅图片(截屏)苹果已经提供了一些非常棒的APIs了，并且在iOS 7中又有了新的方法可以让截屏更加快速。</p>

<p>这些新的方法属于<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/drawViewHierarchyInRect:afterScreenUpdates:">截屏APIs</a>中的一部分，截屏APIs不仅可以对某个view截屏，还能把整个view层次截屏，如果你希望对某个view截屏，那么可以把view中的按钮、标签、开关等各种view也进行截屏。</p>

<p>此处我们将截屏的逻辑实现到UIView的一个category中。这样一来，我们就可以很方便快捷的将任意的view(以及view中的内容)转换为一个图片——也算是代码的重用吧。</p>

<p><div class="entry-content"><h4>创建截图Category</h3></p>

<p>打开File/New/File&hellip;，然后选择iOS/Cocoa Touch/Objective-C category，如下图所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/12/NewCategory-700x477.png"></p>

<p>将这个category命名为Screenshot，并将它的category选为UIView,如下图所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/12/CategoryInfo-700x477.png"></p>

<p>将下面这个方法声明到UIView+Screenshot.h中：</p>

<pre><code>-(UIImage *)convertViewToImage; 
</code></pre>

<p>接着将如下方法添加到 UIView+Screenshot.m 中：</p>

<pre><code>-(UIImage *)convertViewToImage 
{ 
    UIGraphicsBeginImageContext(self.bounds.size); 
    [self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES]; 
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); 
    UIGraphicsEndImageContext(); 

    return image; 
} 
</code></pre>

<p>上面的方法中，首先调用了UIGraphicsBeginImageContext()，最后调用的是UIGraphicsEndImageContext()，这两行代码可以理解为图形上下文的一个事物处理过程。一个上下文可以理解为不同的概念，例如屏幕，或者此处可以理解为一幅图片。这里的两行代码起到一个离屏画布的作用——可以将view绘制上去。</p>

<p>drawViewHierarchyInRect:afterScreenUpdates:方法利用view层次结构并将其绘制到当前的上下文中。</p>

<p>最后，UIGraphicsGetImageFromCurrentImageContext()从图形上下文中获取刚刚生成的UIImage。</p>

<p>现在，我们已经完成了category的实现，接着我们只需要在使用到的地方将其import一下即可。</p>

<p>如下代码所示，将代码添加到DropDownMenuController.m顶部：</p>

<pre><code>#import "UIView+Screenshot.h" 
</code></pre>

<p>同时，将如下方法添加到相同的文件中：</p>

<pre><code>-(void)updateBlur 
{ 
    UIImage *image = [self.view.superview convertViewToImage]; 
} 
</code></pre>

<p>上面的代码确保是对superview进行截屏，而不仅仅是当前的view。不这样做的话，截屏获得的图片只是menu本身。</p>

<p><div class="entry-content"><h4>利用断点测试截屏图片</h3></p>

<p>为了测试截屏的效果，我们在convertViewToImage调用的下面一行添加一个断点。这样当命中断点时，程序会在断点中暂停执行，这样我们就可以看到截屏的图片，以此确保截屏代码的正确性:</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/12/AddBreakpoint.png"></p>

<p>在测试之前还有一件事情需要做：调用上面这个方法。</p>

<p>找到show方法，并在addToParentViewController下面直接调用一下updateBlur：</p>

<pre><code>-(void)show { 
    [self addToParentViewController]; 

    [self updateBlur]; // Add this line 

    CGRect deviceSize = [UIScreen mainScreen].bounds; 

    [UIView animateWithDuration:0.25f animations:^(void){ 
        _blurView.frame = CGRectMake(0, 0, deviceSize.size.height, MENUSIZE); 
        _backgroundView.frame = CGRectMake(0, 0, _backgroundView.frame.size.width, MENUSIZE); 
    }]; 
} 
</code></pre>

<p>编译并运行程序，点击菜单按钮，可以看到Xcode在断点出停止了，如下所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/12/BreakpointInfo-700x211.png"></p>

<p>在debugger左下角hand pane中选择image，然后单击快速查找图标按钮，就可以预览刚刚的截屏啦：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/12/ImagePreview-700x416.png"></p>

<p>如上图所示，正是我们所预期的。
<div class="entry-content"><h4>显示截屏图片</h3></p>

<p>将截取到的图片显示到菜单的背景中就是小菜一碟啦。</p>

<p>一般来说我们都会利用UIImageView来显示一幅图片，而由于我们要利用GPUImage来模糊图片，所以需要使用GPUImageView。</p>

<p>在这里的工程中，已经添加好了GPUImage框架，我们只需要将头文件import一下即可。</p>

<p>将下面的代码添加到DropDownMenuController.m顶部：</p>

<pre><code>#import &lt;GPUImage/GPUImage.h&gt; 
</code></pre>

<p>注意：GPUImage被包含在一个框架中，所以在import语句中，需要利用尖括弧，而不是双引号。</p>

<p>此时，有一个_blurView，类型为UIView——是菜单的灰色背景。将UIView修改为GPUImageView，如下所示：</p>

<pre><code>@implementation DropDownMenuController { 
    GPUImageView *_blurView; 
    UIView *_backgroundView; 
} 
</code></pre>

<p>修改之后，Xcode会报一个warning：大意是你利用UIView进行实例化，而不是预期的GPUImageView。</p>

<p>可以通过下面的方法消除这个警告，在viewDidLad中修改做如下修改：</p>

<pre><code>_blurView = [[GPUImageView alloc] initWithFrame:CGRectMake(0, 0, deviceSize.size.height, 0)]; 
</code></pre>

<p>紧随其后，将如下两行代码添加进去，并移除设置背景色的代码：</p>

<pre><code>_blurView.clipsToBounds = YES; 
_blurView.layer.contentsGravity = kCAGravityTop; 
</code></pre>

<p>clipToBounds属性设置为YES，把超出_blurView范围的子view隐藏起来，而contentsGravity确保图片出现在image view的顶部。</p>

<p>由于_blurView已经用于背景了，所以此处不需要额外设置了。</p>

<p>接着，我们还需要声明一个用于模糊效果的过滤器。</p>

<p>将如下代码添加到DropDownMenuController.m:文件的@implementation中：</p>

<pre><code>GPUImageiOSBlurFilter *_blurFilter; 
</code></pre>

<p>找到之前添加的断点，右键单击，并选中Delete Breakpoint：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/12/DeleteBreakpoint.png"></p>

<p>下面是非常重要的一步了——初始化模糊滤镜。将如下代码添加到DropDownMenuController.m中：</p>

<pre><code>-(void)updateBlur 
{ 
    if(_blurFilter == nil){ 
        _blurFilter = [[GPUImageiOSBlurFilter alloc] init]; 
         _blurFilter.blurRadiusInPixels = 1.0f; 

    } 

    UIImage *image = [self.view.superview convertViewToImage]; 
} 
</code></pre>

<p>注意：上面将模糊半径设置为一个像素，这里暂时将这个值设置低一点，这样可以确保图片的正确定位，当一切ok之后，再增加模糊半径即可。</p>

<p>下面是时候将图片显示到GPUImageView中了。不过并不是简单的实例化一个UIImage，并将其添加到GPUImageView中。首先需创建一个GPUImagePicture。</p>

<p>将如下代码添加到updateBlur方法的底部：</p>

<pre><code>GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:image]; 
</code></pre>

<p>至此，我们获得了一个图片，模糊滤镜和iamge view。</p>

<p>接着再将如下代码添加到updateBlur底部：</p>

<pre><code>[picture addTarget:_blurFilter]; 
[_blurFilter addTarget:_blurView]; 

[picture processImage]; 
</code></pre>

<p>上面这几行代码，就像胶水一样，将所有的事情关联起来。将滤镜当做target添加到图片中，然后将image view当做滤镜的target。</p>

<p>上面代码对图片的处理全程发生在GPU上，也就是说当进行模糊计算和显示时，并不会影响到用户界面。当处理结束时，会把图片显示到image view上面。</p>

<p>编译并运行程序，点击菜单按钮，可以看到如下类似画面：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/12/HalfImage-700x394.png"></p>

<p>上面的图片看起来是不是有点奇怪？看到的图片被缩放到适配到菜单视图中了。要对此做出修正，我们需要指定图片的哪一部分需要显示在GPUImageView中——也就是处理截屏视图的上半部分。</p>

<p><div class="entry-content"><h4>设置contentsRect</h3></p>

<p>按照如下代码所示修改DropDownMenuController.m文件中的show方法：</p>

<pre><code>-(void)show 
{ 
    [self addToParentViewController]; 

    [self updateBlur]; 

    CGRect deviceSize = [UIScreen mainScreen].bounds; 

    [UIView animateWithDuration:0.25f animations:^(void){ 
        _blurView.frame = CGRectMake(0.0f, 0.0f, deviceSize.size.height, MENUSIZE); 
        _backgroundView.frame = CGRectMake(0.0f, 0.0f, _backgroundView.frame.size.width, MENUSIZE); 
        _blurView.layer.contentsRect = CGRectMake(0.0f, 0.0f, 1.0f, MENUSIZE / 320.0f); // Add this line! 
    }]; 
} 
</code></pre>

<p>通过指定_blurView.layer.contentsRect来定义一个矩形，在单元坐标空间(unit coordinate space)中，表示只使用layer content的一部分。</p>

<p>编译并运行程序，点击菜单按钮，会看到如下图所示效果：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/12/HalfBox-700x394.png"></p>

<p>虽然已经使用了图片的一部分，看起来还是不正确，这是因为它的缩放比例还不适合！此处还缺少对正确内容的缩放。</p>

<p>将下面这行代码添加到show方法中动画block的尾部：</p>

<pre><code>_blurView.layer.contentsScale = (MENUSIZE / 320.0f) * 2; 
</code></pre>

<p>contentsScale属性声明了layer在逻辑坐标空间(以点为单位)和物理坐标空间(以像素为单位)之间的映射关系。更高比例因子表示在渲染layer时，一个点代表着多个像素点。</p>

<p>编译并运行程序，点击菜单按钮，可以看到缩放比例已经正常了：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/12/FullBlur-700x394.png"></p>

<p>没错——看起来好多了！现在关闭程序，然后重新打开，ou~~发生了什么？如下图所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/12/HalfBlackBox-700x394.png"></p>

<p>看起来这还是有点问题。如果在对view进行animation之前将contentScale设置回2.0，会解决half bar的问题。</p>

<p>将如下代码添加到DropDownMenuController.m中show方法里面的animation block上面：</p>

<pre><code>_blurView.layer.contentsScale = 2.0f; 
</code></pre>

<p>编译并运行程序，然后点击菜单，接着关闭菜单，再打开菜单，此时菜单开起来如下所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/12/FullBlackBox-700x394.png"></p>

<p>现在半个尺寸的黑色box已经没有问题了——但是现在是全尺寸的黑色box！</p>

<p><div class="entry-content"><h4>重置模糊滤镜</h3></p>

<p>上面问题产生的原因是由于进行了二次模糊计算。解决的方法是移除模糊滤镜中的所有target。如果不这样做的话，之后对滤镜的调用不会输出任何的内容——进而引起黑色box的问题。</p>

<p>按照如下代码更新一下updateBlur方法：</p>

<pre><code>-(void)updateBlur 
{ 
    if(_blurFilter == nil){ 
        _blurFilter = [[GPUImageiOSBlurFilter alloc] init]; 
        _blurFilter.blurRadiusInPixels = 1.0f; 
    } 

    UIImage *image = [self.view.superview convertViewToImage]; 

    GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:image]; 
    [picture addTarget:_blurFilter]; 
    [_blurFilter addTarget:_blurView]; 

    [picture processImageWithCompletionHandler:^{ 
        [_blurFilter removeAllTargets]; 
    }]; 
} 
</code></pre>

<p>上面的代码用processImageWithCompletionHandler:替换了processImage方法。这个新的方法有一个completion block，当image 处理结束时，会运行这个block。一旦image处理结束，我们就可以安全的将滤镜中的target全部移除。</p>

<p>编译并运行程序，点击菜单，检查一下黑色box问题是不是已经解决掉了：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/12/FinalGrayButton-700x394.png"></p>

<p>多次打开和关闭菜单，确保之前的那个bug已经解决掉啦！</p>

<p>现在仔细观察一下打开菜单的模糊效果——有些东西看起来不正确。为了更加明显的观察到问题，我们减慢动画的时间，让其慢慢的移动。</p>

<p>在show方法中，将animation bloc的持续时间修改为10.0f。</p>

<p>编译并运行程序，点击菜单，然后观察一下菜单出场的慢动作：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/12/MisalignedBlur-700x394.png"></p>

<p>恩，现在可能你已经发现问题了。被模糊的图片从顶部往下滑动——而我们的本意是希望模糊效果从上往下滑(并不是图片本身)。
<div class="entry-content"><h4>对其背景图片</h3></p>

<p>此处我们需要对静态模糊效果使用一些技巧。当出现菜单时，我们需要利用背景来将模糊效果对其。所以在这里我们不是对image view做移动处理，而是需要对image view做扩展处理，从0开始扩展至image view的全尺寸。这样就可以确保菜单打开时，图片依然保留在原位。</p>

<p>在show方法中，我们已经将菜单打开至全尺寸了，所以现在只需要将contentRect的高度设置为0即可(当image view首次创建并隐藏的时候)。</p>

<p>将下面的代码添加至DropDownMenuController.m文件的viewDidLoad方法中——在_blurView初始化的下方：</p>

<pre><code>_blurView.layer.contentsRect = CGRectMake(0.0f, 0.0f, 1.0f, 0.0f); 
</code></pre>

<p>同时，在相同的一个文件中，将下面的代码添加到animation block的尾部：</p>

<pre><code>_blurView.layer.contentsRect = CGRectMake(0.0f, 0.0f, 1.0f, 0.0f); 
</code></pre>

<p>contentRect属性是可以动画方式设置的。因此在动画期间会rect会自动的插补上。</p>

<p>编译并运行程序。可以看到，问题已经解决：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/12/HalfView.png"></p>

<p>这样看起来自然多了。现在我们已经有一个具有模糊背景的滑动菜单了。</p>

<p>现在是时候把动画所需时间调整一下了（为了更好的效果，其实之前设置的值是为了测试所用）：设置为0.25秒，接着在updateBlur方法中将_blurFilter.blurRadiusInPixels设置为4.0f。</p>

<p>编译并运行程序，多次打开菜单，看看效果如何：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/12/FinalBlur-700x394.png"></p>

<p><div class="entry-content"><h3>实时模糊</h3></p>

<p>实时模糊涉及到的技术具有一定的难度，有些难点需要解决才行。为了有效的进行实时模糊，我们需要不停(每秒60帧)的截屏、模糊计算和显示。使用GPUImage每秒中处理60张图片(模糊并显示图片)一点问题都没有。</p>

<p>真正棘手的问题是什么呢？如何实时的截取屏幕图片，信不信由你！</p>

<p>由于截取的屏幕是主用户界面，所有必须使用CPU的主线程来截屏，并将其转换为一幅图片。</p>

<p>提醒：如果事物每秒钟的变化速度在46帧以上，那么人眼就无法识别出来了。这对于开发者来说也是一种解脱——现代处理器在各帧之间可以完成更多的大量工作。</p>

<p><div class="entry-content"><h3>线程中简洁的分支</h3></p>

<p>当运行程序时，会执行大量的指令列表。每一个指令列表都运行在各自的线程中，而我们又可以在多个线程中并发运行各自的指令列表。一个程序在主线程中 开始运行，然后会根据需要，创建新的线程，并在后台执行线程。如果之前你并没有管理过多线程，你可能在写程序的时候总是在主线程中执行指令。</p>

<p>主线程主要处理与用户的交互，以及界面的更新。确保主线程的响应时间是非常关键的。如果在主线程上做了太多的任务，你会明显的感觉到主界面响应迟钝。</p>

<p>如果你曾经使用过Twitter货Facebook，并滚动操作过它里面的内容，你可能已经感觉到后台线程在执行操作了——在滚动的过程中，并不是所有的个人图片立即显示出来，滚动过程中，程序会启动后台线程来获取图片，当图片获取成功之后，再显示到屏幕中。</p>

<p>如果不使用后台线程，那么table view的滚动过程中，如果在主线程上去获取个人图片，会感觉到table view被冻结住了。由于图片的获取需要一些时间，所以最好将这样耗时的操作让后台线程来做，这样就能对用户界面做平滑的操作和响应了。</p>

<p>那么对本文的程序有什么影响呢？之间介绍了，UIView的截屏APIs操作必须在主线程中运行。这就意味着每次截屏时，整个用户界面都会被冻结中。</p>

<p>对于静态模糊效果时，由于这个截屏操作很快，你不会感觉到界面的冻结。并且只需要截屏一次。然而在实时模糊效果中需要每秒中截屏60次。如果在主线程中做这样频繁的截屏操作，那么animation和transition会变得非常的迟钝。</p>

<p>更糟糕的时，如果用户界面复杂度增加，那么在截屏过程中就需要消耗更多的时间，那么就会导致整个程序无法使用了！</p>

<p>那么怎么办呢！
<div class="entry-content"><h3>一些潜在的实时模糊方案</h3></p>

<p>这里有一个关于实时模糊方案：源代码开源的<a href="https://github.com/nicklockwood/FXBlurView">live blur libraries</a>，它通过降低截屏的速度来实现实时模糊效果，并不是使用每秒截屏60次，可能是20、30或者40次。即使看起来没有多大区别，但是你的眼睛还是能发现一定的迟钝——模糊效果并没有跟程序的其它部分同步起来——这样一来，界面看起会没有模糊效果更加的糟糕。</p>

<p>实际上苹果在它们自己的一些程序中处理实时模糊并不存在类似的问题——但是苹果并没有公开相关的API。在iOS 7中UIView的截屏方法，相比于旧方法，性能有了很大的提升，但还是不能满足实时模糊的需求。</p>

<p>一些开发者利用UIToolbar的模糊效果来做一些不好的操作。没错，这是有效果的，但是强烈建议不要在程序中使用它们。虽然这不是私有API，但是这并不算是一种可行的方法，苹果也可能会reject你的程序。也就是说在，在之后的iOS 7版本中，并不能保证还能正常使用。</p>

<p>苹果可以在任何时候对UIToolBar做出修改，或许你的程序就有问题了。在iOS 7.0.3更新中，苹果的修改已经影响到UIToolbar和UINavigationBar了，有些开发者也因此报告出利用相关模糊效果已经失效了！所以最好不要陷入这样潜在的陷阱里面！</p>

<p><div class="entry-content"><h3>一个折中的方法——对视频实时模糊</h3></p>

<p>OK，此时你可能在想，要想在程序中做到实时模糊是不可能的了。那么还有什么方法可以突破限制，做到实时模糊效果呢？</p>

<p>在许多场景中，静态模糊是可以接受的。上一节中，我们对view做适当的修改，让用户看起来是对背景图做的实际模糊处理。当然，这对于静止不动的背景是合适的，并且还可以在模糊背景上实现一些不错的效果。</p>

<p>我们可以做一些实验，看看能不能找到一些效果来实现之前无法做到的实时模糊效果呢？</p>

<p>有一个方法可以试试：对实时视频做模糊处理，虽然截屏是一个非常大的瓶颈，但是GPUImage非常的强大，它能够对视频进行模糊(无论是来自摄像头的视频或者已经录制好的视频，都没问题)。</p>

<p><div class="entry-content"><h3>利用GPUImage对视频进行模糊处理</h3></p>

<p>利用GPUImage对视频的模糊处理与图片的模糊处理类似。针对图片，我们实例化一个GPUImagePicture，然后将其发送给GPUImageiOSBlurFilter，接着再将其发送给GPUImageView。</p>

<p>类似的方法，对于视频，我们使用GPUImageVideoCamera或GPUImageMovie，将后将其发送给GPUImageiOSBlurFilter，接着再将其发送给一个GPUImageView。GPUImageVideoCamera用于设备中的实时摄像头，而GPUImageMovie用于已经录制好的视频。</p>

<p>在我们的starter工程中，已经实例化并配置好了GPUImageVideoCamera。现在的任务是将播放和录制按钮的灰色背景替换为视频的实时滤镜效果。</p>

<p>首先是将此处提供的灰色背景实例UIView替换为GPUImageView。完成之后，我们需要调整每个view的contentRect(基于view的frame)。</p>

<p>这听起来对每个view都需要做大量的工作。为了让任务变得简单，我们创建一个GPUImageView的子类，并把自定义的代码放进去，以便重用。</p>

<p>打开File/New/File…，然后选择iOS/Cocoa Touch/Objective-C class，如下所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/12/NewClass.png"></p>

<p>将类命名为BlurView，继承自GPUImageView，如下图所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-27-at-21.20.01-700x474.png"></p>

<p>打开ViewController.m文件，将下面的import添加到文件顶部：</p>

<pre><code>#import "BlurView.h" 
</code></pre>

<p>还是在ViewController.m中，在@implementation中找到<em>recordView和</em>controlView的声明，将其修改为BlurView类型，如下所示：</p>

<pre><code>BlurView *_recordView; //Update this! 
UIButton *_recordButton; 
BOOL _recording; 

BlurView *_controlView; //Update this too! 
UIButton *_controlButton; 
BOOL _playing; 
</code></pre>

<p>然后按照如下代码修改viewDidLoad方法：</p>

<pre><code>_recordView = [[BlurView alloc] initWithFrame: 
                CGRectMake(self.view.frame.size.height/2 - 50, 250, 110, 60)]; //Update this! 
//_recordView.backgroundColor = [UIColor grayColor]; //Delete this! 

_recordButton = [UIButton buttonWithType:UIButtonTypeCustom]; 
_recordButton.frame = CGRectMake(5, 5, 100, 50); 
[_recordButton setTitle:@"Record" forState:UIControlStateNormal]; 
[_recordButton setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; 
[_recordButton setImage:[UIImage imageNamed:@"RecordDot.png"] forState:UIControlStateNormal] ; 
[_recordButton addTarget:self 
                  action:@selector(recordVideo) 
        forControlEvents:UIControlEventTouchUpInside]; 

[_recordView addSubview:_recordButton]; 
_recording = NO; 

_recordView.hidden = YES; 
[self.view addSubview:_recordView]; 


_controlView = [[BlurView alloc] initWithFrame: 
                 CGRectMake(self.view.frame.size.height/2 - 40, 230, 80, 80)]; //Update this! 
//_controlView.backgroundColor = [UIColor grayColor]; //Delete this! 
</code></pre>

<p>接着，需要创建模糊图片，将其显示到上面构建的image view中。回到@implementation中，将下面的两个声明添加进去：</p>

<pre><code>GPUImageiOSBlurFilter *_blurFilter; 
GPUImageBuffer *_videoBuffer; 
</code></pre>

<p>现在你已经知道GPUImageiOSBlurFilter的作用了，那么GPUImageBuffer的作用是什么呢？它的任务是获取视频的输出，并获取每一帧，这样我们就可以方便的对其做模糊处理。一个额外的好处就是它可以提升程序的性能！</p>

<p>一般来说，视频输出的内容会通过模糊滤镜处理，然后发送到背景视图中(被显示出来)。不过，在这里使用buffer的话，发送到buffer的视频输出内容，会被分为背景视图和模糊滤镜。这样可以对视频的输出显示做到平滑处理。</p>

<p>将下面的代码添加到viewDidLoad方法的顶部(在super调用的后面)：</p>

<pre><code>_blurFilter = [[GPUImageiOSBlurFilter alloc] init]; 

_videoBuffer = [[GPUImageBuffer alloc] init]; 
[_videoBuffer setBufferSize:1]; 
</code></pre>

<p>还是在同一个文件中，将如下高亮显示的语句添加到useLiveCamera方法中：</p>

<pre><code>-(void)useLiveCamera 
{ 
    if (![UIImagePickerController isSourceTypeAvailable: UIImagePickerControllerSourceTypeCamera]) { 
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"No camera detected" 
                                                        message:@"The current device has no camera" 
                                                       delegate:self 
                                              cancelButtonTitle:@"Ok" 
                                              otherButtonTitles:nil]; 
        [alert show]; 
        return; 
    } 

    _liveVideo = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPreset1280x720 
                                                     cameraPosition:AVCaptureDevicePositionBack]; 
    _liveVideo.outputImageOrientation = UIInterfaceOrientationLandscapeLeft; 

    [_liveVideo addTarget:_videoBuffer];           //Update this 
    [_videoBuffer addTarget:_backgroundImageView]; //Add this 
    [_videoBuffer addTarget:_blurFilter];          //And this 
    [_blurFilter addTarget:_recordView];           //And finally this 

    [_liveVideo startCameraCapture]; 

    _recordView.hidden = NO; 
    _controlView.hidden = YES; 
} 
</code></pre>

<p>上面的模糊背景是用于录制按钮的。对于播放按钮也要做类似的处理。</p>

<p>将下面的代码添加到loadVideoWithURL:方法中(在_recordedVideo.playAtActualSpeed = YES;之后)：</p>

<pre><code>[_recordedVideo addTarget:_videoBuffer]; 
[_videoBuffer addTarget:_backgroundImageView]; 
[_videoBuffer addTarget:_blurFilter]; 
[_blurFilter addTarget:_controlView]; 
</code></pre>

<p>编译并运行程序，打开录制操作，看看情况如何：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/12/FullImageButton.png"></p>

<p>好消息是看起来基本正常！坏消息是整个屏幕被缩放到录制按钮中去了。这个问题跟之前遇到的类似。我们需要给BlurView这是适当的contentRect。</p>

<p>打开BlurView.m，用下面的代码替换掉initWithFrame:方法：</p>

<pre><code>- (id)initWithFrame:(CGRect)frame 
{ 
    self = [super initWithFrame:frame]; 
    if (self) { 
        CGRect deviceSize = [UIScreen mainScreen].bounds; 
        self.layer.contentsRect = CGRectMake(frame.origin.x/deviceSize.size.height, 
                                             frame.origin.y/deviceSize.size.width, 
                                             frame.size.width/deviceSize.size.height, 
                                             frame.size.height/deviceSize.size.width); 
        self.fillMode = kGPUImageFillModeStretch; 
    } 
    return self; 
} 
</code></pre>

<p>contentRect的每个参数必须在0.0f和1.0f之间。在这里只需要利用view的位置除以屏幕的size，得到的值即可。</p>

<p>编译并运行程序，看看效果如何：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/12/FinishedBlur.png"></p>

<p>恭喜！至此已经完成了静态模糊和实时视频模糊的实现。现在你已经完全可以在程序中添加iOS 7的模糊效果啦！</p>

<p><div class="entry-content"><h3>利何去何从？</h3></p>

<p>可以在<a href="https://github.com/worldligang/Video-Blurring-Final.git">这里</a>下载到完整的工程。</p>

<p>本文不仅指导你在程序中使用iOS 7的模糊效果，还介绍了如何使用GPUImage框架，这个框架也是我非常希望你能看到的东西。重要的是，本文指出了为什么要使用模糊，什么时候使用模糊效果是合适的，这在iOS 7的新设计语言中是一个关键的概念。当然也希望在未来的版本中，苹果能够将相关APIs提供给开发者使用，不过在那之前，GPUImage是一个不错的替代品。</p>

<p>我的微信公众号：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发大众点评URL签名生成规则和SHA-1编码]]></title>
    <link href="http://worldligang.github.io/blog/2014/12/13/ioskai-fa-da-zhong-dian-ping-urlqian-ming-sheng-cheng-gui-ze-he-sha-1bian-ma/"/>
    <updated>2014-12-13T13:52:29+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/12/13/ioskai-fa-da-zhong-dian-ping-urlqian-ming-sheng-cheng-gui-ze-he-sha-1bian-ma</id>
    <content type="html"><![CDATA[<p></br>
URL签名生成规则</p>

<p>所有大众点评API的有效访问URL包括以下三个部分：
1. 资源访问路径，如/v1/deal/find_deals;
2. 请求参数：即API对应所需的参数名和参数值param=value，多个请求参数间用&amp;连接
   如deal_id=1-85462&amp;appkey=00000；
3. 签名串，由签名算法生成</p>

<p>签名算法如下：
1. 对除appkey以外的所有请求参数进行字典升序排列；
2. 将以上排序后的参数表进行字符串连接，如key1value1key2value2key3value3&hellip;keyNvalueN；
3. 将app key作为前缀，将app secret作为后缀，对该字符串进行SHA-1计算，并转换成16进制编码；
4. 转换为全大写形式后即获得签名串</p>

<p>签名串获得后，将其作为sign参数附加到对应的URL中，即可正常访问API。</p>

<pre><code>注意：请保证HTTP请求数据编码务必为UTF-8格式，URL也务必为UTF-8编码格式。
</code></pre>

<p>具体调用示例请参见<a href="https://github.com/dianping/dianping-open-sdk"target="_blank"title="刚刚在线"><a href="https://github.com/dianping/dianping-open-sdk">https://github.com/dianping/dianping-open-sdk</a></a></p>

<pre><code>+ (NSDictionary *)parseQueryString:(NSString *)query {
    NSMutableDictionary *dict = [[NSMutableDictionary alloc] initWithCapacity:6];
    NSArray *pairs = [query componentsSeparatedByString:@"&amp;"];

    for (NSString *pair in pairs) {
        NSArray *elements = [pair componentsSeparatedByString:@"="];

        if ([elements count] &lt;= 1) {
            return nil;
        }

        NSString *key = [[elements objectAtIndex:0] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
        NSString *val = [[elements objectAtIndex:1] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];

        [dict setObject:val forKey:key];
    }
    return dict;
}



+ (NSString *)serializeURL:(NSString *)baseURL params:(NSDictionary *)params
{
    NSURL* parsedURL = [NSURL URLWithString:[baseURL stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];
    NSMutableDictionary *paramsDic = [NSMutableDictionary dictionaryWithDictionary:[self parseQueryString:[parsedURL query]]];
    if (params) {
        [paramsDic setValuesForKeysWithDictionary:params];
    }

    NSMutableString *signString = [NSMutableString stringWithString:DIANPING_APP_KEY];
    NSMutableString *paramsString = [NSMutableString stringWithFormat:@"appkey=%@", DIANPING_APP_KEY];
    NSArray *sortedKeys = [[paramsDic allKeys] sortedArrayUsingSelector: @selector(compare:)];
    for (NSString *key in sortedKeys) {
        [signString appendFormat:@"%@%@", key, [paramsDic objectForKey:key]];
        [paramsString appendFormat:@"&amp;%@=%@", key, [paramsDic objectForKey:key]];
    }
    [signString appendString:DIANPING_APP_Secret];
    unsigned char digest[CC_SHA1_DIGEST_LENGTH];
    NSData *stringBytes = [signString dataUsingEncoding: NSUTF8StringEncoding];
    if (CC_SHA1([stringBytes bytes], (long)[stringBytes length], digest)) {
        /* SHA-1 hash has been calculated and stored in 'digest'. */
        NSMutableString *digestString = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH];
        for (int i=0; i&lt;CC_SHA1_DIGEST_LENGTH; i++) {
            unsigned char aChar = digest[i];
            [digestString appendFormat:@"%02X", aChar];
        }
        [paramsString appendFormat:@"&amp;sign=%@", [digestString uppercaseString]];
        return [NSString stringWithFormat:@"%@://%@%@?%@", [parsedURL scheme], [parsedURL host], [parsedURL path], [paramsString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];
    } else {
        return nil;
    }
}
</code></pre>

<p>直接调用这个方法即可签名成功，+ (NSString <em>)serializeURL:(NSString </em>)baseURL params:(NSDictionary *)params</p>

<pre><code>NSString *url = [LGClient serializeURL:string params:nil];

//string是大众点评的需要请求的接口
</code></pre>

<p>这个url就可以用来请求大众点评数据了</p>

<p>我的微信公众号：</p>

<pre><code>iOSDevTip
</code></pre>

<p>我也会将大家分享的方法发到iOS开发微信公众账号：iOSDevTip 里面，分享给更多iOS开发者。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSMutableURLRequest和NSURLConnection用Post方式上传照片]]></title>
    <link href="http://worldligang.github.io/blog/2014/12/11/nsmutableurlrequesthe-nsurlconnectionyong-postfang-shi-shang-chuan-zhao-pian/"/>
    <updated>2014-12-11T10:00:07+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/12/11/nsmutableurlrequesthe-nsurlconnectionyong-postfang-shi-shang-chuan-zhao-pian</id>
    <content type="html"><![CDATA[<p>需求：上传一张照片和内容，内容包括：用户编辑的内容、经纬度、地点等等，就是类似发一个说说。这就是一个很平常的功能，实现的方式想必各位能想到很多。</p>

<p>接下来我想用系统的NSURLConnection来实现这个功能：</p>

<p>首先我们要定义一个全局变量:</p>

<pre><code>/**
 *  请求返回数据
 */
@property (nonatomic, strong) NSMutableData *mResponseData;
</code></pre>

<p>实现代码：</p>

<pre><code>//字典里面装的是你要上传的内容
NSDictionary *parameters = @{@"content": @"这是刚刚在线的官方网站www.superqq.com"};

//上传的接口
NSString* urlstring = @"http://superqq.com/";
//分界线的标识符
NSString *TWITTERFON_FORM_BOUNDARY = @"AaB03x";
//根据url初始化request
NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlstring]
                                                        cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
                                                    timeoutInterval:10];
//分界线 --AaB03x
NSString *MPboundary=[[NSString alloc]initWithFormat:@"--%@",TWITTERFON_FORM_BOUNDARY];
//结束符 AaB03x--
NSString *endMPboundary=[[NSString alloc]initWithFormat:@"%@--",MPboundary];
//    //要上传的图片
//    UIImage *image=[params objectForKey:@"pic"];
//得到图片的data
NSData *data = UIImagePNGRepresentation(self.image);
//http body的字符串
NSMutableString *body=[[NSMutableString alloc]init];
//参数的集合的所有key的集合
NSArray *keys= [parameters allKeys];

//遍历keys
for(int i=0;i&lt;[keys count];i++)
{
    //得到当前key
    NSString *key=[keys objectAtIndex:i];
    //如果key不是pic，说明value是字符类型，比如name：Boris
    if(![key isEqualToString:@"pic"])
    {
        //添加分界线，换行
        [body appendFormat:@"%@\r\n",MPboundary];
        //添加字段名称，换2行
        [body appendFormat:@"Content-Disposition: form-data; name=\"%@\"\r\n\r\n",key];
        //添加字段的值
        [body appendFormat:@"%@\r\n",[parameters objectForKey:key]];
    }
}

////添加分界线，换行
[body appendFormat:@"%@\r\n",MPboundary];
//声明pic字段，文件名为boris.png
[body appendFormat:@"Content-Disposition: form-data; name=\"pic\"; filename=\"boris.png\"\r\n"];
//声明上传文件的格式
[body appendFormat:@"Content-Type: image/png\r\n\r\n"];

//声明结束符：--AaB03x--
NSString *end=[[NSString alloc]initWithFormat:@"\r\n%@",endMPboundary];
//声明myRequestData，用来放入http body
NSMutableData *myRequestData=[NSMutableData data];
//将body字符串转化为UTF8格式的二进制
[myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];
//将image的data加入
[myRequestData appendData:data];
//加入结束符--AaB03x--
[myRequestData appendData:[end dataUsingEncoding:NSUTF8StringEncoding]];

//设置HTTPHeader中Content-Type的值
NSString *content=[[NSString alloc]initWithFormat:@"multipart/form-data; boundary=%@",TWITTERFON_FORM_BOUNDARY];
//设置HTTPHeader
[request setValue:content forHTTPHeaderField:@"Content-Type"];
//设置Content-Length
[request setValue:[NSString stringWithFormat:@"%d", (int)[myRequestData length]] forHTTPHeaderField:@"Content-Length"];
//设置http body
[request setHTTPBody:myRequestData];
//http method
[request setHTTPMethod:@"POST"];

//建立连接，设置代理
NSURLConnection *conn = [[NSURLConnection alloc] initWithRequest:request delegate:self];

//设置接受response的data
if (conn) {
    _mResponseData = [[NSMutableData alloc] init];
}
</code></pre>

<p>NSURLConnectionDelegate的代理方法：</p>

<pre><code>#pragma mark - NSURLConnectionDelegate

- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
{
   [_mResponseData setLength:0];
}

- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
{
   [_mResponseData appendData:data];
}

- (void)connectionDidFinishLoading:(NSURLConnection *)connection
{

   NSDictionary *dic =  [NSJSONSerialization JSONObjectWithData:_mResponseData options:kNilOptions error:nil];
   NSLog(@"%@", dic);

}

- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
{
   NSLog(@"Error: %@", error);
}
</code></pre>

<p>这是我的实现方式，再次抛砖引玉，如果你要好的方法，欢迎分享！</p>

<p>iOS开发微信公众号：</p>

<pre><code>iOSDevTip
</code></pre>

<p>我也会将大家分享的方法发到iOS开发微信公众账号：iOSDevTip 里面，分享给更多iOS开发者。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员福利各大平台免费接口，非常适用]]></title>
    <link href="http://worldligang.github.io/blog/2014/12/05/cheng-xu-yuan-fu-li-ge-da-ping-tai-mian-fei-jie-kou-,fei-chang-gua-yong/"/>
    <updated>2014-12-05T10:39:56+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/12/05/cheng-xu-yuan-fu-li-ge-da-ping-tai-mian-fei-jie-kou-,fei-chang-gua-yong</id>
    <content type="html"><![CDATA[<p>电商接口</p>

<p>京东获取单个商品价格接口:</p>

<pre><code>http://p.3.cn/prices/mgets?skuIds=J_商品ID&amp;type=1
</code></pre>

<p>ps:商品ID这么获取:<a href="http://item.jd.com/954086.html">http://item.jd.com/954086.html</a>
物流接口</p>

<p>快递接口:</p>

<pre><code>http://www.kuaidi100.com/query?type=快递公司代号&amp;postid=快递单号
</code></pre>

<p>ps:快递公司编码:申通=”shentong” EMS=”ems” 顺丰=”shunfeng” 圆通=”yuantong” 中通=”zhongtong” 韵达=”yunda” 天天=”tiantian” 汇通=”huitongkuaidi” 全峰=”quanfengkuaidi” 德邦=”debangwuliu” 宅急送=”zhaijisong”
谷歌接口</p>

<p>FeedXml转json接口:</p>

<pre><code>http://ajax.googleapis.com/ajax/services/feed/load?q=Feed地址&amp;v=1.0
</code></pre>

<p>备选参数:callback：&amp;callback=foo就会在json外面嵌套foo({})方便做jsonp使用。</p>

<p>备选参数:n：返回多少条记录。
天气接口</p>

<p>百度接口:</p>

<pre><code>http://api.map.baidu.com/telematics/v3/weather?location=嘉兴&amp;output=json&amp;ak=5slgyqGDENN7Sy7pw29IUvrZ
</code></pre>

<p>location:城市名或经纬度 ak:开发者密钥 output:默认xml</p>

<p>气象局接口:</p>

<pre><code>http://m.weather.com.cn/data/101010100.html
</code></pre>

<p>音乐接口</p>

<p>虾米接口</p>

<pre><code>http://kuang.xiami.com/app/nineteen/search/key/歌曲名称/diandian/1/page/歌曲当前页?_=当前毫秒&amp;callback=getXiamiData
</code></pre>

<p>QQ空间音乐接口</p>

<pre><code>http://qzone-music.qq.com/fcg-bin/cgi_playlist_xml.fcg?uin=QQ号码&amp;json=1&amp;g_tk=1916754934
</code></pre>

<p>QQ空间收藏音乐接口</p>

<pre><code>http://qzone-music.qq.com/fcg-bin/fcg_music_fav_getinfo.fcg?dirinfo=0&amp;dirid=1&amp;uin=QQ号&amp;p=0.519638272547262&amp;g_tk=1284234856
</code></pre>

<p>多米音乐接口</p>

<pre><code>http://v5.pc.duomi.com/search-ajaxsearch-searchall?kw=关键字&amp;pi=页码&amp;pz=每页音乐数
</code></pre>

<p>soso接口</p>

<pre><code>http://cgi.music.soso.com/fcgi-bin/fcg_search_xmldata.q?source=10&amp;w=关键字&amp;perpage=1&amp;ie=utf-8
</code></pre>

<p>视频接口</p>

<p>土豆接口</p>

<pre><code>http://api.tudou.com/v3/gw?method=album.item.get&amp;amp;appKey=Appkey&amp;format=json&amp;albumId=视频剧集ID&amp;pageNo=当前页&amp;pageSize=每页显示
</code></pre>

<p>地图接口</p>

<p>阿里云根据地区名获取经纬度接口</p>

<pre><code>http://gc.ditu.aliyun.com/geocoding?a=苏州市
</code></pre>

<p>参数解释: 纬度,经度type 001 (100代表道路，010代表POI，001代表门址，111可以同时显示前三项)</p>

<p>阿里云根据经纬度获取地区名接口</p>

<pre><code>http://gc.ditu.aliyun.com/regeocoding?l=39.938133,116.395739&amp;type=001
</code></pre>

<p>IP接口</p>

<p>新浪接口(ip值为空的时候 获取本地的)</p>

<pre><code>http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=218.4.255.255
</code></pre>

<p>淘宝接口</p>

<pre><code>http://ip.taobao.com/service/getIpInfo.php?ip=63.223.108.42
</code></pre>

<p>手机信息查询接口</p>

<p>淘宝网接口</p>

<pre><code>http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=手机号
</code></pre>

<p>拍拍接口</p>

<pre><code>http://virtual.paipai.com/extinfo/GetMobileProductInfo?mobile=手机号&amp;amount=10000&amp;callname=getPhoneNumInfoExtCallback 用例
</code></pre>

<p>百付宝接口</p>

<pre><code>https://www.baifubao.com/callback?cmd=1059&amp;callback=phone&amp;phone=手机号
</code></pre>

<p>115接口</p>

<pre><code>http://cz.115.com/?ct=index&amp;ac=get_mobile_local&amp;callback=jsonp1333962541001&amp;mobile=手机号
</code></pre>

<p>有道接口</p>

<pre><code>http://www.youdao.com/smartresult-xml/search.s?jsFlag=true&amp;type=mobile&amp;q=手机号
</code></pre>

<p>手机在线接口</p>

<pre><code>http://api.showji.com/Locating/www.showji.com.aspx?m=手机号&amp;output=json&amp;callback=querycallback
</code></pre>

<p>视频信息接口</p>

<p>优酷</p>

<pre><code>http://v.youku.com/player/getPlayList/VideoIDS/视频ID (比如 http://v.youku.com/v_show/id_XNTQxNzc4ODg0.html的ID就是XNTQxNzc4ODg0)
</code></pre>

<p>翻译、词典接口</p>

<p>腾讯</p>

<pre><code>http://dict.qq.com/dict?q=词语
</code></pre>

<p>腾讯的部分接口</p>

<p>获取QQ昵称和用户头像</p>

<pre><code>http://r.qzone.qq.com/cgi-bin/user/cgi_personal_card?uin=QQ
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发：git命令返回任意一个版本的方法]]></title>
    <link href="http://worldligang.github.io/blog/2014/12/04/ioskai-fa-:gitming-ling-fan-hui-ren-yi-%5B%3F%5D-ge-ban-ben-de-fang-fa/"/>
    <updated>2014-12-04T18:28:04+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/12/04/ioskai-fa-:gitming-ling-fan-hui-ren-yi-[?]-ge-ban-ben-de-fang-fa</id>
    <content type="html"><![CDATA[<p>git回退某一个版本的方法：</p>

<p><div class="entry-content"><h3>一：记录回退的hash值</h3></p>

<p>首先要查看你要回退到哪一个版本</p>

<p>方法1：git log</p>

<p>会展示最新的提交记录，然后你按着键盘的“向下”键，看更多的提交记录，记住你要回退的哪一个版本的hash值</p>

<p>方法2：git reflog</p>

<p>会展示最近操作的记录，然后你记住要回退的hash值</p>

<p><div class="entry-content"><h3>二：执行回退命令</h3></p>

<p>知道hash值之后，接下来就是指向回退命令了：</p>

<p>git reset &ndash;hard +版本号回到该版本状态下</p>

<p>这样你就可以回退的任意一个版本了，挺方便的。</p>

<p></br></p>

<p>更多iOS开发技术请关注：</p>

<p>微信公众号：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发：git创建仓库]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/24/ioskai-fa-:gitchuang-jian-cang-ku/"/>
    <updated>2014-11-24T09:17:38+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/24/ioskai-fa-:gitchuang-jian-cang-ku</id>
    <content type="html"><![CDATA[<p>从 Git 中移除某个文件</p>

<pre><code>rm test.txt

git rm test.txt
</code></pre>

<p>添加远程仓库</p>

<pre><code>$ git remote origin $ git remote add pb git://github.com/paulboone/ticgit.git $ git remote -v origin  git://github.com/schacon/ticgit.git pb  git://github.com/paulboone/ticgit.git
</code></pre>

<p>远程仓库的删除和重命名</p>

<pre><code>$ git remote rename pb paul $ git remote origin paul
</code></pre>

<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p>

<pre><code>$ git remote rm paul $ git remote origin 
</code></pre>

<p>我的微信公众号：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发中git分支创建和管理]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/19/ioskai-fa-zhong-gitfen-zhi-chuang-jian-he-guan-li/"/>
    <updated>2014-11-19T10:19:00+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/19/ioskai-fa-zhong-gitfen-zhi-chuang-jian-he-guan-li</id>
    <content type="html"><![CDATA[<p><a href="http://www.superqq.com/">iOS开发中git分支创建和管理</a></p>

<p>创建分支</p>

<pre><code>$ git branch testing
</code></pre>

<p>切换到testing分支</p>

<pre><code>$ git checkout testing
</code></pre>

<p>查看本地分支</p>

<pre><code>$ git branch
</code></pre>

<p>查看远程分支</p>

<pre><code>$ git branch -a
</code></pre>

<p>删除本地分支</p>

<pre><code>$ git branch -D testing
</code></pre>

<p>提交本地分支到远程</p>

<p>1，切换到要提交的分支</p>

<pre><code>$ git checkout testing
</code></pre>

<p>2，提交到远程</p>

<pre><code>$ git push origin testing
</code></pre>

<p>删除远程分支</p>

<pre><code>$git push origin :branch-name
</code></pre>

<p>冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支。</p>

<p>iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods详解之----制作篇]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/18/cocoapodsxiang-jie-zhi-zhi-zuo-pian/"/>
    <updated>2014-11-18T09:33:20+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/18/cocoapodsxiang-jie-zhi-zhi-zuo-pian</id>
    <content type="html"><![CDATA[<p>学会使用别人的Pods依赖库以后，你一定对创建自己的依赖库跃跃欲试，今天就来揭开Pods依赖库创建过程的神秘面纱。整个创建过程都以我实现的一个名称为WZMarqueeView跑马灯效果的view为例，步骤如下：</p>

<p><div class="entry-content"><h3>一、创建自己的github仓库</h3></p>

<p><a href="http://www.superqq.com/">CocoaPods</a>都托管在github上(官方链接为：<a href="https://github.com/CocoaPods">https://github.com/CocoaPods</a>)，所有的Pods依赖库也都依赖github，因此第一步我们需要创建一个属于自己的github仓库。仓库创建界面如下图：
<img src="http://img.blog.csdn.net/20140304101538437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>上图中标了序号的共6处，对应的说明如下：
1、Repository name
仓库名称，这里写成WZMarqueeView，必填的；
2、Description
仓库的描述信息，可选的；
3、仓库的公开性
这里只能选Public，一个是因为Private是要money的，再一个Private别人看不到还共享个毛；
4、是否创建一个默认的README文件
一个完整地仓库，都需要README说明文档，建议选上。当然不嫌麻烦的话你也可以后面再手动创建一个；
5、是否添加.gitignore文件
.gitignore文件里面记录了若干中文件类型，凡是该文件包含的文件类型，git都不会将其纳入到版本管理中。是否选择看个人需要；
6、license类型
正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。</p>

<p>上面的各项都填写完毕后，点击Create repository按钮即可，创建成功地界面如图：
<img src="http://img.blog.csdn.net/20140304103428187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>到这，仓库创建过程就结束了。</p>

<p><div class="entry-content"><h3>二、clone仓库到本地</h3></p>

<p>为了便于向仓库中删减内容，需要先将仓库clone到本地，操作方式有多种，推荐使用命令行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ git clone https://github.com/wangzz/WZMarqueeView.git  
</code></pre>

<p>操作完成后，github上对应的文件都会拷贝到本地，目录结构为：
<img src="http://img.blog.csdn.net/20140304110718828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>github上仓库中的.gitignore文件是以.开头的隐藏文件，因此这里只能看到两个。
后续我们的所有文件增、删、改都在这个目录下进行。</p>

<p><div class="entry-content"><h3>三、向本地git仓库中添加创建Pods依赖库所需文件</h3></p>

<p>注意：以下描述的文件都要放在步骤二clone到本地的git仓库的根目录下面。
1、后缀为.podspec文件
该文件为Pods依赖库的描述文件，每个Pods依赖库必须有且仅有那么一个描述文件。文件名称要和我们想创建的依赖库名称保持一致，我的WZMarqueeView依赖库对应的文件名为WZMarqueeView.podspec。</p>

<p>1.1 podspec文件内容
WZMarqueeView.podspec的保存内容为：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>Pod::Spec.new do |s|  
  s.name             = "WZMarqueeView"  
  s.version          = "1.0.0"  
  s.summary          = "A marquee view used on iOS."  
  s.description      = &lt;&lt;-DESC  
                       It is a marquee view used on iOS, which implement by Objective-C.  
                       DESC  
  s.homepage         = "https://github.com/wangzz/WZMarqueeView"  
  # s.screenshots      = "www.example.com/screenshots_1", "www.example.com/screenshots_2"  
  s.license          = 'MIT'  
  s.author           = { "王中周" =&gt; "wzzvictory_tjsd@163.com" }  
  s.source           = { :git =&gt; "https://github.com/wangzz/WZMarqueeView.git", :tag =&gt; s.version.to_s }  
  # s.social_media_url = 'https://twitter.com/NAME'  

  s.platform     = :ios, '4.3'  
  # s.ios.deployment_target = '5.0'  
  # s.osx.deployment_target = '10.7'  
  s.requires_arc = true  

  s.source_files = 'WZMarqueeView/*'  
  # s.resources = 'Assets'  

  # s.ios.exclude_files = 'Classes/osx'  
  # s.osx.exclude_files = 'Classes/ios'  
  # s.public_header_files = 'Classes/**/*.h'  
  s.frameworks = 'Foundation', 'CoreGraphics', 'UIKit'  

end  
</code></pre>

<p>该文件是ruby文件，里面的条目都很容易知道含义。
其中需要说明的又几个参数：
①s.license
Pods依赖库使用的license类型，大家填上自己对应的选择即可。
②s.source_files
表示源文件的路径，注意这个路径是相对podspec文件而言的。
③s.frameworks
需要用到的frameworks，不需要加.frameworks后缀。</p>

<p>1.2 如何创建podspec文件
大家创建自己的podspec文件可以有两个途径：
①copy我的podspec文件然后修改对应的参数，推荐使用这种方式。
②执行以下创建命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod spec create WZMarqueeView  
</code></pre>

<p>也会创建名为WZMarqueeView.podspec的文件。但是打开创建完的文件你就会发现里面的东西太多了，很多都是我们不需要的。</p>

<p>2、LICENSE文件
CocoaPods强制要求所有的Pods依赖库都必须有license文件，否则验证不会通过。license的类型有很多种，详情可以参考网站tl;dr Legal。在创建github仓库的时候，我已经选择了MIT类型的license。</p>

<p>3、主类文件
创建Pods依赖库就是为了方便别人使用我们的成果，比如我想共享给大家的WZMarqueeView类，是我想提供给广大用户使用的，这个类自然是必不可少的。我把这个类包含的两个文件放到一个名称为WZMarqueeView的文件夹中，对应的目录结构如图：
<img src="http://img.blog.csdn.net/20140304094406921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>里面包含两个文件：WZMarqueeView.h和WZMarqueeView.m</p>

<p>4、demo工程
为了快速地教会别人使用我们的Pods依赖库，通常需要提供一个demo工程。我创建的demo工程放到了一个名为WZMarqueeViewDemo的文件夹中，该目录包含的文件如下图所示：
<img src="http://img.blog.csdn.net/20140304095547765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>5、README.md
使用github的人应该都熟悉这个文件，它是一个成功github仓库必不可少的一部分，使用的是markdown标记语言，用于对仓库的详细说明。</p>

<p>以上所说的5个是创建Pods依赖库所需最基础的文件，其中1、2、3是必需的，4、5是可选但强烈推荐创建的。
添加完这些文件以后，我的github本地仓库目录就变成了下图所示的样子：
<img src="http://img.blog.csdn.net/20140304120124578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p><div class="entry-content"><h3>四、提交修改文件到github</h3></p>

<p>经过步骤三，向本地的git仓库中添加了不少文件，现在需要将它们提交到github仓库中去。提交过程分以下几步：
1、pod验证
执行以下命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ set the new version to 1.0.0  
$ set the new tag to 1.0.0  
</code></pre>

<p>这两条命令是为pod添加版本号并打上tag。然后执行pod验证命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod lib lint  
</code></pre>

<p>如果一切正常，这条命令执行完后会出现下面的输出：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>-&gt; WZMarqueeView (1.0.0)  

ZMarqueeView passed validation.  
</code></pre>

<p>到此，pod验证就结束了。
需要说明的是，在执行pod验证命令的时候，打印出了任何warning或者error信息，验证都会失败！如果验证出现异常，打印的信息会很详细，大家可以根据对应提示做出修改。</p>

<p>2、本地git仓库修改内容上传到github仓库
依次执行以下命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ git add -A &amp;&amp; git commit -m "Release 1.0.0."  
$ git tag '1.0.0'  
$ git push --tags  
$ git push origin master  
</code></pre>

<p>上述命令均属git的范畴，这里不多述。如果一切正常，github上就应该能看到自己刚添加的内容了。如下图所示：
<img src="http://img.blog.csdn.net/20140304144407281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p><div class="entry-content"><h3>五、上传podspec文件到CocoaPods官方仓库中</h3></p>

<p>经过前边的四步操作，你可能以为已经结束了，不幸的是还早着呢。
要想一个Pods依赖库真正可用，还需要做最后一步操作，将我们刚才生成的podspec文件上传到CocoaPods官方的Specs仓库中，链接为：<a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a>
打开这个链接你就会发现，原来我们能使用的，以及我们使用pod search命令能搜索到的所有Pods依赖库都会把它们的podspec文件上传到这个仓库中，也就是说，只有将我们的podspec文件上传到这个仓库中以后，才能成为一个真正的Pods依赖库，别人才能正常使用！
按照git的规则，要想向别人的仓库中添加文件，必须先fork一份别人的仓库，做完相应地修改后，在push给仓库的原作者，等到作者审核通过，然后合并到原来的仓库中。
流程明白了以后，自然知道该怎么干了：
1、fork一份CocoaPods官方的Specs仓库
进入到刚才的官方仓库链接中，点击屏幕右上角的fork按钮，如下图：
<img src="http://img.blog.csdn.net/20140304150419906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>然后大家会发现自己名下会多一份仓库的分支。比如我的分支为：</p>

<p>2、将fork的仓库clone到本地
执行以下命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ git clone https://github.com/wangzz/Specs.git  
</code></pre>

<p>注意，大家需要将对应的仓库地址换成自己的。
这个仓库有点大，需要有耐心啊。</p>

<p>3、将自己的podspec文件添加到本地Specs仓库中
Specs仓库clone到本地后，会放到一个名为Specs的文件夹中。podspec文件在Specs仓库中的保存原则是：
Pods依赖库同名文件夹&mdash;>版本号同名文件夹&mdash;>podspec文件
照此原则，我需要在Specs文件夹下建立一个名为WZMarqueeView的文件夹，然后进入到WZMarqueeView文件夹下，建立一个名称为1.0.0的文件夹，最后进入到1.0.0这个文件夹下，并且将之前创建好的WZMarqueeView.podspec文件拷贝进来。
不难理解，如果以后有对WZMarqueeView类的升级，就在WZMarqueeView文件夹下建立对应版本名称的文件夹，用于保存对应版本的podspec文件即可。
这些操作完成后，目录层次结构如下所示：
<img src="http://img.blog.csdn.net/20140304151710187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>4、上传本地Specs仓库中的修改到github仓库
执行以下命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ git add -A &amp;&amp; git commit -m "Add WZMarqueeView podspec file"  
$ git push origin master  
</code></pre>

<p>成功以后就能在github上自己fork的Specs仓库中看到刚上传的文件了。</p>

<p>5、将在自己fork的Specs上做的修改pull给CocoaPods官方的Specs仓库
进入到自己fork的Specs仓库中，会看到屏幕左上角有一个绿色按钮：
<img src="http://img.blog.csdn.net/20140304152827781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>该按钮点进去以后会有如下图所示的界面：
<img src="http://img.blog.csdn.net/20140304152926843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>点击图中的绿色Create Pull Request按钮，即可将我们fork的Specs上做的修改pull给CocoaPods官方的Specs仓库。</p>

<p>到这一步后，剩下的工作就只有等了，等待CocoaPods的维护人员审核并将我们pull上去的修改合并到官方的Specs仓库中，这个过程通常会有一天左右的等待时间。如果有任何消息，比如审核不通过，或者审核通过了，CocoaPods官方都会发邮件通知的。
等到审核通过的时候，我们就能在官方的Specs仓库中看到自己上传的文件夹了。</p>

<p>6、查看审核进度
当然我们也能查看审核进度，打开这个链接：<a href="https://github.com/CocoaPods/Specs/pulls%EF%BC%8C%E8%BF%99%E9%87%8C%E8%83%BD%E7%9C%8B%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84Specs%E4%BB%93%E5%BA%93pull%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">https://github.com/CocoaPods/Specs/pulls%EF%BC%8C%E8%BF%99%E9%87%8C%E8%83%BD%E7%9C%8B%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84Specs%E4%BB%93%E5%BA%93pull%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A</a>
<img src="http://img.blog.csdn.net/20140304153818828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>红圈标识的就是我刚才pull上来的请求，点进去以后就能看到对应的审核进度。</p>

<p><div class="entry-content"><h3>六、查看我们自己创建的Pods依赖库</h3></p>

<p>如果收到了CocoaPods官方发过来的审核通过邮件以后，你可能很着急的想在自己的电脑上执行pod search命令，看看能不能搜索到自己创建的Pods依赖库。不过你肯定会失望的，因为还需要执行一条命令才能在我们的本地电脑上使用search命令搜索到我们的依赖库：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod setup  
</code></pre>

<p>在我的<a href="http://www.superqq.com/">CocoaPods</a>系列教程中的第一篇：CocoaPods详解之&mdash;-进阶篇中的最后部分介绍过这条命令，它会将所有的Pods依赖库tree跟新到本地。执行完这条命令，再去执行:
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod search WZMarqueeView  
</code></pre>

<p>就能显示出对应的介绍信息了！</p>

<p>说了那么多，到这里整个Pods依赖库创建过程才算真正结束！小伙伴们，你成功了吗？？？遇到问题还请留言。</p>

<p><div class="entry-content"><h3>七、参考文档</h3></p>

<p>1、<a href="http://guides.cocoapods.org">http://guides.cocoapods.org</a></p>

<p>iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p>文章来自： <a href="http://blog.csdn.net/wzzvictory/article/details/20067595"target="_blank"title="CocoaPods详解之----制作篇 ">CocoaPods详解之&mdash;-制作篇 </a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods详解之----进阶篇]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/17/cocoapodsxiang-jie-zhi-jin-jie-pian/"/>
    <updated>2014-11-17T09:28:14+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/17/cocoapodsxiang-jie-zhi-jin-jie-pian</id>
    <content type="html"><![CDATA[<p><div class="entry-content"><h3>一、Podfile.lock文件</h3></p>

<p>上文讲过，在开始使用<a href="http://www.superqq.com/">CocoaPods</a>，执行完pod install之后，会生成一个Podfile.lock文件。这个文件看起来跟我们关系不大，实际上绝对不应该忽略它。
该文件用于保存已经安装的Pods依赖库的版本，通过<a href="http://www.superqq.com/">CocoaPods</a>安装了SBJson、AFNetworking、Reachability三个POds依赖库以后对应的Podfile.lock文件内容为：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>PODS:  
  - AFNetworking (2.1.0):  
    - AFNetworking/NSURLConnection  
    - AFNetworking/NSURLSession  
    - AFNetworking/Reachability  
    - AFNetworking/Security  
    - AFNetworking/Serialization  
    - AFNetworking/UIKit  
  - AFNetworking/NSURLConnection (2.1.0):  
    - AFNetworking/Reachability  
    - AFNetworking/Security  
    - AFNetworking/Serialization  
  - AFNetworking/NSURLSession (2.1.0):  
    - AFNetworking/NSURLConnection  
  - AFNetworking/Reachability (2.1.0)  
  - AFNetworking/Security (2.1.0)  
  - AFNetworking/Serialization (2.1.0)  
  - AFNetworking/UIKit (2.1.0):  
    - AFNetworking/NSURLConnection  
  - Reachability (3.0.0)  
  - SBJson (4.0.0)  

DEPENDENCIES:  
  - AFNetworking (~&gt; 2.0)  
  - Reachability (~&gt; 3.0.0)  
  - SBJson (~&gt; 4.0.0)  

SPEC CHECKSUMS:  
  AFNetworking: c7d7901a83f631414c7eda1737261f696101a5cd  
  Reachability: 500bd76bf6cd8ff2c6fb715fc5f44ef6e4c024f2  
  SBJson: f3c686806e8e36ab89e020189ac582ba26ec4220  

COCOAPODS: 0.29.0  
</code></pre>

<p>Podfile.lock文件最大得用处在于多人开发。对于没有在Podfile中指定Pods依赖库版本的写法，如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>pod 'SBJson'  
</code></pre>

<p>该句话用于获取当前SBJson这个Pods依赖库的最新版本。
当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的SBJson，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！
在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案：</p>

<pre><code>更改Podfile，使其指向最新版本的SBJson依赖库；
执行pod update命令；
</code></pre>

<p>鉴于Podfile.lock文件对团队协作如此重要，我们需要将它添加到版本管理中。</p>

<p><div class="entry-content"><h3>二、Podfile文件</h3></p>

<p>对于普通用户来说，使用CocoaPods我们打交道最多的就是Podfile文件。CocoaPods是用ruby实现的，因此Podfile文件的语法就是ruby的语法。接着从以下几个方面来介绍Podfile:
1、Podfile文件存放位置</p>

<p>这是在上篇文章中，遗留的一个问题。通常情况下我们都推荐Podfile文件都放在工程根目录，如下图所示：
事实上Podfile文件可以放在任意一个目录下，需要做的是在Podfile中指定工程的路径，和原来相比，Podfile文件就在最开始的位置增加了一行，具体内容如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>xcodeproj "/Users/wangzz/Desktop/CocoaPodsTest/CocoaPodsTest.xcodeproj"  

platform :ios    
pod 'Reachability',  '~&gt; 3.0.0'    
pod 'SBJson', '~&gt; 4.0.0'    

platform :ios, '7.0'    
pod 'AFNetworking', '~&gt; 2.0'   
</code></pre>

<p>指定路径使用的是xcodeproj关键字。
此后，进入Podfile文件所在路径，执行pod install命令就会和之前一样下载这些Pods依赖库，而且生成的相关文件都放在了Podfile所在目录下面，如下图：
和之前一样，我们仍然需要使用这里生成的workspace文件打开工程。</p>

<p>2、Podfile和target
Podfile本质上是用来描述Xcode工程中的targets用的。如果我们不显式指定Podfile对应的target，CocoaPods会创建一个名称为default的隐式target，会和我们工程中的第一个target相对应。换句话说，如果在Podfile中没有指定target，那么只有工程里的第一个target能够使用Podfile中描述的Pods依赖库。
如果想在一个Podfile中同时描述project中的多个target，根据需求的不同，可以有不同的实现方式。为了说明问题，在原来的工程中再创建一个名称为Second的target，现在的project中包含的target有：
①多个target中使用相同的Pods依赖库
比如，名称为CocoaPodsTest的target和Second的target都需要使用Reachability、SBJson、AFNetworking三个Pods依赖库，可以使用link_with关键字来实现，将Podfile写成如下方式：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>link_with 'CocoaPodsTest', 'Second'  
platform :ios    
pod 'Reachability',  '~&gt; 3.0.0'    
pod 'SBJson', '~&gt; 4.0.0'    

platform :ios, '7.0'    
pod 'AFNetworking', '~&gt; 2.0'   
</code></pre>

<p>这种写法就实现了CocoaPodsTest和Second两个target共用相同的Pods依赖库。
②不同的target使用完全不同的Pods依赖库
CocoaPodsTest这个target使用的是Reachability、SBJson、AFNetworking三个依赖库，但Second这个target只需要使用OpenUDID这一个依赖库，这时可以使用target关键字，Podfile的描述方式如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>target :'CocoaPodsTest' do  
platform :ios    
pod 'Reachability',  '~&gt; 3.0.0'    
pod 'SBJson', '~&gt; 4.0.0'    

platform :ios, '7.0'    
pod 'AFNetworking', '~&gt; 2.0'  
end  

target :'Second' do  
pod 'OpenUDID', '~&gt; 1.0.0'  
end  
</code></pre>

<p>其中，do/end作为开始和结束标识符。
3、使用Podfile管理Pods依赖库版本
再引入依赖库时，需要显示或隐式注明引用的依赖库版本，具体写法和表示含义如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>pod 'AFNetworking'      //不显式指定依赖库版本，表示每次都获取最新版本  
pod 'AFNetworking', '2.0'     //只使用2.0版本  
pod 'AFNetworking', '&gt; 2.0'     //使用高于2.0的版本  
pod 'AFNetworking', '&gt;= 2.0'     //使用大于或等于2.0的版本  
pod 'AFNetworking', '&lt; 2.0'     //使用小于2.0的版本  
pod 'AFNetworking', '&lt;= 2.0'     //使用小于或等于2.0的版本  
pod 'AFNetworking', '~&gt; 0.1.2'     //使用大于等于0.1.2但小于0.2的版本  
pod 'AFNetworking', '~&gt;0.1'     //使用大于等于0.1但小于1.0的版本  
pod 'AFNetworking', '~&gt;0'     //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本  
</code></pre>

<p><div class="entry-content"><h3>三、CocoaPods常用命令</h3></p>

<p>1、pod install</p>

<p>根据Podfile文件指定的内容，安装依赖库，如果有Podfile.lock文件而且对应的Podfile文件未被修改，则会根据Podfile.lock文件指定的版本安装。
每次更新了Podfile文件时，都需要重新执行该命令，以便重新安装Pods依赖库。</p>

<p>2、pod update</p>

<p>若果Podfile中指定的依赖库版本不是写死的，当对应的依赖库有了更新，无论有没有Podfile.lock文件都会去获取Podfile文件描述的允许获取到的最新依赖库版本。</p>

<p>3、pod search</p>

<p>命令格式为：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod search OpenUDID  
</code></pre>

<p>后面的OpenUDID为参数。
从命令的名称不难看出，该命令是用来按名称搜索可用的Pods依赖库，执行结果如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>-&gt; OpenUDID (1.0.0)  
   Open source initiative for a universal and persistent UDID solution for iOS.  
   pod 'OpenUDID', '~&gt; 1.0.0'  
   - Homepage: http://OpenUDID.org  
   - Source:   https://github.com/ylechelle/OpenUDID.git  
   - Versions: 1.0.0 [master repo]  
</code></pre>

<p>这里我们搜到了一条可用数据，里面描述了OpenUDID库的简要信息。其实我们真正需要的是上述结果中的第三行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>pod 'OpenUDID', '~&gt; 1.0.0'  
</code></pre>

<p>不难看出，这是我们需要添加到Podfile文件中的。
有了这条命令，就可以方便、迅速地找到需要的Pods依赖库。</p>

<p>4、pod setup</p>

<p>命令格式为：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod setup  
</code></pre>

<p>执行完了以后会打印：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>Setting up CocoaPods master repo  
Updating 7cd4668..f3d3ced  

Fast-forward  
</code></pre>

<p>接下来还会打印很多更新信息。
这条命令用于跟新本地电脑上的保存的Pods依赖库tree。由于每天有很多人会创建或者更新Pods依赖库，这条命令执行的时候会相当慢，还请耐心等待。我们需要经常执行这条命令，否则有新的Pods依赖库的时候执行pod search命令是搜不出来的。</p>

<p><div class="entry-content"><h3>四、参考文档</h3></p>

<p><a href="http://guides.cocoapods.org/using/index.html"target="_blank"title="刚刚在线"><a href="http://guides.cocoapods.org/using/index.html">http://guides.cocoapods.org/using/index.html</a></a></p>

<p></br></p>

<p>iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p></br></p>

<p>文章来自： <a href="http://blog.csdn.net/wzzvictory/article/details/19178709"target="_blank"title="CocoaPods详解之----进阶篇">CocoaPods详解之&mdash;-进阶篇</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods详解之----使用篇]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/15/cocoapodsxiang-jie-zhi-shi-yong-pian/"/>
    <updated>2014-11-15T13:40:53+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/15/cocoapodsxiang-jie-zhi-shi-yong-pian</id>
    <content type="html"><![CDATA[<p></br></p>

<p><div class="entry-content"><h3>一、什么是CocoaPods</h3></p>

<p><div class="entry-content"><h5>1、为什么需要CocoaPods</h5></p>

<p>在进行iOS开发的时候，总免不了使用第三方的开源库，比如SBJson、AFNetworking、Reachability等等。使用这些库的时候通常需要：</p>

<p>下载开源库的源代码并引入工程</p>

<p>向工程中添加开源库使用到的framework</p>

<p>解决开源库和开源库以及开源库和工程之间的依赖关系、检查重复添加的framework等问题</p>

<p>如果开源库有更新的时候，还需要将工程中使用的开源库删除，重新执行前面的三个步骤，顿时头都大了。。。</p>

<p>自从有了<a href="http://www.superqq.com/">CocoaPods</a>以后，这些繁杂的工作就不再需要我们亲力亲为了，只需要我们做好少量的配置工作，CocoaPods会为我们做好一切！</p>

<p><div class="entry-content"><h5>2、什么是CocoaPods</h5></p>

<p>CocoaPods是一个用来帮助我们管理第三方依赖库的工具。它可以解决库与库之间的依赖关系，下载库的源代码，同时通过创建一个Xcode的workspace来将这些第三方库和我们的工程连接起来，供我们开发使用。</p>

<p>使用CocoaPods的目的是让我们能自动化的、集中的、直观的管理第三方开源库。</p>

<p><div class="entry-content"><h3>二、安装CocoaPods</h3></p>

<p><div class="entry-content"><h5>1、安装CocoaPods</h5></p>

<p>CocoaPods是用Ruby实现的，要想使用它首先需要有Ruby的环境。幸运的是OS X系统默认的已经可以运行Ruby了，因此我们只需要执行以下命令：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ sudo gem install cocoapods  
</code></pre>

<p>CocoaPods是以Ruby gem包的形式被安装的。在安装执行的过程中，可能会问我们是不是更新rake，输入y即可。这是因为rake gem包会在安装的过程中检查更细，如果有可用的新版本就会出现刚才的选项。</p>

<p>在安装进程结束的时候，执行命令：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod setup  
</code></pre>

<p>如果没有报错，就说明一切安装就成功了！</p>

<p><div class="entry-content"><h5>2、安装过程中可能遇到的问题</h5></p>

<p>①执行完install命令半天没反应</p>

<p>这有可能是因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ gem sources --remove https://rubygems.org/  
//等有反应之后再敲入以下命令  
$ gem sources -a http://ruby.taobao.org/  
</code></pre>

<p>要想验证是否替换成功了，可以执行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ gem sources -l  
</code></pre>

<p>正常的输出是：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>*** CURRENT SOURCES ***  

http://ruby.taobao.org/  
</code></pre>

<p>②gem版本过老</p>

<p>gem是管理Ruby库和程序的标准包，如果它的版本过低也可能导致安装失败，解决方案自然是升级gem，执行下述命令即可：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ sudo gem update --system  
</code></pre>

<p>③安装完成后，执行pod setup命令时报错：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>/Users/wangzz/.rvm/rubies/ruby-1.9.3-p448/lib/ruby/site_ruby/1.9.1/rubygems/dependency.rb:298:in `to_specs': Could not find 'cocoapods' (&gt;= 0) among 6 total gem(s) (Gem::LoadError)  
    from /Users/wangzz/.rvm/rubies/ruby-1.9.3-p448/lib/ruby/site_ruby/1.9.1/rubygems/dependency.rb:309:in `to_spec'  
    from /Users/wangzz/.rvm/rubies/ruby-1.9.3-p448/lib/ruby/site_ruby/1.9.1/rubygems/core_ext/kernel_gem.rb:53:in `gem'  
    from /Users/wangzz/.rvm/rubies/ruby-1.9.3-p448/bin/pod:22:in `&lt;main&gt;'  
</code></pre>

<p>这就是路径设置的问题，可以通过执行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ rvm use ruby-1.9.3-p448  
</code></pre>

<p>解决该问题。</p>

<p><div class="entry-content"><h5>3、升级CocoaPods</h5></p>

<p>升级很简单，再次执行安装命令即可：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ sudo gem install cocoapods  
</code></pre>

<p>需要注意的是，如果安装的时候使用了sudo，升级的时候一样需要使用该关键字，不然升级完了以后又会出现路径不匹配问题。</p>

<p><div class="entry-content"><h3>三、使用CocoaPods</h3></p>

<p>如果之前做的一切顺利，接下来就可以体验体验<a href="http://www.superqq.com/">CocoaPods</a>的神奇之处了，需要经过以下几步：</p>

<p>为了演示这个过程，我创建了一个名为CocoaPodsTest的工程。
<div class="entry-content"><h5>1、创建Podfile</h5></p>

<p>CocoaPods的一切都是从一个名为Podfile的文件开始的，我们需要先创建这个文件。个人习惯使用命令行，我会这样做：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ cd /Users/wangzz/Desktop/CocoaPodsTest  
$ touch Podfile  
</code></pre>

<p>首先进入到工程的根目录下，创建空白的Podfile文件，创建完毕的目录结构如下图：</p>

<p><img src="http://img.blog.csdn.net/20140126162345078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>（PS：Podfile文件也可以不放在工程的根目录下，只是会稍微麻烦点，在下一篇文章中会有介绍，敬请关注。）
<div class="entry-content"><h5>2、编辑Podfile</h5></p>

<p>根据需要，我们可以在Podfile文件中写入需要用到的第三方库，以SBJson、AFNetworking、Reachability三个库为例，我的Podfile内容如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>platform :ios  
pod 'Reachability',  '~&gt; 3.0.0'  
pod 'SBJson', '~&gt; 4.0.0'  

platform :ios, '7.0'  
pod 'AFNetworking', '~&gt; 2.0'  
</code></pre>

<p><div class="entry-content"><h5>3、执行导入命令</h5></p>

<p>准备工作都完成后，开始导入第三方库：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ cd /Users/wangzz/Desktop/CocoaPodsTest  
$ pod install  
</code></pre>

<p>首先进入工程根目录，然后执行pod install命令，CocoaPods就开始为我们做下载源码、配置依赖关系、引入需要的framework等一些列工作，命令的执行结果打印出来如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>Analyzing dependencies  
Downloading dependencies  
Installing AFNetworking (2.1.0)  
Installing JSONKit (1.5pre)  
Installing Reachability (3.0.0)  
Generating Pods project  
Integrating client project  

[!] From now on use `CocoaPodsTest.xcworkspace`.  
</code></pre>

<p>这就说明pod install命令执行成功了。再来看看工程根目录发生的变化，如下图：</p>

<p><img src="http://img.blog.csdn.net/20140126163651109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>可以看到，工程的根目录下多了三个东西：CocoaPodsTest.xcworkspace、Podfile.lock文件和Pods目录。</p>

<p><div class="entry-content"><h5>（PS：篇幅有限，Podfile.lock文件会放到系列文章的下一篇介绍，敬请关注。）</h5></p>

<p>再看看刚才执行完pod install命令打印出来的内容的最后一行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>[!] From now on use `CocoaPodsTest.xcworkspace`.  
</code></pre>

<p>提示我们从现在起，我们需要使用CocoaPodsTest.xcworkspace文件来开发。</p>

<p>对于工程发生的变化，有几点需要说明：</p>

<pre><code>第三方库会被编译成静态库供我们正真的工程使用
</code></pre>

<p>CocoaPods会将所有的第三方库以target的方式组成一个名为Pods的工程，该工程就放在刚才新生成的Pods目录下。整个第三方库工程会生成一个名称为libPods.a的静态库提供给我们自己的CocoaPodsTest工程使用。</p>

<pre><code>我们的工程和第三方库所在的工程会由一个新生成的workspace管理
</code></pre>

<p>为了方便我们直观的管理工程和第三方库，CocoaPodsTest工程和Pods工程会被以workspace的形式组织和管理，也就是我们刚才看到的CocoaPodsTest.xcworkspace文件。</p>

<p>原来的工程设置已经被更改了，这时候我们直接打开原来的工程文件去编译就会报错，只能使用新生成的workspace来进行项目管理。</p>

<p>打开CocoaPodsTest.xcworkspace，界面如下：</p>

<p><img src="http://img.blog.csdn.net/20140126171045546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>工程的目录结构还是非常明显的。</p>

<p>在项目中引用刚才添加的第三方库的头文件，执行编译操作，果断成功！</p>

<p>至此，CocoaPods使用篇告一段落，接下来打算再用一个篇幅介绍CocoaPods稍微深层次的东西，敬请关注。</p>

<p><div class="entry-content"><h3>四、参考资料</h3></p>

<p><a href="http://code4app.com/article/cocoapods-install-usage"target="_blank"title="刚刚在线">1、<a href="http://code4app.com/article/cocoapods-install-usage">http://code4app.com/article/cocoapods-install-usage</a></a></p>

<p><a href="http://cocoapods.org/"target="_blank"title="刚刚在线">2、<a href="http://cocoapods.org/">http://cocoapods.org/</a></a></p>

<p></br></p>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p></br></p>

<p>文章来自： <a href="http://blog.csdn.net/wzzvictory/article/details/18737437"target="_blank"title="CocoaPods详解之----使用篇">CocoaPods详解之&mdash;-使用篇</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac终端关机命令]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/14/maczhong-duan-guan-ji-ming-ling/"/>
    <updated>2014-11-14T14:00:26+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/14/maczhong-duan-guan-ji-ming-ling</id>
    <content type="html"><![CDATA[<p>立即关机</p>

<pre><code>sudo halt
</code></pre>

<p>或者</p>

<pre><code>sudo shutdown -h now
</code></pre>

<p>10分钟后关机</p>

<pre><code>sudo shutdown -h +10
</code></pre>

<p>晚上8点关机</p>

<pre><code>sudo shutdown -h 20:00
</code></pre>

<p>立即重启</p>

<pre><code>sudo reboot
</code></pre>

<p>或者</p>

<pre><code>sudo shutdown -r now
</code></pre>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[中文 iOS/Mac 开发博客列表]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/13/zhong-wen-ios-slash-mac-kai-fa-bo-ke-lie-biao/"/>
    <updated>2014-11-13T09:16:45+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/13/zhong-wen-ios-slash-mac-kai-fa-bo-ke-lie-biao</id>
    <content type="html"><![CDATA[<p></br>
本博客列表会不断更新维护，如果有推荐的博客，请直接在本文下面评论。(排名不分先后)</p>

<h2></br></h2>

<p><a href="http://onevcat.com"target="_blank"title="OneV's Den">OneV&rsquo;s Den</a></p>

<p>嗨，我是王巍 (@onevcat)，一名来自中国的 iOS / Unity 开发者。现居日本，就职于 LINE。正在修行，探求创意之源。
<a href="http://swifter.tips/"target="_blank"title="Swifter.tips">Swifter.tips</a> - 我维护的 Swift 使用技巧分享网站，每周三更新，欢迎访问</p>

<h2></br></h2>

<p><a href="http://www.superqq.com"target="_blank"title="刚刚在线">刚刚在线</a></p>

<p>Blogger, iOS开发, 创业者, 屌丝青年。iOS开发工程师，曾开发今日·天下通，二维码商城等项目。iOS学习交流群：303868520 我的微信公众账号: iOSDevTip</p>

<h2></br></h2>

<p><a href="http://beyondvincent.com"target="_blank"title="破船之家">破船之家</a></p>

<p>程序猿砌墙于云南昆明!长期扎根移动软件开发!爱跑步爱打篮球爱运动!命中无大富大贵之面相!愿健康与平淡相随一生!</p>

<h2></br></h2>

<p><a href="http://nshipster.cn"target="_blank"title="NSHipster">NSHipster</a></p>

<p>NSHipster 关注被忽略的 Objective-C、Swift 和 Cocoa 特性。每周更新。</p>

<h2></br></h2>

<p><a href="http://blog.devtang.com"target="_blank"title="唐巧的技术博客">唐巧的技术博客</a></p>

<p>Blogger, InfoQ编辑, iOS开发, 创业者。Java开发工程师，曾开发网易微博后台。iOS开发工程师，曾开发有道云笔记、粉笔网、猿题库。</p>

<h2></br></h2>

<p><a href="http://blog.xcodev.com"target="_blank"title="Xcode Dev">Xcode Dev</a></p>

<p>谌启亮，资深iOS开发工程师，参与过20多个项目的研发，从苹果还未开放官方SDK(非官方Toolchain)开发做起，6年iOS应用开发经验, 精通界面开发及iOS设备用户体验。喜欢学习一些新的知识并分享自己所学。就职于腾讯。</p>

<h2></br></h2>

<p><a href="http://blog.t-xx.me/blog/archives"target="_blank"title="txx's blog">txx&rsquo;s blog</a></p>

<h2></br></h2>

<p><a href="http://xiangwangfeng.com"target="_blank"title="阿毛的蛋疼地">阿毛的蛋疼地</a></p>

<p>阿毛，杭州猪场全职iOS开发一枚，早年学C#,C++未成，与2011年改投OC怀抱。</p>

<h2></br></h2>

<p><a href="http://nonomori.farbox.com"target="_blank"title="Nonomori">Nonomori</a></p>

<h2></br></h2>

<p><a href="http://adad184.com"target="_blank"title="里脊串的开发随笔">里脊串的开发随笔</a></p>

<p>86年生于长沙, 曾于深圳工作, 现已回长沙.</p>

<h2></br></h2>

<p><a href="http://ivoryxiong.org"target="_blank"title="煲仔饭">煲仔饭</a></p>

<p>byr土著，码农一枚，朋友们都习惯叫&#8221;雕&#8221;【不要问为什么:(】，爱好不多，仅有的兴趣现在也成为了职业&hellip;在网易有道打过杂，也在人人网写过代码，目前在深圳折腾无觅阅读。</p>

<h2></br></h2>

<p><a href="http://www.hotobear.com"target="_blank"title="不掏蜂窝的熊">不掏蜂窝的熊</a></p>

<p>我是不掏蜂窝的熊iOS开发，接触过越狱开发，对iOS程序逆向工程有一定了解。其实我只是一只普通的程序猿而已。一直以为自己是巨蟹座，结果某天发现自己是狮子时，已经没有当狮子的潜质了</p>

<h2></br></h2>

<p>参考唐巧的github：<a href="https://github.com/tangqiaoboy/iOSBlogCN"target="_blank"title="中文 iOS/Mac 开发博客列表">中文 iOS/Mac 开发博客列表</a><br/>
</br>
<a href="http://www.superqq.com/blog/2014/11/13/zhong-wen-ios-slash-mac-kai-fa-bo-ke-lie-biao/"target="_blank"title="刚刚在线">转载请注明来自：刚刚在线</a></p>

<h2></br></h2>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解读AFNetworking中Demo的MVC]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/11/jie-du-afnetworkingzhong-demode-mvc/"/>
    <updated>2014-11-11T11:00:21+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/11/jie-du-afnetworkingzhong-demode-mvc</id>
    <content type="html"><![CDATA[<p>Demo的下载地址：<a href=""></a><a href="https://github.com/AFNetworking/AFNetworking.git"target="_blank"title="AFNetworking下载">AFNetworking下载</a></p>

<p>打开Demo：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylDJt3FABXaQmFVO4Hqm1zNzeQGY2kKVSJ9CtQR7HWcsKelE6nuLauFQMdWtO2L90ccabibh5v1yeg/640"></p>

<p>现实的功能，就是一个简易的微博timeline界面：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylDJt3FABXaQmFVO4Hqm1zNW4svNoeQPlAsBHJ40YJeiaUib7ia5Hdgo9Yf5YBee5zZ1lDbXphGCHibCQ/640"></p>

<p>项目预览：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylDJt3FABXaQmFVO4Hqm1zNFUp9X2kpra3gqd98Qh4Yn1RhnHsIKcI46TP97BVKbvJicpvYoUd5tuA/640"></p>

<p>用到的第三方：AFNetworking 和 UIKit+AFNetworking</p>

<p>功能：用户图像（先显示默认图，在加载图片），用户发的内容，下拉刷新。</p>

<p><div class="entry-content"><h3>C层：</h3></p>

<p>发一个请求：（告诉M 要做什么）</p>

<pre><code>- (void)reload:(__unusedid)sender {
    self.navigationItem.rightBarButtonItem.enabled = NO;

    NSURLSessionTask *task = [PostglobalTimelinePostsWithBlock:^(NSArray *posts, NSError *error) {
        if (!error) {

             self.posts = posts;
            [self.tableViewreloadData];
        }
    }];

    [UIAlertViewshowAlertViewForTaskWithErrorOnCompletion:task delegate:nil];
    [self.refreshControlsetRefreshingWithStateOfTask:task];
}
</code></pre>

<p>M 做完之手，产生多个post对象，放到self.post数组里面。C拿到M给的post对象，去更新V</p>

<pre><code>cell.post = [self.postsobjectAtIndex:(NSUInteger)indexPath.row];
</code></pre>

<p><div class="entry-content"><h3>M层：</h3></p>

<p>M 收到C的请求：去请求数据，解析，转换成post对象，然后通过block返回给C</p>

<pre><code>+ (NSURLSessionDataTask *)globalTimelinePostsWithBlock:(void (^)(NSArray *posts, NSError *error))block {
    return [[AFAppDotNetAPIClientsharedClient] GET:@"stream/0/posts/stream/global"parameters:nilsuccess:^(NSURLSessionDataTask * __unused task, id JSON) {
        NSArray *postsFromResponse = [JSON valueForKeyPath:@"data"];
        NSMutableArray *mutablePosts = [NSMutableArrayarrayWithCapacity:[postsFromResponse count]];
        for (NSDictionary *attributes in postsFromResponse) {
            Post *post = [[Postalloc] initWithAttributes:attributes];
            [mutablePosts addObject:post];
        }

        if (block) {
            block([NSArrayarrayWithArray:mutablePosts], nil);
        }
    } failure:^(NSURLSessionDataTask *__unused task, NSError *error) {
        if (block) {
            block([NSArrayarray], error);
        }
    }];
}
</code></pre>

<p><div class="entry-content"><h3>V层：</h3></p>

<p>V：拿到C给的数据，来展示出来，这一步就是更新UI</p>

<pre><code>- (void)setPost:(Post *)post {
    _post = post;

    self.textLabel.text = _post.user.username;
    self.detailTextLabel.text = _post.text;
    [self.imageViewsetImageWithURL:_post.user.avatarImageURLplaceholderImage:[UIImageimageNamed:@"profile-image-placeholder"]];

    [selfsetNeedsLayout];
}
</code></pre>

<p>其中 ：</p>

<pre><code>    [self.imageViewsetImageWithURL:_post.user.avatarImageURLplaceholderImage:[UIImageimageNamed:@"profile-image-placeholder"]];
</code></pre>

<p>这句代码是对UIImageView的扩展，在UIKit+AFNetworking可以直接使用，非常方便。</p>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅析MVC和说媒的过程]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/10/qian-xi-mvche-shuo-mei-de-guo-cheng/"/>
    <updated>2014-11-10T09:09:18+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/10/qian-xi-mvche-shuo-mei-de-guo-cheng</id>
    <content type="html"><![CDATA[<p>什么是MVC？</p>

<p>MVC 全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面 显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p>

<p>图解MVC（斯坦福公开课的课件）</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlyntSNHaU7eaCHkcL3pjib2pNyjgWU7BF1D1YgmicwMFpFuefvttAe7fEwCu8TTmkmfkRtAO0Hvt1HfA/640"></p>

<p>看了上面的MVC定义和图解，对MVC有了初步的了解，特别是斯坦福这个课件，讲的非常到位。但是在实际开发过程中，却感觉离MVC的标准越来越远。</p>

<p>我也看过一些朋友写的iOS项目，看之前问MVC，都讲的头头是道，但是在项目中却体现的不是那么好。我自己写项目也是，理论上是理解了MVC的模式，但是真去写代码，还是觉得，有些地方不到位。</p>

<p>特别是C（我们就把UIViewController当做C来看，网上有对C的其他解释）显得别急臃肿。有时候C里面代码几千行（并不是说代码过千就是不符合MVC），C干了很多M干的事，同时也干了很多V要干的事。</p>

<p>这几天我看了一个项目（AFNetworking的作者写的DEMO，大家可以到github上下载），觉得MVC用的非常到位。每一步都是很周到，M和C的对接，V和C的对接，做到非常到位。</p>

<p>对于MVC，我说说我的理解，俗一点讲：媒婆说没得过程。M -> 男人 ， V -> 女人 ， C -> 媒婆。</p>

<p>C（媒婆） 要给 M（男人） 介绍个女朋友 V （女人），C 是一个桥梁起着对接的作用， M 和 V 本是不认识的两个人，不能直接沟通。</p>

<p>说媒过程是这样的：C 给 M 说，第一次见女孩子，你要给女孩子准备什么礼物吧？</p>

<p>这个时候，M 肯定不会说，这点小事，你还来麻烦我，自己去买吧，那估计媒婆气都气死了，这事肯定成不了。（写代码的时候，不要让C干M得事）</p>

<p>这事必须 M 自己去做，M 买东西就是处理数据得过程。买东西怎么去买？多少钱？怎么讲价？这都是 M 自己要去干的事。最终结果是 M 买来礼物，礼物就是我们编程过程中 Model所产生的对象。</p>

<p>礼物买来了，M 也不认识 V ，肯定也不知道怎么送给 V，所以这个时候 C 的作用就体现出来了，M 要把 买来的礼物（Object）交给C，让C帮忙送给 V。</p>

<p>就这样，V 拿到礼物，觉得不错，就自己用了。</p>

<p>回想一下这个过程：C 发起一个请求，买礼物。M 知道之后，就去执行这件事，最终买来礼物。M 脱 C 把礼物送给V。一个完整的请求数据，展示数据的过程。</p>

<p>虽然有点俗，但是还是有一定道理的。</p>

<p>后面时间允许的话，我会详解一下AFNetworking的作者写的DEMO。看看MVC在项目的体现到底是什么样的。</p>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode6为什么干掉pch（Precompile Prefix Header）&amp;如何添加pch文件]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/08/xcode6wei-shi-yao-gan-diao-pch(precompile-prefix-header)-and-ru-he-tian-jia-pchwen-jian/"/>
    <updated>2014-11-08T10:11:23+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/08/xcode6wei-shi-yao-gan-diao-pch(precompile-prefix-header)-and-ru-he-tian-jia-pchwen-jian</id>
    <content type="html"><![CDATA[<p>一直在用xcode6开发，但项目都是在xcode5上创建的，所以一直没注意到，xcode6竟然干掉pch文件了。</p>

<p><div class="entry-content"><h3>为什么xcode6没有自动创建pch文件呢？</h3></p>

<p>简单地看：我们在写项目的时候，大部分宏定义，头文件导入都在这里，Xcode6去掉Precompile Prefix Header的主要原因可能在于Prefix Header大大的增加了Build的时间。没有了Prefix Header之后就要通过手动@import来手动导入头文件了，在失去了编程便利性的同时也降低了Build的时间。
具体原因</p>

<p>StackOverFlow上讨论的已经比较清晰了</p>

<p><a href="http://stackoverflow.com/questions/24158648/why-isnt-projectname-prefix-pch-created-automatically-in-xcode-6"target="_blank"title="StackOverFlow:为什么xcode6没有自动创建pch文件呢？">StackOverFlow:为什么xcode6没有自动创建pch文件呢？</a></p>

<p><div class="entry-content"><h3>如何在Xcode6中添加pch（Precompile Prefix Header）？</h3></p>

<p>1，Command+N，打开新建文件窗口：ios->other->PCH file，创建一个pch文件：“工程名-Prefix.pch”：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlynoFBbyWveMYy6wticicsiasX3njmTFhaLX2E5bcJ6nCw3eqnuhNokuWGOpnj2VfFebls5132y2cDI6g/0"></p>

<p>2，将building setting中的precompile header选项的路径添加“$(SRCROOT)/项目名称/pch文件名”（例如：$(SRCROOT)/LotteryFive/LotteryFive-Prefix.pch）</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlynoFBbyWveMYy6wticicsiasX38btBBs0AT3s6kGic99kpGDMk9bJ4ctI8bQRL7ahnavlDqm21QDTfWBA/0"></p>

<p>可以了，编译一下程序，如果有错误检查一下添加的路径是否正确。</p>

<p>3，将Precompile Prefix Header为YES，预编译后的pch文件会被缓存起来，可以提高编译速度</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlynoFBbyWveMYy6wticicsiasX35f55EbKxXYqghNKeE4o3YLYTvRyQzdMMcVaQmmkNE68hZypyI24lQQ/0"></p>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p>✎最新iOS、iPhone资讯，iOS开发者、swift开发、果粉聚集，参与技术讨论，整理开发技巧，分享创业经验！享受生活、热爱编程！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS网络编程之AFNetworking使用]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/"/>
    <updated>2014-11-07T11:07:32+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong</id>
    <content type="html"><![CDATA[<p><a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">iOS网络编程之AFNetworking使用</a></p>

<p>现在大家都喜欢用AFNetworking，因为有人维护。看来一下官方文档，把使用的代码简单罗列一下：</p>

<p>首先通过<a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods</a>(没用过的看这篇文章)把AFNetworking拉下来</p>

<p>Podfile</p>

<pre><code>platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0"
</code></pre>

<p>方法一：GET 请求</p>

<pre><code>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager GET:@"http://example.com/resources.json" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<p>方法二：POST 请求</p>

<pre><code>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
NSDictionary *parameters = @{@"foo": @"bar"};
[manager POST:@"http://example.com/resources.json" parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<p>方法三：POST Multi-Part Request</p>

<pre><code>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
NSDictionary *parameters = @{@"foo": @"bar"};
NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];
[manager POST:@"http://example.com/resources.json" parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
    [formData appendPartWithFileURL:filePath name:@"image" error:nil];
} success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"Success: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<p>方法四：创建一个下载文件任务</p>

<pre><code>NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

NSURL *URL = [NSURL URLWithString:@"http://example.com/download.zip"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];

NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) {
    NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
    return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];
} completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) {
    NSLog(@"File downloaded to: %@", filePath);
}];
[downloadTask resume];
</code></pre>

<p>方法五：创建一个上传文件任务</p>

<pre><code>NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];

NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];
NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:nil completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@"Error: %@", error);
    } else {
        NSLog(@"Success: %@ %@", response, responseObject);
    }
}];
[uploadTask resume];
</code></pre>

<p>方法六：创建一个上传文件任务并显示进度</p>

<pre><code>NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:@"http://example.com/upload" parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
        [formData appendPartWithFileURL:[NSURL fileURLWithPath:@"file://path/to/image.jpg"] name:@"file" fileName:@"filename.jpg" mimeType:@"image/jpeg" error:nil];
    } error:nil];

AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
NSProgress *progress = nil;

NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&amp;progress completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@"Error: %@", error);
    } else {
        NSLog(@"%@ %@", response, responseObject);
    }
}];
[uploadTask resume];
</code></pre>

<p>方法七：创建一个上传数据data任务</p>

<pre><code>NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];

NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@"Error: %@", error);
    } else {
        NSLog(@"%@ %@", response, responseObject);
    }
}];
[dataTask resume];
</code></pre>

<p>方法八：获取网络状态</p>

<pre><code>[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    NSLog(@"Reachability: %@", AFStringFromNetworkReachabilityStatus(status));
}]; 
</code></pre>

<p>方法九： HTTP Manager Reachability</p>

<pre><code>NSURL *baseURL = [NSURL URLWithString:@"http://example.com/"];
AFHTTPRequestOperationManager *manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:baseURL];

NSOperationQueue *operationQueue = manager.operationQueue;
[manager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    switch (status) {
        case AFNetworkReachabilityStatusReachableViaWWAN:
        case AFNetworkReachabilityStatusReachableViaWiFi:
            [operationQueue setSuspended:NO];
            break;
        case AFNetworkReachabilityStatusNotReachable:
        default:
            [operationQueue setSuspended:YES];
            break;
    }
}];

[manager.reachabilityManager startMonitoring];
</code></pre>

<p>方法十：AFHTTPRequestOperation的GET请求</p>

<pre><code>NSURL *URL = [NSURL URLWithString:@"http://example.com/resources/123.json"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[[NSOperationQueue mainQueue] addOperation:op];  
</code></pre>

<p>方法十一：Batch of Operations</p>

<pre><code>NSMutableArray *mutableOperations = [NSMutableArray array];
for (NSURL *fileURL in filesToUpload) {
    NSURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:@"http://example.com/upload" parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
        [formData appendPartWithFileURL:fileURL name:@"images[]" error:nil];
    }];

    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];

    [mutableOperations addObject:operation];
}

NSArray *operations = [AFURLConnectionOperation batchOfRequestOperations:@[...] progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {
    NSLog(@"%lu of %lu complete", numberOfFinishedOperations, totalNumberOfOperations);
} completionBlock:^(NSArray *operations) {
    NSLog(@"All operations in batch complete");
}];
[[NSOperationQueue mainQueue] addOperations:operations waitUntilFinished:NO];
</code></pre>

<p>方法十二：获取请求的一些信息(我也没有用过，不太常用)</p>

<p>Request Serialization</p>

<p>Request serializers create requests from URL strings, encoding parameters as either a query string or HTTP body.</p>

<pre><code>NSString *URLString = @"http://example.com";
NSDictionary *parameters = @{@"foo": @"bar", @"baz": @[@1, @2, @3]};
</code></pre>

<p>Query String Parameter Encoding</p>

<pre><code>[[AFHTTPRequestSerializer serializer] requestWithMethod:@"GET" URLString:URLString parameters:parameters error:nil];

GET http://example.com?foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3
</code></pre>

<p>URL Form Parameter Encoding</p>

<pre><code>[[AFHTTPRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters];

POST http://example.com/
Content-Type: application/x-www-form-urlencoded

foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3
</code></pre>

<p>JSON Parameter Encoding</p>

<pre><code>[[AFJSONRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters];

POST http://example.com/
Content-Type: application/json

{"foo": "bar", "baz": [1,2,3]}
</code></pre>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xcode6.1调试的时候有时参数都为nil怎么解决?]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/07/xcode6-dot-1diao-shi-de-shi-hou-you-shi-can-shu-du-wei-nilzen-yao-jie-jue/"/>
    <updated>2014-11-07T09:18:04+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/07/xcode6-dot-1diao-shi-de-shi-hou-you-shi-can-shu-du-wei-nilzen-yao-jie-jue</id>
    <content type="html"><![CDATA[<p><a href="http://www.superqq.com/blog/2014/11/07/xcode6-dot-1diao-shi-de-shi-hou-you-shi-can-shu-du-wei-nilzen-yao-jie-jue/">xcode6.1调试的时候有时参数都为nil怎么解决?</a></p>

<p>昨天我在写代码的时候，发现xcode6.1调试的时候有时参数都为nil？曾经有朋友遇到过这个问题，我一直没当回事，昨天我也碰到了：</p>

<p>看下图：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylSosnUuLhV6wTjsFzyRRxoxIUFMqUwfUBic9qDUm8IY9gJQibL0oNeGUMCKN1oVJBwnv6l5OAezkicg/640" ></p>

<p>刚创建的vc 和 nav 都为nil，这给断点调试增加了很多麻烦，难道是xcode的bug吗？</p>

<p>群里问问大牛，不得姐，网上有查，最终找到解决方法：</p>

<p>在Project的Build Settings中把Optimization Level 设置成 None 即可。</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylSosnUuLhV6wTjsFzyRRxo44fXntXf13uoSlnLOsdTkbhHFsHXeDljz69g3JR4sEJnr5SRSLO8icQ/640" ></p>

<p>在运行看一下结果：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylSosnUuLhV6wTjsFzyRRxoHE3BZhvRDgzxlCG8ibiceSGl81ykIM58AejX3nYW5YO5aSTwTsick82Sw/640" ></p>

<p>果然，有值了。小问题的解决方法，分享给大家。</p>

<p>喜欢我们的内容，可以点击右上角「分享到朋友圈」</p>

<p>以后大家有什么问题，可以登录<a href="http://www.iswifting.com">swift社区</a> 里面设置有问答区，会有大牛帮大家解答问题的。</p>

<p>微信公众账号：iOS开发</p>

<pre><code>iOSDevTip
</code></pre>

<p>QQ群：iOS学习交流群</p>

<pre><code>303868520
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发：UITableView加载多张照片导致内存上涨的问题]]></title>
    <link href="http://worldligang.github.io/blog/2014/11/06/ioskai-fa-:uitableviewjia-zai-duo-zhang-zhao-pian-dao-zhi-nei-cun-shang-zhang-de-wen-ti/"/>
    <updated>2014-11-06T10:14:54+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/11/06/ioskai-fa-:uitableviewjia-zai-duo-zhang-zhao-pian-dao-zhi-nei-cun-shang-zhang-de-wen-ti</id>
    <content type="html"><![CDATA[<p><a href="http://www.superqq.com/blog/2014/11/06/ioskai-fa-:uitableviewjia-zai-duo-zhang-zhao-pian-dao-zhi-nei-cun-shang-zhang-de-wen-ti/">iOS开发：UITableView加载多张照片导致内存上涨的问题</a></p>

<p>最近在写一个文件管理的页面，里面功能挺多的，有缩略图下载（socket），有文件下载（http）。</p>

<p>说说缩略图下载这一块，我的UITableView的一个cell要加载四张缩略图，iPhone5s的屏幕能加载8行。大概UI上是这样布局的。（另外缩略图需要一张张下载）</p>

<p>刚开始进到文件管理界面，内存占用20几M，随着缩略图不断下载下来内存在上涨，我不断的往上拉，内存一值在涨。达到一定值app出现闪退。大概是300多M的时候闪退。什么原因造成的呢？</p>

<p>先看下图：</p>

<p><img src="http://www.superqq.com/images/neicun1.jpg" ></p>

<p>我是这样写的：建立一个对象，这个对象有一个属性是UIImage。对象保存在数组里面。大概有800多张照片。</p>

<p>当缩略图没有下载下来的时候，我加载的是一张默认图片。当缩略图下载下来的时候，我就把下载下来的缩略图赋给相应对象的UIImage属性。</p>

<p>cell是重用的，这样看应该是没有什么问题的。但是内存就是不断上涨，而且是不动的时候，内存不涨，上下滑动UITableView，内存不断上涨。</p>

<p>我一直在思考cell是重用的，内存怎么会不断上涨呢？问题不是cell引起的，而是上面我说的那个对象的UIImage属性引起的。</p>

<p>思考一下，缩略图不断下载下来， 下载下来的缩略图都赋给对象的UIImage属性，而对象又在数组里面，可想而知，800多张缩略图不断下载内存肯定上涨。</p>

<p>于是，我去掉对象的UIImage属性，把下载下来的照片通过EGOCache缓存起来，加载cell上的UIImage的时候，直接从缓存里面取出来就可以了。</p>

<p>代码如下：</p>

<pre><code>[[EGOCache globalCache] setImage:image forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[[fmObject.path description] hash]] withTimeoutInterval:CacheingTime];
</code></pre>

<p>再次运行起来，看一下内存这一块：</p>

<p><img src="http://www.superqq.com/images/neicun2.png" ></p>

<p>果然，问题解决了。看来以后给对象加UIImage属性需谨慎啊！</p>

<p>大家有问题可以加入iOS学习交流群：</p>

<pre><code>303868520
</code></pre>

<p>微信公众账号：iOS开发</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods安装和使用教程]]></title>
    <link href="http://worldligang.github.io/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/"/>
    <updated>2014-10-16T13:43:44+08:00</updated>
    <id>http://worldligang.github.io/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng</id>
    <content type="html"><![CDATA[<p><a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods安装和使用教程</a></p>

<p><a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods</a> 是什么？</p>

<p>当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之小编的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。</p>

<p>CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。
如何下载和安装CocoaPods？</p>

<p>在安装CocoaPods之前，首先要在本地安装好Ruby环境。至于如何在Mac中安装好Ruby环境，请google一下，本文不再涉及。</p>

<p>假如你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在Terminator（也就是终端）中输入以下命令（注意，本文所有命令都是在终端中输入并运行的。什么，你不知道什么是终端？那请小编吃饭，小编告诉你）：</p>

<pre><code>sudo gem install cocoapods
</code></pre>

<p>但是，且慢。如果你在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。（你会问，我靠，这都要墙！是的，小编也纳闷。）</p>

<p>但是，是的，又但是（不过是个可喜的“但是”）。我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令：</p>

<pre><code>$ gem sources --remove https://rubygems.org/
//等有反应之后再敲入以下命令
$ gem sources -a http://ruby.taobao.org/
</code></pre>

<p>为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看：</p>

<pre><code>$ gem sources -l
</code></pre>

<p>只有在终端中出现下面文字才表明你上面的命令是成功的：</p>

<pre><code>*** CURRENT SOURCES ***

http://ruby.taobao.org/
</code></pre>

<p>上面所有的命令完成之时，在小编的终端上是这个的样子：</p>

<p><img src="http://code4app.com/photo/5273c20b6803fac658000000_1.png" ></p>

<p>这时候，你再次在终端中运行：</p>

<pre><code>$ sudo gem install cocoapods
</code></pre>

<p>等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。</p>

<p>敲入以上命令时，小编终端上是这个样子的（由于太长，仅截取前面一部分）：</p>

<p><img src="http://code4app.com/photo/5273c20b6803fac658000000_11.png" ></p>

<p>看到这里，你心里会不会说，我靠！太爽了，这么容易就可以下载并且安装好了！是的，小编也是这么想的。CocoPods就是这么简单，使用也十分简单。继续往下看吧。
如何使用CocoaPods？</p>

<p>好了，安装好CocoPods之后，接下来就是使用它。所幸，使用CocoPods和安装它一样简单，也是通过一两行命令就可以搞定。</p>

<p>小编在这里用两种使用场景来具体说明如何使用CocoaPods。
场景1：利用CocoaPods，在项目中导入AFNetworking类库</p>

<p>AFNetworking类库在GitHub地址是：<a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a></p>

<p>为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入：</p>

<pre><code>$ pod search AFNetworking
</code></pre>

<p><img src="http://code4app.com/photo/5273c20b6803fac658000000_12.png" ></p>

<p>这说明，AFNetworking是支持CocoaPods，所以我们可以利用CocoaPods将AFNetworking导入你的项目中。</p>

<p>首先，我们需要在我们的项目中加入CocoaPods的支持。你可以跟随小编的步骤，先利用Xcode创建一个名字CocoaPodsDemo的项目，用于以下的教程。创建好之</p>

<p><img src="http://code4app.com/photo/5273c20b6803fac658000000_13.png" ></p>

<p>上图等一下要跟项目支持CocoaPods之后的项目Xcode目录结构做对比。</p>

<p>你看到这里也许会问，CocoaPods为什么能下载AFNetworking呢，而不是下载其他类库呢？这个问题的答案是，有个文件来控制CocoaPods该下载什么。这个文件就叫做“Podfile”（注意，一定得是这个文件名，而且没有后缀）。你创建一个Podfile文件，然后在里面添加你需要下载的类库，也就是告诉CocoaPods，“某某和某某和某某某，快到碗里来！”。每个项目只需要一个Podfile文件。</p>

<p>好吧，废话少说，我们先创建这个神奇的PodFile。在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行：</p>

<pre><code>$ vim Podfile
</code></pre>

<p>然后在Podfile文件中输入以下文字：</p>

<pre><code>platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0"
</code></pre>

<p>注意，这段文字不是小编凭空生成的，可以在AFNetworking的github页面找到。这两句文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 7.0, 要下载的AFNetworking版本是2.0。</p>

<p>然后保存退出。vim环境下，保存退出命令是：</p>

<p>:wq</p>

<p>这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，Podfile文件应该和你的工程文件.xcodeproj在同一个目录下。</p>

<p>这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令：</p>

<pre><code>$ pod install 
</code></pre>

<p>因为是在你的项目中导入AFNetworking，这就是为什么这个命令需要你进入你的项目所在目录中运行。</p>

<p>运行上述命令之后，小编的终端出现以下信息：</p>

<p>EricmatoMacBook-Pro:CocoaPodsDemo ericwang$ pod install
Analyzing dependencies
Downloading dependencies
Installing AFNetworking (2.0.2)
Generating Pods project
Integrating client project</p>

<p>[!] From now on use <code>CocoaPodsDemo.xcworkspace</code>.</p>

<p>注意最后一句话，意思是：以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。</p>

<p>你也许会郁闷，为什么会出现.xcodeproj文件呢。这正是你刚刚运行$ pod install命令产生的新文件。除了这个文件，你会发现还多了另外一个文件“Podfile.lock”和一个文件夹“Pods”。 点击 CocoaPodsDemo.xcworkspace 打开之后工程之后，项目Xcode目录结构如下图：</p>

<p><img src="http://code4app.com/photo/5273c20b6803fac658000000_14.png" ></p>

<p>你会惊喜地发现，AFNetwoking已经成功导入项目了（红框部分）！</p>

<p>现在，你就可以开始使用AFNetworking.h啦。可以稍微测试一下，在你的项目任意代码文件中输入：</p>

<pre><code>#import &lt;AFNetworking.h&gt;
或者
#import "AFNetworking.h"
</code></pre>

<p>然后编译，看看是否出错。如果你严格按照小编上述的步骤来，是不可能出错的啦。</p>

<p>至此，CocoPods的第一个应用场景讲述完毕。别看小编写了这么多，其实过程是十分简单的。总结一下就是：</p>

<p>1,先在项目中创建Podfile，Podfile的内容是你想导入的类库。一般类库的原作者会告诉你导入该类库应该如何写Podfile；
2,运行命令：`$ pod install.</p>

<p>下面，小编继续讲述第二种使用场景。
场景2：如何正确编译运行一个包含CocoPods类库的项目</p>

<p>你也许曾经遇到过（特别是新手iOS开发者）这种情况，好不容易在GitHub上找到一份代码符合自己想需求，兴冲冲下载下来，一编译，傻眼了，发现有各种各样错误。一看，原来是缺失了各种其他第三方类库。这时候莫慌，你再仔细一看，会发现你下载的代码包含了Podfile。没错，这意味着你可以用CocoaPods很方便下载所需要的类库。</p>

<p>下面，小编以代码 UAAppReviewManager 为例来说明如何正确编译运行一个包含CocoPods类库的项目。</p>

<p>UAAppReviewManager是一个能够让你方便地将提醒用户评分的功能加入你的应用中。当你去UAAppReviewManager的GitHub地址下载这份代码之后，打开Example工程（UAAppReviewManagerExample），编译，你会发现Xcode报告一大堆错误，基本都是说你编译的这份代码找不到某某头文件，这就意味着你要成功编译UAAppReviewManager的Example代码，必须先导入一些第三方类库。同时你会发现在UAAppReviewManagerExample文件夹下面有三个跟CocosPods相关的文件（文件夹）：Podfile，Podfile.lock和Pods，如下图：</p>

<p><img src="http://code4app.com/photo/5273c20b6803fac658000000_15.png" ></p>

<p>用</p>

<p>这时候，打开终端，进入UAAppReviewManagerExample所在的目录，也就是和Podfile在同一目录下，和场景1一样，输入以下命令（由于已经有Podfile，所以不需要再创建Podfile）：</p>

<pre><code>$ pod update
</code></pre>

<p>过几秒（也许需要十几秒，取决于你的网络状况）之后，终端出现：</p>

<pre><code>Analyzing dependencies
Fetching podspec for `UAAppReviewManager` from `../`
Downloading dependencies
Installing UAAppReviewManager (0.1.6)
Generating Pods project
Integrating client project

[!] From now on use `UAAppReviewManagerExample.xcworkspace`.
</code></pre>

<p>这时候，再回到UAAppReviewManagerExample文件夹看一看，会看到多了一个文件UAAppReviewManagerExample.xcworkspace：</p>

<p><img src="http://code4app.com/photo/5273c20b6803fac658000000_16.png" ></p>

<p>根据终端的信息提示，你以后就需用新产生的UAAppReviewManagerExample.xcworkspace来运行这个Example代码了。</p>

<p>打开UAAppReviewManagerExample.xcworkspace，编译运行，成功！如下图：</p>

<p><img src="http://code4app.com/photo/5273c20b6803fac658000000_17.png" ></p>

<p>注意，这里有个小问题，如果刚刚你不是输入$ pod update，而是输入$ pod install，会发现类库导入不成功，并且终端出现下面提示：</p>

<pre><code>[!] Required version (UAAppReviewManager (from `../`)) not found for `UAAppReviewManager`.
</code></pre>

<p>Available versions: 0.1.6</p>

<p>这里的意思大概是Podfile文件过期，类库有升级，但是Podfile没有更改。$ pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是 $ pod update会更新所有的类库，获取最新版本的类库。而且你会发现，如果用了 $ pod update，再用 $ pod install 就成功了。</p>

<p>那你也许会问，什么时候用 $ pod install，什么时候用 $ pod update 呢，我又不知道类库有没有新版本。好吧，那你每次直接用 $ pod update 算了。或者先用 $ pod install，如果不行，再用 $ pod update。</p>

<p>好了，小编就啰嗦到这里吧。上述都只是<a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods</a> 是什么？
的最基本用法。要继续研究CocoaPods其他高级用法.</p>

<p>Code4App 原创文章。转载请注明出处：<a href="http://code4app.com/article/cocoapods-install-usage">http://code4app.com/article/cocoapods-install-usage</a></p>

<p>微信公众账号：iOS开发</p>

<pre><code>iOSDevTip
</code></pre>
]]></content>
  </entry>
  
</feed>
