<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刚刚在线]]></title>
  <link href="http://www.superqq.com/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-08-08T10:53:04+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《招聘一个靠谱的iOS》面试题参考答案（上）]]></title>
    <link href="http://www.superqq.com/blog/2015/08/08/interview-ios-question-answer/"/>
    <updated>2015-08-08T00:16:38+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/08/interview-ios-question-answer</id>
    <content type="html"><![CDATA[<blockquote><p>推荐理由：最近比较🔥的关于iOS开发面试题的文章。简单喵了一眼，感觉很不错，作者sunnyxx也是个大牛。特此推荐！</p></blockquote>

<p><a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/">《招聘一个靠谱的 iOS》</a>—参考答案（上）</p>

<p>说明：面试题来源是<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a>的这篇博文：<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>

<p>出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>

<p>答案为<a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a>指正。</p>

<hr />

<h3>1. 风格纠错题</h3>

<p><img src="http://i.imgur.com/O7Zev94.png" alt="enter image description here" />
修改完的代码：</p>

<p>修改方法有很多种，现给出一种做示例：</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readonly) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<p>下面对具体修改的地方，分两部分做下介绍：<strong><em>硬伤部分</em></strong>和<strong><em>优化部分</em></strong>
。因为<strong><em>硬伤部分</em></strong>没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看<strong><em>优化部分</em></strong>。</p>

<h4><strong><em>优化部分</em></strong></h4>

<ol>
<li><p>enum建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html">Adopting Modern Objective-C</a> 一文：</p>

<p>&#8220;`objective-c
//定义一个枚举
typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 2. age属性的类型：应避免使用基本类型，建议使Foundation数据类型，对应关系如下：
</span><span class='line'> 
</span><span class='line'> ```Objective-C
</span><span class='line'>  int -&gt; NSInteger
</span><span class='line'>  unsigned -&gt; NSUInteger
</span><span class='line'>  float -&gt; CGFloat
</span><span class='line'>  动画时间 -&gt; NSTimeInterval</span></code></pre></td></tr></table></div></figure>


<p>同时考虑到age的特点，应使用NSUInteger，而非int。
这样做的是基于64-bit 适配考虑，详情可参考出题者的博文<a href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/">《64-bit Tips》</a>。</p>

<ol>
<li>如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。</li>
<li>doLogIn方法不应写在该类中：虽然<code>LogIn</code>的命名不太清晰，但笔者猜测是login的意思，而登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：</li>
</ol>


<blockquote><p>无论是MVC模式还是MVVM模式，业务逻辑都不应当写在Model里。</p></blockquote>

<p> （如果抛开命名规范，假设该类真的是MVVM模式里的 ViewModel ，那么UserModel这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如：login对应的应当是注册并登录的一个Button，出现login方法也可能是合理的。）</p>

<ol>
<li>doLogIn方法命名不规范：添加了多余的动词前缀。
请牢记：</li>
</ol>


<blockquote><p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用<code>do</code>，<code>does</code>这种多余的关键字，动词本身的暗示就足够了。
 11. <code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中不要用<code>with</code>来连接两个参数:<code>withAge:</code>应当换为<code>age:</code>，<code>age:</code>已经足以清晰说明参数的作用，也不建议用<code>andAge:</code>：通常情况下，即使有类似<code>withA:withB:</code>的命名需求，也通常是使用<code>withA:andB:</code>这种命名，用来表示方法执行了两个相对独立的操作（<em>从设计上来说，这时候也可以拆分成两个独立的方法</em>），它不应该用作阐明有多个参数，比如下面的：</p></blockquote>

<p>  &#8220;`objective-c
//错误，不要使用&#8221;and&#8221;来连接参数
- (int)runModalForDirectory:(NSString <em>)path andFile:(NSString </em>)name andTypes:(NSArray <em>)fileTypes;
//错误，不要使用&#8221;and&#8221;来阐明有多个参数
- (instancetype)initWithName:(CGFloat)width andAge:(CGFloat)height;
//正确，使用&#8221;and&#8221;来表示两个相对独立的操作
- (BOOL)openFile:(NSString </em>)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'> 12. 由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为copy。(原因在下文有详细论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？***)
</span><span class='line'> 2. “性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？
</span><span class='line'>
</span><span class='line'> Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'> ```Objective-C
</span><span class='line'>
</span><span class='line'>    // .m文件
</span><span class='line'>    // http://weibo.com/luohanchenyilong/
</span><span class='line'>    // https://github.com/ChenYilong
</span><span class='line'>    //
</span><span class='line'>
</span><span class='line'>    @implementation CYLUser
</span><span class='line'>
</span><span class='line'>    - (instancetype)initWithName:(NSString *)name
</span><span class='line'>                             age:(NSUInteger)age
</span><span class='line'>                             sex:(CYLSex)sex {
</span><span class='line'>        if(self = [super init]) {
</span><span class='line'>            _name = [name copy];
</span><span class='line'>            _age = age;
</span><span class='line'>            _sex = sex;
</span><span class='line'>        }
</span><span class='line'>        return self;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    - (instancetype)initWithName:(NSString *)name
</span><span class='line'>                             age:(NSUInteger)age {
</span><span class='line'>        return [self initWithName:name age:age sex:nil];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @end</span></code></pre></td></tr></table></div></figure>


<p> 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。</p>

<p>  因为出题者没有给出.m文件，所以有两种猜测：1：本来打算只设计一个designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为readwrite属性，最终给出的修改代码应该是：</p>

<p> &#8220;`Objective-C</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 第二种修改方法（基于第一种修改方法的基础上）

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readwrite) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>
</span><span class='line'> .h中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳--》 [***《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》***](http://is.gd/OQ49zk)。）
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> 2. 按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为instancetype，为保持一致性，init方法和快捷构造方法的返回类型最好都用instancetype。
</span><span class='line'> 2. 如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:
</span><span class='line'>那么在设计对应@property时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样
</span><span class='line'>
</span><span class='line'>        @property (nonatomic, copy, readonly) NSString *name;
</span><span class='line'>        @property (nonatomic, assign, readonly) NSUInter age;
</span><span class='line'>        @property (nonatomic, assign, readonly) CYLSex sex;
</span><span class='line'>      由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。
</span><span class='line'> 2. `initUserModelWithUserName`如果改为`initWithName`会更加简洁，而且足够清晰。
</span><span class='line'> 2. `UserModel`如果改为`User`会更加简洁，而且足够清晰。
</span><span class='line'> 2. `UserSex`如果改为`Sex`会更加简洁，而且足够清晰。
</span><span class='line'>
</span><span class='line'>####***硬伤部分***
</span><span class='line'>
</span><span class='line'> 1. 在-和(void)之间应该有一个空格
</span><span class='line'> 3. enum中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。
</span><span class='line'> 3. enum左括号前加一个空格，或者将左括号换到下一行
</span><span class='line'> 4. enum右括号后加一个空格
</span><span class='line'> 2. `UserModel :NSObject` 应为`UserModel : NSObject`，也就是`:`右侧少了一个空格。
</span><span class='line'> 2. @interface与@property属性声明中间应当间隔一行。
</span><span class='line'> 2. 两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。
</span><span class='line'> 9. 
</span><span class='line'>  `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;`方法中方法名与参数之间多了空格。而且`-` 与`(id)`之间少了空格。
</span><span class='line'> 10. 
</span><span class='line'>  `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;`方法中方法名与参数之间多了空格：`(NSString*)name`前多了空格。
</span><span class='line'> 10. 
</span><span class='line'>  `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;`方法中`(NSString*)name`,应为`(NSString *)name`，少了空格。 
</span><span class='line'> 7.  doLogIn方法命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。
</span><span class='line'> 2. 第二个@property中assign和nonatomic调换位置。
</span><span class='line'>
</span><span class='line'>###2. 什么情况使用 weak 关键字，相比 assign 有什么不同？
</span><span class='line'>什么情况使用 weak 关键字？
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> 1. 在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性
</span><span class='line'>
</span><span class='line'> 2. 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong。在下文也有论述：***《IBOutlet连出来的视图属性为什么可以被设置成weak?》***
</span><span class='line'>
</span><span class='line'>不同点：
</span><span class='line'> 
</span><span class='line'> 1. `weak` 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，
</span><span class='line'>然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。
</span><span class='line'>而 `assign` 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 
</span><span class='line'>NSlnteger 等)的简单赋值操作。
</span><span class='line'>
</span><span class='line'> 2. assigin 可以用非OC对象,而weak必须用于OC对象
</span><span class='line'>
</span><span class='line'>###3. 怎么用 copy 关键字？
</span><span class='line'>用途：
</span><span class='line'>
</span><span class='line'> 1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
</span><span class='line'> 2. block也经常使用copy关键字，具体原因见[官方文档：***Objects Use Properties to Keep Track of Blocks***](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12)：
</span><span class='line'>
</span><span class='line'> block使用copy是从MRC遗留下来的“传统”,在MRC中,方法内部的block是在栈区的,使用copy可以把它放到堆区.在ARC中写不写都行：对于block使用copy还是strong效果是一样的，但写上copy也无伤大雅，还能时刻提醒我们：编译器自动对block进行了copy操作。
</span><span class='line'>
</span><span class='line'> ![enter image description here](http://i.imgur.com/VlVKl8L.png)
</span><span class='line'>
</span><span class='line'>下面做下解释：
</span><span class='line'>copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
</span><span class='line'>当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&gt; 用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。
</span><span class='line'> 
</span><span class='line'>该问题在下文中也有论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？***
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>###4. 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`
</span><span class='line'>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为copy就是复制一个不可变NSArray的对象；2、使用了atomic属性会严重影响性能 ； 
</span><span class='line'>
</span><span class='line'>第1条的相关原因在下文中有论述***《用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？》*** 以及上文***《怎么用 copy 关键字？》***也有论述。
</span><span class='line'>
</span><span class='line'>比如下面的代码就会发生崩溃
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p>Objective-C
// .h文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 下面的代码就会发生崩溃</p>

<p>@property (nonatomic, copy) NSMutableArray *mutableArray;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C
// .m文件
// <a href="http://weibo.com/luohanchenyilong/">http://weibo.com/luohanchenyilong/</a>
// <a href="https://github.com/ChenYilong">https://github.com/ChenYilong</a>
// 下面的代码就会发生崩溃</p>

<p>NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];
self.mutableArray = array;
[self.mutableArray removeObjectAtIndex:0];</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>接下来就会奔溃：
</span><span class='line'>
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p>Objective-C
 -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>第2条原因，如下：
</span><span class='line'>
</span><span class='line'>&gt; 该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明nonatomic可以节省这些虽然很小但是不必要额外开销。
</span><span class='line'>
</span><span class='line'>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备nonatomic特质，那它就是“原子的”(atomic))。
</span><span class='line'>
</span><span class='line'>在iOS开发中，你会发现，几乎所有属性都声明为nonatomic。
</span><span class='line'>
</span><span class='line'>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。
</span><span class='line'>
</span><span class='line'>因此，开发iOS程序时一般都会使用nonatomic属性。但是在开发Mac OS X程序时，使用
</span><span class='line'>atomic属性通常都不会有性能瓶颈。
</span><span class='line'>
</span><span class='line'>###5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&gt; 若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopyiog与NSMutableCopying协议。
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>具体步骤：
</span><span class='line'>
</span><span class='line'> 1. 需声明该类遵从NSCopying协议
</span><span class='line'> 2. 实现NSCopying协议。该协议只有一个方法: 
</span><span class='line'>
</span><span class='line'> ```Objective-C
</span><span class='line'>- (id)copyWithZone: (NSZone*) zone</span></code></pre></td></tr></table></div></figure>


<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是“copyWithZone”方法。</p>

<p>以第一题的代码为例：</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 修改完的代码

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readonly) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<p>然后实现协议中规定的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">CYLUser</span> <span class="o">*</span><span class="k">copy</span> <span class="o">=</span> <span class="p">[[[</span><span class="nb">self</span> <span class="k">copy</span><span class="p">]</span> <span class="nl">allocWithZone</span><span class="p">:</span><span class="n">zone</span><span class="p">]</span>
</span><span class='line'>                   <span class="nl">initWithName</span><span class="p">:</span><span class="n">_name</span>
</span><span class='line'>                                <span class="nl">age</span><span class="p">:</span><span class="n">_age</span>
</span><span class='line'>                                <span class="nl">sex</span><span class="p">:</span><span class="n">_sex</span><span class="p">];</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如CYLUser中含有一个数组，与其他CYLUser对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 以第一题《风格纠错题》里的代码为例

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readonly) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
- (void)addFriend:(CYLUser *)user;
- (void)removeFriend:(CYLUser *)user;

@end
</code></pre>

<p>// .m文件</p>

<pre><code>// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 

@implementation CYLUser {
    NSMutableSet *_friends;
}

- (void)setName:(NSString *)name {
    _name = [name copy];
}

- (instancetype)initWithName:(NSString *)name 
                             age:(NSUInteger)age 
                             sex:(CYLSex)sex {
     if(self = [super init]) {
        _name = [name copy];
        _age = age;
        _sex = sex;
        _friends = [[NSMutableSet alloc] init];
     }
     return self;
}

- (void)addFriend:(CYLUser *)user {
    [_friends addObject:user];
}

- (void)removeFriend:(CYLUser *)user {
    [_friends removeObject:person];
}

- (id)copyWithZone:(NSZone *)zone {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    copy-&gt;_friends = [_friends mutableCopy];
    return copy;
}

- (id)deepCopy {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends 
                                             copyItems:YES];
    return copy;
}

@end
</code></pre>

<p>以上做法能满足基本的需求，但是也有缺陷：</p>

<blockquote><p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p></blockquote>

<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</em></strong>】</p>

<p>在例子中，存放朋友对象的set是用“copyWithZooe:”方法来拷贝的，这种浅拷贝方式不会逐个复制set中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>

<pre><code>- (id)deepCopy {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends 
                                             copyItems:YES];
    return copy;
}
</code></pre>

<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>

<p>如果抛开本例来回答的话，如下：</p>

<pre><code>- (void)setName:(NSString *)name {
    _name = [name copy];
}
</code></pre>

<p>如果单单就上文的代码而言，我们不需要也不能重写name的 setter ：由于是name是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”&ndash;copy，是因为：如果不写copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效。）。</p>

<p>那如何确保name被copy？在初始化方法(initializer)中做：</p>

<pre><code>- (instancetype)initWithName:(NSString *)name 
                             age:(NSUInteger)age 
                             sex:(CYLSex)sex {
     if(self = [super init]) {
        _name = [name copy];
        _age = age;
        _sex = sex;
        _friends = [[NSMutableSet alloc] init];
     }
     return self;
}
</code></pre>

<h3>6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3>

<p><strong>@property 的本质是什么？</strong></p>

<blockquote><p>@property = ivar + getter + setter;</p></blockquote>

<p>下面解释下：</p>

<blockquote><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p></blockquote>

<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为<code>Objective-C 2.0</code>的一部分。
而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。
正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>

<blockquote><p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。
所以你也可以这么说：</p>

<p>@property = getter + setter;</p></blockquote>

<p>例如下面这个类：</p>

<pre><code>@interface Person : NSObject 
@property NSString *firstName; 
@property NSString *lastName; 
@end 
</code></pre>

<p>上述代码写出来的类与下面这种写法等效：</p>

<pre><code>@interface Person : NSObject 
- (NSString *)firstName; 
- (void)setFirstName:(NSString *)firstName; 
- (NSString *)lastName; 
- (void)setLastName:(NSString *)lastName; 
@end 
</code></pre>

<p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>

<blockquote><p>“自动合成”( autosynthesis)</p></blockquote>

<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”( autosynthesis)。需要强调的是，这个过程由编译
器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为
<code>_firstName</code>与<code>_lastName</code>。也可以在类的实现代码里通过
@synthesize语法来指定实例变量的名字.</p>

<pre><code>@implementation Person 
@synthesize firstName = _myFirstName; 
@synthesize lastName = myLastName; 
@end 
</code></pre>

<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>

<ol>
<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter与getter方法对应的实现函数</li>
<li><code>ivar_list</code> ：成员变量列表</li>
<li><code>method_list</code> ：方法列表</li>
<li><code>prop_list</code> ：属性列表</li>
</ol>


<p>也就是说我们每次在增加一个属性,系统都会在<code>ivar_list</code>中添加一个成员变量的描述,在<code>method_list</code>中增加setter与getter方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出setter与getter方法对应的实现,在setter方法中从偏移量的位置开始赋值,在getter方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>

<h3>7. @protocol 和 category 中如何使用 @property</h3>

<ol>
<li>在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>
<li><p>category 使用 @property 也是只会生成setter和getter方法的声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数：</p></li>
<li><p><code>objc_setAssociatedObject</code></p></li>
<li><code>objc_getAssociatedObject</code></li>
</ol>


<h3>8. runtime 如何实现 weak 属性</h3>

<p>要实现weak属性，首先要搞清楚weak属性的特点：</p>

<blockquote><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<p>那么runtime如何实现weak变量的自动置nil？</p>

<blockquote><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p></blockquote>

<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>

<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>

<p><code>objc_storeWeak</code>函数把第二个参数&ndash;赋值对象（b）的内存地址作为键值key，将第一个参数&ndash;weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>

<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>

<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>

<p>而如果a是由assign修饰的，则：
在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>

<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="c1">// 使用伪代码模拟：runtime如何实现weak属性</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'> <span class="kt">id</span> <span class="n">obj1</span><span class="p">;</span>
</span><span class='line'> <span class="n">objc_initWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="cm">/*obj引用计数变为0，变量作用域结束*/</span>
</span><span class='line'> <span class="n">objc_destroyWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>

<p>总体说来，作用是：
通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>

<p>下面分别介绍下方法的内部实现：</p>

<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="n">obj1</span> <span class="o">=</span> <span class="mi">0</span><span class="err">；</span>
</span><span class='line'><span class="n">obj_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说：</p>

<blockquote><p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p></blockquote>

<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>

<p>前面的源代码与下列源代码相同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="c1">// 使用伪代码模拟：runtime如何实现weak属性</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'><span class="kt">id</span> <span class="n">obj1</span><span class="p">;</span>
</span><span class='line'><span class="n">obj1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="cm">/* ... obj的引用计数变为0，被置nil ... */</span>
</span><span class='line'><span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>objc_storeWeak</code>函数把第二个参数&ndash;赋值对象（obj）的内存地址作为键值，将第一个参数&ndash;weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除，在后面的相关一题会详解。</p>

<p>使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：</p>

<blockquote><p>如何让不使用weak修饰的@property，拥有weak的效果。</p></blockquote>

<p>我们从setter方法入手：</p>

<pre><code>- (void)setObject:(NSObject *)object
{
    objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
    [object cyl_runAtDealloc:^{
        _object = nil;
    }];
}
</code></pre>

<p>也就是有两个步骤：</p>

<ol>
<li><p>在setter方法中做如下设置：</p>

<pre><code>objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
</code></pre></li>
<li><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助runtime：</p></li>
</ol>


<p> &#8220;`Objective-C
//要销毁的目标对象
id objectToBeDeallocated;
//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。
id objectWeWantToBeReleasedWhenThatHappens;
objc_setAssociatedObject(objectToBeDeallocted,
                         someUniqueKey,
                         objectWeWantToBeReleasedWhenThatHappens,
                         OBJC_ASSOCIATION_RETAIN);</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="err">知道了思路，我们就开始实现`</span><span class="n">cyl_runAtDealloc</span><span class="err">`方法，实现过程分两部分：</span>
</span><span class='line'>
</span><span class='line'><span class="err">第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助</span><span class="n">block</span><span class="err">执行“事件”。</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// .h文件</span>
</span><span class='line'>    <span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'>    <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>    <span class="c1">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">voidBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@interface</span> <span class="nc">CYLBlockExecutor</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nl">initWithBlock</span><span class="p">:(</span><span class="n">voidBlock</span><span class="p">)</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// .m文件</span>
</span><span class='line'>    <span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'>    <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>    <span class="c1">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</span>
</span><span class='line'>
</span><span class='line'>    <span class="cp">#import &quot;CYLBlockExecutor.h&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@interface</span> <span class="nc">CYLBlockExecutor</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">voidBlock</span> <span class="n">_block</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">@implementation</span> <span class="nc">CYLBlockExecutor</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nl">initWithBlock</span><span class="p">:(</span><span class="n">voidBlock</span><span class="p">)</span><span class="n">aBlock</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_block</span> <span class="o">=</span> <span class="p">[</span><span class="n">aBlock</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">_block</span> <span class="o">?</span> <span class="n">_block</span><span class="p">()</span> <span class="o">:</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="err">第二部分：核心代码：利用</span><span class="n">runtime</span><span class="err">实现`</span><span class="n">cyl_runAtDealloc</span><span class="err">`方法</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// CYLNSObject+RunAtDealloc.h文件</span>
</span><span class='line'>    <span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'>    <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>    <span class="c1">// 利用runtime实现cyl_runAtDealloc方法</span>
</span><span class='line'>
</span><span class='line'>    <span class="cp">#import &quot;CYLBlockExecutor.h&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">runAtDeallocBlockKey</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">runAtDeallocBlockKey</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@interface</span> <span class="bp">NSObject</span> <span class="nl">(CYLRunAtDealloc)</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">cyl_runAtDealloc</span><span class="p">:(</span><span class="n">voidBlock</span><span class="p">)</span><span class="n">block</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// CYLNSObject+RunAtDealloc.m文件</span>
</span><span class='line'>    <span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'>    <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>    <span class="c1">// 利用runtime实现cyl_runAtDealloc方法</span>
</span><span class='line'>
</span><span class='line'>    <span class="cp">#import &quot;CYLNSObject+RunAtDealloc.h&quot;</span>
</span><span class='line'>    <span class="cp">#import &quot;CYLBlockExecutor.h&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@implementation</span> <span class="bp">NSObject</span> <span class="nl">(CYLRunAtDealloc)</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">cyl_runAtDealloc</span><span class="p">:(</span><span class="n">voidBlock</span><span class="p">)</span><span class="n">block</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CYLBlockExecutor</span> <span class="o">*</span><span class="n">executor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CYLBlockExecutor</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithBlock</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span>
</span><span class='line'>                                     <span class="n">runAtDeallocBlockKey</span><span class="p">,</span>
</span><span class='line'>                                     <span class="n">executor</span><span class="p">,</span>
</span><span class='line'>                                     <span class="n">OBJC_ASSOCIATION_RETAIN</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="err">使用方法：</span>
</span><span class='line'><span class="err">导入</span>
</span><span class='line'>
</span><span class='line'>    <span class="cp">#import &quot;CYLNSObject+RunAtDealloc.h&quot;</span>
</span><span class='line'><span class="err">然后就可以使用了：</span>
</span><span class='line'>
</span><span class='line'>        <span class="bp">NSObject</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">foo</span> <span class="nl">cyl_runAtDealloc</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;正在释放foo!&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">如果对`</span><span class="n">cyl_runAtDealloc</span><span class="err">`的实现原理有兴趣，可以看下这篇博文</span> <span class="p">[</span><span class="o">***</span><span class="n">Fun</span> <span class="n">With</span> <span class="n">the</span> <span class="n">Objective</span><span class="o">-</span><span class="n">C</span> <span class="nl">Runtime</span><span class="p">:</span> <span class="n">Run</span> <span class="n">Code</span> <span class="n">at</span> <span class="n">Deallocation</span> <span class="n">of</span> <span class="n">Any</span> <span class="n">Object</span><span class="o">***</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//stackoverflow.com/a/31560217/3395008)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</span>
</span><span class='line'><span class="err">属性可以拥有的特质分为四类</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">原子性</span><span class="o">---</span><span class="err">`</span><span class="k">nonatomic</span><span class="err">`特质</span>
</span><span class='line'>
</span><span class='line'>    <span class="err">在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性</span><span class="p">(</span><span class="n">atomicity</span><span class="p">)</span><span class="err">。如果属性具备</span><span class="k">nonatomic</span><span class="err">特质，则不使用同步锁。请注意，尽管没有名为“</span><span class="k">atomic</span><span class="err">”的特质</span><span class="p">(</span><span class="err">如果某属性不具备</span><span class="k">nonatomic</span><span class="err">特质，那它就是“原子的”</span> <span class="p">(</span> <span class="k">atomic</span><span class="p">)</span> <span class="p">)</span><span class="err">，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">2.</span> <span class="err">读</span><span class="o">/</span><span class="err">写权限</span><span class="o">---</span><span class="err">`</span><span class="k">readwrite</span><span class="p">(</span><span class="err">读写</span><span class="p">)</span><span class="err">`、`</span><span class="n">readooly</span> <span class="p">(</span><span class="err">只读</span><span class="p">)</span><span class="err">`</span>
</span><span class='line'> <span class="mf">3.</span> <span class="err">内存管理语义</span><span class="o">---</span><span class="err">`</span><span class="k">assign</span><span class="err">`、`</span><span class="k">strong</span><span class="err">`、</span> <span class="err">`</span><span class="k">weak</span><span class="err">`、`</span><span class="k">unsafe_unretained</span><span class="err">`、`</span><span class="k">copy</span><span class="err">`</span>
</span><span class='line'> <span class="mf">4.</span> <span class="err">方法名</span><span class="o">---</span><span class="err">`</span><span class="k">getter</span><span class="o">=&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="err">`</span> <span class="err">、`</span><span class="k">setter</span><span class="o">=&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="err">`</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">`</span><span class="k">getter</span><span class="o">=&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="err">`的样式：</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">getter</span><span class="o">=</span><span class="n">isOn</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">on</span><span class="p">;</span>
</span><span class='line'><span class="err">（</span> <span class="err">`</span><span class="k">setter</span><span class="o">=&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="err">`这种不常用，也不推荐使用。故不在这里给出写法。）</span>
</span><span class='line'> <span class="mf">3.</span> <span class="err">不常用的：`</span><span class="n">nonnull</span><span class="err">`</span><span class="p">,</span><span class="err">`</span><span class="n">null_resettable</span><span class="err">`</span><span class="p">,</span><span class="err">`</span><span class="n">nullable</span><span class="err">`</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###10. weak属性需要在dealloc中置nil么？</span>
</span><span class='line'><span class="err">不需要。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="err">在</span><span class="n">ARC</span><span class="err">环境无论是强指针还是弱指针都无需在</span> <span class="n">dealloc</span> <span class="err">设置为</span> <span class="nb">nil</span> <span class="err">，</span> <span class="n">ARC</span> <span class="err">会自动帮我们处理</span>
</span><span class='line'>
</span><span class='line'><span class="err">即便是编译器不帮我们做这些，</span><span class="k">weak</span><span class="err">也不需要在</span><span class="n">dealloc</span><span class="err">中置</span><span class="nb">nil</span><span class="err">：</span>
</span><span class='line'>
</span><span class='line'><span class="err">正如上文的：</span><span class="o">***</span><span class="n">runtime</span> <span class="err">如何实现</span> <span class="k">weak</span> <span class="err">属性</span><span class="o">***</span> <span class="err">中提到的：</span>
</span><span class='line'>
</span><span class='line'><span class="err">我们模拟下</span><span class="k">weak</span><span class="err">的</span><span class="k">setter</span><span class="err">方法，应该如下：</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setObject</span><span class="p">:(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="s">&quot;object&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_ASSIGN</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">object</span> <span class="nl">cyl_runAtDealloc</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="n">_object</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="err">也即</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="err">在属性所指的对象遭到摧毁时，属性值也会清空</span><span class="p">(</span><span class="nb">nil</span> <span class="k">out</span><span class="p">)</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###11. @synthesize和@dynamic分别有什么作用？</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="k">@property</span><span class="err">有两个对应的词，一个是</span><span class="k">@synthesize</span><span class="err">，一个是</span><span class="k">@dynamic</span><span class="err">。如果</span><span class="k">@synthesize</span><span class="err">和</span><span class="k">@dynamic</span><span class="err">都没写，那么默认的就是`</span><span class="p">@</span><span class="n">syntheszie</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_var</span><span class="p">;</span><span class="err">`</span>
</span><span class='line'> <span class="mf">2.</span> <span class="k">@synthesize</span><span class="err">的语义是如果你没有手动实现</span><span class="k">setter</span><span class="err">方法和</span><span class="k">getter</span><span class="err">方法，那么编译器会自动为你加上这两个方法。</span>
</span><span class='line'> <span class="mf">3.</span> <span class="k">@dynamic</span><span class="err">告诉编译器：属性的</span><span class="k">setter</span><span class="err">与</span><span class="k">getter</span><span class="err">方法由用户自己实现，不自动生成。（当然对于</span><span class="k">readonly</span><span class="err">的属性只需提供</span><span class="k">getter</span><span class="err">即可）。假如一个属性被声明为</span><span class="k">@dynamic</span> <span class="n">var</span><span class="err">，然后你没有提供</span><span class="p">@</span><span class="k">setter</span><span class="err">方法和</span><span class="p">@</span><span class="k">getter</span><span class="err">方法，编译的时候没问题，但是当程序运行到`</span><span class="n">instance</span><span class="p">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">someVar</span><span class="err">`，由于缺</span><span class="k">setter</span><span class="err">方法会导致程序崩溃；或者当运行到</span> <span class="err">`</span><span class="n">someVar</span> <span class="o">=</span> <span class="n">var</span><span class="err">`时，由于缺</span><span class="k">getter</span><span class="err">方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">对应基本数据类型默认关键字是</span>
</span><span class='line'>
</span><span class='line'> <span class="k">atomic</span><span class="p">,</span><span class="k">readwrite</span><span class="p">,</span><span class="k">assign</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">对于普通的</span><span class="n">OC</span><span class="err">对象</span>
</span><span class='line'>
</span><span class='line'> <span class="k">atomic</span><span class="p">,</span><span class="k">readwrite</span><span class="p">,</span><span class="k">strong</span>
</span><span class='line'>
</span><span class='line'><span class="err">参考链接：</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="p">[</span> <span class="o">***</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span> <span class="nl">ARC</span><span class="p">:</span> <span class="k">strong</span> <span class="n">vs</span> <span class="k">retain</span> <span class="n">and</span> <span class="k">weak</span> <span class="n">vs</span> <span class="k">assign</span><span class="o">***</span> <span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//stackoverflow.com/a/15541801/3395008)</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">2.</span> <span class="p">[</span> <span class="o">***</span><span class="n">Variable</span> <span class="n">property</span> <span class="n">attributes</span> <span class="n">or</span> <span class="n">Modifiers</span> <span class="k">in</span> <span class="n">iOS</span><span class="o">***</span> <span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">因为父类指针可以指向子类对象</span><span class="p">,</span><span class="err">使用</span><span class="k">copy</span><span class="err">的目的是为了让本对象的属性不受外界影响</span><span class="p">,</span><span class="err">使用</span><span class="k">copy</span><span class="err">无论给我传入是一个可变对象还是不可对象</span><span class="p">,</span><span class="err">我本身持有的就是一个不可变的副本</span><span class="p">.</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">如果我们使用是</span><span class="k">strong</span><span class="p">,</span><span class="err">那么这个属性就有可能指向一个可变对象</span><span class="p">,</span><span class="err">如果这个可变对象在外部被修改了</span><span class="p">,</span><span class="err">那么会影响该属性</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="k">copy</span><span class="err">此特质所表达的所属关系与</span><span class="k">strong</span><span class="err">类似。然而设置方法并不保留新值，而是将其“拷贝”</span> <span class="p">(</span><span class="k">copy</span><span class="p">)</span><span class="err">。</span>
</span><span class='line'><span class="err">当属性类型为</span><span class="bp">NSString</span><span class="err">时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个</span><span class="bp">NSMutableString</span><span class="err">类的实例。这个类是</span><span class="bp">NSString</span><span class="err">的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”</span> <span class="p">(</span><span class="n">immutable</span><span class="p">)</span><span class="err">的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”</span> <span class="p">(</span><span class="n">mutable</span><span class="p">)</span><span class="err">，就应该在设置新属性值时拷贝一份。</span>
</span><span class='line'>
</span><span class='line'><span class="err">为了理解这种做法，首先要知道，对非集合类对象的</span><span class="k">copy</span><span class="err">操作：</span>
</span><span class='line'>
</span><span class='line'><span class="err">在非集合类对象中：对</span><span class="n">immutable</span><span class="err">对象进行</span><span class="k">copy</span><span class="err">操作，是指针复制，</span><span class="n">mutableCopy</span><span class="err">操作时内容复制；对</span><span class="n">mutable</span><span class="err">对象进行</span><span class="k">copy</span><span class="err">和</span><span class="n">mutableCopy</span><span class="err">都是内容复制。用代码简单表示如下：</span>
</span><span class='line'>
</span><span class='line'> <span class="o">-</span> <span class="p">[</span><span class="n">immutableObject</span> <span class="k">copy</span><span class="p">]</span> <span class="c1">// 浅复制</span>
</span><span class='line'> <span class="o">-</span> <span class="p">[</span><span class="n">immutableObject</span> <span class="n">mutableCopy</span><span class="p">]</span> <span class="c1">//深复制</span>
</span><span class='line'> <span class="o">-</span> <span class="p">[</span><span class="n">mutableObject</span> <span class="k">copy</span><span class="p">]</span> <span class="c1">//深复制</span>
</span><span class='line'> <span class="o">-</span> <span class="p">[</span><span class="n">mutableObject</span> <span class="n">mutableCopy</span><span class="p">]</span> <span class="c1">//深复制</span>
</span><span class='line'>  
</span><span class='line'><span class="err">比如以下代码：</span>
</span><span class='line'>
</span><span class='line'>  <span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableString</span> <span class="nl">stringWithString</span><span class="p">:</span><span class="s">@&quot;origin&quot;</span><span class="p">];</span><span class="c1">//copy</span>
</span><span class='line'>  <span class="bp">NSString</span> <span class="o">*</span><span class="n">stringCopy</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="err">查看内存，会发现</span> <span class="n">string</span><span class="err">、</span><span class="n">stringCopy</span> <span class="err">内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">[</span><span class="n">string</span> <span class="nl">appendString</span><span class="p">:</span><span class="s">@&quot;origion!&quot;</span><span class="p">]</span>
</span><span class='line'><span class="n">stringCopy</span><span class="err">的值也不会因此改变，但是如果不使用</span><span class="k">copy</span><span class="err">，</span><span class="n">stringCopy</span><span class="err">的值就会被改变。</span>
</span><span class='line'>  <span class="err">集合类对象以此类推。</span>
</span><span class='line'><span class="err">所以，</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="err">用</span><span class="k">@property</span><span class="err">声明</span> <span class="bp">NSString</span><span class="err">、</span><span class="bp">NSArray</span><span class="err">、</span><span class="bp">NSDictionary</span> <span class="err">经常使用</span><span class="k">copy</span><span class="err">关键字，是因为他们有对应的可变类型：</span><span class="bp">NSMutableString</span><span class="err">、</span><span class="bp">NSMutableArray</span><span class="err">、</span><span class="bp">NSMutableDictionary</span><span class="err">，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</span>
</span><span class='line'>
</span><span class='line'><span class="err">参考链接：</span><span class="p">[</span><span class="n">iOS</span> <span class="err">集合的深复制与浅复制</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.zybuluo.com/MicroCai/note/50592)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为`_foo`的实例变量，那么还会自动合成新变量么？</span>
</span><span class='line'><span class="err">在回答之前先说明下一个概念：</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="err">实例变量</span> <span class="o">=</span> <span class="err">成员变量</span> <span class="err">＝</span> <span class="n">ivar</span>
</span><span class='line'>
</span><span class='line'><span class="err">这些说法，笔者下文中，可能都会用到，指的是一个东西。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">正如</span>
</span><span class='line'><span class="p">[</span><span class="n">Apple</span><span class="err">官方文档</span> <span class="o">***</span><span class="n">You</span> <span class="n">Can</span> <span class="n">Customize</span> <span class="n">Synthesized</span> <span class="n">Instance</span> <span class="n">Variable</span> <span class="n">Names</span><span class="o">***</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6) 所说：</span>
</span><span class='line'><span class="o">!</span><span class="p">[</span><span class="n">enter</span> <span class="n">image</span> <span class="n">description</span> <span class="n">here</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//i.imgur.com/D6d0zGJ.png)</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”</span><span class="p">(</span> <span class="k">auto</span> <span class="n">synthesis</span><span class="p">)</span><span class="err">。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法”</span> <span class="p">(</span><span class="n">synthesized</span> <span class="n">method</span><span class="p">)</span><span class="err">的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</span>
</span><span class='line'>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C
@interface CYLPerson : NSObject
@property NSString <em>firstName;
@property NSString </em>lastName;
@end</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="err">在上例中，会生成两个实例变量，其名称分别为</span>
</span><span class='line'><span class="err">`</span><span class="n">_firstName</span><span class="err">`与`</span><span class="n">_lastName</span><span class="err">`。也可以在类的实现代码里通过`</span><span class="k">@synthesize</span><span class="err">`语法来指定实例变量的名字</span><span class="o">:</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C
@implementation CYLPerson
@synthesize firstName = <em>myFirstName;
@synthesize lastName = </em>myLastName;
@end</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="err">上述语法会将生成的实例变量命名为`</span><span class="n">_myFirstName</span><span class="err">`与`</span><span class="n">_myLastName</span><span class="err">`，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</span>
</span><span class='line'>
</span><span class='line'><span class="err">总结下</span><span class="k">@synthesize</span><span class="err">合成实例变量的规则，有以下几点：</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">如果指定了成员变量的名称</span><span class="p">,</span><span class="err">会生成一个指定的名称的成员变量</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">2.</span> <span class="err">如果这个成员已经存在了就不再生成了</span><span class="p">.</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">如果是</span> <span class="err">`</span><span class="k">@synthesize</span> <span class="n">foo</span><span class="p">;</span><span class="err">`</span> <span class="err">还会生成一个名称为</span><span class="n">foo</span><span class="err">的成员变量，也就是说：</span>
</span><span class='line'>
</span><span class='line'> <span class="o">&gt;</span> <span class="err">如果没有指定成员变量的名称会自动生成一个属性同名的成员变量</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="mf">2.</span> <span class="err">如果是</span> <span class="err">`</span><span class="k">@synthesize</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">_foo</span><span class="p">;</span><span class="err">`</span> <span class="err">就不会生成成员变量了</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="err">假如</span><span class="n">property</span><span class="err">名为</span><span class="n">foo</span><span class="err">，存在一个名为</span><span class="n">_foo</span><span class="err">的实例变量，那么还会自动合成新变量么？</span>
</span><span class='line'><span class="err">不会。如下图：</span>
</span><span class='line'>
</span><span class='line'><span class="o">!</span><span class="p">[</span><span class="n">enter</span> <span class="n">image</span> <span class="n">description</span> <span class="n">here</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//i.imgur.com/t28ge4W.png)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</span>
</span><span class='line'>
</span><span class='line'><span class="err">回答这个问题前，我们要搞清楚一个问题，什么情况下不会</span><span class="n">autosynthesis</span><span class="err">（自动合成）？</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">同时重写了</span><span class="k">setter</span><span class="err">和</span><span class="k">getter</span><span class="err">时</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">重写了只读属性的</span><span class="k">getter</span><span class="err">时</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">使用了</span><span class="k">@dynamic</span><span class="err">时</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">在</span> <span class="k">@protocol</span> <span class="err">中定义的所有属性</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">在</span> <span class="n">category</span> <span class="err">中定义的所有属性</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">重载的属性</span>
</span><span class='line'>
</span><span class='line'> <span class="err">当你在子类中重载了父类中的属性，你必须</span> <span class="err">使用`</span><span class="k">@synthesize</span><span class="err">`来手动合成</span><span class="n">ivar</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理</span><span class="k">@property</span><span class="err">的所有内容时，你就会尝试通过实现</span><span class="k">@property</span><span class="err">的所有“存取方法”（</span><span class="n">the</span> <span class="n">accessor</span> <span class="n">methods</span><span class="err">）或者使用`</span><span class="k">@dynamic</span><span class="err">`来达到这个目的，这时编译器就会认为你打算手动管理</span><span class="k">@property</span><span class="err">，于是编译器就禁用了</span><span class="n">autosynthesis</span><span class="err">（自动合成）。</span>
</span><span class='line'>
</span><span class='line'><span class="err">因为有了</span><span class="n">autosynthesis</span><span class="err">（自动合成），大部分开发者已经习惯不去手动定义</span><span class="n">ivar</span><span class="err">，而是依赖于</span><span class="n">autosynthesis</span><span class="err">（自动合成），但是一旦你需要使用</span><span class="n">ivar</span><span class="err">，而</span><span class="n">autosynthesis</span><span class="err">（自动合成）又失效了，如果不去手动定义</span><span class="n">ivar</span><span class="err">，那么你就得借助`</span><span class="k">@synthesize</span><span class="err">`来手动合成</span><span class="n">ivar</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">其实，`</span><span class="k">@synthesize</span><span class="err">`语法还有一个应用场景，但是不太建议大家使用：</span>
</span><span class='line'>
</span><span class='line'><span class="err">可以在类的实现代码里通过`</span><span class="k">@synthesize</span><span class="err">`语法来指定实例变量的名字</span><span class="o">:</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C
@implementation CYLPerson
@synthesize firstName = <em>myFirstName;
@synthesize lastName = </em>myLastName;
@end</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="err">上述语法会将生成的实例变量命名为`</span><span class="n">_myFirstName</span><span class="err">`与`</span><span class="n">_myLastName</span><span class="err">`，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">举例说明：应用场景：</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//</span>
</span><span class='line'>  <span class="c1">// .m文件</span>
</span><span class='line'>  <span class="c1">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
</span><span class='line'>  <span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>  <span class="c1">// 打开第14行和第17行中任意一行，就可编译成功</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">@</span><span class="n">import</span> <span class="n">Foundation</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">@interface</span> <span class="nc">CYLObject</span> : <span class="bp">NSObject</span>
</span><span class='line'>  <span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">title</span><span class="p">;</span>
</span><span class='line'>  <span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">@implementation</span> <span class="nc">CYLObject</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//    NSString *_title;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//@synthesize title = _title;</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="n">init</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">_title</span> <span class="o">=</span> <span class="s">@&quot;微博@iOS程序犭袁&quot;</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">title</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">_title</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setTitle</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">title</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_title</span> <span class="o">=</span> <span class="p">[</span><span class="n">title</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">@end</span>
</span><span class='line'><span class="err">结果编译器报错：</span>
</span><span class='line'><span class="o">!</span><span class="p">[</span><span class="n">enter</span> <span class="n">image</span> <span class="n">description</span> <span class="n">here</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//i.imgur.com/fAEGHIo.png)</span>
</span><span class='line'>
</span><span class='line'><span class="err">当你同时重写了</span><span class="k">setter</span><span class="err">和</span><span class="k">getter</span><span class="err">时，系统就不会生成</span><span class="n">ivar</span><span class="err">（实例变量</span><span class="o">/</span><span class="err">成员变量）。这时候有两种选择：</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">要么如第</span><span class="mi">14</span><span class="err">行：手动创建</span><span class="n">ivar</span>
</span><span class='line'> <span class="mf">2.</span> <span class="err">要么如第</span><span class="mi">17</span><span class="err">行：使用`</span><span class="k">@synthesize</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">_foo</span><span class="p">;</span><span class="err">`</span> <span class="err">，关联</span><span class="k">@property</span><span class="err">与</span><span class="n">ivar</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">更多信息，请戳</span><span class="o">-</span> <span class="err">》</span><span class="p">[</span> <span class="o">***</span><span class="n">When</span> <span class="n">should</span> <span class="n">I</span> <span class="n">use</span> <span class="k">@synthesize</span> <span class="n">explicitly</span><span class="o">?***</span> <span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//stackoverflow.com/a/19821816/3395008)</span>
</span><span class='line'><span class="cp">###16. objc中向一个nil对象发送消息将会发生什么？</span>
</span><span class='line'><span class="err">在</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span><span class="err">中向</span><span class="nb">nil</span><span class="err">发送消息是完全有效的——只是在运行时不会有任何作用</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span> <span class="err">如果一个方法返回值是一个对象，那么发送给</span><span class="nb">nil</span><span class="err">的消息将返回</span><span class="mi">0</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span><span class="err">。例如：</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="err">```</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span>
</span><span class='line'><span class="n">Person</span> <span class="o">*</span> <span class="n">motherInlaw</span> <span class="o">=</span> <span class="p">[[</span><span class="n">aPerson</span> <span class="n">spouse</span><span class="p">]</span> <span class="n">mother</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p> 如果spouse对象为nil，那么发送给nil的消息mother也将返回nil。
 2. 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。
 2. 如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0。
 2. 如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。</p>

<p>具体原因如下：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="c1">// runtime.h（类在runtime中的定义）</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">objc_class</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">Class</span> <span class="n">isa</span> <span class="n">OBJC_ISA_AVAILABILITY</span><span class="p">;</span> <span class="c1">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span>
</span><span class='line'>  <span class="cp">#if !__OBJC2__</span>
</span><span class='line'>  <span class="kt">Class</span> <span class="n">super_class</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 父类</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 类名</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">version</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 类的版本信息，默认为0</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">info</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 类信息，供运行期使用的一些位标识</span>
</span><span class='line'>  <span class="kt">long</span> <span class="n">instance_size</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 该类的实例变量大小</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_ivar_list</span> <span class="o">*</span><span class="n">ivars</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 该类的成员变量链表</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_method_list</span> <span class="o">**</span><span class="n">methodLists</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 方法定义的链表</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_cache</span> <span class="o">*</span><span class="n">cache</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">objc_protocol_list</span> <span class="o">*</span><span class="n">protocols</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span> <span class="c1">// 协议链表</span>
</span><span class='line'>  <span class="cp">#endif</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">OBJC2_UNAVAILABLE</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。
那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>

<h3>17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3>

<p>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.如果我没有记错的大概是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="p">((</span><span class="kt">void</span> <span class="p">()(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">obj</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说：</p>

<blockquote><p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p></blockquote>

<h3>18. 什么时候会报unrecognized selector的异常？</h3>

<p>简单来说：</p>

<blockquote><p>当使用某对象上的某个方法,而该对象上没有实现这个方法的时候，
可以通过“消息转发”进行解决。</p></blockquote>

<p>简单的流程如下，在上一题中也提到过：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>

<ol>
<li>Method resolution</li>
</ol>


<p> objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回 YES，那运行时系统就会重新启动一次消息发送的过程，如果 resolve 方法返回 NO ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>

<ol>
<li>Fast forwarding</li>
</ol>


<p> 如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。
这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。
 3. Normal forwarding</p>

<p> 这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>

<h3>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3>

<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li><p>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</p></li>
<li><p>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</p></li>
<li>成员变量的列表,</li>
<li>属性列表,</li>
</ul>


<p> 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>

<p> <img src="http://i.imgur.com/7mJlUj1.png" alt="enter image description here" /></p>

<ul>
<li><p>根对象就是NSobject，它的superclass指针指向nil</p></li>
<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p></li>
</ul>


<p>如图:
<img src="http://i.imgur.com/w6tzFxz.png" alt="enter image description here" /></p>

<h3>20. 一个objc对象的isa的指针指向什么？有什么作用？</h3>

<p>指向他的类对象,从而可以找到对象上的方法</p>

<h3>21. 下面的代码输出什么？</h3>

<pre><code>@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre>

<p><strong>答案：</strong></p>

<p>都输出 Son</p>

<pre><code>NSStringFromClass([self class]) = Son
NSStringFromClass([super class]) = Son
</code></pre>

<p><strong>解惑：</strong></p>

<p>（以下解惑部分摘自<a href="http://weibo.com/junbbcom">微博@Chun_iOS</a>的博文<a href="http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1">刨根问底Objective－C Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)）</p>

<p>这个题目主要是考察关于objc中对 self 和 super 的理解。</p>

<p>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。</p>

<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>

<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>

<p>真的是这样吗？继续看：</p>

<p>使用clang重写命令:</p>

<pre><code>$ clang -rewrite-objc test.m
</code></pre>

<p>发现上述代码被转化为:</p>

<pre><code>NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName("class"))));

NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass("Son")) }, sel_registerName("class"))));
</code></pre>

<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>

<pre><code>id objc_msgSend(id self, SEL op, ...)
</code></pre>

<p>我们把 self 做为第一个参数传递进去。</p>

<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>

<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</code></pre>

<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>

<pre><code>struct objc_super {
   __unsafe_unretained id receiver;
   __unsafe_unretained Class super_class;
};
</code></pre>

<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>

<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>

<p>objc Runtime开源代码对- (Class)class方法的实现:</p>

<pre><code>- (Class)class {
    return object_getClass(self);
}
</code></pre>

<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。
第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。
第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，
此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>

<h3>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3>

<p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>

<h3>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3>

<ul>
<li>在ARC下不需要。</li>
<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>
</ul>


<blockquote><p>无论在MRC下还是ARC下均不需要。</p></blockquote>

<p><a href="https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html"> <strong><em>2011年版本的Apple API 官方文档 - Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="c1">// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放</span>
</span><span class='line'><span class="c1">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
</span><span class='line'><span class="c1">// https://github.com/ChenYilong</span>
</span><span class='line'><span class="c1">// 摘自2011年版本的Apple API 官方文档 - Associative References </span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">char</span> <span class="n">overviewKey</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithObjects</span><span class="p">:</span><span class="s">@&quot;One&quot;</span><span class="p">,</span> <span class="s">@&quot;Two&quot;</span><span class="p">,</span> <span class="s">@&quot;Three&quot;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="c1">// For the purposes of illustration, use initWithFormat: to ensure</span>
</span><span class='line'><span class="c1">// the string can be deallocated</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">overview</span> <span class="o">=</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="s">@&quot;First three numbers&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">objc_setAssociatedObject</span> <span class="p">(</span>
</span><span class='line'>    <span class="n">array</span><span class="p">,</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">overviewKey</span><span class="p">,</span>
</span><span class='line'>    <span class="n">overview</span><span class="p">,</span>
</span><span class='line'>    <span class="n">OBJC_ASSOCIATION_RETAIN</span>
</span><span class='line'><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">overview</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'><span class="c1">// (1) overview valid</span>
</span><span class='line'><span class="p">[</span><span class="n">array</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'><span class="c1">// (2) overview invalid</span>
</span></code></pre></td></tr></table></div></figure>


<p>文档指出</p>

<blockquote><p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p></blockquote>

<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>

<p>既然会被销毁，那么具体在什么时间点？</p>

<blockquote><p>根据<a href="https://developer.apple.com/videos/wwdc/2011/#322-video"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p></blockquote>

<p>对象的内存销毁时间表，分四个步骤：</p>

<pre><code>// 对象的内存销毁时间表
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 

// 1. 调用 -release ：引用计数变为零
//     * 对象正在被销毁，生命周期即将结束.
//     * 不能再有新的 __weak 弱引用， 否则将指向 nil.
//     * 调用 [self dealloc] 
// 2. 父类 调用 -dealloc
//     * 继承关系中最底层的父类 在调用 -dealloc
//     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）
//     * 继承关系中每一层的父类 都在调用 -dealloc
// 3. NSObject 调 -dealloc
//     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法
// 4. 调用 object_dispose()
//     * 为 C++ 的实例变量们（iVars）调用 destructors 
//     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
//     * 解除所有使用 runtime Associate方法关联的对象
//     * 解除所有 __weak 引用
//     * 调用 free()
</code></pre>

<p>（<a href="http://stackoverflow.com/a/10843510/3395008">对象的内存销毁时间表参考链接</a>）</p>

<h3>24. objc中的类方法和实例方法有什么本质区别和联系？</h3>

<p>类方法：</p>

<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ol>


<p>实例方法：</p>

<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>


<h2>下一篇文章将发布在<a href="https://github.com/ChenYilong/iOSInterviewQuestions">这里</a>，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注<a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a></h2>

<p>@property部分主要参考
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2">Apple官方文档：Properties Encapsulate an Object’s Values</a>
runtime部分主要参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html">Apple官方文档：Declared Properties</a></p>

<h3>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3>

<h3>26. runtime如何实现weak变量的自动置nil？</h3>

<h3>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3>

<h3>28. runloop和线程有什么关系？</h3>

<h3>29. runloop的mode作用是什么？</h3>

<h3>30. 以+ scheduledTimerWithTimeInterval&hellip;的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3>

<h3>31. 猜想runloop内部是如何实现的？</h3>

<h3>32. objc使用什么机制管理对象内存？</h3>

<h3>33. ARC通过什么方式帮助开发者管理内存？</h3>

<h3>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3>

<h3>35. <code>BAD_ACCESS</code>在什么情况下出现？</h3>

<h3>36. 苹果是如何实现autoreleasepool的？</h3>

<h3>37. 使用block时什么情况会发生引用循环，如何解决？</h3>

<h3>38. 在block内如何修改block外部变量？</h3>

<h3>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3>

<h3>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3>

<h3>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3>

<h3>42. <code>dispatch_barrier_async</code>的作用是什么？</h3>

<h3>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3>

<h3>44. 以下代码运行结果如何？</h3>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
</code></pre>

<h3>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3>

<h3>46. 如何手动触发一个value的KVO</h3>

<h3>47. 若一个类有实例变量<code>NSString *_foo</code>，调用setValue:forKey:时，可以以foo还是<code>_foo</code>作为key？</h3>

<h3>48. KVC的keyPath中的集合运算符如何使用？</h3>

<h3>49. KVC和KVO的keyPath一定是属性么？</h3>

<h3>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3>

<h3>51. apple用什么方式实现对一个对象的KVO？</h3>

<h3>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3>

<h3>53. IB中User Defined Runtime Attributes如何使用？</h3>

<h3>54. 如何调试<code>BAD_ACCESS</code>错误</h3>

<h3>55. lldb（gdb）常用的调试命令？</h3>

<hr />

<p>Posted by <a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a><br/>
原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">Creative Commons BY-NC-ND 3.0</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现placeholder属性的UITextView]]></title>
    <link href="http://www.superqq.com/blog/2015/08/07/implement-uitextview-placeholder/"/>
    <updated>2015-08-07T00:27:43+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/07/implement-uitextview-placeholder</id>
    <content type="html"><![CDATA[<p>iOS开发微信公众号上的iOS技术文章，都将发布在<a href="http://www.superqq.com/">刚刚在线</a>。所以大家可以到我的网站上查看之前的文章，也可以在底部的精彩文章查看历史文章。</p>

<p>上一篇文章<a href="http://www.superqq.com/blog/2015/08/06/uitextview-placeholder-practice/">UITextView实现placeholder的猥琐做法</a>讲了关于<code>UITextView</code>的<code>placeholder</code>实现原理。大家都一致认为做法比较猥琐。</p>

<p>那么，这一次我将简单的封装一个<code>UITextView</code>。暂且取名叫<code>GGPlaceholderTextView</code>，GG前缀看着有点任性的哈。</p>

<h2>GGPlaceholderTextView简介</h2>

<p><code>GGPlaceholderTextView</code>也是对<code>text</code>操作，具体逻辑如下：</p>

<ol>
<li>继承<code>UITextView</code>，并设置<code>placeholder</code>属性</li>
<li>注册开始编辑和结束编辑通知，然后对<code>text</code>做相应的操作</li>
<li>通过<code>UIApplicationWillTerminateNotification</code>通知，在APP退出的时候移除通知。</li>
</ol>


<p>我把<code>GGPlaceholderTextView</code>写在下面。不过，微信里看代码还是不太方便，我已经把代码push到:<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>。你可以下载下来。</p>

<h2>GGPlaceholderTextView.h</h2>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface GGPlaceholderTextView : UITextView
@property(nonatomic, strong) NSString *placeholder;

@end
</code></pre>

<p>定义<code>placeholder</code>属性，类似于<code>UITextField</code>。</p>

<h2>GGPlaceholderTextView.m</h2>

<pre><code>#import "GGPlaceholderTextView.h"

@implementation GGPlaceholderTextView

- (id)initWithFrame:(CGRect)frame {
    if (self = [super initWithFrame:frame]) {
        [self addObserver];
    }
    return self;
}

- (id)init {
    if (self = [super init]) {
        [self addObserver];
    }
    return self;
}

- (void)setPlaceholder:(NSString *)placeholder
{
    _placeholder = placeholder;
    self.text = placeholder;
    self.textColor = [UIColor grayColor];
}

-(void)addObserver
{
    //注册通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didBeginEditing:) name:UITextViewTextDidBeginEditingNotification object:self];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didEndEditing:) name:UITextViewTextDidEndEditingNotification object:self];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(terminate:) name:UIApplicationWillTerminateNotification object:[UIApplication sharedApplication]];
}

- (void)terminate:(NSNotification *)notification {
    //移除通知
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

- (void)didBeginEditing:(NSNotification *)notification {
    if ([self.text isEqualToString:self.placeholder]) {
        self.text = @"";
        self.textColor = [UIColor blackColor];
    }
}

- (void)didEndEditing:(NSNotification *)notification {
    if (self.text.length&lt;1) {
        self.text = self.placeholder;
        self.textColor = [UIColor grayColor];
    }
}

@end
</code></pre>

<p>以上就是关于<code>GGPlaceholderTextView</code>的实现，如果你有类似需求，直接拿去用吧！具体用法请往下看。</p>

<h2>实践</h2>

<pre><code>GGPlaceholderTextView *textView = [[GGPlaceholderTextView alloc] initWithFrame:CGRectMake(0, 64, SCREEN.width , 200)];
textView.backgroundColor = [UIColor whiteColor];
textView.placeholder = @"关注微信公众号iOS开发：iOSDevTip";
[self.view addSubview:textView];
</code></pre>

<p>经过封装后的<code>GGPlaceholderTextView</code>，使用起来是不是跟<code>UITextField</code>非常相似。当然，我封装的比较简单，github上也有一些朋友封装带<code>placeholder</code>属性的<code>UITextView</code>。比如：TextViewPlaceholder。感兴趣的童鞋可以去试用一下。</p>

<p><strong>广告时间</strong></p>

<p>你的分享就是对我最大的支持，希望你能把iOS开发推荐给你的朋友，不甚感激！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITextView实现placeholder的猥琐做法]]></title>
    <link href="http://www.superqq.com/blog/2015/08/06/uitextview-placeholder-practice/"/>
    <updated>2015-08-06T21:37:38+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/06/uitextview-placeholder-practice</id>
    <content type="html"><![CDATA[<p>我经常写一些<a href="http://www.superqq.com/">iOS开发</a>的小技巧，为了在自己需要的时候能用得上，也希望能对正在看文章的你一些帮助，亦或是引发一些思考。</p>

<p>如果你觉得文章对你有帮助，请多多分享。你身边一定有很多做iOS开发的朋友，希望你能把我的iOS开发：<strong>iOSDevTip</strong>推荐给你的朋友。不甚感激！</p>

<p>我们都知道iOS开发中的<code>UITextField</code>有个<code>placeholder</code>属性，<code>placeholder</code>可以很方便引导用户输入。但是<code>UITextView</code>却没有<code>placeholder</code>属性。</p>

<h2>猥琐法分析</h2>

<p>如何让<code>UITextView</code>也有<code>placeholder</code>功能呢？今天给各位分享一个比较猥琐的做法。思路大概是这样的：</p>

<ol>
<li>把<code>UITextView</code>的<code>text</code>当<code>placeholder</code>使用。</li>
<li>在开始编辑的代理方法里清除<code>placeholder</code>。</li>
<li>在结束编辑的代理方法里在设置<code>placeholder</code>。</li>
</ol>


<h2>实现方法</h2>

<h3>创建UITextView</h3>

<pre><code>UITextView *textViewPlaceholder = [[UITextView alloc] initWithFrame:CGRectMake(20, 70, SCREEN.width - 40, 100)];
textViewPlaceholder.backgroundColor = [UIColor whiteColor];
textViewPlaceholder.text = @"关注微信公众号iOS开发：iOSDevTip";
textViewPlaceholder.textColor = [UIColor grayColor];
textViewPlaceholder.delegate = self;
[self.view addSubview:textViewPlaceholder];
</code></pre>

<p>初始化<code>UITextView</code>，给<code>UITextView</code>的<code>text</code>赋值，并且给<code>UITextView</code>的<code>textColor</code>属性设置成灰色，让其看起来更像<code>placeholder</code>。</p>

<p>别忘了设置<code>UITextView</code>的代理，因为后面我们要用到<code>UITextView</code>的两个代理方法。</p>

<h3>开始编辑的代理方法</h3>

<pre><code>- (void)textViewDidBeginEditing:(UITextView *)textView {

    if ([textView.text isEqualToString:@"关注微信公众号iOS开发：iOSDevTip"]) {
        textView.text = @"";
        textView.textColor = [UIColor blackColor];
    }
}
</code></pre>

<p>在开始编辑的代理方法里面，判断如果是<code>UITextView</code>的<code>text</code>的值是<code>placeholder</code>，那么，就清空<code>text</code>，并且把<code>textColor</code>设置成真正的内容颜色，假设是黑色。</p>

<h3>结束编辑的代理方法</h3>

<pre><code>- (void)textViewDidEndEditing:(UITextView *)textView {
    if (textView.text.length&lt;1) {
        textView.text = @"关注微信公众号iOS开发：iOSDevTip";
        textView.textColor = [UIColor grayColor];
    }
}
</code></pre>

<p>在结束编辑的代理方法里，判断如果<code>UITextView</code>的<code>text</code>值为空，那么，就要把需要设置的<code>placeholder</code>赋值给<code>UITextView</code>的<code>text</code>，并且将<code>textColor</code>属性设置成灰色。</p>

<h2>添加轻击手势</h2>

<pre><code>UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapGesture:)];
tapGesture.numberOfTapsRequired = 1; //点击次数
tapGesture.numberOfTouchesRequired = 1; //点击手指数
[self.view addGestureRecognizer:tapGesture];

//轻击手势触发方法
-(void)tapGesture:(UITapGestureRecognizer *)sender
{
    [self.view endEditing:YES];
}
</code></pre>

<p>至此，就很猥琐的实现了<code>placeholder</code>功能。为了方便测试，我加了一个手势。作用是用键盘消失，这样可以测试结束编辑的时候<code>placeholder</code>会不会显示。demo地址：Demo地址:<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>

<p>添加手势的方法很简单，关于iOS开发中的手势汇总，你可以看这篇文章<a href="http://www.superqq.com/blog/2015/01/14/ioskai-fa-zhi-shou-shi-shi-bie-hui-zong/">iOS开发之手势识别汇总</a>。</p>

<p>我看了网上一些实现<code>UITextView</code>的<code>placeholder</code>功能的更猥琐的做法，在<code>UITextView</code>上面盖一个<code>UILabel</code>，然后在<code>UITextView</code>的代理方法里控制<code>UILabel</code>的值。还有用两个<code>UITextView</code>实现的。</p>

<p>在这里，我只是抛砖引玉，如果你有更好的实现方法欢迎投稿给我：<strong>worldligang@163.com</strong>，下一篇文章，我将会封装一个带有<code>placeholder</code>属性的<code>UITextView</code>，敬请期待！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多个UIImage合并成一个UIImage]]></title>
    <link href="http://www.superqq.com/blog/2015/08/05/multiple-uiimage-merged/"/>
    <updated>2015-08-05T17:43:53+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/05/multiple-uiimage-merged</id>
    <content type="html"><![CDATA[<p>写了两篇关于照片保存的文章：</p>

<ol>
<li><a href="http://www.superqq.com/blog/2015/08/03/ioskai-fa-zhi-bao-cun-zhao-pian-dao-xi-tong-xiang-ce-%28photo-album%29/">iOS开发之保存照片到系统相册（Photo Album）</a></li>
<li><a href="http://www.superqq.com/blog/2015/08/04/save-photo-to-own-album/">iOS开发之保存照片到自己创建的相簿</a></li>
</ol>


<p>介绍了如何将图片保存到系统相册，也可以将照片保存到自己的相簿。里面还介绍了一个第三方<code>ALAssetsLibrary+CustomPhotoAlbum</code>保存照片的方法。</p>

<p>本篇文章将会介绍如何将多个<code>UIImage</code>合并成一个<code>UIImage</code>。听起来似乎有点晕晕乎乎的，这个可以合并吗？答案是肯定的。我们拿两个<code>UIImage</code>来举例。</p>

<h2>创建两个UIImage</h2>

<pre><code>UIImage *image1 = [UIImage imageNamed:@"iOSDevTip"];
UIImage *image2 = [UIImage imageNamed:@"CodePush"];
</code></pre>

<p>创建<code>UIImage</code>的方法有很多种，我们就简单的通过<code>imageNamed:</code>方法来创建。</p>

<h2>合并之后的size</h2>

<pre><code>CGSize size = CGSizeMake(image1.size.width + image2.size.width, image1.size.height);
</code></pre>

<p>合并两个<code>UIImage</code>，需要计算合并之后的<code>size</code>。假设这两个<code>UIImage</code>的高度是是相同的，把他们的宽度相加，得到合并之后的<code>UIImage</code>的<code>size</code>。</p>

<h2>合并方法</h2>

<p>有了<code>UIImage</code>和<code>size</code>接下来就是把两个<code>UIImage</code>合并，方法如下：</p>

<pre><code> UIGraphicsBeginImageContext(size);
[image1 drawInRect:CGRectMake(0, 0, image1.size.width, size.height)];
[image2 drawInRect:CGRectMake(image1.size.width, 0, image2.size.width, size.height)];
UIImage *togetherImage = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
</code></pre>

<p>通过上述的代码，就可以实现两个<code>UIImage</code>的合并。` 这个小功能还挺有用的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之保存照片到自己创建的相簿]]></title>
    <link href="http://www.superqq.com/blog/2015/08/04/save-photo-to-own-album/"/>
    <updated>2015-08-04T22:41:08+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/04/save-photo-to-own-album</id>
    <content type="html"><![CDATA[<p>在<a href="http://www.superqq.com/">刚刚在线</a>上一篇文章<a href="http://www.superqq.com/blog/2015/08/03/ioskai-fa-zhi-bao-cun-zhao-pian-dao-xi-tong-xiang-ce-%28photo-album%29/">iOS开发之保存照片到系统相册（Photo Album）</a>，我们讲到了如何保持照片系统相册。还有其他保存的方法吗？</p>

<p>保存照片还可以用<code>ALAssetsLibrary</code>，<code>ALAssetsLibrary</code>提供了我们对iOS设备中的相片、视频的访问，是连接应用程序和相册之间访问的一个桥梁。</p>

<p>接下来，我们来详细讲解一下关于系统相册权限获取、保存照片、创建自己的相簿等等功能。</p>

<h2>创建自己的相簿</h2>

<p>这也是一种比较创建的作法，创建自己的相簿，然后把照片或者视频保存到自己的相簿中。相关代码如下：</p>

<pre><code>  ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
[library addAssetsGroupAlbumWithName:@"test" resultBlock:^(ALAssetsGroup *group) {

    //创建相簿成功

} failureBlock:^(NSError *error) {
    //失败
}];
</code></pre>

<h2>保存照片</h2>

<p>这个方法也是将照片保存到系统相簿里面，不是保存到自己创建的相簿里面。代码如下：</p>

<pre><code> ALAssetsLibrary *library = [[ALAssetsLibrary alloc]init];
[library writeImageToSavedPhotosAlbum:image.CGImage orientation:(ALAssetOrientation)image.imageOrientation completionBlock:^(NSURL *asSetUrl,NSError *error){
    if (error) {
       //失败
    }else{
        UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"存储成功"
                                                       message:nil
                                                      delegate:nil
                                             cancelButtonTitle:@"确定"
                                             otherButtonTitles:nil, nil];
        [alert show];

    }
}];
</code></pre>

<h2>获取权限</h2>

<p>在保存照片之前，如果用户关闭相册权限，这个时候是保存失败的。如果你不做任何处理，用户是不会知道自己保存失败了。所以，我们可以在保存照片之前，做出相应的提示。如何获取这个权限呢？一般有两种方法：</p>

<ol>
<li><p>创建相簿失败</p></li>
<li><p>保存照片失败</p></li>
</ol>


<p>在上面两个方法<strong>创建自己的相簿</strong>和<strong>保存照片</strong>的失败结果里，我们可以弹出获取照片权限失败的提示。我们拿第一个创建相簿失败来举例：</p>

<pre><code>ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
[library addAssetsGroupAlbumWithName:@"test" resultBlock:^(ALAssetsGroup *group)    {

      //创建相簿成功

} failureBlock:^(NSError *error) {
    UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"存储失败"
                                                       message:@"请打开 设置-隐私-照片 来进行设置"
                                                      delegate:nil
                                             cancelButtonTitle:@"确定"
                                             otherButtonTitles:nil, nil];
    [alert show];
}];
</code></pre>

<p>在保存照片失败的结果里，我们也可以弹出相应的提示，让用户打开应用程序的相册权限。</p>

<h2>保存照片到自己的相簿</h2>

<p>下面这段代码是在大谷歌里面找到的，亲自测试过是可以用的，整理如下：</p>

<pre><code>#pragma mark - 创建相册
- (void)createAlbum
{
    ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];
    NSMutableArray *groups=[[NSMutableArray alloc]init];
    ALAssetsLibraryGroupsEnumerationResultsBlock listGroupBlock = ^(ALAssetsGroup *group, BOOL *stop)
    {
        if (group)
        {
            [groups addObject:group];
        }

        else
        {
            BOOL haveHDRGroup = NO;

            for (ALAssetsGroup *gp in groups)
            {
                NSString *name =[gp valueForProperty:ALAssetsGroupPropertyName];

                if ([name isEqualToString:@"iOSDevTip"])
                {
                    haveHDRGroup = YES;
                }
            }

            if (!haveHDRGroup)
            {
                //do add a group named "XXXX"
                [assetsLibrary addAssetsGroupAlbumWithName:@"iOSDevTip"
                                               resultBlock:^(ALAssetsGroup *group)
                 {
                     [groups addObject:group];

                 }
                                              failureBlock:nil];
                haveHDRGroup = YES;
            }
        }

    };
    //创建相簿
    [assetsLibrary enumerateGroupsWithTypes:ALAssetsGroupAlbum usingBlock:listGroupBlock failureBlock:nil];

    [self saveToAlbumWithMetadata:nil imageData:UIImagePNGRepresentation(self.image) customAlbumName:@"iOSDevTip" completionBlock:^
     {
         //这里可以创建添加成功的方法

     }
                     failureBlock:^(NSError *error)
     {
         //处理添加失败的方法显示alert让它回到主线程执行，不然那个框框死活不肯弹出来
         dispatch_async(dispatch_get_main_queue(), ^{

             //添加失败一般是由用户不允许应用访问相册造成的，这边可以取出这种情况加以判断一下
             if([error.localizedDescription rangeOfString:@"User denied access"].location != NSNotFound ||[error.localizedDescription rangeOfString:@"用户拒绝访问"].location!=NSNotFound){
                 UIAlertView *alert=[[UIAlertView alloc]initWithTitle:error.localizedDescription message:error.localizedFailureReason delegate:nil cancelButtonTitle:NSLocalizedString(@"ok", nil) otherButtonTitles: nil];

                 [alert show];
             }
         });
     }];
}

- (void)saveToAlbumWithMetadata:(NSDictionary *)metadata
                      imageData:(NSData *)imageData
                customAlbumName:(NSString *)customAlbumName
                completionBlock:(void (^)(void))completionBlock
                   failureBlock:(void (^)(NSError *error))failureBlock
{

    ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];
    __weak ALAssetsLibrary *weakSelf = assetsLibrary;
    void (^AddAsset)(ALAssetsLibrary *, NSURL *) = ^(ALAssetsLibrary *assetsLibrary, NSURL *assetURL) {
        [assetsLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
            [assetsLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {

                if ([[group valueForProperty:ALAssetsGroupPropertyName] isEqualToString:customAlbumName]) {
                    [group addAsset:asset];
                    if (completionBlock) {
                        completionBlock();
                    }
                }
            } failureBlock:^(NSError *error) {
                if (failureBlock) {
                    failureBlock(error);
                }
            }];
        } failureBlock:^(NSError *error) {
            if (failureBlock) {
                failureBlock(error);
            }
        }];
    };
    [assetsLibrary writeImageDataToSavedPhotosAlbum:imageData metadata:metadata completionBlock:^(NSURL *assetURL, NSError *error) {
        if (customAlbumName) {
            [assetsLibrary addAssetsGroupAlbumWithName:customAlbumName resultBlock:^(ALAssetsGroup *group) {
                if (group) {
                    [weakSelf assetForURL:assetURL resultBlock:^(ALAsset *asset) {
                        [group addAsset:asset];
                        if (completionBlock) {
                            completionBlock();
                        }
                    } failureBlock:^(NSError *error) {
                        if (failureBlock) {
                            failureBlock(error);
                        }
                    }];
                } else {
                    AddAsset(weakSelf, assetURL);
                }
            } failureBlock:^(NSError *error) {
                AddAsset(weakSelf, assetURL);
            }];
        } else {
            if (completionBlock) {
                completionBlock();
            }
        }
    }];
}
</code></pre>

<h2>ALAssetsLibrary+CustomPhotoAlbum保存照片</h2>

<p><code>github</code>上有一个项目<a href="https://github.com/Kjuly/ALAssetsLibrary-CustomPhotoAlbum">ALAssetsLibrary+CustomPhotoAlbum</a>，讲保存照片做了很好的封装。使用之前记得先导入头文件：</p>

<pre><code>#import "ALAssetsLibrary+CustomPhotoAlbum.h"
</code></pre>

<p>保存照片到自己的相簿，直接调用：</p>

<pre><code>ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
[library saveImage:self.image toAlbum:@"gang" completion:^(NSURL *assetURL, NSError *error) {
    if (!error) {

    }
} failure:^(NSError *error) {

}];
</code></pre>

<p><code>ALAssetsLibrary+CustomPhotoAlbum</code>对保存视频的封装也是非常好的。我现在项目中用的也是这个第三方来保存照片和视频。因为不错，所以推荐给大家使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之保存照片到系统相册（Photo Album）]]></title>
    <link href="http://www.superqq.com/blog/2015/08/03/ioskai-fa-zhi-bao-cun-zhao-pian-dao-xi-tong-xiang-ce-(photo-album)/"/>
    <updated>2015-08-03T21:43:34+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/03/ioskai-fa-zhi-bao-cun-zhao-pian-dao-xi-tong-xiang-ce-(photo-album)</id>
    <content type="html"><![CDATA[<p>保存照片到系统相册这个功能很多社交类的APP都有的，今天我们简单讲解一下，如何将图片保存到系统相册（Photo Album）。</p>

<h2>创建UIImageView</h2>

<p>创建<code>UIImageView</code>是为了将照片展示出来，我们是要把<code>UIImage</code>保存到系统相册（Photo Album）:</p>

<pre><code>#define SCREEN [UIScreen mainScreen].bounds.size

self.image = [UIImage imageNamed:@"iOSDevTip"];
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake((SCREEN.width - 300) / 2, 70, 300, 150)];
imageView.image = self.image;
[self.view addSubview:imageView];
</code></pre>

<h2>创建UIButton</h2>

<p>创建<code>UIButton</code>并绑定<code>actionClick:</code>事件:</p>

<pre><code>UIButton *button = [[UIButton alloc] init];
button.frame = CGRectMake( 100, 300, SCREEN.width - 200, 40);
[button addTarget:self action:@selector(actionClick:) forControlEvents:UIControlEventTouchUpInside];
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
[button setBackgroundColor:[UIColor orangeColor]];
[button setTitle:@"SavePhoto" forState:UIControlStateNormal];
[self.view addSubview:button];


- (void)actionClick:(UIButton *)button
{

}
</code></pre>

<h2>保存照片到系统相册（Photo Album）</h2>

<p>在<code>actionClick:</code>方法里调用：</p>

<pre><code>UIImageWriteToSavedPhotosAlbum(self.image, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL);
</code></pre>

<p>这个时候，我们想知道保存是否成功，所以需要制定回调方法</p>

<pre><code>// 指定回调方法
- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo
{
    if(!error){
        NSLog(@"save success");
    }else{
        NSLog(@"save failed");
    }
}
</code></pre>

<p>在这个方法里，我们就知道照片是否保存成功。然后，根据需求来刷新UI线程。用户第一次使用APP的时候，点击<code>SavePhoto</code>按钮的时候，系统会询问权限：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/46869740F32868C1F9769ED5FED1C7D0.png" alt="photo" /></p>

<p>Demo地址:<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a> 下一篇文章，将会讲如何创建自己的相册并保存照片。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义导航按钮UIBarButtonItem]]></title>
    <link href="http://www.superqq.com/blog/2015/08/02/custom-navigation-button-uibarbuttonitem/"/>
    <updated>2015-08-02T00:13:14+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/02/custom-navigation-button-uibarbuttonitem</id>
    <content type="html"><![CDATA[<p>基本上每个iOS APP里面都有导航，比如微信、QQ、支付宝。导航可以很方便地帮助我们管理视图控制器（UIViewController）。导航的重要性不言而喻，基本上是每一位iOS初学者都要接触到的问题。</p>

<p>iOS系统导航栏中有<code>leftBarButtonItem</code>和<code>rightBarButtonItem</code>，我们可以根据自己的需求来自定义这两个<code>UIBarButtonItem</code>。</p>

<h2>四种创建方法</h2>

<p>系统提供了四种创建的方法：</p>

<pre><code>- (instancetype)initWithBarButtonSystemItem:(UIBarButtonSystemItem)systemItem target:(id)target action:(SEL)action;


- (instancetype)initWithImage:(UIImage *)image style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;


- (instancetype)initWithTitle:(NSString *)title style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;

- (instancetype)initWithBarButtonSystemItem:(UIBarButtonSystemItem)systemItem target:(id)target action:(SEL)action;

- (instancetype)initWithCustomView:(UIView *)customView;
</code></pre>

<h3>通过系统UIBarButtonSystemItem创建</h3>

<p>自定义<code>rightBarButtonItem</code>，代码如下：</p>

<pre><code>self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone target:self action:@selector(right:)];
</code></pre>

<p>UIBarButtonSystemItem有以下样式可以供选择：</p>

<pre><code>typedef NS_ENUM(NSInteger, UIBarButtonSystemItem) {
    UIBarButtonSystemItemDone,
    UIBarButtonSystemItemCancel,
    UIBarButtonSystemItemEdit,  
    UIBarButtonSystemItemSave,  
    UIBarButtonSystemItemAdd,
    UIBarButtonSystemItemFlexibleSpace,
    UIBarButtonSystemItemFixedSpace,
    UIBarButtonSystemItemCompose,
    UIBarButtonSystemItemReply,
    UIBarButtonSystemItemAction,
    UIBarButtonSystemItemOrganize,
    UIBarButtonSystemItemBookmarks,
    UIBarButtonSystemItemSearch,
    UIBarButtonSystemItemRefresh,
    UIBarButtonSystemItemStop,
    UIBarButtonSystemItemCamera,
    UIBarButtonSystemItemTrash,
    UIBarButtonSystemItemPlay,
    UIBarButtonSystemItemPause,
    UIBarButtonSystemItemRewind,
    UIBarButtonSystemItemFastForward,
#if __IPHONE_3_0 &lt;= __IPHONE_OS_VERSION_MAX_ALLOWED
    UIBarButtonSystemItemUndo,
    UIBarButtonSystemItemRedo,
#endif
#if __IPHONE_4_0 &lt;= __IPHONE_OS_VERSION_MAX_ALLOWED
    UIBarButtonSystemItemPageCurl,
#endif
};
</code></pre>

<p>最后别忘了实现<code>right:</code>方法：</p>

<pre><code>- (void)right:(id)sender
{
    NSLog(@"rightBarButtonItem");
}
</code></pre>

<h3>自定义文字的UIBarButtonItem</h3>

<p>在文章<a href="http://www.superqq.com/blog/2015/07/30/six-tips-on-navigation-bar/">关于导航栏的六个小技巧</a>的第五个技巧里面有自定义<code>rightBarButtonItem</code></p>

<pre><code>self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"back" style:UIBarButtonItemStylePlain target:self action:@selector(back:)];
</code></pre>

<p>UIBarButtonItemStyle有以下三种选择：</p>

<pre><code>typedef NS_ENUM(NSInteger, UIBarButtonItemStyle) {
    UIBarButtonItemStylePlain,
    UIBarButtonItemStyleBordered NS_ENUM_DEPRECATED_IOS(2_0, 8_0, "Use UIBarButtonItemStylePlain when minimum deployment target is iOS7 or later"),
    UIBarButtonItemStyleDone,
};
</code></pre>

<p>实现<code>back:</code>方法：</p>

<pre><code>- (void)back:(id)sender
{
    [self.navigationController popViewControllerAnimated:YES];
}
</code></pre>

<h3>自定义照片的UIBarButtonItem</h3>

<pre><code>self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithImage:[UIImage imageNamed:@"test"] style:UIBarButtonItemStylePlain target:self action:@selector(right:)];
</code></pre>

<h3>自定义UIView的UIBarButtonItem</h3>

<p>自定义<code>UIView</code>，然后通过<code>initWithCustomView:</code>方法来创建<code>UIBarButtonItem</code>。</p>

<pre><code>UIView *testView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 40, 60)];
self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:testView];
</code></pre>

<p>看到有朋友在后台提问：</p>

<pre><code>刚哥，我现在即需要改那个导航原生的返回图片，也要改返回文字，应该怎么改呢，求指教。
</code></pre>

<p>其实，这个就可以用<code>initWithCustomView:</code>来解决，自定义<code>UIView</code>你可以放<code>UIImageView</code>和<code>UILabel</code>。可以自定义<code>UIView</code>，那么想怎么定义都是可以的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《大圣归来》和《捉妖记》第一次购票看电影]]></title>
    <link href="http://www.superqq.com/blog/2015/08/02/first-watch-movie/"/>
    <updated>2015-08-02T00:03:54+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/02/first-watch-movie</id>
    <content type="html"><![CDATA[<p>这个周末，你看电影了吗？</p>

<p>说来惭愧，我很少去电影院看电影。第一次是妹妹买票送给我看的，看的是《撒娇的女人最好命》。第二次是公司领导请我们一起看的，看的是《煎饼侠》。</p>

<p>说实话，电影院里看电影就是跟手机上看感觉不一样。在电影院里，很多人坐在一起看电影有氛围，还是大屏幕带来的视觉感。而手机还是显得比较low。</p>

<h2>第一次购票看电影</h2>

<p>这个周六和老婆一起到电影院看了两场电影，分别是《大圣归来》和《捉妖记》。两部电影拍的都不错，好像也是最近比较热播的两部电影。</p>

<p>截至7月30日，《大圣归来》票房突破7.2亿元，打破《功夫熊猫2》保持4年的动画票房纪录，“登顶”中国动画电影票房总冠军。</p>

<p>电影《捉妖记》上映17天，票房破17亿，再创华语票房新记录！此前《捉妖记》票房突破十五亿大关，超越《复仇者联盟2》成为内地影史票房第三高的影片。</p>

<p>既然是热播电影，肯定会有它火的原因在里面。我不是个电影迷，所以我也无法为大家推荐好的电影。</p>

<p>这是我第一次自己购票看电影还是不便宜的，花了我近两百元。我以前一直以为电影票就10元一张呢，搞不好还给你打个折。看来都是我想多了。</p>

<p>这一次亲自购票经历，让我发现一个比较优惠的APP，叫猫眼电影，以后买电影票可以在这上面买。票价相对较便宜，我对比了一下，比其他几个知名app都要便宜。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为刚刚在线（Octopress）添加多说评论系统]]></title>
    <link href="http://www.superqq.com/blog/2015/08/01/octopress-add-duoshuo/"/>
    <updated>2015-08-01T01:04:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/01/octopress-add-duoshuo</id>
    <content type="html"><![CDATA[<blockquote><p>今天是八一建军节，中国人民解放军建军纪念日。心里不由自主地升起一份爱国之情。</p></blockquote>

<p>我的网站<a href="http://www.superqq.com/">刚刚在线</a>去年九月份正式上线的，马上快一周年啦！作为一个技术型的博客网站，<a href="http://www.superqq.com/">刚刚在线</a>成长速度还是蛮快的。</p>

<h2>刚刚在线排名</h2>

<p>特别是最近一段时间，我一直在关注<a href="http://www.superqq.com/">刚刚在线</a>的排名，每天的进步速度非常快。这也是我持续更新的结果，百度对持续更新的网站是非常友好的。</p>

<p>我用Alexa的插件看了一下<a href="http://www.superqq.com/">刚刚在线</a>的排名，全球排名：<strong>240334</strong> ， 中国区排名：<strong>14665</strong> 。我特意截了一张图给大家看一看：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/superqqalexa.jpg" alt="superqqalexa.jpg" /></p>

<p>路漫漫其修远兮，吾将上下而求索。要想取得更好的成就，仍需努力！<a href="http://www.superqq.com/">刚刚在线</a>一直有一个问题困惑着我。就是在火狐浏览器中，文章底部评论模块会出现错乱。</p>

<h2>火狐评论版块错乱修复</h2>

<p><a href="http://www.superqq.com/">刚刚在线</a>的评论模块用的是友言。也挺奇怪的，在其他浏览器中就好好的，唯独在火狐浏览器了会出现错乱。我知道这个问题的存在，已有一些访客反应过这个问题。但是，我一直没有找到原因。</p>

<p>估计iOS开发者用火狐浏览器的人肯定不少，这个错乱问题一直在这里的话，肯定会给访客留下不好的印象。所以得尽早解决这个问题。</p>

<p>既然找不到解决错乱的方法，就把友言给替换掉吧。百度搜了一下，发现国内的还有多说，评论功能还是挺不错的。我也看到很多网站在用多说。</p>

<h2>把友言替换成多说</h2>

<p>说换就换，多说（ **<a href="http://duoshuo.com/**">http://duoshuo.com/**</a> ）接入流程也不复杂。网上有很多教程，我简单说一下我是如何操作的。</p>

<h3>1.获取站点的short_name</h3>

<p>到多说的官网注册账号，并且添加你的站点。<code>short_name</code>就是添加站点的时候的多说域名框里填写的。添加站点流程如下：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/duoshuozhuce.jpg" alt="duoshuozhuce.jpg" /></p>

<h3>2.配置_config.yml</h3>

<p>在 <code>_config.yml</code> 中添加</p>

<pre><code># duoshuo comments
duoshuo_comments: true
duoshuo_short_name: superqq
</code></pre>

<p>具体配置方法请看点击<a href="http://blog.csdn.net/iosdevtip/article/details/47179709"> 为 Octopress 添加多说评论系统 </a></p>

<p>ok，经过上面五小步就可以实现接入多说评论版块啦。迫不及待地想看看问题有没有解决，下过如何？赶紧部署上去，我简单的测试了一下。你可以点击<a href="http://www.superqq.com/">刚刚在线</a>，看看实现效果：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/duoshuocomment.jpg" alt="duoshuocomment.jpg" /></p>

<h2>网站有评论必回复噢</h2>

<p>既然网站评论已经成功接入，大家以后有什么问题，或者需要交流的可以直接在网站上评论。虽然，每天有很多少要做，但是我依然会抽出时间来看看大家提的评论，一起探讨，一起成长。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AKTabBarController：类似微信的第三方库]]></title>
    <link href="http://www.superqq.com/blog/2015/07/31/aktabbarcontroller-similar-to-wechat-library/"/>
    <updated>2015-07-31T00:28:53+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/31/aktabbarcontroller-similar-to-wechat-library</id>
    <content type="html"><![CDATA[<p>自从有了评论之后，就可以很方便的和大家交流。以前都是我一个人默默的发文章，看不出大家对文章的看法。评论开通之后，就可以很快速的获取大家对文章的看法。</p>

<p>有人会指出文章里有错误的地方，真的很感激他们，非常的认真；有人会对文章说出自己的见解，加深自己的印象，同时，也能帮助到其他的朋友；有人也会在评论里，提出一些问题，但是鉴于评论的字数限制，只能简单的回答一下。</p>

<p>在昨天的文章评论里面，有一个朋友提出了一个问题，关于微信导航栏的。</p>

<h2>问题分析和解答</h2>

<p><strong>问：</strong></p>

<pre><code>自定义导航栏怎么写？就像微信那样，tabBar的四个界面切换导航栏都不变化
</code></pre>

<p><strong>答：</strong></p>

<pre><code>github上搜索AKTabBarController
</code></pre>

<p>其实，这位朋友的问题不是关于自定义导航栏，我觉得他可能是想问微信底部的<code>TabBar</code>和导航结合使用是如何实现的。</p>

<p>记得之前在github看到过有一个类似微信的框架（算不上框架，我们就这么简单的叫一下）。就是<a href="https://github.com/alikaragoz/AKTabBarController">AKTabBarController</a>。</p>

<p><code>AKTabBarController</code>是一个非常不错的第三方。在github上有663个<code>star</code>，使用方法也不是很复杂，下面我们简单的看一下。</p>

<h2>如何导入到项目中</h2>

<p><code>AKTabBarController</code>是支持<a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods</a>导入的。想理解CocoaPods的请点击：<a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods安装和使用教程</a>。在你的Podfile文件中加入：</p>

<pre><code>platform :ios

pod 'AKTabBarController'
</code></pre>

<p>添加成功之后，在终端执行：</p>

<pre><code>pod install 
</code></pre>

<h2>如何使用AKTabBarController</h2>

<p>安装成功之后，在你想用的地方导入头文件：</p>

<pre><code>#import "AKTabBarController.h"
</code></pre>

<p>然后，创建<code>tabBar</code></p>

<pre><code>// Create and initialize the height of the tab bar to 50px.
_tabBarController = [[AKTabBarController alloc] initWithTabBarHeight:50];

// Create and initialize with specific height and position atop the view controller
_tabBarController = [[AKTabBarController alloc] initWithTabBarHeight:50 position:AKTabBarPositionTop];

// Adding the view controllers to manage.
[_tabBarController setViewControllers:@[[[FirstViewController alloc] init], [[SecondViewController alloc] init], [[ThirdViewController alloc] init], [[FourthViewController alloc] init]]]];  
</code></pre>

<p>关于更多AKTabBarController的用法，请访问：**<a href="https://github.com/alikaragoz/AKTabBarController**">https://github.com/alikaragoz/AKTabBarController**</a></p>

<h2>功能简介</h2>

<pre><code>• 自适应竖屏和横屏模式，tab 上的图标会根据竖屏和横屏模式自动缩放大小以适应tab的高度。

• 自定义 tab bar 的高度；

• 当进入下个视图时，可以自动隐藏tab bar；

• 可以只显示图片，而不显示文字；并且当 tab bar 的高度太小时，可以自动缩放图片以及隐藏文字；

• 只需要一张图片来表示 tab 被选择和非选择模式。即tab 被选中时的高光是用CoreGraphics绘制的，不需要额外的图片。

• 选择不同 tab 时的动画切换效果用的是淡入淡出（cross fade）的效果. 

• 支持预渲染图像

• 支持设置tabBar字体。
</code></pre>

<h2>实际效果</h2>

<p>最终实现的效果如下所示：</p>

<p><img src="https://github.com/alikaragoz/AKTabBarController/raw/master/Screenshots/iphone-portrait.png" alt="1" /></p>

<p>这里只是简单的讲解一下。大家闲的时候，如果有兴趣的话，可以自己动手来熟练关于<code>AKTabBarController</code>更多的功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于导航栏的六个小技巧]]></title>
    <link href="http://www.superqq.com/blog/2015/07/30/six-tips-on-navigation-bar/"/>
    <updated>2015-07-30T00:13:43+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/30/six-tips-on-navigation-bar</id>
    <content type="html"><![CDATA[<p><code>UINavigationBar</code>和<code>UINavigationItem</code>是iOS开发中常用的控件。今天给大家介绍一下六个关于导航栏的小技巧。</p>

<h2>1.设置导航栏标题</h2>

<pre><code>self.title = @"iOS开发：iOSDevTip";
</code></pre>

<h2>2.设置导航栏样式</h2>

<p>设置方法：</p>

<pre><code>[self.navigationController.navigationBar setBarStyle:UIBarStyleBlack];
</code></pre>

<p><code>UIBarStyle</code>的样式：</p>

<pre><code>typedef NS_ENUM(NSInteger, UIBarStyle) {
    UIBarStyleDefault          = 0,
    UIBarStyleBlack            = 1,

    UIBarStyleBlackOpaque      = 1, // Deprecated. Use UIBarStyleBlack
    UIBarStyleBlackTranslucent = 2, // Deprecated. Use UIBarStyleBlack and set the translucent property to YES
};
</code></pre>

<p><code>UIBarStyleDefault</code>是默认样式，<code>UIBarStyleBlack</code>是黑色不透明。<code>UIBarStyleBlackOpaque</code>和<code>UIBarStyleBlackTranslucent</code>这两个已经废弃了。</p>

<p>如果想设置导航栏透明，可以加上下面这句代码：</p>

<pre><code>self.navigationController.navigationBar.translucent = YES;
</code></pre>

<h2>3.修改返回按钮title</h2>

<pre><code>self.navigationItem.title = @"test";
</code></pre>

<h2>4.隐藏返回按钮title</h2>

<p>比较笨的方法是：</p>

<pre><code>self.navigationItem.title = @"";
</code></pre>

<p>还可以这样设置：</p>

<pre><code>[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60) forBarMetrics:UIBarMetricsDefault];
</code></pre>

<h2>5.设置leftBarButtonItem</h2>

<pre><code>self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"back" style:UIBarButtonItemStylePlain target:self action:@selector(back:)];

- (void)back:(id)sender
{
    [self.navigationController popViewControllerAnimated:YES];
}
</code></pre>

<h2>6.左滑返回手势失效了怎么办</h2>

<p>如果按上一步设置<code>leftBarButtonItem</code>之后，左滑返回手势就会失效。设置一下<code>UIGestureRecognizerDelegate</code>代理即可：</p>

<pre><code>self.navigationController.interactivePopGestureRecognizer.delegate = self;
</code></pre>

<p>以上是六个关于导航栏的小技巧。更多iOS开发相关的技术，请关注我的微信公众号iOS开发：<strong>iOSDevTip</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之UIImage等比缩放]]></title>
    <link href="http://www.superqq.com/blog/2015/07/29/uiimage-geometric-zoom/"/>
    <updated>2015-07-29T00:01:15+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/29/uiimage-geometric-zoom</id>
    <content type="html"><![CDATA[<h2>评论功能真不错</h2>

<p>评论开通后，果然有很多人吐槽。谢谢大家的支持和关爱，如果有做的不到的地方，还请海涵。毕竟我一个人的力量是有限的，我会尽自己最大的努力大家准备一些干货。</p>

<p>有些内容可能都是比较基础的，记住：不积跬步无以至千里，不积小流无以成江海。我想这个道理大家都懂，在为大家准备文章的过程中，对我来说也是一次学习成长。</p>

<p>大家可以继续吐槽！微信的评论就是一个沟通的渠道，也是一篇文章的延续。你也可以在评论中写一些你对iOS开发的见解，说不定就会对他人有帮助。</p>

<p>很高兴，已经有好几位iOS开发的朋友答应以后会写文章投稿给我。在这里，我再强调一下：如果你有好的技术文章一定要投稿给我噢！投稿邮箱：</p>

<pre><code>worldligang@163.com
</code></pre>

<p>前面讲了<a href="http://www.superqq.com/blog/2015/07/26/jie-qu-uiimagezhi-ding-da-xiao-qu-yu/">截取UIImage指定大小区域</a>，很方便的截取<code>UIImage</code>。今天要和大家分享的是<code>UIImage</code>的缩放。</p>

<p>两种缩放:</p>

<ol>
<li>缩放到指定大小，也就是指定的<code>size</code>.</li>
<li>等比缩放。</li>
</ol>


<h2>缩放到指定大小</h2>

<pre><code>- (UIImage*)imageCompressWithSimple:(UIImage*)image scaledToSize:(CGSize)size
{
    UIGraphicsBeginImageContext(size);
    [image drawInRect:CGRectMake(0,0,size.width,size.height)];
    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
</code></pre>

<h2>等比缩放</h2>

<h3>通过缩放系数</h3>

<pre><code>- (UIImage*)imageCompressWithSimple:(UIImage*)image scale:(float)scale
{
    CGSize size = image.size;
    CGFloat width = size.width;
    CGFloat height = size.height;
    CGFloat scaledWidth = width * scale;
    CGFloat scaledHeight = height * scale;
    UIGraphicsBeginImageContext(size); // this will crop
    [image drawInRect:CGRectMake(0,0,scaledWidth,scaledHeight)];
    UIImage* newImage= UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
</code></pre>

<p><code>scale</code>是缩放系数  。</p>

<h3>通过计算得到缩放系数</h3>

<pre><code>- (UIImage*)imageByScalingAndCroppingForSize:(CGSize)targetSize
{

    UIImage *sourceImage = [UIImage imageNamed:@"test.jpg"];
    UIImage *newImage = nil;
    CGSize imageSize = sourceImage.size;
    CGFloat width = imageSize.width;
    CGFloat height = imageSize.height;
    CGFloat targetWidth = targetSize.width;
    CGFloat targetHeight = targetSize.height;
    CGFloat scaleFactor = 0.0;
    CGFloat scaledWidth = targetWidth;
    CGFloat scaledHeight = targetHeight;
    CGPoint thumbnailPoint = CGPointMake(0.0,0.0);

    if (CGSizeEqualToSize(imageSize, targetSize) == NO)
    {
        CGFloat widthFactor = targetWidth / width;
        CGFloat heightFactor = targetHeight / height;
        if (widthFactor &gt; heightFactor)
            scaleFactor = widthFactor; // scale to fit height
        else
            scaleFactor = heightFactor; // scale to fit width

        scaledWidth= width * scaleFactor;
        scaledHeight = height * scaleFactor;
        // center the image
        if (widthFactor &gt; heightFactor)
        {
            thumbnailPoint.y = (targetHeight - scaledHeight) * 0.5;
        }
        else if (widthFactor &lt; heightFactor)
        {
            thumbnailPoint.x = (targetWidth - scaledWidth) * 0.5;
        }
    }

    UIGraphicsBeginImageContext(targetSize); // this will crop
    CGRect thumbnailRect = CGRectZero;
    thumbnailRect.origin = thumbnailPoint;
    thumbnailRect.size.width= scaledWidth;
    thumbnailRect.size.height = scaledHeight;
    [sourceImage drawInRect:thumbnailRect];
    newImage = UIGraphicsGetImageFromCurrentImageContext();

    if(newImage == nil)
        NSLog(@"could not scale image");
    //pop the context to get back to the default
    UIGraphicsEndImageContext();

    return newImage;

}
</code></pre>

<p>很久之前写了一篇文章<a href="http://www.superqq.com/blog/2015/01/22/jie-jue-mwphotobrowserzhong-de-sdwebimagejia-zai-da-tu-dao-zhi-de-nei-cun-jing-gao-wen-ti/">解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题</a>。这个我记得当时从服务器拿到的照片大概有10几M的样子，加载出来会导致内存警告。所以我当时通过修改SDWebImage源码，就是把下载下来的照片进行缩放，内存就降下来了。一般情况下应该不会加载这么大的照片的，用户要是知道，早把你的APP给删掉了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[著名的AFNetworking网络基础库Swift版Alamofire]]></title>
    <link href="http://www.superqq.com/blog/2015/07/28/swift-alamofire/"/>
    <updated>2015-07-28T20:42:52+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/28/swift-alamofire</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/Alamofire/Alamofire" target="_blank" title=“源代码”>源代码</a></p>

<p><img src="http://swiftmi.qiniudn.com/codeimage/201409/13_1410874399080_89.gif" alt="swift-gif" /></p>

<h2>Swift Alamofire 简介</h2>

<p><img src="https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png" alt="Alamofire: Elegant Networking in Swift" /></p>

<p>Alamofire是 Swift 语言的 HTTP 网络开发工具包,相当于Swift实现<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">AFNetworking</a>版本。</p>

<p>当然,AFNetworking非常稳定,在Mac OSX与iOS中也能像其他Objective-C代码一样用Swift编写。不过Alamofire更适合Swift语言风格习惯(Alamofire与AFNetworking可以共存一个项目中,互不影响).</p>

<pre><code>Alamofire 取名来源于 [Alamo Fire flower](https://aggie-horticulture.tamu.edu/wildseed/alamofire.html)
</code></pre>

<h2>Alamofire安装使用方法</h2>

<p>使用CocoaPods安装，在podfile</p>

<pre><code>source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', '~&gt; 1.2'
</code></pre>

<p>submodule 方式安装</p>

<pre><code>$ git submodule add https://github.com/Alamofire/Alamofire.git
</code></pre>

<h2>环境要求</h2>

<p>Xcode 6</p>

<p>iOS 7.0+ / Mac OS X 10.9+</p>

<h2>Alamofire使用方法</h2>

<h3>GET 请求</h3>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get")
</code></pre>

<p>带参数</p>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
</code></pre>

<p>Response结果处理</p>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .response { (request, response, data, error) in
                     println(request)
                     println(response)
                     println(error)
                   }
</code></pre>

<p>Response结果字符串处理</p>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .responseString { (request, response, string, error) in
                  println(string)
         }
</code></pre>

<h2>HTTP 方法（Medthods）</h2>

<p>Alamofire.Method enum 列表出在RFC 2616中定义的HTTP方法 §9:</p>

<pre><code>public enum Method: String {
    case OPTIONS = "OPTIONS"
    case GET = "GET"
    case HEAD = "HEAD"
    case POST = "POST"
    case PUT = "PUT"
    case PATCH = "PATCH"
    case DELETE = "DELETE"
    case TRACE = "TRACE"
    case CONNECT = "CONNECT"
}
</code></pre>

<p>这些值可以作为Alamofire.request请求的第一个参数.</p>

<pre><code>Alamofire.request(.POST, "http://httpbin.org/post")

Alamofire.request(.PUT, "http://httpbin.org/put")

Alamofire.request(.DELETE, "http://httpbin.org/delete")
</code></pre>

<p>POST请求</p>

<pre><code>let parameters = [
    "foo": "bar",
    "baz": ["a", 1],
    "qux": [
        "x": 1,
        "y": 2,
        "z": 3
    ]
]

Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters)
</code></pre>

<p>发送以下HttpBody内容:</p>

<pre><code>foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3
</code></pre>

<p>Alamofire 使用Alamofire.ParameterEncoding可以支持URL query/URI form,JSON, PropertyList方式编码参数。</p>

<p>Parameter Encoding</p>

<pre><code>enum ParameterEncoding {
    case URL
    case JSON(options: NSJSONWritingOptions)
    case PropertyList(format: NSPropertyListFormat,
                      options: NSPropertyListWriteOptions)

    func encode(request: NSURLRequest,
                parameters: [String: AnyObject]?) -&gt;
                    (NSURLRequest, NSError?)
    { ... }
}
</code></pre>

<p>NSURLRequest方式编码参数</p>

<pre><code>let URL = NSURL(string: "http://httpbin.org/get")
var request = NSURLRequest(URL: URL)

let parameters = ["foo": "bar"]
let encoding = Alamofire.ParameterEncoding.URL
(request, _) = encoding.encode(request, parameters)
</code></pre>

<p>POST JSON格式数据</p>

<pre><code>Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters, encoding: .JSON(options: nil))
         .responseJSON {(request, response, JSON, error) in
            println(JSON)
     }
</code></pre>

<p>Response 方法</p>

<pre><code>response()
responseString(encoding: NSStringEncoding)
responseJSON(options: NSJSONReadingOptions)
responsePropertyList(options: NSPropertyListReadOptions)
</code></pre>

<h3>上传（Uploading）</h3>

<p>支持的类型</p>

<pre><code>File
Data
Stream
Multipart (Coming Soon)
</code></pre>

<p>上传文件</p>

<pre><code>let fileURL = NSBundle.mainBundle()
                  .URLForResource("Default",
                                  withExtension: "png")

Alamofire.upload(.POST, "http://httpbin.org/post", file: fileURL)
</code></pre>

<h3>上传进度</h3>

<pre><code>Alamofire.upload(.POST, "http://httpbin.org/post", file: fileURL)
    .progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in
        println(totalBytesWritten)
    }
    .responseJSON { (request, response, JSON, error) in
        println(JSON)
    }
</code></pre>

<h3>下载</h3>

<p>支持的类型</p>

<pre><code>Request
Resume Data
</code></pre>

<p>下载文件</p>

<pre><code>Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: { (temporaryURL, response) in
    if let directoryURL = NSFileManager.defaultManager()
                          .URLsForDirectory(.DocumentDirectory,
                                            inDomains: .UserDomainMask)[0]
                          as? NSURL {
        let pathComponent = response.suggestedFilename

        return directoryURL.URLByAppendingPathComponent(pathComponent)
    }

    return temporaryURL
})
</code></pre>

<p>下载到默认路径</p>

<pre><code>let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)

Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
</code></pre>

<p>下载进度</p>

<pre><code>Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
         .progress { (bytesRead, totalBytesRead, totalBytesExpectedToRead) in
             println(totalBytesRead)
         }
         .response { (request, response, _, error) in
             println(response)
         }
</code></pre>

<h3>认证（Authentication）</h3>

<p>支持以下几种认证</p>

<pre><code>HTTP Basic
HTTP Digest
Kerberos
NTLM
</code></pre>

<p>Http basic认证</p>

<pre><code>let user = "user"
let password = "password"

Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
    .authenticate(HTTPBasic: user, password: password)
    .response {(request, response, _, error) in
        println(response)
        }
</code></pre>

<p>采用NSURLCredential&amp;NSURLProtectionSpace方式认证</p>

<pre><code>let user = "user"
let password = "password"

let credential = NSURLCredential(user: user, password: password, persistence: .ForSession)
let protectionSpace = NSURLProtectionSpace(host: "httpbin.org", port: 0, `protocol`: "https", realm: nil, authenticationMethod: NSURLAuthenticationMethodHTTPBasic)



Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
    .authenticate(usingCredential: credential, forProtectionSpace: protectionSpace)
    .response {(request, response, _, error) in
        println(response)
}
</code></pre>

<h3>Printable</h3>

<pre><code>let request = Alamofire.request(.GET, "http://httpbin.org/ip")

println(request)
// GET http://httpbin.org/ip (200)
</code></pre>

<h3>调试</h3>

<pre><code>let request = Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])

debugPrintln(request)
</code></pre>

<h3>Output (cURL)</h3>

<pre><code>$ curl -i \
    -H "User-Agent: Alamofire" \
    -H "Accept-Encoding: Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
    -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
    "http://httpbin.org/get?foo=bar"
</code></pre>

<p>更多的用法将会在接口文档中一一列出,敬请期待。</p>

<p>Alamofire与AFNetworking是同一个作者</p>

<blockquote><p>作者李刚是刚刚在线（www.superqq.com）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://upload-images.jianshu.io/upload_images/624136-963198258f95cc10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOSDevTip" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[五种创建UIImage的类方法]]></title>
    <link href="http://www.superqq.com/blog/2015/07/28/four-create-uiimage-method/"/>
    <updated>2015-07-28T01:08:30+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/28/four-create-uiimage-method</id>
    <content type="html"><![CDATA[<h3>iOS开发已开通评论功能</h3>

<p>皇天不负有心人，iOS开发的评论功能已经被邀请开通啦。这几天一直想着，微信团队大概在月底的时候会邀请我开通评论功能。果然不出我所料。这是我收到的消息：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/weixincomment.png" alt="weixincomment.png" /></p>

<p>至此，iOS开发的原创、赞赏、评论三个功能都齐啦，这也是对我辛苦努力的一种肯定。前方的路依然很漫长，我们一起努力，让iOS开发变得更好。</p>

<p>既然评论功能已经开通，大家也别闲着啦！今天的文章大家一起尽情的吐槽吧！</p>

<p><code>UIImage</code>有五个类方法，用来创建<code>UIImage</code>的。下面介绍一下每个类方法的作用和创建实例。</p>

<h3>1.使用类方法<code>imageNamed:</code>创建</h3>

<pre><code>+ (UIImage *)imageNamed:(NSString *)name;      // load from main bundle      
</code></pre>

<p><code>name</code>是照片名称。创建UIImage对象，代码如下：</p>

<pre><code>UIImage *image = [UIImage imageNamed:@"ganggang"];   
</code></pre>

<p>使用<code>imageNamed:</code>初始化的时候，会先检查缓存中是否存在<code>ganggang</code>的照片，如不存在，图片首先会被缓存起来，然后才返回要加载的图片对象；如果存在，直接返回要加载的照片对象。</p>

<h3>2.使用类方法<code>imageWithContentsOfFile:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithContentsOfFile:(NSString *)path;
</code></pre>

<p><code>path</code>是需要加载照片的路径，如何获取照片的路径请点击<a href="http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing/">iOS开发之获取沙盒路径</a>。实现代码如下：</p>

<pre><code>UIImage *image = [UIImage imageWithContentsOfFile:path];   
</code></pre>

<p>使用<code>imageWithContentsOfFile:</code>创建<code>UIImage</code>的时候，是直接从磁盘上加载。当收到内存警告时，<code>UIImage</code>对象会被释放，下一次绘图的时候，需要重新加载。</p>

<h3>3.使用类方法<code>imageWithData:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithData:(NSData *)data;
</code></pre>

<p><code>data</code>是照片数据，一般是请求返回的，然后通过<code>imageWithData:</code>创建<code>UIImage</code>。实现代码如下所示：</p>

<pre><code>NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@"http://www.superqq.com/images/getqrcode.jpg"]];
UIImage *image =[UIImage imageWithData:data]; 
</code></pre>

<h3>4.使用类方法<code>imageWithCGImage:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage;
</code></pre>

<p><code>cgImage</code>是定义在QuartzCore框架中的一个结构体指针。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。</p>

<pre><code>UIImage *image = [UIImage imageWithCGImage:cgImage];   
</code></pre>

<h3>5.使用类方法<code>imageWithCIImage:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithCIImage:(CIImage *)ciImage NS_AVAILABLE_IOS(5_0);
</code></pre>

<p><code>CIImage</code>是<code>CoreImage</code>框架中最基本代表图像的对象，在<code>CIImage</code>被<code>CIContext</code>渲染出来之前，他是依赖于滤镜链的，滤镜是不会更改<code>CIImage</code>中的图像数据。</p>

<pre><code> UIImage *image = [UIImage imageWithCGImage:ciImage];   
</code></pre>

<p>以上四种方法都是<code>UIImage</code>的类方法，使用<code>UIImage</code>的初始化方法也是可以创建<code>UIImage</code>对象的大家可以进<code>UIImage</code>详细了解一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之layoutSubviews的作用和调用机制]]></title>
    <link href="http://www.superqq.com/blog/2015/07/27/ioskai-fa-zhi-layoutsubviewsde-zuo-yong-he-diao-yong-ji-zhi/"/>
    <updated>2015-07-27T13:57:27+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/27/ioskai-fa-zhi-layoutsubviewsde-zuo-yong-he-diao-yong-ji-zhi</id>
    <content type="html"><![CDATA[<p>在UIView里面有一个方法<code>layoutSubviews</code>，这个方法具体作用是什么呢？</p>

<pre><code>- (void)layoutSubviews;    // override point. called by layoutIfNeeded automatically. As of iOS 6.0, when constraints-based layout is used the base implementation applies the constraints-based layout, otherwise it does nothing.
</code></pre>

<h2>官方文档解释</h2>

<p>我们先来看看苹果官方文档的解释：</p>

<pre><code>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.

Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.

You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.
</code></pre>

<p>最后一段说，不要直接调用此方法。如果你想强制更新布局，你可以调用<code>setNeedsLayout</code>方法；如果你想立即数显你的<code>views</code>，你需要调用<code>layoutIfNeeded</code>方法。</p>

<h2>layoutSubviews作用</h2>

<p><code>layoutSubviews</code>是对<code>subviews</code>重新布局。比如，我们想更新子视图的位置的时候，可以通过调用<code>layoutSubviews</code>方法，既可以实现对子视图重新布局。</p>

<p><code>layoutSubviews</code>默认是不做任何事情的，用到的时候，需要在自雷进行重写。</p>

<h2>layoutSubviews以下情况会被调用</h2>

<p>苹果官方文档已经强调，不能直接调用<code>layoutSubviews</code>对子视图进行重新布局。那么，<code>layoutSubviews</code>什么情况下会被调用呢？通过百度搜索，发现以下几种情况<code>layoutSubviews</code>会被调用。</p>

<ol>
<li>直接调用<code>setLayoutSubviews</code>。（这个在上面苹果官方文档里有说明）</li>
<li><code>addSubview</code>的时候。</li>
<li>当<code>view</code>的<code>frame</code>发生改变的时候。</li>
<li>滑动<code>UIScrollView</code>的时候。</li>
<li>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>
<li>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>
</ol>


<p>我简单测试了一下，上面基本都会被调用。 注意：</p>

<pre><code>当view的fram的值为0的时候，`addSubview`也不会调用`layoutSubviews`的。
</code></pre>

<p><code>layoutSubviews</code>方法在对自雷视图进行布局的时候非常方便。可以自己动手，深入理解<code>layoutSubviews</code>的调用机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[截取UIImage指定大小区域]]></title>
    <link href="http://www.superqq.com/blog/2015/07/26/jie-qu-uiimagezhi-ding-da-xiao-qu-yu/"/>
    <updated>2015-07-26T10:07:58+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/26/jie-qu-uiimagezhi-ding-da-xiao-qu-yu</id>
    <content type="html"><![CDATA[<p>最近遇到这样的需求：从服务器获取到一张照片，只需要显示他的左半部分，或者中间部分等等。也就是截取UIImage指定大小区域。</p>

<h2>UIImage扩展</h2>

<p>我的解决方案是对<code>UIImage</code>进行扩展。通过<code>CGImageRef</code>和<code>CGImage</code>完成截取，调用的方法是：<code>CGImageCreateWithImageInRect</code>。扩展类叫<code>UIImage+Crop</code>，具体代码如下：</p>

<h3>UIImage+Crop.h</h3>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

typedef NS_ENUM(NSInteger, XYCropImageStyle){
    XYCropImageStyleRight               =0,      // 右半部分
    XYCropImageStyleCenter              =1,      // 中间部分
    XYCropImageStyleLeft                =2,      // 左半部分
    XYCropImageStyleRightOneOfThird     =3,      // 右侧三分之一部分
    XYCropImageStyleCenterOneOfThird    =4,      // 中间三分之一部分
    XYCropImageStyleLeftOneOfThird      =5,      // 左侧三分之一部分
    XYCropImageStyleRightQuarter        =6,      // 右侧四分之一部分
    XYCropImageStyleCenterRightQuarter  =7,      // 中间右侧四分之一部分
    XYCropImageStyleCenterLeftQuarter   =8,      // 中间左侧四分之一部分
    XYCropImageStyleLeftQuarter         =9,      // 左侧四分之一部分
};

@interface UIImage (Crop)
- (UIImage *)imageByCroppingWithStyle:(XYCropImageStyle)style;

@end
</code></pre>

<h3>UIImage+Crop.m</h3>

<pre><code>#import "UIImage+Crop.h"

@implementation UIImage (Crop)

- (UIImage *)imageByCroppingWithStyle:(XYCropImageStyle)style
{
    CGRect rect;
    switch (style) {
        case XYCropImageStyleLeft:
            rect = CGRectMake(0, 0, self.size.width/2, self.size.height);
            break;
        case XYCropImageStyleCenter:
            rect = CGRectMake(self.size.width/4, 0, self.size.width/2, self.size.height);
            break;
        case XYCropImageStyleRight:
            rect = CGRectMake(self.size.width/2, 0, self.size.width/2, self.size.height);
            break;
        case XYCropImageStyleLeftOneOfThird:
            rect = CGRectMake(0, 0, self.size.width/3, self.size.height);
            break;
        case XYCropImageStyleCenterOneOfThird:
            rect = CGRectMake(self.size.width/3, 0, self.size.width/3, self.size.height);
            break;
        case XYCropImageStyleRightOneOfThird:
            rect = CGRectMake(self.size.width/3*2, 0, self.size.width/3, self.size.height);
            break;
        case XYCropImageStyleLeftQuarter:
            rect = CGRectMake(0, 0, self.size.width/4, self.size.height);
            break;
        case XYCropImageStyleCenterLeftQuarter:
            rect = CGRectMake(self.size.width/4, 0, self.size.width/4, self.size.height);
            break;
        case XYCropImageStyleCenterRightQuarter:
            rect = CGRectMake(self.size.width/4*2, 0, self.size.width/4, self.size.height);
            break;
        case XYCropImageStyleRightQuarter:
            rect = CGRectMake(self.size.width/4*3, 0, self.size.width/4, self.size.height);
            break;
        default:
            break;
    }
    CGImageRef imageRef = self.CGImage;
    CGImageRef imagePartRef = CGImageCreateWithImageInRect(imageRef, rect);
    UIImage *cropImage = [UIImage imageWithCGImage:imagePartRef];
    CGImageRelease(imagePartRef);
    return cropImage;
}
</code></pre>

<h2>实际运用</h2>

<p>简单测试一下，看看有没有实现我们想要的效果。首先，先加载一个完整的UIImageView。这个应该不难。代码如下：</p>

<pre><code>UIImageView *imgView = [[UIImageView alloc] init];
imgView.frame = CGRectMake((SCREEN.width - 226) / 2, 100, 226, 106);
UIImage *image = [UIImage imageNamed:@"ganggang"];
imgView.image = image;
[self.view addSubview:imgView];
</code></pre>

<p>运行一下：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/jiequing.png" alt="jiequing" /></p>

<p>要对UIImage进行裁剪，首先导入头文件：</p>

<pre><code>#import "UIImage+Crop.h"
</code></pre>

<p>在上面<code>UIImage *image = [UIImage imageNamed:@"ganggang"];</code>这段代码之后加上下面这句：</p>

<pre><code>image = [image imageByCroppingWithStyle:XYCropImageStyleLeft];
</code></pre>

<p><code>XYCropImageStyleLeft</code>是截取照片的左半部分。效果如下：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/jiequed.png" alt="jiequed" /></p>

<p>截取成功，还可以截取其他区域的，只需要传入不同的<code>XYCropImageStyle</code>即可实现。以上代码依然在<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>里。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员：这个周末不加班]]></title>
    <link href="http://www.superqq.com/blog/2015/07/25/cheng-xu-yuan-:zhe-ge-zhou-mo-bu-jia-ban/"/>
    <updated>2015-07-25T09:01:33+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/25/cheng-xu-yuan-:zhe-ge-zhou-mo-bu-jia-ban</id>
    <content type="html"><![CDATA[<p>时间依然没有停住它的脚步，新的周末如期而至。这应该是一件令人兴奋的时期，谁不想度过一个美好的周末呢？</p>

<p>作为程序员每天都在解决永远解不完的bug，做着永远做不完的需求，能有个周末好好休息休息，真的是一件非常奢侈的事情。</p>

<h2>我也是加班加过来的</h2>

<p>说到这个话题应该是程序员心中的痛啊，哪有程序员不加班的呢？我刚进公司的时候，公司刚成立不久。为了项目进度，拼命的加班，老板每天都在催进度。</p>

<p>那一段时间，公司的程序员们基本都是八九点下班。偶尔一次迎着夕阳下班，都高兴的不得了。不禁感叹一句，终于可以和太阳一起下班啦！</p>

<p>每个周六没有事情，大家也都乖乖的来加班。听着老板不断的画饼。不过好在，公司的发展很迅速，产品销售的也还不错。不过这好像跟我们程序员一点关系都没有。</p>

<h2>少加班或拒绝加班</h2>

<p>公司发展的好，对于程序员来说肯定是一件好事。无论老板有没有兑现当时画饼的承诺，我们都应该为公司的迅速发展而高兴。</p>

<p>随着公司的发展，越来越多的人才不断加入公司。我就喜欢和厉害的人一起工作，这样可以学到不少东西，这对我来说也是一种进步。</p>

<p>我想以后如果没有什么特别重要的事情，尽量选择少加班，或者直接拒绝加班。这应该是我们的权利。当然，说是这么说。如果真的需要加班，那还会义不容辞的，谁让我们选择这个苦逼的行业呢！</p>

<h2>这个周末如何度过</h2>

<p>这个周末我选择不加班。周六准备和高中同学一起聚会，就在上海。好几位同学都是做程序员的（笑），有的人今天还是请假出来聚会的。</p>

<p>自从高中毕业，相见的机会越来越少。所以这一次聚会大家都很珍惜。</p>

<p>周日大学同学来上海，他不是来找我的，他是来找他女朋友的。我呢，还是需要过去见上一面，一起聊聊各自的情况，毕竟来到上海啦。</p>

<p>这个周末你选择如何度过呢？·</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之沙盒和文件操作（汇总）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/25/ioskai-fa-zhi-sha-he-he-wen-jian-cao-zuo-(hui-zong-)/"/>
    <updated>2015-07-25T00:15:17+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/25/ioskai-fa-zhi-sha-he-he-wen-jian-cao-zuo-(hui-zong-)</id>
    <content type="html"><![CDATA[<p>关于沙盒和文件操作的文章写了几篇，在写的过程中加深了自己的记忆。今天来做一下汇总，算是对知识点的梳理。</p>

<h2>文章梳理</h2>

<p>1 <a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a></p>

<p>这是一篇关于沙盒的基础知识教程。简述沙盒的作用，对Documents、Library、tmp之间的区别做了介绍。通过两种方法打开沙盒，查看其中的内容。</p>

<p>2 <a href="http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing/">iOS开发之获取沙盒路径</a></p>

<p>沙盒里的文件夹包括Documents、Library、tmp。文章介绍了如何获取Documents、Library、Caches、tmp的路径。</p>

<p>3 <a href="http://www.superqq.com/blog/2015/07/23/ru-he-cha-kan-zhen-ji-de-sha-he-%28tu-wen-jiao-cheng-%29/">如何查看真机的沙盒（图文教程）</a></p>

<p>通过图文的方式详细讲解如何查看真机沙盒。</p>

<p>4 <a href="http://www.superqq.com/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng/">NSFileManager文件操作的十个小功能</a></p>

<p>NSFileManager是一个单列类，也是一个文件管理器。可以通过NSFileManager创建文件夹、创建文件、写文件、读文件内容等等基本功能。</p>

<h2>小记</h2>

<p>希望以上的知识梳理能帮助大家更好的掌握沙盒机制以及文件操作。我会持续分享更多关于iOS开发相关的技术文章。</p>

<p>swift推出这么久，不知道你有没有开始用swift写项目。推荐给你一个swift学习网站:<a href="http://www.iswifting.com/">swift开发</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSFileManager文件操作的十个小功能]]></title>
    <link href="http://www.superqq.com/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng/"/>
    <updated>2015-07-24T00:14:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng</id>
    <content type="html"><![CDATA[<p>NSFileManager是一个单列类，也是一个文件管理器。可以通过NSFileManager创建文件夹、创建文件、写文件、读文件内容等等基本功能。</p>

<p>下面将介绍NSFileManager文件操作的十个小功能。我们在Documents里面进行举例，首先是获取Documents的路径。这个在<a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a>已经详细讲解过了。获取Documents路径方法如下：</p>

<pre><code>- (NSString *)getDocumentsPath
{
    //获取Documents路径
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *path = [paths objectAtIndex:0];
    NSLog(@"path:%@", path);
    return path;
}
</code></pre>

<h3>创建文件夹</h3>

<pre><code>-(void)createDirectory{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSDirectory = [documentsPath stringByAppendingPathComponent:@"iOS"];
    BOOL isSuccess = [fileManager createDirectoryAtPath:iOSDirectory withIntermediateDirectories:YES attributes:nil error:nil];
    if (isSuccess) {
        NSLog(@"success");
    } else {
        NSLog(@"fail");
    }
}
</code></pre>

<h3>创建文件</h3>

<pre><code>-(void)createFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager createFileAtPath:iOSPath contents:nil attributes:nil];
    if (isSuccess) {
        NSLog(@"success");
    } else {
        NSLog(@"fail");
    }
}
</code></pre>

<h3>写文件</h3>

<pre><code>-(void)writeFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *content = @"我要写数据啦";
    BOOL isSuccess = [content writeToFile:iOSPath atomically:YES encoding:NSUTF8StringEncoding error:nil];
    if (isSuccess) {
        NSLog(@"write success");
    } else {
        NSLog(@"write fail");
    }
}
</code></pre>

<h3>读取文件内容</h3>

<pre><code>-(void)readFileContent{
    NSString *documentsPath =[self getDocumentsPath];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *content = [NSString stringWithContentsOfFile:iOSPath encoding:NSUTF8StringEncoding error:nil];
    NSLog(@"read success: %@",content);
}
</code></pre>

<h3>判断文件是否存在</h3>

<pre><code>- (BOOL)isSxistAtPath:(NSString *)filePath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:filePath];
    return isExist;
}
</code></pre>

<h3>计算文件大小</h3>

<pre><code>- (unsigned long long)fileSizeAtPath:(NSString *)filePath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:filePath];
    if (isExist){
        unsigned long long fileSize = [[fileManager attributesOfItemAtPath:filePath error:nil] fileSize];
        return fileSize;
    } else {
        NSLog(@"file is not exist");
        return 0;
    }
}
</code></pre>

<h3>计算整个文件夹中所有文件大小</h3>

<pre><code>- (unsigned long long)folderSizeAtPath:(NSString*)folderPath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:folderPath];
    if (isExist){
        NSEnumerator *childFileEnumerator = [[fileManager subpathsAtPath:folderPath] objectEnumerator];
        unsigned long long folderSize = 0;
        NSString *fileName = @"";
        while ((fileName = [childFileEnumerator nextObject]) != nil){
            NSString* fileAbsolutePath = [folderPath stringByAppendingPathComponent:fileName];
            folderSize += [self fileSizeAtPath:fileAbsolutePath];
        }
        return folderSize / (1024.0 * 1024.0);
    } else {
        NSLog(@"file is not exist");
        return 0;
    }
}
</code></pre>

<h3>删除文件</h3>

<pre><code>-(void)deleteFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager removeItemAtPath:iOSPath error:nil];
    if (isSuccess) {
        NSLog(@"delete success");
    }else{
        NSLog(@"delete fail");
    }
}
</code></pre>

<h3>移动文件</h3>

<pre><code>- (void)moveFileName
{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *filePath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *moveToPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager moveItemAtPath:filePath toPath:moveToPath error:nil];
    if (isSuccess) {
        NSLog(@"rename success");
    }else{
        NSLog(@"rename fail");
    }
}
</code></pre>

<h3>重命名</h3>

<pre><code>- (void)renameFileName
{
    //通过移动该文件对文件重命名
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *filePath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *moveToPath = [documentsPath stringByAppendingPathComponent:@"rename.txt"];
    BOOL isSuccess = [fileManager moveItemAtPath:filePath toPath:moveToPath error:nil];
    if (isSuccess) {
        NSLog(@"rename success");
    }else{
        NSLog(@"rename fail");
    }
}
</code></pre>

<p>以上文件操作代码都在<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>，可以直接通过git拉下来进行测试。关于NSFileManager的用法还有很多，一起接续探索吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何查看真机的沙盒（图文教程）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/23/ru-he-cha-kan-zhen-ji-de-sha-he-(tu-wen-jiao-cheng-)/"/>
    <updated>2015-07-23T00:29:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/23/ru-he-cha-kan-zhen-ji-de-sha-he-(tu-wen-jiao-cheng-)</id>
    <content type="html"><![CDATA[<p>在<a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a>，我们了解到如何查看模拟器的沙盒内容。直接在Finder->前往->前往文件夹里输入：</p>

<pre><code>/Users/ligang/Library/Application Support/iPhone Simulator/ 
</code></pre>

<p>这样就可以查看模拟器的沙盒内容。在平时开发中，我们应该大部分用的是真机测试。如果需要在沙盒里操作文件，那么我们可以通过观察真机沙盒的内容，来确定文件操作是否正确。</p>

<p>如果你已经知道如何查看真机的沙盒，请看看其他的文章吧，在这里<a href="zhannei.superqq.com">刚刚在线站内搜索</a>可以搜索到更多iOS开发相关的文章。接下来，通过图文的方式详细讲解如何查看真机沙盒。有兴趣的同学可以继续往下看。</p>

<h2>查看真机沙盒教程</h2>

<h3>打开Devices</h3>

<p>在xcode的上部导航栏里，选择window -> Devices</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox1.jpg" alt="realsandbox1.jpg" /></p>

<h3>找到目标APP</h3>

<p>我们拿<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>举例。界面如下图所示：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox2.jpg" alt="realsandbox2.jpg" /></p>

<h3>浏览沙盒目录结构</h3>

<h4>双击iOSStrongDemo</h4>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox3.jpg" alt="realsandbox3.jpg" /></p>

<h4>点击Show Container</h4>

<p>设置图标单击之后，如图所示：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox4.jpg" alt="realsandbox4.jpg" /></p>

<p>这样我们只能看到沙盒的目录结构。看不到实体文件。那么，我们下一步就是找到这个沙盒。</p>

<h3>Download Container保存到桌面</h3>

<p>如上图所示，有一个Download Container，选择之后，保存到桌面。</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox5.jpg" alt="realsandbox5.jpg" /></p>

<h3>右键显示包内容</h3>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox6.jpg" alt="realsandbox6.jpg" /></p>

<h3>查看沙盒目录</h3>

<p>AppDataInfo.plist是APP的配置文件：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox7.jpg" alt="realsandbox7.jpg" /></p>

<h3>打开AppData</h3>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox8.jpg" alt="realsandbox8.jpg" /></p>

<p>这就是APP的沙盒，在这里我们可以对文件进行增删查改操作。更多内容以后继续慢慢分享。</p>
]]></content>
  </entry>
  
</feed>
