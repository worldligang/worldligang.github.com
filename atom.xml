<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刚刚在线]]></title>
  <link href="http://www.superqq.com/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-07-05T12:36:41+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UIButton中的三个UIEdgeInsets属性（二）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/04/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-(er-)/"/>
    <updated>2015-07-04T14:14:43+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/04/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-(er-)</id>
    <content type="html"><![CDATA[<p>昨天去公司加班的人请举手，不是只有我一个吧？（😭）我觉得加班的人应该不少吧。今天周日，应该不需要去加班了。心里暗暗自喜，终于可以休息一天啦。（😄）</p>

<p>说到加班，应该是程序猿心里的痛啊。不加班吧，东西做不完；加班吧，身体吃不消。作为程序猿真的不容易，每天从早忙到晚。突然有一天，六点下班，看见太阳还在等我，心里被踢有多高兴。</p>

<p>弱弱的问一下：加班好不好？</p>

<p>要看这个问题问谁了。如果问老板，老板肯定美滋滋的说，加班好啊，说明你有责任心，有上进心，把公司当成自己的&hellip;</p>

<p>如果问我，哈哈，我当然说加班不好啦，不然会被打死的。开个玩笑。说句实话，加班肯定是不好的，尤其是对程序猿来说。每天面对电脑，每天坐着，时间长了，各种问题就凸显出来。</p>

<p>但是，我说加班不好有用吗？如果我要是老板，我就直接让员工在家办公。（😊）所以大家感觉支持我吧，说不定哪天我真的&hellip;</p>

<p>接着昨天的<a href="http://www.superqq.com/blog/2015/07/03/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-%28%5B%3F%5D-%29/">UIButton中的三个UIEdgeInsets属性</a>，今天我们具体谈谈UIButton的contentEdgeInsets、titleEdgeInsets、imageEdgeInsets属性。</p>

<h2>创建UIButton</h2>

<pre><code>UIButton *button = [[UIButton alloc] init];
button.frame = CGRectMake(50, 200, 200, 50);
[button setTitle:@"我是UIButton" forState:UIControlStateNormal];
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
[button setBackgroundColor:[UIColor orangeColor]];
button.titleLabel.textAlignment = NSTextAlignmentLeft;
button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;
[self.view addSubview:button];
</code></pre>

<p>创建一个button，让button的title居左，以便观察：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button1.png" alt="1" /></p>

<h2>UIButton的contentEdgeInsets属性</h2>

<pre><code>@property(nonatomic)          UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR; // default is UIEdgeInsetsZero
</code></pre>

<p>contentEdgeInsets里有一个content应该指的就是UIButton的title。</p>

<h3>参数含义</h3>

<p>上一篇文章我们讲了UIEdgeInsets是个结构体类型。里面有四个参数，分别是：top, left, bottom, right。这四个参数表示距离上边界、左边界、下边界、右边界的距离。</p>

<p>这四个参数的值可以为正值，也可以为负值。拿left举例：</p>

<pre><code>left = 10; //代表以当前位置为基准，向右移动10个像素
left = -10; //代表以当前位置为基准，向左移动10个像素
</code></pre>

<h3>向右移动20个像素</h3>

<pre><code>button.contentEdgeInsets = UIEdgeInsetsMake(0, 20, 0, 0);
</code></pre>

<p>向右移动20个像素，left = 20，就可以了。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button2.png" alt="2" /></p>

<h3>向左移动20个像素</h3>

<pre><code>button.contentEdgeInsets = UIEdgeInsetsMake(0, -20, 0, 0);
</code></pre>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button3.png" alt="2" /></p>

<h2>UIButton的titleEdgeInsets属性</h2>

<p>titleEdgeInsets和contentEdgeInsets的作用差不多。我们及设置contentEdgeInsets，又设置titleEdgeInsets，会怎样呢？</p>

<pre><code>button.titleEdgeInsets = UIEdgeInsetsMake(0, 20, 0, 0);
button.contentEdgeInsets = UIEdgeInsetsMake(0, 20 , 0, 0);
</code></pre>

<p>看一下效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button4.png" alt="3" /></p>

<h2>UIButton的titleEdgeInsets属性</h2>

<h3>创建一个带照片的button</h3>

<pre><code>UIButton *button = [[UIButton alloc] init];
button.frame = CGRectMake(50, 200, 200, 200);
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
[button setBackgroundColor:[UIColor orangeColor]];
[button setImage:[UIImage imageNamed:@"test"] forState:UIControlStateNormal];
[self.view addSubview:button];
</code></pre>

<p>运行一下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button5.png" alt="5" /></p>

<h3>向右移动50个像素</h3>

<pre><code>button.imageEdgeInsets = UIEdgeInsetsMake(0, 50, 0, 0);
</code></pre>

<p>看看效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button6.png" alt="6" /></p>

<h3>向左移动50个像素</h3>

<pre><code>button.imageEdgeInsets = UIEdgeInsetsMake(0, -50, 0, 0);
</code></pre>

<p>看看效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button7.png" alt="7" /></p>

<p>大家可以自行设置其他三个参数看看效果是怎样的，自己动手便于理解。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="ios" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton中的三个UIEdgeInsets属性（一）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/03/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-(%5B%3F%5D-)/"/>
    <updated>2015-07-03T23:29:55+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/03/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-([?]-)</id>
    <content type="html"><![CDATA[<p>随着时间的推移，随着我的坚持，公众号的订阅用户已经越来越多了。非常感谢大家的信任，我会再接再厉，努力为大家提供更多优秀的文章。</p>

<p>当初创建<a href="http://www.superqq.com/">iOS开发</a>（ <strong>iOSDevTip</strong> ），只是自己的兴趣。刚开始还不怎么会用微信公众号的后台，连发图文消息都不会。不知道怎么去编辑，当初的微信公众号后台也没有现在这么强大。我还以为就是个一对多的聊天工具呢。（😊）</p>

<p>慢慢的我学会了编辑文章，成为一个真正意义上的小编。每天负责为大家推送一些iOS相关的技术文章。每天到各大论坛、网站、大神的博客找一些好的文章。这个过程是漫长的，但是是值得的。</p>

<p>找文章的过程中，对自己来说，也是学习的好机会。如果没有这个公众号，我可能就看不到那么多的技术文章，也不能为大家推荐文章，自己也不会建立博客。</p>

<p>现在微信团队已经邀请我开通原创功能，以后，我就会多发一些原创内容。一个人的力量比较是有限的，订阅的用户如果有喜欢写技术文章的，欢迎头投稿给我，我的邮箱：<strong>worldligang@163.com</strong></p>

<p><strong>相信我，你的付出也会有回报的。</strong></p>

<p>今天是周六，不知道正在看文章的你有没有在加班。没有加班的，就好好休息一下吧；加班的，我只能同情一下啦。今天我们来看看UIButton中的三个UIEdgeInsets属性。</p>

<h2>UIEdgeInsets是什么</h2>

<p>UIEdgeInsets是什么？我们点进去看一下：</p>

<pre><code>typedef struct UIEdgeInsets {
    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to 'outset'
} UIEdgeInsets;
</code></pre>

<p>UIEdgeInsets是个结构体类型。里面有四个参数，分别是：top, left, bottom, right。这四个参数表示距离上边界、左边界、下边界、右边界的距离。</p>

<h2>哪三个UIEdgeInsets属性</h2>

<p>不知道大家发现没有，UIButton里面有三个UIEdgeInsets属性，分别是：</p>

<pre><code>@property(nonatomic)          UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR; // default is UIEdgeInsetsZero

@property(nonatomic)          UIEdgeInsets titleEdgeInsets;                // default is UIEdgeInsetsZero

@property(nonatomic)          UIEdgeInsets imageEdgeInsets;                // default is UIEdgeInsetsZero
</code></pre>

<p>contentEdgeInsets后面有个UI_APPEARANCE_SELECTOR是什么意思呢？</p>

<pre><code>提示：UI_APPEARANCE_SELECTOR标记的属性都支持通过外观代理来定制。
</code></pre>

<p>举例，设置UIButton的contentEdgeInsets属性，可以直接调用：</p>

<pre><code>[[UIButton appearance] setTitleEdgeInsets:UIEdgeInsetsMake(0, 0, 0, 0)];
</code></pre>

<p>关于UIButton三个UIEdgeInsets属性的作用，下一篇文章介绍。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="ios" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton文字居左显示]]></title>
    <link href="http://www.superqq.com/blog/2015/07/02/uibuttonwen-zi-ju-zuo-xian-shi/"/>
    <updated>2015-07-02T22:18:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/02/uibuttonwen-zi-ju-zuo-xian-shi</id>
    <content type="html"><![CDATA[<p>题外话：时间依旧过的很快，不知不觉2015年就过去一半了。感觉自己好像没有大的改变，只能感叹时间飞逝，却不能有所收获。</p>

<p>我从来都不是一个安于现状的人，改变自己的想法从未停止过。我想大多数人都跟我有类似的想法。但是为什么很难有所成就呢？我觉得最重要的原因就是，<strong>只是想一下，而没有去行动</strong>。</p>

<p>这是一个全民创业的时代，不把握机会，只能错过。错过的机会，越多遗憾就越多。有句话说：<strong>老了之后，回想人生，不会因为自己做过什么而后悔，而会因为自己没有做过什么而遗憾。</strong>不想给人生留下遗憾，所以努力去尝试是唯一的选择。</p>

<p>随便感慨一下。每天上班太舒服了，淡忘了自己的理想，借此提醒一下自己。</p>

<p>来来，收回思路，今天我们来讲如何让UIButton文字居左显示？我们都应该写过让UILabel的text居左显示。代码也非常简单。</p>

<h2>UILabel文字居左显示</h2>

<p>实现文字居左显示代码如下：</p>

<pre><code>UILabel *label = [[UILabel alloc] init];
label.frame = CGRectMake(50, 100, 200, 50);
label.text = @"我是label";
label.textAlignment = NSTextAlignmentLeft;
label.backgroundColor = [UIColor orangeColor];
[self.view addSubview:label];
</code></pre>

<p>运行起来看一下效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/labelleft.png" alt="1" /></p>

<p>label.backgroundColor = [UIColor orangeColor];设置label的背景颜色方便我们参考。你是不是这样做的。依次类推UIButton也很简单，你肯定能想到。我们来看看。</p>

<h2>UIButton文字居左显示</h2>

<h3>创建UIButton</h3>

<pre><code>UIButton *button = [[UIButton alloc] init];
//设置坐标
button.frame = CGRectMake(100, 100, 100, 50);
//设置标题
[button setTitle:@"我是UIButton" forState:UIControlStateNormal];
//设置标题颜色
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
//设置背景颜色    
[button setBackgroundColor:[UIColor orangeColor]];
[self.view addSubview:button];
</code></pre>

<p>以上代码是创建一个button，设置坐标、标题、和标题颜色。</p>

<h3>让文字居左</h3>

<p>按照UILabel文字居左的写法，UIButton应该这么写：</p>

<pre><code> button.titleLabel.textAlignment = NSTextAlignmentLeft;
</code></pre>

<p>运行一下看一下效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/buttonnoleft.png" alt="2" /></p>

<p>我们发现UIButton的文字还是居中显示。竟然没有居左显示，怎么办呢？进UIButton看看，还有哪些属性。很快发现：</p>

<pre><code>@property(nonatomic) UIControlContentHorizontalAlignment contentHorizontalAlignment; // how to position content hozontally inside control. default is center

typedef NS_ENUM(NSInteger, UIControlContentHorizontalAlignment) {
    UIControlContentHorizontalAlignmentCenter = 0,
    UIControlContentHorizontalAlignmentLeft   = 1,
    UIControlContentHorizontalAlignmentRight  = 2,
    UIControlContentHorizontalAlignmentFill   = 3,
};
</code></pre>

<h3>设置contentHorizontalAlignment</h3>

<pre><code>button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;
</code></pre>

<p>再次运行起来看效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/buttonleft.png" alt="3" /></p>

<p>果然可以，是不是看着居左显示很难看，太靠边了。很简单，设置UIButton的titleEdgeInsets属性：</p>

<pre><code>button.titleEdgeInsets = UIEdgeInsetsMake(0, 10, 0, 0);
</code></pre>

<p>这样button的title就距左边10个像素的距离。</p>

<p>居右显示就很简单了：</p>

<pre><code>button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentRight;
</code></pre>

<p>ok，UIButton文字居左显示完成了。更多iOS技术请点击<a href="www.superqq.com">刚刚在线</a> : <strong>www.superqq.com</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EGOCache如何检测缓存时间过期]]></title>
    <link href="http://www.superqq.com/blog/2015/07/02/egocacheru-he-jian-ce-huan-cun-shi-jian-guo-qi/"/>
    <updated>2015-07-02T00:38:14+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/02/egocacheru-he-jian-ce-huan-cun-shi-jian-guo-qi</id>
    <content type="html"><![CDATA[<blockquote><p>子曰:学而不思则罔,思而不学则殆。</p></blockquote>

<p>在上一篇文章中：<a href="http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie/">EGOCache缓存框架详细讲解</a> 提到<strong>EGOCache</strong>可以设定缓存过期时间，默认是1天。查看了一下EGOCache源码，设置默认时间：</p>

<pre><code>    [self setDefaultTimeoutInterval:86400];

    //86400 = 24 * 60 * 60 刚好是一天时间。
</code></pre>

<p>EGOCache为什么要提供设定缓存过期时间呢？或者说设定缓存过期时间有什么好处呢？我觉得最大的好处就是可以定时清除缓存。可以设置某一项的缓存时间，很方便管理缓存。</p>

<p>那么问题来了：</p>

<ol>
<li>EGOCache是怎么检测缓存过期时间的呢？</li>
<li>检测到时间过期之后，什么时候触发删除缓存项的？</li>
</ol>


<p>带着这两个问题，我们来继续分析。</p>

<h2>你会怎么实现</h2>

<p>记得在公司里，老板经常会举这样的例子：</p>

<pre><code>某某同志，刚来我们公司的时候，遇到问题就知道抱怨。从来不知道去思考怎么解决，只知道把问题抛给领导。工作半年下来，成长了很多。现在碰到问题，不仅把问题抛出来，而且还提供了自己的解决方案...
</code></pre>

<p>类似的例子，相信大家都听过。同样，既然前面我们提出这两个问题，我们也先来思考一下，如果我们来做该怎么解决？</p>

<p>如果让我来写的话，我脑海里初步实现方法有几个：</p>

<ol>
<li>通过定时器来轮询，每隔一段时间检测一次。</li>
<li>写一个while循环来检测。</li>
<li>每次去读取缓存项的时候，判断缓存时间有没有过期。没过期，就返回读取的缓存项；否则，返回nil。</li>
</ol>


<p>当然，还有一些方法，不一一例举了。仔细想想，这些方法弊端很容易显露出来。</p>

<ol>
<li>为了小小的缓存时间，就用定时器轮询，显然是资源浪费</li>
<li>跟方法1差不多。</li>
<li>每次读取的时候判断是否过期，如果一直不读取，app的缓存会越来越大，也不可取。</li>
</ol>


<p>这些方法都被排除了，还有好的方法吗？继续往下看：</p>

<h2>EGOCache是怎么实现的？</h2>

<p>仔细查看EGOCache源码，发现在initWithCacheDirectory:方法里，每次初始化EGOCache实例对象的时，会遍历一遍plist文件中所有已存在的缓存项，拿每个缓存项的时间和当前时间作比较，缓存项过期时间早于当前时间，则删除对应缓存文件，并删除 plist 文件中对应 key 的记录。</p>

<p>具体实现代码如下：</p>

<h3>读取缓存项信息</h3>

<pre><code>_cacheInfo = [[NSDictionary dictionaryWithContentsOfFile:cachePathForKey(_directory, @"EGOCache.plist")] mutableCopy];

if(!_cacheInfo) {
    _cacheInfo = [[NSMutableDictionary alloc] init];
}
</code></pre>

<h3>获取当前时间的NSTimeInterval</h3>

<pre><code>NSTimeInterval now = [[NSDate date] timeIntervalSinceReferenceDate];
</code></pre>

<h3>声明removedKeys保存过期的缓存项对应的key</h3>

<pre><code>NSMutableArray* removedKeys = [[NSMutableArray alloc] init];
</code></pre>

<h3>遍历缓存项信息并判断缓存时间</h3>

<pre><code>for(NSString* key in _cacheInfo) {
    //判断缓存项过期时间是否早于当前时间
    if([_cacheInfo[key] timeIntervalSinceReferenceDate] &lt;= now) {
        //如果缓存项过期时间早于当前时间，移除缓存项
        [[NSFileManager defaultManager] removeItemAtPath:cachePathForKey(_directory, key) error:NULL];
        //把过期的缓存项对于的key保存到removedKeys里面
        [removedKeys addObject:key];
    }
}
</code></pre>

<h3>删除过期缓存项对于的key</h3>

<pre><code>[_cacheInfo removeObjectsForKeys:removedKeys];
</code></pre>

<p>看到这些，是不是觉得人家思路特牛叉，反正，我是觉得这个作者不简单。到这一步就解决了吗？</p>

<h2>EGOCache还做了什么？</h2>

<p>细心的童鞋会发现：<strong>EGOCache是个<a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">单列类</a></strong>，也就是说整个程序应用周期只初始化一次。</p>

<pre><code>+ (instancetype)globalCache {
    static id instance;

    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        instance = [[[self class] alloc] init];
    });

    return instance;
}
</code></pre>

<p>每次初始化的时候去判断了缓存项是否过期，这样做非常正确。思考一个场景：</p>

<ol>
<li>用户打开app，EGOCache被初始化，并判断了缓存项是否过期。</li>
<li>如果刚好有一些缓存项在EGOCache被初始化之后过期。这个时候我们依然可以读到这个缓存项。这就不对了。</li>
</ol>


<p>继续分析EGOCache源码发现，EGOCache在读取一个缓存项的时候，先判断缓存项是否存在，然后读取缓存项（注意：是读取EGOCache初始化的时候没有过期的缓存项，并没有说现在没有过期），最后去判断读取到的缓存项跟当前时间相比是否过期.</p>

<p>具体实现如下：</p>

<pre><code>- (BOOL)hasCacheForKey:(NSString*)key {
    //读取EGOCache初始化的时候没有过期的缓存项
    NSDate* date = [self dateForKey:key];
    if(date == nil) return NO;
    //判断读取到的缓存项当前是否过期
    if([date timeIntervalSinceReferenceDate] &lt; CFAbsoluteTimeGetCurrent()) return NO;

    return [[NSFileManager defaultManager] fileExistsAtPath:cachePathForKey(_directory, key)];
}

- (NSDate*)dateForKey:(NSString*)key {
    __block NSDate* date = nil;

    dispatch_sync(_frozenCacheInfoQueue, ^{
        date = (self.frozenCacheInfo)[key];
    });

    return date;
}
</code></pre>

<p>EGOCache检测缓存时间过期的思路值得学习，以后遇到类似场景，完全可以借鉴。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EGOCache缓存框架详细讲解]]></title>
    <link href="http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie/"/>
    <updated>2015-07-01T00:10:18+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie</id>
    <content type="html"><![CDATA[<p><strong>EGOCache</strong>是一个轻量级的缓存框架。用法简单方便，在现在的项目中，我就用到EGOCache来缓存下载过的照片和字符串。</p>

<p>有人可能会问到，缓存照片还需要用EGOCache吗？<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">AFNetworking</a>和<a href="http://www.superqq.com/blog/2015/06/09/sdwebimagejia-zai-tu-pian-huan-cun-tu-pian/">SDWebImage</a>不是已经有这些功能了吗？</p>

<p>是的，不过AFNetworking和SDWebImage是http。我的项目用的是socket，所以我选择EGOCache来做缓存。用下来觉得EGOCache还是挺强大的。</p>

<h2>EGOCache简介</h2>

<pre><code>EGOCache is a simple, thread-safe key value cache store. It has native support for NSString, UI/NSImage, and NSData, but can store anything that implements &lt;NSCoding&gt;. All cached items expire after the timeout, which by default, is one day.
</code></pre>

<p>翻译过来就是：EGOCache一个简单、线程安全的基于 key-value 的缓存框架，原生支持NSString、UI/NSImage、和NSData，也支持储存任何实现<NSCoding>协议的类，可以设定缓存过期时间，默认是1天。</p>

<p>EGOCache只有一个类，EGOCache.h和EGOCache.m两个文件。用法也比较容易掌握，仔细研究一下EGOCache.h的方法，很快就可以上手。</p>

<p>EGOCache只提供了磁盘缓存，没有提供内存缓存。同时，也提供了清理缓存的方法：</p>

<pre><code>- (void)clearCache;
</code></pre>

<p>EGOCache还提供了判断缓存是否存在的方法：</p>

<pre><code>- (BOOL)hasCacheForKey:(NSString* __nonnull)key;
</code></pre>

<h2>通过Cocoapods直接加入项目</h2>

<p>直接在你的项目的Podfile加入下面一行：</p>

<pre><code>pod 'EGOCache'
</code></pre>

<p>然后执行：</p>

<pre><code>$ pod update
</code></pre>

<h2>EGOCache用法</h2>

<h3>用EGOCache缓存NSString</h3>

<p>存储：</p>

<pre><code>NSString *saveString = @"把我保存起来吧";
[[EGOCache globalCache] setString:saveString forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[saveString hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>NSString *getSaveString = [[EGOCache globalCache] stringForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveString" hash]]];
</code></pre>

<p>是不是感觉跟NSDictionary很相似，确实，前面我们说了EGOCache是基于key-value 的缓存框架。</p>

<h3>用EGOCache缓存UIImage</h3>

<p>存储：</p>

<pre><code> UIImage *saveImage = [UIImage imageNamed:@"iOSDevTip"];
[[EGOCache globalCache] setImage:saveImage forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveImage" hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>UIImage *getSaveImage = [[EGOCache globalCache] imageForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveImage" hash]]];
</code></pre>

<h3>用EGOCache缓存NSData</h3>

<p>存储：</p>

<pre><code>NSData *saveData = [NSData data];
[[EGOCache globalCache] setData:saveData forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveData" hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>UIImage *getSaveData = [[EGOCache globalCache] dataForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveData" hash]]];
</code></pre>

<h2>EGOCache源码下载</h2>

<p><a href="https://github.com/enormego/EGOCache">EGOCache</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[唯有坚持方能成功]]></title>
    <link href="http://www.superqq.com/blog/2015/06/30/wei-you-jian-chi-fang-neng-cheng-gong/"/>
    <updated>2015-06-30T00:44:54+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/30/wei-you-jian-chi-fang-neng-cheng-gong</id>
    <content type="html"><![CDATA[<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/jianchi.jpg" alt="2" /></p>

<p>或许这不是一篇心灵鸡汤，因为心灵鸡汤不是我的擅长;或许这就是一篇心灵鸡汤，希望能点燃你的斗志。</p>

<h2>坚持才有希望</h2>

<p>我常说一句话：不是因为有了希望才坚持，而是坚持了才有希望。我也一直用这句话来告诫自己。只要持续努力，才有成功的可能。</p>

<p>以前，我认为如果谁能给我机会，我将会怎样怎样。我就一直等啊等，等啊等，两年三年后，好像发现没人会给我机会，反而错过很多本应该能抓住的机会。</p>

<p>现在，我改变了这种想法。我要用自己的努力，自己的坚持，来获取更多的机会，更多的可能。</p>

<h2>iOS开发开通原创功能</h2>

<p>就在昨天20:11微信团队邀请我开通微信原创功能。对于我来说，这是一个值得纪念的时刻，这也是对我的努力的一种肯定。特给大家分享一下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/yuanchuang.png" alt="2" /></p>

<p>随着iOS开发微信微信公众号订阅的用户越来越多，让我觉得责任越来越重。</p>

<p>正在看文章的你，可能是一位技术大牛，有时候我发的文章很基础，你会觉得文章水平太低，你想阅读到更多先进的技术；也可能你是一位iOS新人，渴望阅读一些iOS进阶的文章；还可能你是一位大学生，或者是你已经上班，想转行做iOS开发，你想阅读一些如何入门的文章。</p>

<p>这些我都知道。我也在努力去改变，去写一些真正能够帮助到大家的文章。我甚至发说说，问我的朋友，如何提高写作水平？</p>

<p>后来，我发现我错了。iOS开发分享的是技术文章，不是华丽的文字。</p>

<p>我希望能从我的手里写出更多优秀的文章。这对于我来说，真的是一个很大的挑战。我相信，只要我坚持，我就能为大家提供更多优质的文章。</p>

<h2>iOS入门：坚持做一个项目</h2>

<p>有人在微信里问我，iOS开发如何入门。我给大家讲一个，我身边的真实案例。</p>

<p>我有一个朋友，我们叫他A吧。A刚来上海工作，是做Java的，在一家房地产公司。工作相对来说比较稳定，偶尔也加加班，这对程序员来说是常态。</p>

<p>后来，A想学iOS开发。A是一个行动力很强的人，立马花了一万多买了一个MacBook。开始iOS学习之旅。</p>

<p>A的学习方法很简单，网上下载了一些iOS入门视频。他就跟着视频里讲的，做一个新浪微博客户端。</p>

<p>连续写了一个多月，终于，把新浪微博做出来。做到过程中，他遇到一些开发上的问题。就问问身边的朋友，或者百度一下，google一下。</p>

<p>在解决问题的过程中，很熟练地掌握了iOS开发。过完年来了，立马换了一家公司做iOS开发的。薪资比他做Java工作要高一些。</p>

<p>所以，如果你在问iOS开发如何入门，请你认认真真的写一个项目。遇到问题，一定要想办法解决它，解决问题就是学习最好的方法。</p>

<h2>欢迎投稿</h2>

<p>订阅iOS开发的用户不乏有一些大牛，希望你们能把自己的技术分享出来。分享既是快乐，分享既是成长。</p>

<p>投稿邮箱：<strong>worldligang@163.com</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CGContextRef使用简要教程]]></title>
    <link href="http://www.superqq.com/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng/"/>
    <updated>2015-06-29T10:55:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng</id>
    <content type="html"><![CDATA[<p>Graphics Context是图形上下文,也可以理解为一块画布,我们可以在上面进行绘画操作,绘制完成后,将画布放到我们的view中显示即可,view看作是一个画框.</p>

<p>CGContextRef功能强大，我们借助它可以画各种图形。开发过程中灵活运用这些技巧，可以帮助我们提供代码水平。</p>

<p>说到画图，我就立马想到：我的数学公式都快忘完了。</p>

<h2>高中数学你还记得多少？</h2>

<p>我记得我上学的时候，数学一直都很好。以至于在班里都不敢和别人吵吵闹闹。一吵吵闹闹，别人就会来一句：以为你数学好，就可以怎么样怎么样了是吧？说的我好无奈啊。</p>

<p>这么多年过去了，说句实话，高中时学的数学公式什么的，都忘记的差不多了。现在要去做高三的考题，估计比写代码还难。</p>

<p>作为一名程序员，数学好，一定是优势。就拿画图来说吧，如果你还清楚的记得那些公式，那么你就可以很随意地画出一些好看的图形出来。</p>

<p>接下来，我们来看看CGContextRef到底能实现些什么？</p>

<h2>写文字</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //开始写字
    [@"我是文字" drawInRect:CGRectMake(10, 10, 100, 30) withFont:font];  
    [super drawRect:rect];
}
</code></pre>

<p>这段代码就可以很漂亮的写出四个大字：我是文字。很容易理解，每句话都有注释。</p>

<h2>画直线</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //顶部横线
    CGContextMoveToPoint(ctx, 0, 10);
    CGContextAddLineToPoint(ctx, self.bounds.size.width, 10);
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<h2>画圆</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //void CGContextAddArc(CGContextRef c,CGFloat x, CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle, int clockwise)1弧度＝180°/π （≈57.3°） 度＝弧度×180°/π 360°＝360×π/180 ＝2π 弧度
    // x,y为圆点坐标，radius半径，startAngle为开始的弧度，endAngle为 结束的弧度，clockwise 0为顺时针，1为逆时针。
    CGContextAddArc(ctx, 100, 20, 20, 0, 2*M_PI, 0); //添加一个圆
    CGContextDrawPath(ctx, kCGPathStroke); //绘制路径
    [super drawRect:rect];
}
</code></pre>

<p>这个画圆的公式你还记得吗？你还知道M_PI是什么吗？等于多少吗？赶紧脑补一下吧！</p>

<h2>画矩形</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    CGContextAddRect(ctx, CGRectMake(2, 2, 30, 30));
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<p>图形千千万，万变不离其宗。更多画图方法，期待你的探索。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用正则表达式验证邮箱和手机号]]></title>
    <link href="http://www.superqq.com/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao/"/>
    <updated>2015-06-27T07:35:42+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao</id>
    <content type="html"><![CDATA[<blockquote><p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></blockquote>

<p>做iOS开发的童鞋，应该都用过正则表达式吧。正则表达式很好地，帮助我们判断一个字符串是否合法。比如：</p>

<ol>
<li><p>在做app注册页面的时候，需要判断手机号是否格式正确，是否够11位。</p></li>
<li><p>在做意见反馈的时候，需要判断邮箱格式是否正确。</p></li>
</ol>


<p>判断手机号和判断邮箱，应该是iOS开发者们最常用的。具体如何判断，简单整理如下：</p>

<h2>验证邮箱</h2>

<pre><code>+ (BOOL)validateEmail:(NSString *)email
{
    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}";
    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex];
    return [emailTest evaluateWithObject:email];
}
</code></pre>

<p>NSPredicate是一个Foundation类，是用来查询的，原理和用法都类似于SQL中的where。</p>

<h2>验证手机号</h2>

<h3>简单的判断方法</h3>

<pre><code>+ (BOOL)validatePhone:(NSString *)phone
{
    NSString *phoneRegex = @"1[3|5|7|8|][0-9]{9}";
    NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", phoneRegex];
    return [phoneTest evaluateWithObject:phone];
}
</code></pre>

<p>这只是简单地判断手机号格式。其实手机的格式还是有一点复杂的。</p>

<h3>详细的判断方法</h3>

<pre><code>//正则判断手机号码格式
+ (BOOL)validatePhone:(NSString *)phone
{
       /**
        * 手机号码
        * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        * 联通：130,131,132,152,155,156,185,186
        * 电信：133,1349,153,180,189
        */
       NSString * MOBILE = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";
       /**
        10         * 中国移动：China Mobile
        11         * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        12         */
       NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d{7}$";
       /**
        15         * 中国联通：China Unicom
        16         * 130,131,132,152,155,156,185,186
        17         */
       NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d{8}$";
       /**
        20         * 中国电信：China Telecom
        21         * 133,1349,153,180,189
        22         */
       NSString * CT = @"^1((33|53|8[09])[0-9]|349)\\d{7}$";
       /**
        25         * 大陆地区固话及小灵通
        26         * 区号：010,020,021,022,023,024,025,027,028,029
        27         * 号码：七位或八位
        28         */
      // NSString * PHS = @"^0(10|2[0-5789]|\\d{3})\\d{7,8}$";

     NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBILE];
     NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM];
     NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU];
     NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT];

    if (([regextestmobile evaluateWithObject:phone] == YES)
    || ([regextestcm evaluateWithObject:phone] == YES)
    || ([regextestct evaluateWithObject:phone] == YES)
    || ([regextestcu evaluateWithObject:phone] == YES))
    {
        if([regextestcm evaluateWithObject:phone] == YES) {
          NSLog(@"China Mobile");
        } else if([regextestct evaluateWithObject:phone] == YES) {
          NSLog(@"China Telecom");
        } else if ([regextestcu evaluateWithObject:phone] == YES) {
          NSLog(@"China Unicom");
        } else {
          NSLog(@"Unknow");
        }

        return YES;
    }
    else 
    {
        return NO;
    }
}
</code></pre>

<p>以上这段（来自网络）是手机号判断的详细方法。基本上这个判断就够用了，如果三大运营商，再出其他段的手机号。直接子啊上面做简单修改即可。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode真机调试报错：The Application Could Not Be Verified.]]></title>
    <link href="http://www.superqq.com/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified/"/>
    <updated>2015-06-26T15:33:34+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified</id>
    <content type="html"><![CDATA[<p> 今天真机调试的时候遇到这个错误：</p>

<pre><code>The application could not be verified.
</code></pre>

<p> 这还是第一次遇到，应该是手机上的app的证书跟现在的证书不一致导致。</p>

<p> 解决方法有两个</p>

<p> ###xcode中切换证书：</p>

<pre><code>你手机上的app用的是哪个证书，你现在还用那个证书运行。
</code></pre>

<p> ###删除手机上的app</p>

<pre><code>直接删除手机上的app，再运行就可以啦！
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSDate和NSString相互转换]]></title>
    <link href="http://www.superqq.com/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan/"/>
    <updated>2015-06-26T07:34:32+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan</id>
    <content type="html"><![CDATA[<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/2NSDate.jpg" alt="1" /></p>

<p>不积小流无以成江海，不及硅步无以至千里。做<a href="http://www.superqq.com/blog/2015/01/14/ioskai-fa-zhi-shou-shi-shi-bie-hui-zong/">iOS开发</a>也是这样，平时写代码要多收集一些有用的代码，以免每次都从新来一遍，不仅浪费时间，也影响开发效率。</p>

<p>有人把做app形容成盖房子，码农就是搬砖的，真的是形象无比。随着时间的推移，手里积累的优秀代码就越来越多。这样，盖起房子来，效率肯定是杠杠的。</p>

<p>我也会收集一些有用的代码，有的会写在博客里，有的会写成demo放在<a href="http://www.superqq.com/blog/2014/11/19/ioskai-fa-zhong-gitfen-zhi-chuang-jian-he-guan-li/">github</a>上面，有的就很安静的躺在我的电脑里。每次我用到的时候，我都会顺手复制过来。</p>

<p>今天给大家分享一些关于NSDate和NSString相互转换。百度一下，有一大推相关的方法。每次都百度，不如自己收集起来方便。</p>

<h2>NSDate转NSString</h2>

<p>日期转成字符串。这个虽然简单，但是我相信很多朋友初次遇到肯定束手无策。脑子里蹦出四个字：这怎么转？直接上代码：</p>

<pre><code>//获取系统当前时间
NSDate *currentDate = [NSDate date];
//用于格式化NSDate对象
NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
//设置格式：zzz表示时区
[dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
//NSDate转NSString
NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
//输出currentDateString
NSLog(@"%@",currentDateString);
</code></pre>

<p>NSDate对象包含两个部分，日期（Date）和时间（Time）。格式化的时间字符串主要也是针对日期和时间的。NSDateFormatter是一个很常用的类，用于格式化NSDate对象，支持本地化的信息。</p>

<p>NSDateFormatter常用的格式有：</p>

<pre><code>yyyy-MM-dd HH:mm:ss.SSS 
yyyy-MM-dd HH:mm:ss
yyyy-MM-dd
MM dd yyyy
</code></pre>

<p>NSDateFormatter格式化参数如下：</p>

<pre><code>G: 公元时代，例如AD公元
yy: 年的后2位
yyyy: 完整年
MM: 月，显示为1-12
MMM: 月，显示为英文月份简写,如 Jan
MMMM: 月，显示为英文月份全称，如 Janualy
dd: 日，2位数表示，如02
d: 日，1-2位显示，如 2
EEE: 简写星期几，如Sun
EEEE: 全写星期几，如Sunday
aa: 上下午，AM/PM
H: 时，24小时制，0-23
K：时，12小时制，0-11
m: 分，1-2位
mm: 分，2位
s: 秒，1-2位
ss: 秒，2位
S: 毫秒
</code></pre>

<h2>NSString转NSDate</h2>

<p>既然NSDate可以转成NSString，毫无疑问NSString也可以转成NSDate。代码如下：</p>

<pre><code>//需要转换的字符串
NSString *dateString = @"2015-06-26 08:08:08";
 //设置转换格式
NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
[formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
//NSString转NSDate
NSDate *date=[formatter dateFromString:dateString];
</code></pre>

<p>NSDate和NSString相互转换就是这么简单。</p>

<h2>转换工具类</h2>

<p>在项目中，我们需要用到转换的地方可能不止一处，所以建议我们定义一个工具类。在工具类里实现如下两个方法：</p>

<pre><code>//NSDate转NSString
+ (NSString *)stringFromDate:(NSDate *)date
{
    //获取系统当前时间
    NSDate *currentDate = [NSDate date];
    //用于格式化NSDate对象
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //设置格式：zzz表示时区
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
    //NSDate转NSString
    NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
    //输出currentDateString
    NSLog(@"%@",currentDateString);
    return currentDateString;
}

//NSString转NSDate
+ (NSDate *)dateFromString:(NSString *)string
{
    //需要转换的字符串
    NSString *dateString = @"2015-06-26 08:08:08";
    //设置转换格式
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    //NSString转NSDate
    NSDate *date=[formatter dateFromString:dateString];
    return date;
}
</code></pre>

<p>有了这个工具类，妈妈再也不用担心我的转换能力啦！</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何成为一名优秀的iOS开发工程师]]></title>
    <link href="http://www.superqq.com/blog/2015/06/25/ru-he-cheng-wei-%5B%3F%5D-ming-you-xiu-de-ioskai-fa-gong-cheng-shi/"/>
    <updated>2015-06-25T07:49:07+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/25/ru-he-cheng-wei-[?]-ming-you-xiu-de-ioskai-fa-gong-cheng-shi</id>
    <content type="html"><![CDATA[<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/1iOSkaifa.jpg" alt="1" /></p>

<p>如果你是一位专业的<strong>iOS开发工程师</strong>，你应该为自己感到自豪。因为你能在强大的iOS系统下，一展身手实现自己和他人的想法，这是一件令人无比激动的事情。</p>

<p>作为一名iOS开发工程师，你一定想成为行业的佼佼者。那么，如何成为一名优秀的iOS开发工程师呢？我觉得做到以下几点，你就离优秀越来越近了。</p>

<h3>提高英语水平</h3>

<p>作为码农，英语水平虽然不是一个硬指标，但是，如果你的英语水平足够好，那真是如虎添翼。在公司里面，糟糕的英语表达能力也掩盖了你在软件开发技术上的优势。</p>

<p>很多优秀的技术文章都是英文版本的，就像苹果官方文档一样，你看不懂你就比别人落后了一步。当这些文档被汉化，被翻译成中文，那是需要一段时间的。少则几天，多则几个月。所以与其被动等待，不如先把英语水平提上去。</p>

<p>英语的重要性，不言而喻，不仅仅有助于写代码。如果万一哪一天你成为公众人物了，你是想向刘强东一样讲英语，还是想向雷布斯一样讲英语呢？我觉得你应该更想像马云一样。</p>

<p>至于，如何提高英语水平，请问度娘。</p>

<h3>控制代码质量</h3>

<p>想成为优秀的iOS开发工程师，代码质量是很重要的一关。关于如何提高代码质量，推荐大家看一篇文章：<a href="http://www.90159.com/2015/06/17/Objective-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%9A26%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%A7%A3%E5%86%B3iOS%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/">Objective-C编码规范：26个方面解决iOS开发问题</a>，这篇文章详细的讲述了iOS开发方面的编码规范，建议大家多看一看。</p>

<p>如果你能按着上面的编码规范来规范自己，我觉得最起码你代码看起来就比较整洁。这样的话，哪怕你一个月回头再来看自己的代码，应该很快就可以理解。而且，当你离开现在的公司，不至于后来的人骂你。</p>

<p>没听人常说嘛：良好的习惯是成功的第一步，iOS开发者也不例外。</p>

<h3>写博客分享技术</h3>

<p>在csdn上看到有人问：不写博客的程序员是好程序员吗？这个问题问的其实挺好。不写博客的人也有进BAT的，BAT里面的程序员并不一定都写博客；写博客的人大部分都没有进BAT，比如像我这样的屌丝。</p>

<p>但是这并不能说明什么。且看，写博客的好处在哪里？</p>

<p><strong>写博客你可以交到一群志同道合的朋友</strong>。即使你们现实中从来没见过面，但是你们在互联网上有过思想的碰撞，这就已经足够了。</p>

<p><strong>书写就是很好的思考</strong>。当你想熟练掌握一项技能，请将你的技术分享出来吧。</p>

<p><strong>写的过程中也是学习</strong>。当你能把一项技术讲清楚，说明你已经完全理解了。</p>

<p><strong>你的博客将比简历更有价值</strong>。你在各大招聘网站写简历不如你有一个有价值的博客。</p>

<p>把技术分享出来，不仅帮助新人，更是提高自己，这是一种双赢。如果你写了技术文章没有好的地方可以发布，可以投稿给我：<a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x77;&#111;&#114;&#108;&#100;&#108;&#x69;&#103;&#x61;&#x6e;&#103;&#x40;&#49;&#x36;&#51;&#46;&#99;&#111;&#x6d;">&#119;&#x6f;&#114;&#x6c;&#100;&#108;&#105;&#x67;&#97;&#110;&#103;&#x40;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#109;</a> 我将发布在我的公众号iOS开发（<strong>iOSDevTip</strong>）上，直接分享给上万名iOS开发者。</p>

<h3>看github开源项目</h3>

<p>github对于程序员来说，可谓是一个金库。很多优秀的人才，都在上面开源自己的项目。这些人都是伟大的。</p>

<p>当你想实现一个功能，很有可能有一些大牛已经实现了。与其我们写出蹩脚代码来实现，不如去阅读大牛们在github上的开源项目。去看大牛是怎么实现的？思路是什么？如果是你你会怎么写？经过这样的思考之后，比你自己去实现重要的多。</p>

<p>如果你自己就是大牛，那就另说了。你可以实现之后，把代码分享到github，帮助更多人。</p>

<h3>实现自己的想法</h3>

<p>一个不想当老板的程序员不是好程序员。谁不想成为马云呢，谁不想改变世界呢。所以，你要敢想，然后通过自己的技术去实现它。</p>

<p>有些人可能以为：在公司里上班，去想做个什么东西，就是对老板不忠。这是一个很严重的错误想法。</p>

<p>在大公司，都是支持内部创业的。如果你有好的想法，尽管去干吧。说不定第一个天使投资人就是你的老板。屌丝逆袭说不定从此开始。</p>

<p>行了，醒醒，有想法更要有行动。</p>

<p>按照我们老师的话说：成为一名优秀的iOS开发工程师任重而道远！这句话也送给你。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Command – 命令模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/"/>
    <updated>2015-06-21T23:39:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi</id>
    <content type="html"><![CDATA[<p><strong>命令模式</strong>封装一个请求或行为作为一个对象。封装的请求比原的更加灵活，可以在对象之间传递，储存，动态修改，或放入一个队列。苹果的Target-Action调用机制已经实现了命令模式。</p>

<p>你可以查看跟多关于<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html">Target-Action</a>的苹果官方文档，
NSInvocation包含一个target对象，一个方法和一些参数。这个对象可以按需要动态修改。这是一个非常好的命令模式的列子。减少发送对象和接受对象之间的操作，直接写成一个请求或请求链。</p>

<h3>如何用命令模式</h3>

<p>调用之前，你需要设置取消动作的框架。所以你需要定义一个UIToolBar和NSMutableArray保存需要撤销的堆栈。</p>

<p>添加代码到ViewController.m 文件：</p>

<pre><code>    UIToolbar *toolbar;
// We will use this array as a stack to push and pop operation for the undo option
    NSMutableArray *undoStack;
</code></pre>

<p>创建一个toolbar将显示新的动作按钮，以及一个数组作为命令队列。</p>

<p>将下面的代码添加到viewDidLoad：</p>

<pre><code>  toolbar = [[UIToolbar alloc] init];
UIBarButtonItem *undoItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemUndo target:self action:@selector(undoAction)];
undoItem.enabled = NO;
UIBarButtonItem *space = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];
UIBarButtonItem *delete = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemTrash target:self action:@selector(deleteAlbum)];
[toolbar setItems:@[undoItem,space,delete]];
[self.view addSubview:toolbar];
undoStack = [[NSMutableArray alloc] init];
</code></pre>

<p>上面的代码创建了一个toolbar和两个按钮，它还创建一个空的撤消堆栈。这里的撤销按钮被禁用因为撤销栈为空。</p>

<p>将下面代码添加到ViewController.m：</p>

<pre><code>- (void)viewWillLayoutSubviews
{
    toolbar.frame = CGRectMake(0, self.view.frame.size.height-44, self.view.frame.size.width, 44);
    dataTable.frame = CGRectMake(0, 130, self.view.frame.size.width, self.view.frame.size.height - 200);
}
</code></pre>

<p>在ViewController.m增加三个方法：增加、删除、撤销。</p>

<p>增加一个新专辑代码如下：</p>

<pre><code>- (void)addAlbum:(Album*)album atIndex:(int)index
{
    [[LibraryAPI sharedInstance] addAlbum:album atIndex:index];
    currentAlbumIndex = index;
    [self reloadScroller];
}
</code></pre>

<p>在这里你添加相册，将其设置为当前专辑索引，并重新加载。</p>

<p>接下来就是删除方法：</p>

<pre><code>- (void)deleteAlbum
{
    // 1
    Album *deletedAlbum = allAlbums[currentAlbumIndex];

    // 2
    NSMethodSignature *sig = [self methodSignatureForSelector:@selector(addAlbum:atIndex:)];
    NSInvocation *undoAction = [NSInvocation invocationWithMethodSignature:sig];
    [undoAction setTarget:self];
    [undoAction setSelector:@selector(addAlbum:atIndex:)];
    [undoAction setArgument:&amp;deletedAlbum atIndex:2];
    [undoAction setArgument:&amp;currentAlbumIndex atIndex:3];
    [undoAction retainArguments];

    // 3
    [undoStack addObject:undoAction];

    // 4
    [[LibraryAPI sharedInstance] deleteAlbumAtIndex:currentAlbumIndex];
    [self reloadScroller];

    // 5
    [toolbar.items[0] setEnabled:YES];
}
</code></pre>

<p>这是一段新的令人激动的代码，讲解如下：</p>

<ol>
<li>得到要删除的专辑信息</li>
<li>Define an object of type NSMethodSignature to create the NSInvocation, which will be used to reverse the delete action if the user later decides to undo a deletion. The NSInvocation needs to know three things: The selector (what message to send), the target (who to send the message to) and the arguments of the message. In this example the message sent is delete’s opposite since when you undo a deletion, you need to add back the deleted album.</li>
<li>After the undoAction has been created you add it to the undoStack. This action will be added to the end of the array, just as in a normal stack.</li>
<li>Use LibraryAPI to delete the album from the data structure and reload the scroller.</li>
<li><p>Since there’s an action in the undo stack, you need to enable the undo button.</p>

<pre><code> 提示: With NSInvocation, you need to keep the following points in mind:

 The arguments must be passed by pointer.
 The arguments start at index 2; indices 0 and 1 are reserved for the target and the selector.
 If there’s a chance that the arguments will be deallocated, then you should call retainArguments.
</code></pre></li>
</ol>


<p>最后，添加撤销方法：</p>

<pre><code>- (void)undoAction
{
    if (undoStack.count &gt; 0)
    {
        NSInvocation *undoAction = [undoStack lastObject];
        [undoStack removeLastObject];
        [undoAction invoke];
    }

    if (undoStack.count == 0)
    {
        [toolbar.items[0] setEnabled:NO];
    }
}
</code></pre>

<p>这个撤销操作是取消栈里最后一个对象，This object is always of type NSInvocation and can be invoked by calling … invoke. This invokes the command you created earlier when the album was deleted, and adds the deleted album back to the album list. Since you also deleted the last object in the stack when you “popped” it, you now check to see if the stack is empty. If it is, that means there are no more actions to undo. So you disable the Undo button.</p>

<p>运行你的app，测试撤销功能，删除一个专辑（或两个）然后点击撤销按钮看看效果：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage4.png" alt="1" /></p>

<p>这也是一个很好的地方来测试是否你的相册数据保留会变化。现在，如果你删除一个专辑，app退到后台，并终止应用程序，在下次启动应用程序显示的专辑列表不会有删除专辑信息。</p>

<p>这里的源代码完成的项目：<a href="cdn2.raywenderlich.com/wp-content/uploads/2013/08/BlueLibrary-final.zip">最后bluelibrary</a></p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Archiving – 归档模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/"/>
    <updated>2015-06-20T06:54:13+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi</id>
    <content type="html"><![CDATA[<p><strong>备忘录模式</strong>就是苹果中一种归档形式。它能够把对象转化成一种数据流，在不依赖于外部类的私有属性的情况下来存储和取出数据。你可以在 iOS 6 by Tutorials 这本书的第 16 章读到更多的相关信息。或者这里 Apple’s Archives and Serializations Programming Guide。</p>

<h3>如何使用归档 Archiving</h3>

<p>首先，你需要声明 Album，用 NSCoding 协议来归档数据。打开 Album.h 文件，修改 @ interface 行如下：</p>

<pre><code>@interface Album : NSObject &lt;NSCoding&gt;
</code></pre>

<p>在 Album.m 添加下面两个方法：</p>

<pre><code>- (void)encodeWithCode:(NSCode *)aCoder
{
    [aCode encodeObject:self.year forKey:@“year”];
    [aCode encodeObject:self.title forKey:@“album”];
    [aCode encodeObject:self.artist forKey:@“artist”];
    [aCode encodeObject:self.coverUrl forKey:@“cover_url”];     [aCode encodeObject:self.genre forKey:@“genre”];
}

- (id)initWithCode:(NSCode *)aDecoder
{
    self = [super init];
    if (self) {
        _year = [aDecoder decodeObjectForKey:@“year”];
        _title = [aDecoder decodeObjectForKey:@“album”];
        _artist = [aDecoder decodeObjectForKey:@“artist”];
        _coverUrl = [aDecoder decodeObjectForKey:@“cover_url”];
        _genre = [aDecoder decodeObjectForKey:@“genre”];
    }
    return self;
}
</code></pre>

<p>当你存档这个类的实例时调用 encodeWithCoder:。相反，当你通过解档来创建一个 Album 实例时，需要调用 iniWithCode: 。就这么简单，非常强大。</p>

<p>现在 Album 类可以存档了，添加的代码实际上是存储和加载专辑列表的。</p>

<p>在 PersistencyManger.h 里添加下面方法：</p>

<pre><code>- (void)saveAlbums;
</code></pre>

<p>当存储专辑的时候调用些方法。</p>

<p>现在，在 PersistencyManger.m 里添加方法实现：</p>

<pre><code>- (void)saveAlbums
{
    NSString *filename = [NSHomeDirectory() stringByAppendingString:@“/Document/albums.bin”];
    NSData *data = [NSKeyedArchiver archivedDataWithRootObject:albums];
    [data writeToFile:filename atomically:YES];
}
</code></pre>

<p>NSKeyedArchiver 把专辑数组存档进一个叫 album.bin 的文件里。</p>

<p>当你存档的一个对象包含另一个对象的时候，存档自动递归的把子对象、子对象的子对象一并存储。在这个实例里，存储的是一个专辑实例的数组。因为数组和 Album 都支持 NSCopying 的接口，数组里的东西都会被自动存档。</p>

<p>现在用下面代码替换 PersistencyManger.m 里的 init 方法：</p>

<pre><code>- (id)init
{
    self = [super init];
    if (self) {
        NSData *data = [NSData dataWithContentsOfFile:[NSHomeDirectory() stringByAppendString:@“/Document/albums.bin”]];
        albums = [NSKeyedUnarchiver unarchiveObjectWithData:data];
        if (albums == nil) {
            albums = [NSMutableArray arrayWithArray:
                 @[[[Album alloc] initWithTitle:@"Best of Bowie" artist:@"David Bowie" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png" year:@"1992"],
                 [[Album alloc] initWithTitle:@"It's My Life" artist:@"No Doubt" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png" year:@"2003"],
                 [[Album alloc] initWithTitle:@"Nothing Like The Sun" artist:@"Sting" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png" year:@"1999"],
                 [[Album alloc] initWithTitle:@"Staring at the Sun" artist:@"U2" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png" year:@"2000"],
                 [[Album alloc] initWithTitle:@"American Pie" artist:@"Madonna" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png" year:@"2000"]]];
                [self saveAlbums];
        }
    }
    return self;
}
</code></pre>

<p>在新代码里，如果文件存在，NSKeyedUnarchiver 就从文件加载专辑数据。如果不存在，它就创建专辑数据，然后立即存储，为下一次启动 app 使用。</p>

<p>当然你也可以在 app 后台运行的时候再存储专辑数据。现在它看起来不是很有必要，但如果你在稍后添加修改专辑数据呢？你需要确保所有的数据修改都会被存储。</p>

<p>在 LibraryAPI.h 添加下面的方法</p>

<pre><code>- (void)saveAlbums;
</code></pre>

<p>因为程序的所以有服务都需要通过 LibraryAPI 提供，这就是程序为什么需要 PersistenrcyManger 来存储专辑数据。</p>

<p>现在在 LibraryAPI.m 中添加实现方法：</p>

<pre><code>- (void)saveAlbums
{
    [persistencyManger saveAlbums];
}
</code></pre>

<p>这里是从 LibraryAPI 调用 PersistencyManger 来存储专辑。</p>

<p>在 ViewController.m 文件 saveCurrentState 的后面添加下面代码：</p>

<p>[[LibraryAPI sharedInstance] saveAlbums];</p>

<p>上面的代码是每当 ViewController 存储当前状态时，使用 LibraryAPI 来存储专辑数据。</p>

<p>构建你的 app，检查所有的都能正确编译。</p>

<p>不幸的是，没有一种简单的方法来验证数据是否被正确的创建。你可以在 Finder 里检查模拟器下当前 app 的 Documents 文件夹，来看看专辑数据文件是否被创建，但是为了查看其它变化你还需要添加一些数据来改变专辑数据。</p>

<p>但是，为了修改数据，假使为了删除专辑而需要临时添加一个删除选项，但这个选项并不会一直在你的库中存在？此外，由于误操作，错误的删除了一个专辑，但如果给这个操作添加一个撤消选项不是很好吗？</p>

<p>现在是时候讨论最后一个设计模式了：<a href="http://www.superqq.com/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/">命令 Command</a>。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Memento – 备忘录模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/"/>
    <updated>2015-06-19T06:31:19+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi</id>
    <content type="html"><![CDATA[<p><strong>备忘录模式</strong>是捕获和具体化当前对象的内部状态。换句话说，就是在某个地方存储个东西。稍后，在不违反封装的情况下能够恢复这个具体化的状态；就是说，一些私有数据被私下存储下来了。</p>

<h3>如何使用备忘录模式</h3>

<p>添加下面两个方法到 ViewController.m 文件：</p>

<pre><code>- (void)saveCurrentState
{
    // 当用户退出应用之后再重新打开，他想要跟他之前退出时一样的状态
    // 退出应用，这个时候我们需要做的是把当前显示的专辑存储下来
    // 因为只有一小片信息，我们可用 NSUserDefaults 来存储信息
    [[NSUserDefaults standardUserDefaults] setInteger:currentAlbumIndex forKey:@“currentAlbumIndex”];
}

- (void)loadPreviousState
{
    currentAlbumIndex = [[NSUserDefaults standardUserDefaults] integerForKey@“currentAlbumIndex”];
    [self showDataForAlbumAtIndex:currentAlbumIndex];
}
</code></pre>

<p>saveCurrentState 存储当前专辑的索引到 NSUserDefaults ─ NSUserDefaults 是一个标准数据存储，iOS 用来专门存放程序设置和数据。</p>

<p>loadPreviousState 加载这之前存储的专辑索引。这不是备忘录模式的全部，不过你已经达到目的了。</p>

<p>现在，在 ViewController.m 里，滚动视图初始化之前，在 viewDidLoad 里添加下面一行：</p>

<pre><code>[self loadPreviousState];
</code></pre>

<p>当程序启动的时候加载上一次存储的状态。但是你在哪里存储程序的当前状态呢？你需要使用通知来做这样的事情。当程序进入后台时，iOS 会发送一个 UIApplicationDidEnterBackgroundNotification 通知。你可利用这个通知调用 saveCurrentState。就这么方便？</p>

<p>在 viewDidLoad: 最后面添加下面一行</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(saveCurrentState) name:UIApplicationDidEnterBackgroundNotification object:nil];
</code></pre>

<p>现在，当你的 app 进入后台运行后，ViewController 会自动调用 saveCurrentState 存储当前的状态。</p>

<p>现在，添加下面代码：</p>

<pre><code>- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}
</code></pre>

<p>这里是确保当 ViewController 被释放时，移除类的 <a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">Observer</a>。</p>

<p>构建和运行你的 app，点击到一个专辑，用 Command+Shift+H（如果你使用的是模拟器的话） 将程序在后台运行，然后关掉 app。重启 app，检查之前选择的专辑是不是居中显示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/2013-09-02_10-51-27-214x320.png" alt="1" /></p>

<p>专辑数据看起来是对的，但是正确的专辑封面确没有居中，哪出问题了？</p>

<p>这就是可选方法 initialViewIndexForHorizontalScroller 的用处！因为这个方法没有被委托执行，ViewController 在这种情况下总是会显示默认的第一个专辑封面。</p>

<p>修复这个问题，在 ViewController.m 中添加如下代码：</p>

<pre><code>- (NSInteger)initialViewIndexForHorizontalScroller:(HorizontalScroller *)scroller
{
    return currentAlbumIndex;
}
</code></pre>

<p>现在 HorizontalScroller 的第一个视图总是会被设置成 currentAlbumIndex 索引的图片。这种方法能够确保你的 app 有一个非常棒的用户体验，并且它是可恢复的。</p>

<p>重新运行你的 app，滚动专辑封面，关闭 app，然后重启确保问题已经得到解决：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/2013-09-02_10-56-59-214x320.png" alt="2" /></p>

<p>如果你查看 PersistencyManger 的初始化方法，你会注意到专辑的数据是一种硬编码，PersistencyManger 每次创建，数据也会重复创建一次。有没有一种更好的方法当专辑列表被创建的时候就存储它们呢。那么如何把专辑数据存储到文件里呢？</p>

<p>一种选择就是循环访问 Album 的属性，然后把它存储在一个 plist 文件里，当需要它们的时候重新创建一个 Album 的实例。这不是最好的选择，这需要你在每一个类里根据不同的数据或属性写特定的代码。例子，如果稍后你需要一个电影的类，里面有一些不同的属性，存储和加载这些数据你就需要写一些新的代码。</p>

<p>此外，你不能在每一个类的实例里存储私有变量，因为他们是不可访问的外部类。这就是为什么苹果要创建归档 (Archiving) 机制。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Observer – 观察者模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/"/>
    <updated>2015-06-18T10:14:51+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>在<strong>观察者模式</strong>中，当状态发生改变的时候，一个对象会通知另一个对象。这个对象不需要知道另一个对象发生了什么改变─因此非常鼓励这种分离式的设计。这种模式经常用于，当一个属性发生改变时通知跟它相关的对象。</p>

<p>它通常需要一个观察者(observer)注册跟踪另外一个对象的状态。当状态发生改变的时候，所有的观察对象都会被通知改变。苹果的推送通知服务就是一个这样的例子。</p>

<p>如果你想要一直使用 <a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">MVC 模式</a>（你确实需要），你如果想在模型和视图之间，不直接相互引用的情况下还要有通信。这时候就要用到观察者模式了。</p>

<p>Cocoa 有两个常用的方法来执行观察者模式：Notifications 和 Key-Value Observing (KVO)。</p>

<h3>通知 Notifications</h3>

<p>不要把它和推送、本地通知弄混淆了，通知是基于一个对象（信息发布者）发信息给另一个对象（订阅/监听）的订阅-发布模式的。信息发布者不需要知道任何关于订阅者的信息。</p>

<p>苹果大量的使用了通知。例子，当键盘打开/关闭的时候，系统会分别发送一个 UIKeyboardWillShowNotification/UIKeyboardWillHideNotification。当你的程序要退出的时候，系统会发送一个 UIApplicationDidEnterBackgroundNotification 通知。</p>

<pre><code>提示：打开 UIApplication.h，在文件最后你会看见系统能发送的通知列表有 20 个之多。
</code></pre>

<h3>如何使用通知 Notifications</h3>

<p>打开 AlbumView.m 文件，在 initWithFrame:albumCover: 里面的 [self addSubview:indicator] 后面插入下面代码：</p>

<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:@“BLDownloadImageNotification” object:self userInfo:@{@“imageView”:coverImage, @“coverUrl”:albumCover}];
</code></pre>

<p>这行代码是通过 NSNotificationCenter 单例来发送一个通知。通知内容包括 coverImage 图片视图 和下载封面图片的 URL。这是执行下载专辑封面所需的所有信息。</p>

<p>在 LibraryAPI.m 的 init 方法里，isOnline = NO; 后面添加下面代码：</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downImage:) name:@“BLDownloadImageNotification” object:nil];
</code></pre>

<p>这是等式另一边的观察者对象。任何时候只要 AlbumView 类发送一个 BLDownloadImageNotification 通知，系统就会通知 LibraryAPI，因为 LibraryAPI 已经注册了一个相同的观察者通知。qLibraryAPI 执行 downloadImage:。</p>

<p>不管任何时候，在你执行 downloadImage: 之前，一定要记住在你释放这个类的时候一定要取消这个通知的订阅。如果你不正确的取消一个通知的订阅，这个通知可能发送一个已经释放的实例。这会造成你的程序崩溃。</p>

<p>在 LibraryAPI.m 里添加下面代码：</p>

<pre><code>- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removerObserver:self];
}
</code></pre>

<p>当这个类释放后，移除一个观察者自己已经注册的所有通知。</p>

<p>这里还有一件事情要做。它可以把下载过的封面图片存在本地，这样 app 就不用一次又一次的下载同一个图片了。</p>

<p>打开 PersistencyManger.h 添加下面两个方法：</p>

<pre><code>- (void)saveImage:(UIImage*)image filename:(NSString*)filename;
- (UIImage*)getImage:(NSString*)filename;
</code></pre>

<p>在 PersistencyManger.m 中实现：</p>

<pre><code>- (void)saveImage:(UIImage*)image filename:(NSString*)filename
{
    filename = [NSHomeDirectory() stringByAppendingFormat:@“/Documents/%@”, filename];
    NSData *data = UIImagePNGRepresentation(image);
    [data writeToFile:filename atomically:YES];
}

- (UIImage*)getImage:(NSString*)filename 
{
    filename = [NSHomeDirectory() stringByAppendingFormat:@“/Documents/%@“, filename];
    NSData *data = [NSData dataWithContentsOfFile:filename];
    return [UIImage imageWithData:data];
}
</code></pre>

<p>这里的代码很简单。下载完成的图片会被存储进 Documents 文件夹中，如果没有跟 filename 相匹配的文件，getImage: 会返回 nil。</p>

<p>现在在 LibraryAPI.m 里面添加下面方法：</p>

<pre><code>- (void)downImage:(NSNotification*)notification
{
    // 1 
    UIImageView *imageView = notification.userInfo[@“imageView”];
    NSString *coverUrl   = notification.userInfo[@“coverUrl”];

    // 2
    imageView.image = [persistencyManger getImage:[coverUrl lastPathComponent];

    if (imageView.image == nil) {
        // 3 
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            UIImage *image = [httpClient downloadImage:coverUrl];
            dispatch_sync(dispatch_get_main_queue(), ^{
                imageView.image = image;
                [persistencyManger saveImage:image filename:[coverUrl lastPathComponent];
            });
        });
    }
}
</code></pre>

<p>现在来分析上面的代码：</p>

<ol>
<li>通知执行 downloadImage 方法，方法接受这个这个通知对象，就像它是一个变量一样。通知里会传递 UIImageView 和图片的 URL。</li>
<li>如果以前已经下载过，就从 PersistencyManger 里取出图片。</li>
<li>如果图片没有下载过，使用 HTTPClient 开始下载图片。</li>
<li>当下载完成的时候，在图片视图中显示图片，用 PersistencyManger 存储它到本地。</li>
</ol>


<p>此外，你用外观模式(Facade pattern)隐藏了另外一个下载图片的复杂类。通知发送者不关心图片的来源，不管是从网上下载的还是本地存储的。</p>

<p>构建和运行你的 app，可以看到漂亮的封面已经出现在 HorizontalScroller 里面了：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-4-297x320.png" alt="1" /></p>

<p>停止你的 app，然后再运行它。注意这里显示封面已经没有延时了，因为它们已经下载到本地了。你可断开网络试试，你的 app 同样可以完美的运行。虽然已经很完美了，但是仍然有一个小问题：就是下载提示的小菊花仍然一直在转动，从来没有停止过！哪里出问题了？</p>

<p>当你开始下载图片的时候，你运行了下载提示符，但当图片下载完成的时候，你没有停止下载提示符的方法。你也可以当每个图片下载完成的时候再发送一个通知，当然另一个代替方案，你可以使用另一种观察者模式，KVO。</p>

<h3>键 – 值 观察 (Key-Value Observing KVO)</h3>

<p>在 <a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">KVO</a>  里，一个对象的任何一个特别的属性改变后都可以请求一个通知；不管是它自己的还是其它的对象。如果你感兴趣，你可以在这里读到更多的信息：Apple’s KVO Programming Guide.</p>

<h3>如何使用 KVO 模式</h3>

<p>如上所述，<a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">KVO</a> 的原理是允许一个对象观察一个属性的改变。你所要关心的是，使用 KVO 观察 UIImageView 的 image 属性是否已经改变，就是它是否已经存储了图片。</p>

<p>打开 AlbumView.m，在 initWithFrame:albumCover: 里的 [self addSubview:indicator]; 后面添加下面代码：</p>

<pre><code>[coverImage addObserver:self forKeyPath:@“image” options:0 context:nil];
</code></pre>

<p>不添加在自己上面(self)，在当前的类里，观察 coverImage 的 image 属性。</p>

<p>当你使用过后，你同样需要注销这个观察(observer)。继续在当前文件里面添加下面代码：</p>

<pre><code>- (void)dealloc
{
    [coverImage removerObserver:self forKeyPath:@“image”];
}
</code></pre>

<p>最后，添加下面方法：</p>

<pre><code>- (void)observerValueForKeyPath:(NSString*)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    if ([KeyPath isEqualToString:@“image”])
    {
        [indicator stopAnimating];
    }
}
</code></pre>

<p>你必须在每个类里执行这个方法。如果观察的属性改变了，系统每次都会执行这个方法。上面的代码里，当 image 的属性发生改变时，你停止下载提示符的运行。这种方法，当图片下载完成，下载提示转动的小菊花将会停止转动。</p>

<p>构建个运行你的项目。你会看到小菊花已经不在了：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage3-287x320.png" alt="2" /></p>

<pre><code>提示：永远记住，当你释放内存，你一定要移除这些观察(observers)，或者是当你的程序发送这些不存的观察对象时会造成程序崩溃。
</code></pre>

<p>如果你玩弄一会你的 app，然后关闭它，你程序的当前状态并没有被存储下来。当程序启动的时候你看到的视图并不是上次退出时的样子。</p>

<p>为了更正这些，你需要使用下一项设计模式：备忘录 (Memento)。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[上海iOS开发工资待遇如何？]]></title>
    <link href="http://www.superqq.com/blog/2015/06/17/shang-hai-ioskai-fa-gong-zi-dai-yu-ru-he-%3F/"/>
    <updated>2015-06-17T23:25:30+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/17/shang-hai-ioskai-fa-gong-zi-dai-yu-ru-he-?</id>
    <content type="html"><![CDATA[<p><strong>上海iOS开发</strong>工资待遇如何呢？一般来说，上海iOS开发的工资还算相对不错的，毕竟是一线城市的魔都，整体来说还算可以。</p>

<p>上海<a href="http://www.superqq.com/blog/2014/12/27/ioskai-fa-zhong-de-gcdduo-xian-cheng-tips/">iOS开发</a>起步薪资大概在5k~8k吧，如果你技术好，在大学里面就是学霸，对计算机也非常精通，超过8k，也不是完全没有可能的。5k~8k只是一个参考值，主要还是靠自己。</p>

<p>对于工作一两年的上海iOS开发者朋友们来说，工资应该在8k~15k。也就是说，上海iOS开发者有一两年工作经验，工资很轻松过五位数。</p>

<p>做一位一名程序员，工作过五位数很正常，尤其是上海iOS开发程序员。</p>

<p>当你在上海做iOS开发三四年以上，而且你的技术确实有牛C，这个时候，工资完全可以突破2万。2万对于程序员来说是一个重要的标志，上海iOS开发程序员也不例外。2万说明你应该是一名很不错的程序员了。</p>

<p>以上是上海iOS开发工资的一个参考，具体可以根据实际<a href="http://www.superqq.com/blog/2015/06/04/mian-shi-guan-wen-xian-zai-gong-zi-shi-duo-shao-gai-zen-yao-hui-da/">面试</a>情况来谈你的工资。</p>

<p>上海iOS开发需求量也很大，所以对于想进入iOS开发行业的人来说，上海iOS开发职位是一个很不错的选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Adapter – 适配器模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/"/>
    <updated>2015-06-17T14:24:04+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>注：本节有点长，并且有些难度，希望大家有毅力看下去。</p>

<p>一个适配器允许接口不兼容的类在一起工作。它把它自己包裹成一个对象，公开一个与这个对象相互作用的标准接口。</p>

<p>如果你熟习<strong>适配器模式</strong>，你会注意到苹果实施它的时候有一点不同的习惯─苹果使用协议 (protocols)。你可能熟习像 UITableViewDelegate, UIScrollViewDelegate, NSCoding 和 NSCopying 这样的协议。例子，NSCopying 的协议 (protocol)，任何类都可以提供这样一个标准的复制方法。</p>

<h3>如何使用适配器模式</h3>

<p>我们提到的滚动区域是这样的：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/protocol1.png" alt="1" /></p>

<p>现在开始，在项目导航的 View 文件夹上右击鼠标，选择 New File…，用 iOS\Cocoa Touch\Object-C class 模板创建一个新类。新类的名字叫 HorizontalScroller，选择它的子类为 UIView。</p>

<p>打开 HorizontalScroller.h 文件在 @end 后面插入如下代码：</p>

<pre><code>@protocol HorizontalScrollerDelegate &lt;NSObject&gt;
// methods declaration goes in here
@end
</code></pre>

<p>这里定义一个 HorizontalScrollerDelegate 名字的协议，它继承于 NSObject 协议，同样的这是继承它父类的一个 Objective-C 类。符合 NSObject 协议，这是一个很好的做法─或者遵照 NSObject 协议。这能使你从定义的 NSObject 发送消息到 HorizontalScroller 的代理。你将会看到为什么这很重要。</p>

<p>定义个代理执行的方法，要在 @protocol 和 @end 之间，它们分为必要方法和可选方法。添加下面协议方法：</p>

<pre><code>@required
// 询问 delegate 在滚动区域里有多少个视图要被显示
- (NSInteger)numberOfViewsForHorizontalScroller:    (HorizontalScroller*)scroller;

// 返回索引是 index 的视图
- (UIView*)horizontalScroller:(HorizontalScroller*)scroller viewAtIndex:(int)index;

// 当索引是 index 的视图被点击了，通知 delegate 
- (void)horizontalScroller:(HorizontalScroller*)scroller clickedViewAtIndex:(int)index;

@optional
// 通知 delegate，显示初始化时索引是 Index 的视图。这个方法是可选的
// ask the delegate for the index of the initial view to display. this method is optional
// 如果没有被 delegate 执行，默认值是 0
- (NSInteger)initialViewIndexForHorizontalScroller:(HorizontalScroller*)scroller;
</code></pre>

<p>这里我们必选的和可选的方法我们都定义了。必选方法一定要被代理执行，它通常包含一些类必须要执行的数据。这里，必选方法是获取视图的数量，当前显示视图的索引和当视图被点击的时候执行的操作。可选方法这里是初始化视图；如果没有执行 HorizontalScroller 将会显示第一个索引的视图。</p>

<p>接下来，你需要在 HorizontalScroller 内部定义你的新代理。但是协议的定义在类的定义下面，因此在这点上它是不可见的。你该怎么办？</p>

<p>解决办法就是在前面声明协议以便于编译器（和Xcode）知道这个协议是可用的。好了，在 @interface 上面加入下面代码：</p>

<pre><code>@protocol HorizontalScrollerDelegate;
</code></pre>

<p>还是 HorizontalScroller.h，在 @interface 和 @end 之间加入下面代码：</p>

<pre><code>@property (weak) id&lt;HorizontalScrollerDelegate&gt; delegate;
- (void)reload;
</code></pre>

<p>这个属性被定义成为一个 weak。这是为了防止循环 retain。如果一个类保持一个强指针(strong pointer)指向它的委托(delegate)，同时委托也保持一个强指针指向这个类，在释放类所占用的内存时会造成 app 内存泄漏。</p>

<p>id 的意思是把这个代理指定给一个类，它遵照 HorizontalScrollerDelegate，给你一些类型安全。</p>

<p>reload 方法是模仿 UITableView 类的 relaodData；它重新加载所有数据用来创建一个水平移动视图。</p>

<p>用下面代码替换 HorizontalScroller.m 的内容：</p>

<pre><code>#import “HorizontalScroller.m”

#define VIEW_PADDING 10
#define VIEW_DIMENSIONS 100
#define VIEW_OFFSET 100

@interface HorizontalScroller () &lt;UIScrollViewDelegate&gt;
@end

@implementation HorizontalScroller
{
    UIScrollView *scroller;
}
@end
</code></pre>

<p>来解释下每块代码：</p>

<ol>
<li>常量定义，在设计时间可以方便修改布局。在滚动视图内，每个图片的大小在一个 100×100 内边距为 10 点(point) 的矩形内。</li>
<li>HorizontalScroller 遵照 UIScrollViewDelegate 协议。因为 HorizontalScroller 使用一个 UIScrollView 来滚动专辑封面，它需要知道用户什么时候停止滚动。</li>
<li>创建一个包含图片的滚动视图。</li>
</ol>


<p>接下来你需要执行初始化。添加下面的方法：</p>

<pre><code>- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        scroller = [[UIScrollerView alloc] initWithFrame:CGRectMake(0, 0, frame.size.width, frame.size.height)];
        scroller.delegate = self;
        UITapGestureRecognizer *tapRecognizer = [[UITapGestureRecognizer alloc] initWithTarger:self action:@select(scrollerTapped:)];
        [scroller addGestureRecognizer:tapRecognizer];
    }
    return self;
}
</code></pre>

<p>HorizontalScroller 将被滚动视图整个填充。如果一个专辑封面被点击，UITapGestureRecognizer 将会监听它上面的事件。如果有，它会通知 HorizontalScroller 的代理。</p>

<p>现在添加下面方法：</p>

<pre><code>- (void)scrollerTapped:(UITapGestureRecognizer*)gesture
{
    CGPoint location = [gesture locationInView:gesture.view];
    // we can’t use an enumerator here, because we don’t want to enumerate over ALL of the UIScrollView subviews.
    // we want to enumerate only the subview that we added
    for (int index=0; index&lt;[self.delegate numberOfViewForHorizontalScroller:self]; index++) {
        UIView *view = scroller.subviews[index];
        if (CGRectContainsPoint(view.frame, location)) {
            [self.delegate horizontalScroller:self clickedViewAtIndex:index];
            [scroller setContentOffset:CGPointMake(view.frame.origin.x - self.frame.size.width/2 + view.frame.size.width/2, 0) animated:YES];
            break;
        }
    }
}
</code></pre>

<p>手势操作就如同传入的一个参数，可以从 locationInView: 获取定位信息。</p>

<p>接下来，调用委托的 numberOfViewForHorizontalScroller: 方法。它必须遵照 HorizontalScrollerDelegate 的协议安全发送消息，否则 HorizontalScroller 实例的代理是没法使用这些信息。</p>

<p>滚动视图里的每个视图，用 CGRectContainsPoint 执行一个点击测试，找到那个被点击的视图。当视图被找到，发送给委托一个消息 horizontalScroller:clickedViewAtIndex:。当你跳出这个循环后，设置被点击的视图滚动到视图中间。</p>

<p>现在添加下面的代码，用来刷新滚动视图(scroller):</p>

<pre><code>- (void)reload
{
    // 1 - nothing to load if there’s no delegate
    if (self.delegate == nil) return;

    // 2 - remover all subviews
    [scroller.subviews enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        [obj removeFromSuperview];
    }

    // 3 - xValue is the starting point of the views inside the scroller
    CGFloat xValue = VIEWS_OFFSET;
    for (int i=0; i&lt;[self.delegate numberOfViewsForHorizontalScroller:self]; i++) {
        // 4 - add a view at the right position
        xValue += VIEW_PADDING;
        UIView *view = [self.delegate horizontalScroller:self viewAtIndex:i]
        view.frame = CGRectMake(xValue, VIEW_PADDING, VIEW_DIMENSIONS, VIEW_DIMENSIONS);
        xValue += VIEW_DIMENSIONS + VIEW_PADDING;
    }

    // 5
    [scroller setContentSize:CGSizeMake(xValue+VIEWS_OFFSET, self.frame.size.height)];

    // 6 - if an initial view is defined, center the scroller on it
    if (self.delegate respondsToSelector:@select(initialViewIndexForHorizontalScroller:)]) {
        int initialView = [self.delegate initialViewIndexForHorizontalScroller:self];
        [scroller setContentOffset:CGPointMake(initialView*(VIEW_DIMENSIONS+(2*VIEW_PADDING)), 0) animated:YES];
    }
}
</code></pre>

<p>能过代码一步步来讨论：</p>

<ol>
<li>如果没有代理，这里什么事情也不做。</li>
<li>移除之前添加的所有的子视图。</li>
<li>给所有视图设置一个偏移(offset)位置。现在的是 100，但是通过顶部的 #define，它很容易修改。</li>
<li>HorizontalScroller 通过它的委托一次请求一个视图，用之前定义的 padding 值把它们依次的一个个放置下来。</li>
<li>当所有的视图都生成好，通过设置滚动视图内容的偏移量以达到用户能过滚动可以看到所有专辑封面的目的。</li>
<li>HorizontalScroller 的委托需要验证是否响应了 initialViewIndexForHorizontalScroller: 方法。这个验证是必需的，因为这个特别的协议方法是可选性的。如果代理没有执行这个方法，它的默认值会是 0。最终，通过委托，这块代码会在滚动视图中间设置一个初始化好的视图。</li>
</ol>


<p>当数据发生改变的时候执行 reload 方法。当添加 HorizontalScroller 到别个一个视图时，你同样可以执行这个方法。在 HorizontalScroller.m 添加下面的代码替换后面的方案：</p>

<pre><code>- (void)didMoveToSuperview
{
    [self reload];
} 
</code></pre>

<p>当它要添加一个子视图的时候，didMoveToSuperview 会发送消息给视图。这时正好可以更新滚动视图的内容。</p>

<p>HorizontalScroller 的最后一个难题就是，如何设置你看到的专辑总是在滚动视图的中间。为了这些，当用户通过他们的手指拖动滚动视图的时候你就需要做一些计算了。</p>

<p>添加下面方法（同样在 HorizontalScroller.m）：</p>

<pre><code>- (void)centerCurrentView {
    int xFinal = scroller.contentOffset.x + (VIEWS_OFFSET/2) + VIEW_PADDING;
    int viewIndex = xFinal / (VIEW_DIMENSIONS + (2*VIEW_PADDING));
    xFinal = viewIndex * (VIEW_DIMENSIONS+(2*VIEW_PADDING));
    [scroller setContentOffset:CGPointMake(xFinal, 0) animated:YES];
    [self.delegate horizontalScroller:self clickedViewAtIndex:viewIndex];
}
</code></pre>

<p>上面的代码通过滚动视图的当前偏移量，外观尺寸，内边距来计算当前视图离中心的距离。最后一行非常重要：当一个视图居中后，你需要通知委托你选择的视图改变了。</p>

<p>为了侦测用户在滚动视图内完成拖拽的动作，你需要添加 UIScrollViewDelegate 方法：</p>

<pre><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate
{
    if (!decelerate)
    {
        [self centerCurrentView];
    }
}

- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView
{
    [self centerCurrentView];
}
</code></pre>

<p>当用户完成拖拽的时候 scrollViewDidEndDragging:willDecelerate: 通知委托。如果滚动视图没有停止滚动， decelerate 参数会返回 true。当滚动结束，系统将会调用 scrollViewDidEndDecelerating。当用户拖动滚动当前视图后，两种情况，我们都需要调用一个新方法来使当前视图居中。</p>

<p>HorizontalScroller 现在可以使用了。浏览你刚刚写的代码；这里没有一处提到 Album 和 AlbumView 类。这非常棒，说明这个新的滚动视图是真正的完全独立的和可重用的。</p>

<p>Build 项目，确保所有的代码编译正确。</p>

<p>现在 HorizontalScroller 完成了，是时候在你的 APP 中使用了。打开 ViewController.m 添加如下引用：</p>

<pre><code>#import “HorizontalScroller.h”
#import “AlbumView.h”
</code></pre>

<p>给 ViewController 添加 HorizontalScrollerDelegate：</p>

<p>@interf<!---->ace ViewController () &lt;UITableViewDataSource, UITableViewDelegate, HorizontalScroller></p>

<p>在类的扩展里为水平滚动视图添加如下实例变量：</p>

<p>Horizonta<!---->lScroller *scroller;</p>

<p>现在你可以执行代理方法了；你会惊奇的发现只需要几行代码你就能实现很多功能。</p>

<p>在 ViewController.m 添加如下代码：</p>

<pre><code>#pragma mark - HorizontalScrollerDelegate methods
- (void)horizontalScroller:(HorizontalScroller *)scroller clickedViewAtIndex:(int)index
{
    currentAlbumIndex = index;
    [self showDataForAlbumAtIndex:index];
}
</code></pre>

<p>这里设置一个变量用来存储当前的专辑，然后调用 showDataForAlbumAtIndex: 显示一个新专辑的数据。</p>

<p>提示：一般在方法代码的前面放置 #pragma mark 指示符。编译器会忽略这一行，当你在使用 Xcode 的跳转工具栏(Xcode’s jump bar)查看你的方法列表时，你会看到一个分隔符和个加粗的指示标题。在 Xcode 里，这可以帮助你很容易的组织代码。</p>

<p>下面，添加如下代码：</p>

<pre><code>- (NSInteger)numberOfViewsForHorizontalScroller:(HorizontalScroller *)scroller
{
    return allAlbums.count;
}
</code></pre>

<p>这里，协议方法返回滚动视图里的视图数量。因为滚动视图需要显示所有的专辑封面，这个 count 是所有专辑的数目。</p>

<p>现在，添加这些代码：</p>

<pre><code>- (UIView *)horizontalScroller:(HorizontalScroller *)scroller viewAtIndex:(ini)index
{
    Album *album = allAlbums[index];
    return [[Album alloc] initWithFrame:CGRectMake(0, 0, 100, 100) albumCover:album.coverUrl];
}
</code></pre>

<p>这里你创建了一个新 AlbumView，然后交给 HorizontalScroller 使用。</p>

<p>就是这样，通过三个这么短的方法就可以显示一个漂亮的滚动视图。</p>

<p>实际上，你仍需要创建一个真正的滚动视图，然后添加到你的主视图上，但是在这之前，先添加下面的方法：</p>

<pre><code>- (void)reloadScroller
{
    allAlbums = [[LibraryAPI sharedInstance] getAlbums];
    if (currentAlbumIndex &lt; 0) currentAlbumIndex = 0;
    else if (currentAlbumIndex &gt;=allAlbum.count) currentAlbumIndex = allAlbum.count - 1;
    [scroller reload];

    [self showDataFroAlbumAtIndex:currentAlbumIndex;
}
</code></pre>

<p>这个方法从 LibraryAPI 加载专辑数据，然后以当前视图的索引值为基础设置显示当前的图片。 如果当前视图的索引小于零，意味着当前没有选择视图，显示列表里的第一张专辑。否则显示最后一张专辑。</p>

<p>现在，在 viewDidLoad 里 [self showDataForAlbumIndex:0] 前面添加下面代码来初始化滚动视图：</p>

<pre><code>scroller  = [[HorizontalScroller alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 120)];
scroller.backgroundColor = [UIColor colorWithRed:0.24f greed:0.35f blue:0.49f alpha:1];
scroller.delegate = self;
[self.view addSubview:scroller];

[self reloadScroller];
</code></pre>

<p>上面的代码创建了一个 HorizontalScroller 的实例，设置了它的背景颜色和委托，添加滚动视图到主视图上，在滚动视图的子视图上加载专辑数据。</p>

<pre><code>提示：如果一个协议变得很大，里面有很多方法，你应该考虑把它们分散到几个小的协议里去。UITableViewDelegate 和 UITableViewDataSource 就是一个很好的例子，因为它们都是 UITablveView 的协议。设计协议的时候，最好一个名称引导一个功能。
</code></pre>

<p>构建和运行你的项目，你会看到一个新的很了不起的水平滚动视图：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-3-298x320.png" alt="2" /></p>

<p>啊嗯，等等。水平滚动的视图已经有了，可是专辑封面在哪里？</p>

<p>对了，你还没有代码来执行下载图片的功能。你需要添加一个下载图片的方法。查检 LibraryAPI 服务的所有接口，这里需要添加一个新的方法。不管怎样，现在还有几件事情需要考虑：</p>

<ol>
<li>AlbumView 并没没有通过 LibraryAPI 立即工作。你没有给视图添加通信逻辑。</li>
<li>相同的原因，LibraryAPI 并不认识 AlbumView。</li>
<li>LibraryAPI 需要通知 AlbumView，一旦封面下载完成，AlbumView 就会显示它。</li>
</ol>


<p>听起来这是一个难题？不用害怕，你将要学习如何使用观察者模式 (Observer pattern)。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Decorator – 装饰器模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/"/>
    <updated>2015-06-16T13:38:15+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi</id>
    <content type="html"><![CDATA[<p><strong>装饰器模式</strong>可以在不修改代码的情况下灵活的为一对象添加行为和职责。当你要修改一个被其它类包含的类的行为时，它可以代替子类化方法。</p>

<p>在 Object-C 里有两个种非常常见的实现模式：分类(Category)和委托(Delegation)。</p>

<h3>分类 Category</h3>

<p>分类是一种非常强大的机制，它允许你在一个已存在的类里添加新方法，而不需要去为他添加一个子类。新方法在编译的时候添加，它能像这个类的扩展方法一样正常执行。一个装饰器跟类的定义稍微有点不同的就是，因为装饰器不能被实例化，它只是一个扩展。</p>

<pre><code>提示：除了你自己类的扩展，你还可在任何 Cocoa 类里的扩展添加方法。
</code></pre>

<h3>如何使用分类</h3>

<p>现在你有一个 Album 对象，你需要把它显示在一个表单视图里(table view)：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-category1.png" alt="1" /></p>

<p>专辑的标题从哪里来？Album 只是一个模型对象，它才不会去关心你如果去显示这些数据。为了这些，你需要给 Album 类添加一些额外的代码，但是请不要直接修改这个类。</p>

<p>你现在就需要为 Album 添加一个分类 (category) 的扩展；它将定义一个新地方法用来返回一个数据结构，这个数据结构可以很容易的被 UITableViews 使用。</p>

<p>这个数据结构看起来如下：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/delegate2-480x67.png" alt="2" /></p>

<p>为 Album 添加一个分类，导航 File\New\File… 选择 Object-C category 模版─不要习惯的去选择 Object-C class，在 Category 后面输入 TableRepresentation，Category to 后面输入 Album。</p>

<pre><code>提示：你有没有注意这个新文件的名字？Album+TableRepresentation 说明它是 Album 类的一个扩展。这个习惯很重要，因为第一这很容易读，第二防止你或者其他人创建的分类跟其冲突。
</code></pre>

<p>打开 Album+TableRepresentation，加入下面的方法原型：</p>

<pre><code>- (NSDictionary*)tr_tableRepresentation;
</code></pre>

<p>注意，这是一个 tr_ 开头的方法名，就像是这个分类名字的缩写一样：TableRepresentation。其次，这个习惯会避免这个方法跟其它方法重名！</p>

<pre><code>提示：如果分类 (Category) 声明的一个方法跟原始类的一个方法重名，或者跟同类里的的另一个分类名字重复（或者是它的父类），当它在运行的时候，它就不知道要执行哪个方法。如果是在你自己类的分类里，它不太可能出现大的问题，但是如果一个标准 Cocoa 或者 Cocoa Touch 类里面添加这个分类的方法，就可能会引起严重的问题。
</code></pre>

<p>打开 Album+TableRepersentation.m 文件添加下面的方法：</p>

<pre><code>- (NSDictionary*)tr_TableRepersentation
{
    return @{@"titles":@[@"Artist", @"Album", @"Genre", @"Year"],
            @"values":@[self.artist, self.title, self.genre, self.year]};
};
</code></pre>

<p>考虑一会，为什么这种模式如些强大：</p>

<ul>
<li>你能够直接使用 Album 的属性。</li>
<li>你已经添加在 Album 类里，但它并不是它的子类。如果子类需要，你同样也可以这样做。</li>
<li>这样一个简单的添加，Album 类的数据返回一个 UITableView 可用的数据结构，但并不需要修改 Album 的代码。</li>
</ul>


<p>苹果在基础类里大量的使用了分类设计模式。去看看他们是怎么做的，打开 NSString.h。找到 @interface NSString，你将会看到这个类定义了三个分类：NSStringExtensionMethods, NSExtendedStringPropertyListParsing 和 NSStingDeprecated。在代码片里，分类将帮助你保持方法的组织性和分离必。</p>

<h3>委托 Delegation</h3>

<p>另外一种装饰器的设计模式是，委托 (Delegation)，它是一种机制，一个对象代表另外一个对象或者其相互合作。例子，当你使用 UITableView 的时候，其中一个方法是你必需要执行的，tableView:numberOfRowsInSection:。</p>

<p>你可能并不期望 UITableView 知道每个 section 中有多少行，这是程序的特性。因此，计算每个 section 有多少行的工作就交给了 UITableView 的委托 (delegate)。它允许 UITableView 类不依赖它显示的数据。</p>

<p>当你创建了一个新的 UITableView 的时候，这里有一个类似的解释：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/delegate-480x252.png" alt="3" /></p>

<p>UITableView 对象的工作就是显示一个表单视图。然而，最终它都需要一些它信息，它并不拥有这些信息。然后，它会转向它的委托，发送一个添加信息的消息。在 Object-C 中实现委托模式，一个类可以通过协议 (protocol) 来声明一个可选和必选的方法。稍后，在这个教程你将覆盖一个协议 (protocols)。</p>

<p>它看起来比子类更容易，覆盖需要的方法，但是考虑如果是单类的话你只能创建子类。如果你想一个对象委托两个或者多个对象的时候，子类化的方法是不能实现的。</p>

<pre><code>提示：这是一个很重要的模式。苹果在 UIKit 类中大量的使用了此方法：UITableView, UITextView, UITextField, UIWebView, UIAlert, UIActionSheet, UICollectionView, UIPickerView, UIGestureRecognizer, UIScrollView。这个列表还可以有很多。
</code></pre>

<h3>如何使用委托模式</h3>

<p>打开 ViewController.m，在顶部引入如下文件</p>

<pre><code>#import "LibraryAPI.h"
#import "Album+TableRepresentation.h"
</code></pre>

<p>现在，在类的扩展里的添加一些私有变量，它们看起来如下：</p>

<pre><code>@interface ViewController (){
    UITableView *dataTable;
    NSArray *allAlbums;
    NSDictionary *currentAlbumData;
    int currentAlbumIndex;
}
@end
</code></pre>

<p>现在，替换类扩展里的 @interface 这一行，完成后如下：</p>

<pre><code>@interface ViewController () &lt;UITableViewDataSoure, UITableViewDelegate&gt; {
</code></pre>

<p>这就是如何设置一个正确的委托─把它相象成允许一个委托来履行一个方法的合同。这里，表明 ViewController 将会遵照 UITableViewDataSource 和 UITableViewDelegate 协议。这种方法下 UITableView 必须执行它自己的委托方法。</p>

<p>下面，用下面的代码替换 viewDidLoad:</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // 1
    self.view.backgroundColor = [UIColor colorWithRed:0.76f green:0.81f blue:0.87f alpha:1];
    currentAlbumIndex = 0;

    //2
    allAlbums = [[LibraryAPI sharedInstance] getAlbums];

    // 3
    // the uitableview that presents the album data
    dataTable = [[UITableView alloc] initWithFrame:CGRectMake(0, 120, self.view.frame.size.width, self.view.frame.size.height-120) style:UITableViewStyleGrouped];
    dataTable.delegate = self;
    dataTable.dataSource = self;
    dataTable.backgroundView = nil;
    [self.view addSubview:dataTable];
}
</code></pre>

<p>这里分析下上面的代码：</p>

<ol>
<li>把背景色改为漂亮的深蓝色。</li>
<li>从 API 获取一个列表，它包含所有的专辑数据。不能直接使用 PersistencyManager。</li>
<li>创建一个 UITableView。你声明了视图控制器是 UITableView delegate/data source；因此，UITableView 将会提供视图控制器需要的所有信息。</li>
</ol>


<p>现在，在 ViewController.m 里面添加如下方法：</p>

<pre><code>- (void)showDataForAlbumAtIndex:(int)albumIndex{
    // defensive code: make sure the requested index is lower than the amount of albums
    if (albumIndex &lt; allAlbums.count) {
        // fetch the album
        Album *album = allAlbums[albumIndex];
        // save the albums data to present it later in the tableview
        currentAlbumData = [album tr_tableRepresentation];
    } else {
        currentAlbumData = nil;
    }

    // we have the data we need, let's refresh our tableview
    [dataTable reloaddata];
}
</code></pre>

<p>showDataForAlbumAtIndex: 从专辑数组中取出需要的专辑数据。当你需要显示新数据的时候，你只需要重载数据 (relaodData)。这是因为 UITableView 需要请求它的委托代理，像有多少 sections 将会在表单视图中显示，每个 section 中有多少行，每行看起来是什么样的。</p>

<p>在 viewDidLoad 中添加下面代码</p>

<pre><code>[self showDataForAlbumAtIndex:currentAlbumIndex];
</code></pre>

<p>当程序运行的时候它会加载当前的专辑信息。由于 currentAlbumIndex 的预设值为 0，所以会显示收藏中的第一张专辑信息。</p>

<p>构建并运行你的项目，你的程序会崩溃掉，在控制台会输入如下的异常：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/2013-09-01_15-57-32-700x112.png" alt="4" /></p>

<p>出现什么问题了？你已经声明了 ViewController 中的 UItableView 的委托(delegate)和数据源(data source)。但是在这种情况下，你必需执行所有的必需方法─包含 tableView:numberOfRowsInsection:─你现在还没有它。</p>

<p>在 ViewContrller.m 的 @implementation 和 @end 的任何地方添加如下代码：</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return [currentAlbumData[@"titles"] count];
}

- (UITableViewCell*)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"];
    if (!cell) {
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:@"cell"];
    }

    cell.textLabel.text = currentAlbumData[@"titles"][indexPath.row];
    cell.detailTextLabel.text = currentAlbumData[@"values"][indexPath.row];

    return cell;
}
</code></pre>

<p>tableView:numberOfRowsIndexSection: 返回表单视图显示的行数，匹配数据结构中标题的数目。</p>

<p>tableView:cellForRowAtIndexPath: 创建并返回一个带标题和信息的 cell。</p>

<p>现在构建并运行你的项目。你的程序开始运行并显示出下图的界面：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage1.png" alt="5" /></p>

<p>这目前为止事情看起来很不错。但是如果你回过去看第一张图片的时候，你会发现在屏幕的顶端有一个可以水平滚动的视图，用于切换专辑。它只是简单的水平滚动，为什么不做一个可以重复使用的视图来代替它呢。</p>

<p><img src="%E8%BF%99%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E4%BA%8B%E6%83%85%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E4%B8%8D%E9%94%99%E3%80%82%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%9B%9E%E8%BF%87%E5%8E%BB%E7%9C%8B%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0%E5%9C%A8%E5%B1%8F%E5%B9%95%E7%9A%84%E9%A1%B6%E7%AB%AF%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%A7%86%E5%9B%BE%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%88%87%E6%8D%A2%E4%B8%93%E8%BE%91%E3%80%82%E5%AE%83%E5%8F%AA%E6%98%AF%E7%AE%80%E5%8D%95%E7%9A%84%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%86%E5%9B%BE%E6%9D%A5%E4%BB%A3%E6%9B%BF%E5%AE%83%E5%91%A2%E3%80%82" alt="6" /></p>

<p>这个可以重复使用的视图 (view)，它所有的内容都由另一个对象来管理：委托 (delegate)。这个水平滚动区域需要声明一个方法，一个为滚动区域工作的代理工具，就像 UITableView 代理方法如何工作一样。当我讨论下一个设计模式时将会实施它。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Facade – 外观模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/"/>
    <updated>2015-06-15T10:06:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi</id>
    <content type="html"><![CDATA[<p>目前你有 PersistencyManager 来在本地存储专辑数据，HTTPClient 处理远程通信。项目中其它的类跟这些逻辑都没关。</p>

<p>执行这个<a href="http://www.superqq.com/blog/2015/03/21/dan-li-mo-shi-de-xie-fa/">模式</a>，只有 LibraryAPI 来保存 PersistencyManager 和 HTTPClient 的实例。之后，LibraryAPI 将会公开一个简单的 API 来访问这些服务。</p>

<pre><code>提示：通常，单例存在 app 的整个生命周期。不需一直使用很多指针指向其它对象，因为她们直到程序关闭后才会被释放。   
</code></pre>

<p>这个设计就像下图：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-facade-uml-480x71.png" alt="icon" /></p>

<p>LibraryAPI 将会公开给其它代码，但是它隐藏了 APP 中 HTTPClient 和 PersistencyManager 的复杂部分。</p>

<p>打开 LibraryAPI.h，在顶部引入面文件：</p>

<pre><code>#import "Album.h"
</code></pre>

<p>接下来，在 LibraryAPI.h下面添加如下方法：</p>

<pre><code>- (NSArray*)getAlbums;
- (void)addAlbum:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></pre>

<p>现在，这些方法都公开给了其它类。</p>

<p>在 LibraryAPI.m 文件引入如下两个文件：</p>

<pre><code>#import "PersistencyManager.h"
#import "HTTPClient.h"
</code></pre>

<p>只有在这个地方你才会需要引入这些类。记住：你的 API 将会是你「复杂」系统的唯一的接入点。</p>

<p>现在添加一些私有属性在你的类的扩展里（在 @implementation 上面）</p>

<pre><code>@interface LibraryAPI () {
    PersistencyManager *persistencyManager;
    HTTPClient *httpClient;
    BOOL isOnline;
}
@end
</code></pre>

<p>isOnline 用来判断，如果专辑列表数据发生变化是否能够更新到服务器，例如添加或者删除专辑。</p>

<p>你现在需要在 init 方法中初始化这些变量，在 LibraryAPI.m 中添加下面代码：</p>

<pre><code>- (id)init
{
    self = [super init];
    if (self) {
        persistencyManager = [[PersistencyManager alloc] init];
        httpClient = [[HTTPClient alloc] init];
        isOnline = NO;
    }
    return self;
}
</code></pre>

<p>这个 HTTP 客户端在这里并不真正的工作，它只是在外观设计里面起一个示范用法的作用，所以 isOnline 永远是 NO 了。</p>

<p>接下来，在 LibraryAPI.m 里面添加下面三个方法：</p>

<pre><code>- (NSArray*)getAlbums
{
    return [persistencyManager getAlbums];
}

- (void)addAlbum:(Album*)album atIndex:(int)index
{
    [persistencyManager addAlbum:album atIndex:index];
    if (isOnline)
    {
        [httpClient postRequest:@"/api/addAlbum" body:[album description]];
    }
}

- (void)deleteAlbumAtIndex:(int)index
{
    [persistencyManager deleteAlbumAtIndex:index];
    if (isOnline)
    {
        [httpClient postRequest:@"/api/deleteAlbum" body:[@(index) description]];
    }
}
</code></pre>

<p>看一下 addAlbum:atIndex:。这个类首先更新本地数据，如果联网，它再更新远端服务器。这就是外观设计的长处；当一些系统外的类添加了一个新专辑，它不知道─也不需要知道─复杂的内部系统。</p>

<pre><code>提示：当在你的子系统里设计一个外观类的时候，记住没有任何东西可能阻止客户访问这些「隐藏」类。要多写些防御性的代码，不要想当然的认为所有客户都会用同样的方式使用你的外观类。
</code></pre>

<p>运行你的程序，你会看一个黑底空白内容的屏幕，像下面这样：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/2013-09-01_12-08-44-211x320.png" alt="icon1" /></p>

<p>你需要在屏幕上显示一些专辑数据─这就需要使用到下面一个设计模式：装饰器 (Decorator)。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Singleton – 单例模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/"/>
    <updated>2015-06-13T08:21:55+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi</id>
    <content type="html"><![CDATA[<p><a href="http://www.superqq.com/blog/2015/03/21/dan-li-mo-shi-de-xie-fa/">单例设计模式</a>确切的说就是一个类只有一个实例，有一个全局的接口来访问这个实例。当第一次载入的时候，它通常使用延时加载的方法创建单一实例。</p>

<pre><code>提示：苹果大量的使用了这种方法。例子：[NSUserDefaults standerUserDefaults], [UIApplication sharedApplication], [UIScreen mainScreen], [NSFileManager defaultManager] 都返回一个单一对象。
</code></pre>

<p>你可能想知道你为什么要关心一个类有多个的实例。代码和内存都很便宜，不是吗？</p>

<p>在一些情况下，一个类只有一个实例是有意义的。例如，这里没有必要有多个登录实例，除非你一次想写入多个日志文件。或者，一个全局的配置类文件：它可以很容易的很安全的执行一个公共资源，这样的一个配置文件，要比同时修改多个配置类文件好很多。</p>

<h3>如何使用单例模式</h3>

<p>请看下面的图片</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/08/singleton.png" alt="icon" /></p>

<p>上面的图片显示的是一个登录类，它有一个属性（这个单一实例），有两个方法：sharedInstance 和 init。</p>

<p>首先一个客户端(client)发送 sharedInstance 信息，但是属性 instance 还没有初始化，所以你要先给这个类创建一个实例。</p>

<p>然后你调用 sharedInstance，instance 会马上返回初始化的值。这个逻辑最终只会返回一个实例。</p>

<p>你需要执行这个模式来创建单例类来管理所有的专辑数据。</p>

<p>你需要注意在项目里有一个叫 API 文件夹，给你的 APP 提供服务的所有类都需要放在这里。在这个文件夹里用 iOS\Cocoa Touch\Object-C class 创建一个新类。类的名字叫 LibraryAPI，子类选择 NSObject。</p>

<p>打开 LibraryAPI.h 文件用下面的代码替换里面的内容：</p>

<pre><code>@interface LibraryAPI: NSObject
+ (LibraryAPI*)sharedInstance;
@end
</code></pre>

<p>现在打开 LibraryAPI.m 文件，在 @implentation 后面添加如下方法：</p>

<pre><code>+ (LibraryAPI*)sharedInstance 
{
    // 1
    static LibraryAPI *_sharedInstance = nil;

    // 2 
    static dispatch_once_t oncePredicate; 

    // 3
    dispatch_once(&amp;nocePredicate, ^{
        _sharedInstance = [[LibraryAPI alloc] init];
    });
    return _sharedInstance;
}
</code></pre>

<p>在这个短方法中做了这些事情：</p>

<ul>
<li>在这个类中，声明一个静态变量来保存这个实例，保证它是一个全局可用的变量。</li>
<li>声明一个静态这是 dispatch_one_t，确保这些初始化代码只能被执行一次。</li>
<li>使用 Grand Central Dispatch（GCD）执行一个 block 来初始化 LibraryAPI 实例。这是单例设计模式的关键所在：一个类只能被实例化一次。</li>
</ul>


<p>接下来执行 sharedInstance，在 dispatch_once block 里的代码是不会被执行的（当它已经被执行过一次后），它会返回之前创建的 LibraryAPI 实例。</p>

<pre><code>提示：想了解更多关于 GCD 和使用它，请点击这里的教程 Multithreading and Grand Central Dispatch，如何使用 Blocks 在这里。
</code></pre>

<p>你现在有一个单例对象来管理专辑了。下一步就是创建一个类用来保存你的专辑数据了。</p>

<p>用 iOS\Cocoa Touch\Object-C class 在 API 文件夹下创建一个新的类，名字叫 PersistencyManager，子类选择 NSObject。</p>

<p>打开 PersistencyManager.h，在顶部引入面文件：</p>

<pre><code>#import "Album.h"
</code></pre>

<p>然后在 @interface 后面加入下面代码：</p>

<pre><code>- (NSArray *)getAlbums;
- (void)addAlbums:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></pre>

<p>上面的三个方法都需要跟专辑的数据相结合。</p>

<p>打开 PersistencyManager.m，在 @implementation 上面添加如下代码：</p>

<pre><code>@interface PersistencyManager () {
    NSMutableArray *albums;
}
</code></pre>

<p>上面的代码是给类添加了一个扩展，这是另一种给类添加私有方法和私有属性的方法，类外面的成员是看不到这些的。这里，你声明了一个 NSMutableArray 来保存专辑的数据。这是一个可变数组，你可以很容易的添加和删除专辑。</p>

<p>现在在 @implementation 下面添加实现代码：</p>

<pre><code>- (id)init {
    self = [super init];
    if (self) {
        albums = [NSMutableArray arrayWithArray:@[[[Album alloc] initWithTitle:@"Best of Bowie" artist:@"David Bowie" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png" year:@"1992"],
        [[Album alloc] initWithTitle:@"It's My Life" artist:@"No Doubt" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png" year:@"2003"],
                [[Album alloc] initWithTitle:@"Nothing Like The Sun" artist:@"Sting" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png" year:@"1999"],
            [[Album alloc] initWithTitle:@"Staring at the Sun" artist:@"U2" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png" year:@"2000"],
                [[Album alloc] initWithTitle:@"American Pie" artist:@"Madonna" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png" year:@"2000"]]];
    }
    return self;
}
</code></pre>

<p>在 init 里你在数组中加入了 5 张专辑。如果上面的专辑你不喜欢，你可以随意替换成你喜欢的。:]</p>

<p>现存在 PersistencyManager.m 添加下面三个方法：</p>

<pre><code>- (NSArray*)getAlbums
{
        return albums;
}

- (void)addAlbum:(Album*)album atIndex:(int)index
{
        if (albums.count &gt;= index)
            [albums insertObject:album atIndex:index];
        else
        [albums addObject:album];
}

- (void)deleteAlbumAtIndex:(int)index
{
        [albums removeObjectAtIndex:index];
}
</code></pre>

<p>这些方法是获取，添加，删除专辑。</p>

<p>Build 你的项目，确保所有的代码都能正确编译。</p>

<p>现在，你也许想知道为什么会有一个 PersistencyManager 类，因为它都不是单例类。不要着急，接下来第二步，外观设计模式(Facade design patten) 将会探讨 LibraryAPI 和 PersistencyManager 之间的关系。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
</feed>
