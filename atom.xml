<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刚刚在线]]></title>
  <link href="http://www.superqq.com/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-07-31T15:41:02+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AKTabBarController：类似微信的第三方库]]></title>
    <link href="http://www.superqq.com/blog/2015/07/31/aktabbarcontroller-similar-to-wechat-library/"/>
    <updated>2015-07-31T00:28:53+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/31/aktabbarcontroller-similar-to-wechat-library</id>
    <content type="html"><![CDATA[<p>自从有了评论之后，就可以很方便的和大家交流。以前都是我一个人默默的发文章，看不出大家对文章的看法。评论开通之后，就可以很快速的获取大家对文章的看法。</p>

<p>有人会指出文章里有错误的地方，真的很感激他们，非常的认真；有人会对文章说出自己的见解，加深自己的印象，同时，也能帮助到其他的朋友；有人也会在评论里，提出一些问题，但是鉴于评论的字数限制，只能简单的回答一下。</p>

<p>在昨天的文章评论里面，有一个朋友提出了一个问题，关于微信导航栏的。</p>

<h2>问题分析和解答</h2>

<p><strong>问：</strong></p>

<pre><code>自定义导航栏怎么写？就像微信那样，tabBar的四个界面切换导航栏都不变化
</code></pre>

<p><strong>答：</strong></p>

<pre><code>github上搜索AKTabBarController
</code></pre>

<p>其实，这位朋友的问题不是关于自定义导航栏，我觉得他可能是想问微信底部的<code>TabBar</code>和导航结合使用是如何实现的。</p>

<p>记得之前在github看到过有一个类似微信的框架（算不上框架，我们就这么简单的叫一下）。就是<a href="https://github.com/alikaragoz/AKTabBarController">AKTabBarController</a>。</p>

<p><code>AKTabBarController</code>是一个非常不错的第三方。在github上有663个<code>star</code>，使用方法也不是很复杂，下面我们简单的看一下。</p>

<h2>如何导入到项目中</h2>

<p><code>AKTabBarController</code>是支持<a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods</a>导入的。想理解CocoaPods的请点击：<a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods安装和使用教程</a>。在你的Podfile文件中加入：</p>

<pre><code>platform :ios

pod 'AKTabBarController'
</code></pre>

<p>添加成功之后，在终端执行：</p>

<pre><code>pod install 
</code></pre>

<h2>如何使用AKTabBarController</h2>

<p>安装成功之后，在你想用的地方导入头文件：</p>

<pre><code>#import "AKTabBarController.h"
</code></pre>

<p>然后，创建<code>tabBar</code></p>

<pre><code>// Create and initialize the height of the tab bar to 50px.
_tabBarController = [[AKTabBarController alloc] initWithTabBarHeight:50];

// Create and initialize with specific height and position atop the view controller
_tabBarController = [[AKTabBarController alloc] initWithTabBarHeight:50 position:AKTabBarPositionTop];

// Adding the view controllers to manage.
[_tabBarController setViewControllers:@[[[FirstViewController alloc] init], [[SecondViewController alloc] init], [[ThirdViewController alloc] init], [[FourthViewController alloc] init]]]];  
</code></pre>

<p>关于更多AKTabBarController的用法，请访问：**<a href="https://github.com/alikaragoz/AKTabBarController**">https://github.com/alikaragoz/AKTabBarController**</a></p>

<h2>功能简介</h2>

<pre><code>• 自适应竖屏和横屏模式，tab 上的图标会根据竖屏和横屏模式自动缩放大小以适应tab的高度。

• 自定义 tab bar 的高度；

• 当进入下个视图时，可以自动隐藏tab bar；

• 可以只显示图片，而不显示文字；并且当 tab bar 的高度太小时，可以自动缩放图片以及隐藏文字；

• 只需要一张图片来表示 tab 被选择和非选择模式。即tab 被选中时的高光是用CoreGraphics绘制的，不需要额外的图片。

• 选择不同 tab 时的动画切换效果用的是淡入淡出（cross fade）的效果. 

• 支持预渲染图像

• 支持设置tabBar字体。
</code></pre>

<h2>实际效果</h2>

<p>最终实现的效果如下所示：</p>

<p><img src="https://github.com/alikaragoz/AKTabBarController/raw/master/Screenshots/iphone-portrait.png" alt="1" /></p>

<p>这里只是简单的讲解一下。大家闲的时候，如果有兴趣的话，可以自己动手来熟练关于<code>AKTabBarController</code>更多的功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于导航栏的六个小技巧]]></title>
    <link href="http://www.superqq.com/blog/2015/07/30/six-tips-on-navigation-bar/"/>
    <updated>2015-07-30T00:13:43+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/30/six-tips-on-navigation-bar</id>
    <content type="html"><![CDATA[<p><code>UINavigationBar</code>和<code>UINavigationItem</code>是iOS开发中常用的控件。今天给大家介绍一下六个关于导航栏的小技巧。</p>

<h2>1.设置导航栏标题</h2>

<pre><code>self.title = @"iOS开发：iOSDevTip";
</code></pre>

<h2>2.设置导航栏样式</h2>

<p>设置方法：</p>

<pre><code>[self.navigationController.navigationBar setBarStyle:UIBarStyleBlack];
</code></pre>

<p><code>UIBarStyle</code>的样式：</p>

<pre><code>typedef NS_ENUM(NSInteger, UIBarStyle) {
    UIBarStyleDefault          = 0,
    UIBarStyleBlack            = 1,

    UIBarStyleBlackOpaque      = 1, // Deprecated. Use UIBarStyleBlack
    UIBarStyleBlackTranslucent = 2, // Deprecated. Use UIBarStyleBlack and set the translucent property to YES
};
</code></pre>

<p><code>UIBarStyleDefault</code>是默认样式，<code>UIBarStyleBlack</code>是黑色不透明。<code>UIBarStyleBlackOpaque</code>和<code>UIBarStyleBlackTranslucent</code>这两个已经废弃了。</p>

<p>如果想设置导航栏透明，可以加上下面这句代码：</p>

<pre><code>self.navigationController.navigationBar.translucent = YES;
</code></pre>

<h2>3.修改返回按钮title</h2>

<pre><code>self.navigationItem.title = @"test";
</code></pre>

<h2>4.隐藏返回按钮title</h2>

<p>比较笨的方法是：</p>

<pre><code>self.navigationItem.title = @"";
</code></pre>

<p>还可以这样设置：</p>

<pre><code>[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60) forBarMetrics:UIBarMetricsDefault];
</code></pre>

<h2>5.设置leftBarButtonItem</h2>

<pre><code>self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"back" style:UIBarButtonItemStylePlain target:self action:@selector(back:)];

- (void)back:(id)sender
{
    [self.navigationController popViewControllerAnimated:YES];
}
</code></pre>

<h2>6.左滑返回手势失效了怎么办</h2>

<p>如果按上一步设置<code>leftBarButtonItem</code>之后，左滑返回手势就会失效。设置一下<code>UIGestureRecognizerDelegate</code>代理即可：</p>

<pre><code>self.navigationController.interactivePopGestureRecognizer.delegate = self;
</code></pre>

<p>以上是六个关于导航栏的小技巧。更多iOS开发相关的技术，请关注我的微信公众号iOS开发：<strong>iOSDevTip</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之UIImage等比缩放]]></title>
    <link href="http://www.superqq.com/blog/2015/07/29/uiimage-geometric-zoom/"/>
    <updated>2015-07-29T00:01:15+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/29/uiimage-geometric-zoom</id>
    <content type="html"><![CDATA[<h2>评论功能真不错</h2>

<p>评论开通后，果然有很多人吐槽。谢谢大家的支持和关爱，如果有做的不到的地方，还请海涵。毕竟我一个人的力量是有限的，我会尽自己最大的努力大家准备一些干货。</p>

<p>有些内容可能都是比较基础的，记住：不积跬步无以至千里，不积小流无以成江海。我想这个道理大家都懂，在为大家准备文章的过程中，对我来说也是一次学习成长。</p>

<p>大家可以继续吐槽！微信的评论就是一个沟通的渠道，也是一篇文章的延续。你也可以在评论中写一些你对iOS开发的见解，说不定就会对他人有帮助。</p>

<p>很高兴，已经有好几位iOS开发的朋友答应以后会写文章投稿给我。在这里，我再强调一下：如果你有好的技术文章一定要投稿给我噢！投稿邮箱：</p>

<pre><code>worldligang@163.com
</code></pre>

<p>前面讲了<a href="http://www.superqq.com/blog/2015/07/26/jie-qu-uiimagezhi-ding-da-xiao-qu-yu/">截取UIImage指定大小区域</a>，很方便的截取<code>UIImage</code>。今天要和大家分享的是<code>UIImage</code>的缩放。</p>

<p>两种缩放:</p>

<ol>
<li>缩放到指定大小，也就是指定的<code>size</code>.</li>
<li>等比缩放。</li>
</ol>


<h2>缩放到指定大小</h2>

<pre><code>- (UIImage*)imageCompressWithSimple:(UIImage*)image scaledToSize:(CGSize)size
{
    UIGraphicsBeginImageContext(size);
    [image drawInRect:CGRectMake(0,0,size.width,size.height)];
    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
</code></pre>

<h2>等比缩放</h2>

<h3>通过缩放系数</h3>

<pre><code>- (UIImage*)imageCompressWithSimple:(UIImage*)image scale:(float)scale
{
    CGSize size = image.size;
    CGFloat width = size.width;
    CGFloat height = size.height;
    CGFloat scaledWidth = width * scale;
    CGFloat scaledHeight = height * scale;
    UIGraphicsBeginImageContext(size); // this will crop
    [image drawInRect:CGRectMake(0,0,scaledWidth,scaledHeight)];
    UIImage* newImage= UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
</code></pre>

<p><code>scale</code>是缩放系数  。</p>

<h3>通过计算得到缩放系数</h3>

<pre><code>- (UIImage*)imageByScalingAndCroppingForSize:(CGSize)targetSize
{

    UIImage *sourceImage = [UIImage imageNamed:@"test.jpg"];
    UIImage *newImage = nil;
    CGSize imageSize = sourceImage.size;
    CGFloat width = imageSize.width;
    CGFloat height = imageSize.height;
    CGFloat targetWidth = targetSize.width;
    CGFloat targetHeight = targetSize.height;
    CGFloat scaleFactor = 0.0;
    CGFloat scaledWidth = targetWidth;
    CGFloat scaledHeight = targetHeight;
    CGPoint thumbnailPoint = CGPointMake(0.0,0.0);

    if (CGSizeEqualToSize(imageSize, targetSize) == NO)
    {
        CGFloat widthFactor = targetWidth / width;
        CGFloat heightFactor = targetHeight / height;
        if (widthFactor &gt; heightFactor)
            scaleFactor = widthFactor; // scale to fit height
        else
            scaleFactor = heightFactor; // scale to fit width

        scaledWidth= width * scaleFactor;
        scaledHeight = height * scaleFactor;
        // center the image
        if (widthFactor &gt; heightFactor)
        {
            thumbnailPoint.y = (targetHeight - scaledHeight) * 0.5;
        }
        else if (widthFactor &lt; heightFactor)
        {
            thumbnailPoint.x = (targetWidth - scaledWidth) * 0.5;
        }
    }

    UIGraphicsBeginImageContext(targetSize); // this will crop
    CGRect thumbnailRect = CGRectZero;
    thumbnailRect.origin = thumbnailPoint;
    thumbnailRect.size.width= scaledWidth;
    thumbnailRect.size.height = scaledHeight;
    [sourceImage drawInRect:thumbnailRect];
    newImage = UIGraphicsGetImageFromCurrentImageContext();

    if(newImage == nil)
        NSLog(@"could not scale image");
    //pop the context to get back to the default
    UIGraphicsEndImageContext();

    return newImage;

}
</code></pre>

<p>很久之前写了一篇文章<a href="http://www.superqq.com/blog/2015/01/22/jie-jue-mwphotobrowserzhong-de-sdwebimagejia-zai-da-tu-dao-zhi-de-nei-cun-jing-gao-wen-ti/">解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题</a>。这个我记得当时从服务器拿到的照片大概有10几M的样子，加载出来会导致内存警告。所以我当时通过修改SDWebImage源码，就是把下载下来的照片进行缩放，内存就降下来了。一般情况下应该不会加载这么大的照片的，用户要是知道，早把你的APP给删掉了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[著名的AFNetworking网络基础库Swift版Alamofire]]></title>
    <link href="http://www.superqq.com/blog/2015/07/28/swift-alamofire/"/>
    <updated>2015-07-28T20:42:52+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/28/swift-alamofire</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/Alamofire/Alamofire" target="_blank" title=“源代码”>源代码</a></p>

<p><img src="http://swiftmi.qiniudn.com/codeimage/201409/13_1410874399080_89.gif" alt="swift-gif" /></p>

<h2>Swift Alamofire 简介</h2>

<p><img src="https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png" alt="Alamofire: Elegant Networking in Swift" /></p>

<p>Alamofire是 Swift 语言的 HTTP 网络开发工具包,相当于Swift实现<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">AFNetworking</a>版本。</p>

<p>当然,AFNetworking非常稳定,在Mac OSX与iOS中也能像其他Objective-C代码一样用Swift编写。不过Alamofire更适合Swift语言风格习惯(Alamofire与AFNetworking可以共存一个项目中,互不影响).</p>

<pre><code>Alamofire 取名来源于 [Alamo Fire flower](https://aggie-horticulture.tamu.edu/wildseed/alamofire.html)
</code></pre>

<h2>Alamofire安装使用方法</h2>

<p>使用CocoaPods安装，在podfile</p>

<pre><code>source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', '~&gt; 1.2'
</code></pre>

<p>submodule 方式安装</p>

<pre><code>$ git submodule add https://github.com/Alamofire/Alamofire.git
</code></pre>

<h2>环境要求</h2>

<p>Xcode 6</p>

<p>iOS 7.0+ / Mac OS X 10.9+</p>

<h2>Alamofire使用方法</h2>

<h3>GET 请求</h3>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get")
</code></pre>

<p>带参数</p>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
</code></pre>

<p>Response结果处理</p>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .response { (request, response, data, error) in
                     println(request)
                     println(response)
                     println(error)
                   }
</code></pre>

<p>Response结果字符串处理</p>

<pre><code>Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .responseString { (request, response, string, error) in
                  println(string)
         }
</code></pre>

<h2>HTTP 方法（Medthods）</h2>

<p>Alamofire.Method enum 列表出在RFC 2616中定义的HTTP方法 §9:</p>

<pre><code>public enum Method: String {
    case OPTIONS = "OPTIONS"
    case GET = "GET"
    case HEAD = "HEAD"
    case POST = "POST"
    case PUT = "PUT"
    case PATCH = "PATCH"
    case DELETE = "DELETE"
    case TRACE = "TRACE"
    case CONNECT = "CONNECT"
}
</code></pre>

<p>这些值可以作为Alamofire.request请求的第一个参数.</p>

<pre><code>Alamofire.request(.POST, "http://httpbin.org/post")

Alamofire.request(.PUT, "http://httpbin.org/put")

Alamofire.request(.DELETE, "http://httpbin.org/delete")
</code></pre>

<p>POST请求</p>

<pre><code>let parameters = [
    "foo": "bar",
    "baz": ["a", 1],
    "qux": [
        "x": 1,
        "y": 2,
        "z": 3
    ]
]

Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters)
</code></pre>

<p>发送以下HttpBody内容:</p>

<pre><code>foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3
</code></pre>

<p>Alamofire 使用Alamofire.ParameterEncoding可以支持URL query/URI form,JSON, PropertyList方式编码参数。</p>

<p>Parameter Encoding</p>

<pre><code>enum ParameterEncoding {
    case URL
    case JSON(options: NSJSONWritingOptions)
    case PropertyList(format: NSPropertyListFormat,
                      options: NSPropertyListWriteOptions)

    func encode(request: NSURLRequest,
                parameters: [String: AnyObject]?) -&gt;
                    (NSURLRequest, NSError?)
    { ... }
}
</code></pre>

<p>NSURLRequest方式编码参数</p>

<pre><code>let URL = NSURL(string: "http://httpbin.org/get")
var request = NSURLRequest(URL: URL)

let parameters = ["foo": "bar"]
let encoding = Alamofire.ParameterEncoding.URL
(request, _) = encoding.encode(request, parameters)
</code></pre>

<p>POST JSON格式数据</p>

<pre><code>Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters, encoding: .JSON(options: nil))
         .responseJSON {(request, response, JSON, error) in
            println(JSON)
     }
</code></pre>

<p>Response 方法</p>

<pre><code>response()
responseString(encoding: NSStringEncoding)
responseJSON(options: NSJSONReadingOptions)
responsePropertyList(options: NSPropertyListReadOptions)
</code></pre>

<h3>上传（Uploading）</h3>

<p>支持的类型</p>

<pre><code>File
Data
Stream
Multipart (Coming Soon)
</code></pre>

<p>上传文件</p>

<pre><code>let fileURL = NSBundle.mainBundle()
                  .URLForResource("Default",
                                  withExtension: "png")

Alamofire.upload(.POST, "http://httpbin.org/post", file: fileURL)
</code></pre>

<h3>上传进度</h3>

<pre><code>Alamofire.upload(.POST, "http://httpbin.org/post", file: fileURL)
    .progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in
        println(totalBytesWritten)
    }
    .responseJSON { (request, response, JSON, error) in
        println(JSON)
    }
</code></pre>

<h3>下载</h3>

<p>支持的类型</p>

<pre><code>Request
Resume Data
</code></pre>

<p>下载文件</p>

<pre><code>Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: { (temporaryURL, response) in
    if let directoryURL = NSFileManager.defaultManager()
                          .URLsForDirectory(.DocumentDirectory,
                                            inDomains: .UserDomainMask)[0]
                          as? NSURL {
        let pathComponent = response.suggestedFilename

        return directoryURL.URLByAppendingPathComponent(pathComponent)
    }

    return temporaryURL
})
</code></pre>

<p>下载到默认路径</p>

<pre><code>let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)

Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
</code></pre>

<p>下载进度</p>

<pre><code>Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
         .progress { (bytesRead, totalBytesRead, totalBytesExpectedToRead) in
             println(totalBytesRead)
         }
         .response { (request, response, _, error) in
             println(response)
         }
</code></pre>

<h3>认证（Authentication）</h3>

<p>支持以下几种认证</p>

<pre><code>HTTP Basic
HTTP Digest
Kerberos
NTLM
</code></pre>

<p>Http basic认证</p>

<pre><code>let user = "user"
let password = "password"

Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
    .authenticate(HTTPBasic: user, password: password)
    .response {(request, response, _, error) in
        println(response)
        }
</code></pre>

<p>采用NSURLCredential&amp;NSURLProtectionSpace方式认证</p>

<pre><code>let user = "user"
let password = "password"

let credential = NSURLCredential(user: user, password: password, persistence: .ForSession)
let protectionSpace = NSURLProtectionSpace(host: "httpbin.org", port: 0, `protocol`: "https", realm: nil, authenticationMethod: NSURLAuthenticationMethodHTTPBasic)



Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
    .authenticate(usingCredential: credential, forProtectionSpace: protectionSpace)
    .response {(request, response, _, error) in
        println(response)
}
</code></pre>

<h3>Printable</h3>

<pre><code>let request = Alamofire.request(.GET, "http://httpbin.org/ip")

println(request)
// GET http://httpbin.org/ip (200)
</code></pre>

<h3>调试</h3>

<pre><code>let request = Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])

debugPrintln(request)
</code></pre>

<h3>Output (cURL)</h3>

<pre><code>$ curl -i \
    -H "User-Agent: Alamofire" \
    -H "Accept-Encoding: Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
    -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
    "http://httpbin.org/get?foo=bar"
</code></pre>

<p>更多的用法将会在接口文档中一一列出,敬请期待。</p>

<p>Alamofire与AFNetworking是同一个作者</p>

<blockquote><p>作者李刚是刚刚在线（www.superqq.com）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://upload-images.jianshu.io/upload_images/624136-963198258f95cc10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOSDevTip" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[五种创建UIImage的类方法]]></title>
    <link href="http://www.superqq.com/blog/2015/07/28/four-create-uiimage-method/"/>
    <updated>2015-07-28T01:08:30+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/28/four-create-uiimage-method</id>
    <content type="html"><![CDATA[<h3>iOS开发已开通评论功能</h3>

<p>皇天不负有心人，iOS开发的评论功能已经被邀请开通啦。这几天一直想着，微信团队大概在月底的时候会邀请我开通评论功能。果然不出我所料。这是我收到的消息：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/weixincomment.png" alt="weixincomment.png" /></p>

<p>至此，iOS开发的原创、赞赏、评论三个功能都齐啦，这也是对我辛苦努力的一种肯定。前方的路依然很漫长，我们一起努力，让iOS开发变得更好。</p>

<p>既然评论功能已经开通，大家也别闲着啦！今天的文章大家一起尽情的吐槽吧！</p>

<p><code>UIImage</code>有五个类方法，用来创建<code>UIImage</code>的。下面介绍一下每个类方法的作用和创建实例。</p>

<h3>1.使用类方法<code>imageNamed:</code>创建</h3>

<pre><code>+ (UIImage *)imageNamed:(NSString *)name;      // load from main bundle      
</code></pre>

<p><code>name</code>是照片名称。创建UIImage对象，代码如下：</p>

<pre><code>UIImage *image = [UIImage imageNamed:@"ganggang"];   
</code></pre>

<p>使用<code>imageNamed:</code>初始化的时候，会先检查缓存中是否存在<code>ganggang</code>的照片，如不存在，图片首先会被缓存起来，然后才返回要加载的图片对象；如果存在，直接返回要加载的照片对象。</p>

<h3>2.使用类方法<code>imageWithContentsOfFile:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithContentsOfFile:(NSString *)path;
</code></pre>

<p><code>path</code>是需要加载照片的路径，如何获取照片的路径请点击<a href="http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing/">iOS开发之获取沙盒路径</a>。实现代码如下：</p>

<pre><code>UIImage *image = [UIImage imageWithContentsOfFile:path];   
</code></pre>

<p>使用<code>imageWithContentsOfFile:</code>创建<code>UIImage</code>的时候，是直接从磁盘上加载。当收到内存警告时，<code>UIImage</code>对象会被释放，下一次绘图的时候，需要重新加载。</p>

<h3>3.使用类方法<code>imageWithData:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithData:(NSData *)data;
</code></pre>

<p><code>data</code>是照片数据，一般是请求返回的，然后通过<code>imageWithData:</code>创建<code>UIImage</code>。实现代码如下所示：</p>

<pre><code>NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@"http://www.superqq.com/images/getqrcode.jpg"]];
UIImage *image =[UIImage imageWithData:data]; 
</code></pre>

<h3>4.使用类方法<code>imageWithCGImage:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage;
</code></pre>

<p><code>cgImage</code>是定义在QuartzCore框架中的一个结构体指针。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。</p>

<pre><code>UIImage *image = [UIImage imageWithCGImage:cgImage];   
</code></pre>

<h3>5.使用类方法<code>imageWithCIImage:</code>创建</h3>

<pre><code>+ (UIImage *)imageWithCIImage:(CIImage *)ciImage NS_AVAILABLE_IOS(5_0);
</code></pre>

<p><code>CIImage</code>是<code>CoreImage</code>框架中最基本代表图像的对象，在<code>CIImage</code>被<code>CIContext</code>渲染出来之前，他是依赖于滤镜链的，滤镜是不会更改<code>CIImage</code>中的图像数据。</p>

<pre><code> UIImage *image = [UIImage imageWithCGImage:ciImage];   
</code></pre>

<p>以上四种方法都是<code>UIImage</code>的类方法，使用<code>UIImage</code>的初始化方法也是可以创建<code>UIImage</code>对象的大家可以进<code>UIImage</code>详细了解一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之layoutSubviews的作用和调用机制]]></title>
    <link href="http://www.superqq.com/blog/2015/07/27/ioskai-fa-zhi-layoutsubviewsde-zuo-yong-he-diao-yong-ji-zhi/"/>
    <updated>2015-07-27T13:57:27+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/27/ioskai-fa-zhi-layoutsubviewsde-zuo-yong-he-diao-yong-ji-zhi</id>
    <content type="html"><![CDATA[<p>在UIView里面有一个方法<code>layoutSubviews</code>，这个方法具体作用是什么呢？</p>

<pre><code>- (void)layoutSubviews;    // override point. called by layoutIfNeeded automatically. As of iOS 6.0, when constraints-based layout is used the base implementation applies the constraints-based layout, otherwise it does nothing.
</code></pre>

<h2>官方文档解释</h2>

<p>我们先来看看苹果官方文档的解释：</p>

<pre><code>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.

Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.

You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.
</code></pre>

<p>最后一段说，不要直接调用此方法。如果你想强制更新布局，你可以调用<code>setNeedsLayout</code>方法；如果你想立即数显你的<code>views</code>，你需要调用<code>layoutIfNeeded</code>方法。</p>

<h2>layoutSubviews作用</h2>

<p><code>layoutSubviews</code>是对<code>subviews</code>重新布局。比如，我们想更新子视图的位置的时候，可以通过调用<code>layoutSubviews</code>方法，既可以实现对子视图重新布局。</p>

<p><code>layoutSubviews</code>默认是不做任何事情的，用到的时候，需要在自雷进行重写。</p>

<h2>layoutSubviews以下情况会被调用</h2>

<p>苹果官方文档已经强调，不能直接调用<code>layoutSubviews</code>对子视图进行重新布局。那么，<code>layoutSubviews</code>什么情况下会被调用呢？通过百度搜索，发现以下几种情况<code>layoutSubviews</code>会被调用。</p>

<ol>
<li>直接调用<code>setLayoutSubviews</code>。（这个在上面苹果官方文档里有说明）</li>
<li><code>addSubview</code>的时候。</li>
<li>当<code>view</code>的<code>frame</code>发生改变的时候。</li>
<li>滑动<code>UIScrollView</code>的时候。</li>
<li>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>
<li>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>事件。</li>
</ol>


<p>我简单测试了一下，上面基本都会被调用。 注意：</p>

<pre><code>当view的fram的值为0的时候，`addSubview`也不会调用`layoutSubviews`的。
</code></pre>

<p><code>layoutSubviews</code>方法在对自雷视图进行布局的时候非常方便。可以自己动手，深入理解<code>layoutSubviews</code>的调用机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[截取UIImage指定大小区域]]></title>
    <link href="http://www.superqq.com/blog/2015/07/26/jie-qu-uiimagezhi-ding-da-xiao-qu-yu/"/>
    <updated>2015-07-26T10:07:58+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/26/jie-qu-uiimagezhi-ding-da-xiao-qu-yu</id>
    <content type="html"><![CDATA[<p>最近遇到这样的需求：从服务器获取到一张照片，只需要显示他的左半部分，或者中间部分等等。也就是截取UIImage指定大小区域。</p>

<h2>UIImage扩展</h2>

<p>我的解决方案是对<code>UIImage</code>进行扩展。通过<code>CGImageRef</code>和<code>CGImage</code>完成截取，调用的方法是：<code>CGImageCreateWithImageInRect</code>。扩展类叫<code>UIImage+Crop</code>，具体代码如下：</p>

<h3>UIImage+Crop.h</h3>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

typedef NS_ENUM(NSInteger, XYCropImageStyle){
    XYCropImageStyleRight               =0,      // 右半部分
    XYCropImageStyleCenter              =1,      // 中间部分
    XYCropImageStyleLeft                =2,      // 左半部分
    XYCropImageStyleRightOneOfThird     =3,      // 右侧三分之一部分
    XYCropImageStyleCenterOneOfThird    =4,      // 中间三分之一部分
    XYCropImageStyleLeftOneOfThird      =5,      // 左侧三分之一部分
    XYCropImageStyleRightQuarter        =6,      // 右侧四分之一部分
    XYCropImageStyleCenterRightQuarter  =7,      // 中间右侧四分之一部分
    XYCropImageStyleCenterLeftQuarter   =8,      // 中间左侧四分之一部分
    XYCropImageStyleLeftQuarter         =9,      // 左侧四分之一部分
};

@interface UIImage (Crop)
- (UIImage *)imageByCroppingWithStyle:(XYCropImageStyle)style;

@end
</code></pre>

<h3>UIImage+Crop.m</h3>

<pre><code>#import "UIImage+Crop.h"

@implementation UIImage (Crop)

- (UIImage *)imageByCroppingWithStyle:(XYCropImageStyle)style
{
    CGRect rect;
    switch (style) {
        case XYCropImageStyleLeft:
            rect = CGRectMake(0, 0, self.size.width/2, self.size.height);
            break;
        case XYCropImageStyleCenter:
            rect = CGRectMake(self.size.width/4, 0, self.size.width/2, self.size.height);
            break;
        case XYCropImageStyleRight:
            rect = CGRectMake(self.size.width/2, 0, self.size.width/2, self.size.height);
            break;
        case XYCropImageStyleLeftOneOfThird:
            rect = CGRectMake(0, 0, self.size.width/3, self.size.height);
            break;
        case XYCropImageStyleCenterOneOfThird:
            rect = CGRectMake(self.size.width/3, 0, self.size.width/3, self.size.height);
            break;
        case XYCropImageStyleRightOneOfThird:
            rect = CGRectMake(self.size.width/3*2, 0, self.size.width/3, self.size.height);
            break;
        case XYCropImageStyleLeftQuarter:
            rect = CGRectMake(0, 0, self.size.width/4, self.size.height);
            break;
        case XYCropImageStyleCenterLeftQuarter:
            rect = CGRectMake(self.size.width/4, 0, self.size.width/4, self.size.height);
            break;
        case XYCropImageStyleCenterRightQuarter:
            rect = CGRectMake(self.size.width/4*2, 0, self.size.width/4, self.size.height);
            break;
        case XYCropImageStyleRightQuarter:
            rect = CGRectMake(self.size.width/4*3, 0, self.size.width/4, self.size.height);
            break;
        default:
            break;
    }
    CGImageRef imageRef = self.CGImage;
    CGImageRef imagePartRef = CGImageCreateWithImageInRect(imageRef, rect);
    UIImage *cropImage = [UIImage imageWithCGImage:imagePartRef];
    CGImageRelease(imagePartRef);
    return cropImage;
}
</code></pre>

<h2>实际运用</h2>

<p>简单测试一下，看看有没有实现我们想要的效果。首先，先加载一个完整的UIImageView。这个应该不难。代码如下：</p>

<pre><code>UIImageView *imgView = [[UIImageView alloc] init];
imgView.frame = CGRectMake((SCREEN.width - 226) / 2, 100, 226, 106);
UIImage *image = [UIImage imageNamed:@"ganggang"];
imgView.image = image;
[self.view addSubview:imgView];
</code></pre>

<p>运行一下：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/jiequing.png" alt="jiequing" /></p>

<p>要对UIImage进行裁剪，首先导入头文件：</p>

<pre><code>#import "UIImage+Crop.h"
</code></pre>

<p>在上面<code>UIImage *image = [UIImage imageNamed:@"ganggang"];</code>这段代码之后加上下面这句：</p>

<pre><code>image = [image imageByCroppingWithStyle:XYCropImageStyleLeft];
</code></pre>

<p><code>XYCropImageStyleLeft</code>是截取照片的左半部分。效果如下：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/jiequed.png" alt="jiequed" /></p>

<p>截取成功，还可以截取其他区域的，只需要传入不同的<code>XYCropImageStyle</code>即可实现。以上代码依然在<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>里。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员：这个周末不加班]]></title>
    <link href="http://www.superqq.com/blog/2015/07/25/cheng-xu-yuan-:zhe-ge-zhou-mo-bu-jia-ban/"/>
    <updated>2015-07-25T09:01:33+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/25/cheng-xu-yuan-:zhe-ge-zhou-mo-bu-jia-ban</id>
    <content type="html"><![CDATA[<p>时间依然没有停住它的脚步，新的周末如期而至。这应该是一件令人兴奋的时期，谁不想度过一个美好的周末呢？</p>

<p>作为程序员每天都在解决永远解不完的bug，做着永远做不完的需求，能有个周末好好休息休息，真的是一件非常奢侈的事情。</p>

<h2>我也是加班加过来的</h2>

<p>说到这个话题应该是程序员心中的痛啊，哪有程序员不加班的呢？我刚进公司的时候，公司刚成立不久。为了项目进度，拼命的加班，老板每天都在催进度。</p>

<p>那一段时间，公司的程序员们基本都是八九点下班。偶尔一次迎着夕阳下班，都高兴的不得了。不禁感叹一句，终于可以和太阳一起下班啦！</p>

<p>每个周六没有事情，大家也都乖乖的来加班。听着老板不断的画饼。不过好在，公司的发展很迅速，产品销售的也还不错。不过这好像跟我们程序员一点关系都没有。</p>

<h2>少加班或拒绝加班</h2>

<p>公司发展的好，对于程序员来说肯定是一件好事。无论老板有没有兑现当时画饼的承诺，我们都应该为公司的迅速发展而高兴。</p>

<p>随着公司的发展，越来越多的人才不断加入公司。我就喜欢和厉害的人一起工作，这样可以学到不少东西，这对我来说也是一种进步。</p>

<p>我想以后如果没有什么特别重要的事情，尽量选择少加班，或者直接拒绝加班。这应该是我们的权利。当然，说是这么说。如果真的需要加班，那还会义不容辞的，谁让我们选择这个苦逼的行业呢！</p>

<h2>这个周末如何度过</h2>

<p>这个周末我选择不加班。周六准备和高中同学一起聚会，就在上海。好几位同学都是做程序员的（笑），有的人今天还是请假出来聚会的。</p>

<p>自从高中毕业，相见的机会越来越少。所以这一次聚会大家都很珍惜。</p>

<p>周日大学同学来上海，他不是来找我的，他是来找他女朋友的。我呢，还是需要过去见上一面，一起聊聊各自的情况，毕竟来到上海啦。</p>

<p>这个周末你选择如何度过呢？·</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之沙盒和文件操作（汇总）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/25/ioskai-fa-zhi-sha-he-he-wen-jian-cao-zuo-(hui-zong-)/"/>
    <updated>2015-07-25T00:15:17+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/25/ioskai-fa-zhi-sha-he-he-wen-jian-cao-zuo-(hui-zong-)</id>
    <content type="html"><![CDATA[<p>关于沙盒和文件操作的文章写了几篇，在写的过程中加深了自己的记忆。今天来做一下汇总，算是对知识点的梳理。</p>

<h2>文章梳理</h2>

<p>1 <a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a></p>

<p>这是一篇关于沙盒的基础知识教程。简述沙盒的作用，对Documents、Library、tmp之间的区别做了介绍。通过两种方法打开沙盒，查看其中的内容。</p>

<p>2 <a href="http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing/">iOS开发之获取沙盒路径</a></p>

<p>沙盒里的文件夹包括Documents、Library、tmp。文章介绍了如何获取Documents、Library、Caches、tmp的路径。</p>

<p>3 <a href="http://www.superqq.com/blog/2015/07/23/ru-he-cha-kan-zhen-ji-de-sha-he-%28tu-wen-jiao-cheng-%29/">如何查看真机的沙盒（图文教程）</a></p>

<p>通过图文的方式详细讲解如何查看真机沙盒。</p>

<p>4 <a href="http://www.superqq.com/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng/">NSFileManager文件操作的十个小功能</a></p>

<p>NSFileManager是一个单列类，也是一个文件管理器。可以通过NSFileManager创建文件夹、创建文件、写文件、读文件内容等等基本功能。</p>

<h2>小记</h2>

<p>希望以上的知识梳理能帮助大家更好的掌握沙盒机制以及文件操作。我会持续分享更多关于iOS开发相关的技术文章。</p>

<p>swift推出这么久，不知道你有没有开始用swift写项目。推荐给你一个swift学习网站:<a href="http://www.iswifting.com/">swift开发</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSFileManager文件操作的十个小功能]]></title>
    <link href="http://www.superqq.com/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng/"/>
    <updated>2015-07-24T00:14:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/24/nsfilemanagerwen-jian-cao-zuo-de-shi-ge-xiao-gong-neng</id>
    <content type="html"><![CDATA[<p>NSFileManager是一个单列类，也是一个文件管理器。可以通过NSFileManager创建文件夹、创建文件、写文件、读文件内容等等基本功能。</p>

<p>下面将介绍NSFileManager文件操作的十个小功能。我们在Documents里面进行举例，首先是获取Documents的路径。这个在<a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a>已经详细讲解过了。获取Documents路径方法如下：</p>

<pre><code>- (NSString *)getDocumentsPath
{
    //获取Documents路径
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *path = [paths objectAtIndex:0];
    NSLog(@"path:%@", path);
    return path;
}
</code></pre>

<h3>创建文件夹</h3>

<pre><code>-(void)createDirectory{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSDirectory = [documentsPath stringByAppendingPathComponent:@"iOS"];
    BOOL isSuccess = [fileManager createDirectoryAtPath:iOSDirectory withIntermediateDirectories:YES attributes:nil error:nil];
    if (isSuccess) {
        NSLog(@"success");
    } else {
        NSLog(@"fail");
    }
}
</code></pre>

<h3>创建文件</h3>

<pre><code>-(void)createFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager createFileAtPath:iOSPath contents:nil attributes:nil];
    if (isSuccess) {
        NSLog(@"success");
    } else {
        NSLog(@"fail");
    }
}
</code></pre>

<h3>写文件</h3>

<pre><code>-(void)writeFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *content = @"我要写数据啦";
    BOOL isSuccess = [content writeToFile:iOSPath atomically:YES encoding:NSUTF8StringEncoding error:nil];
    if (isSuccess) {
        NSLog(@"write success");
    } else {
        NSLog(@"write fail");
    }
}
</code></pre>

<h3>读取文件内容</h3>

<pre><code>-(void)readFileContent{
    NSString *documentsPath =[self getDocumentsPath];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *content = [NSString stringWithContentsOfFile:iOSPath encoding:NSUTF8StringEncoding error:nil];
    NSLog(@"read success: %@",content);
}
</code></pre>

<h3>判断文件是否存在</h3>

<pre><code>- (BOOL)isSxistAtPath:(NSString *)filePath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:filePath];
    return isExist;
}
</code></pre>

<h3>计算文件大小</h3>

<pre><code>- (unsigned long long)fileSizeAtPath:(NSString *)filePath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:filePath];
    if (isExist){
        unsigned long long fileSize = [[fileManager attributesOfItemAtPath:filePath error:nil] fileSize];
        return fileSize;
    } else {
        NSLog(@"file is not exist");
        return 0;
    }
}
</code></pre>

<h3>计算整个文件夹中所有文件大小</h3>

<pre><code>- (unsigned long long)folderSizeAtPath:(NSString*)folderPath{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isExist = [fileManager fileExistsAtPath:folderPath];
    if (isExist){
        NSEnumerator *childFileEnumerator = [[fileManager subpathsAtPath:folderPath] objectEnumerator];
        unsigned long long folderSize = 0;
        NSString *fileName = @"";
        while ((fileName = [childFileEnumerator nextObject]) != nil){
            NSString* fileAbsolutePath = [folderPath stringByAppendingPathComponent:fileName];
            folderSize += [self fileSizeAtPath:fileAbsolutePath];
        }
        return folderSize / (1024.0 * 1024.0);
    } else {
        NSLog(@"file is not exist");
        return 0;
    }
}
</code></pre>

<h3>删除文件</h3>

<pre><code>-(void)deleteFile{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *iOSPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager removeItemAtPath:iOSPath error:nil];
    if (isSuccess) {
        NSLog(@"delete success");
    }else{
        NSLog(@"delete fail");
    }
}
</code></pre>

<h3>移动文件</h3>

<pre><code>- (void)moveFileName
{
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *filePath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *moveToPath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    BOOL isSuccess = [fileManager moveItemAtPath:filePath toPath:moveToPath error:nil];
    if (isSuccess) {
        NSLog(@"rename success");
    }else{
        NSLog(@"rename fail");
    }
}
</code></pre>

<h3>重命名</h3>

<pre><code>- (void)renameFileName
{
    //通过移动该文件对文件重命名
    NSString *documentsPath =[self getDocumentsPath];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *filePath = [documentsPath stringByAppendingPathComponent:@"iOS.txt"];
    NSString *moveToPath = [documentsPath stringByAppendingPathComponent:@"rename.txt"];
    BOOL isSuccess = [fileManager moveItemAtPath:filePath toPath:moveToPath error:nil];
    if (isSuccess) {
        NSLog(@"rename success");
    }else{
        NSLog(@"rename fail");
    }
}
</code></pre>

<p>以上文件操作代码都在<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>，可以直接通过git拉下来进行测试。关于NSFileManager的用法还有很多，一起接续探索吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何查看真机的沙盒（图文教程）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/23/ru-he-cha-kan-zhen-ji-de-sha-he-(tu-wen-jiao-cheng-)/"/>
    <updated>2015-07-23T00:29:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/23/ru-he-cha-kan-zhen-ji-de-sha-he-(tu-wen-jiao-cheng-)</id>
    <content type="html"><![CDATA[<p>在<a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a>，我们了解到如何查看模拟器的沙盒内容。直接在Finder->前往->前往文件夹里输入：</p>

<pre><code>/Users/ligang/Library/Application Support/iPhone Simulator/ 
</code></pre>

<p>这样就可以查看模拟器的沙盒内容。在平时开发中，我们应该大部分用的是真机测试。如果需要在沙盒里操作文件，那么我们可以通过观察真机沙盒的内容，来确定文件操作是否正确。</p>

<p>如果你已经知道如何查看真机的沙盒，请看看其他的文章吧，在这里<a href="zhannei.superqq.com">刚刚在线站内搜索</a>可以搜索到更多iOS开发相关的文章。接下来，通过图文的方式详细讲解如何查看真机沙盒。有兴趣的同学可以继续往下看。</p>

<h2>查看真机沙盒教程</h2>

<h3>打开Devices</h3>

<p>在xcode的上部导航栏里，选择window -> Devices</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox1.jpg" alt="realsandbox1.jpg" /></p>

<h3>找到目标APP</h3>

<p>我们拿<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>举例。界面如下图所示：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox2.jpg" alt="realsandbox2.jpg" /></p>

<h3>浏览沙盒目录结构</h3>

<h4>双击iOSStrongDemo</h4>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox3.jpg" alt="realsandbox3.jpg" /></p>

<h4>点击Show Container</h4>

<p>设置图标单击之后，如图所示：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox4.jpg" alt="realsandbox4.jpg" /></p>

<p>这样我们只能看到沙盒的目录结构。看不到实体文件。那么，我们下一步就是找到这个沙盒。</p>

<h3>Download Container保存到桌面</h3>

<p>如上图所示，有一个Download Container，选择之后，保存到桌面。</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox5.jpg" alt="realsandbox5.jpg" /></p>

<h3>右键显示包内容</h3>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox6.jpg" alt="realsandbox6.jpg" /></p>

<h3>查看沙盒目录</h3>

<p>AppDataInfo.plist是APP的配置文件：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox7.jpg" alt="realsandbox7.jpg" /></p>

<h3>打开AppData</h3>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/realsandbox8.jpg" alt="realsandbox8.jpg" /></p>

<p>这就是APP的沙盒，在这里我们可以对文件进行增删查改操作。更多内容以后继续慢慢分享。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快快快！27个提升效率的iOS开源库推荐]]></title>
    <link href="http://www.superqq.com/blog/2015/07/22/kuai-kuai-kuai-!27ge-ti-sheng-xiao-lu-de-ioskai-yuan-ku-tui-jian/"/>
    <updated>2015-07-22T13:11:49+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/22/kuai-kuai-kuai-!27ge-ti-sheng-xiao-lu-de-ioskai-yuan-ku-tui-jian</id>
    <content type="html"><![CDATA[<blockquote><p>CSDN移动将持续为您优选移动开发的精华内容，共同探讨移动开发的技术热点话题，涵盖移动应用、开发工具、移动游戏及引擎、智能硬件、物联网等方方面面。如果您想投稿、参与内容翻译工作，或寻求近匠报道，请发送邮件至tangxy#csdn.net（请把#改成@）。</p></blockquote>

<p>我热爱开源，更喜爱那些花费宝贵的业余时间来创造奇迹的开发者们，感谢他们将自己辛苦劳动的成果无偿分享给大家。开源作者和贡献者们，你们太了不起了，感谢你们所付出的一切。</p>

<p>鉴于我是收集不全会死星人，这里我根据个人喜好选取了一些iOS的开源库。这些项目的顺序完全随机，每个都棒到爆。绝大多数支持CocoaPods，所以将它们添加到你的Xcode项目中只是小事一桩。</p>

<p>在本文末尾你可以找到一个长文慎入版本——一个只包含题目与项目链接的简单列表。如果你觉得这篇文章有用的话，请把它分享给其他做iOS开发的小伙伴们，好酒也怕巷子深。</p>

<h3>1. <a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" title=“DZNEmptyDataSet”>DZNEmptyDataSet</a></h3>

<p>DZNEmptyDataSet算是一个很标准的iOS内建方式，适合用来处理空的table view和collection view。默认情况下，如果你的table view为空，屏幕就为空，这样一来用户体验并不理想。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55adfe02a4a2f_middle.jpg" alt="1" /></p>

<p>使用这个库，你只需遵守一些协议，iOS就会自动将collection view处理完善，并将用户消息以合适美观的方式显示出来。每个iOS项目都可以自动处理，不用再一一费神。</p>

<h3>2. <a href="https://github.com/jivesoftware/PDTSimpleCalendar" target="_blank" title=“PDTSimpleCalendar”>PDTSimpleCalendar</a></h3>

<p>你的应用需要一个简单美观且正常运行的日历组件吗？现在有了——PDTSimpleCalendar也许可以算是iOS最棒的日历组件了。你可以在各个方面对它进行定制，无论是运行逻辑还是外观方面。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55adff269e028_middle.jpg" alt="2" /></p>

<h3>3. <a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" title=“MagicalRecord”>MagicalRecord</a></h3>

<p>他们都说：Core Data简洁易用。他们又说：很棒很好用噢。哈？真的吗，苹果？添加到各个项目中的大量样板数据完全不符合简洁而易用的标准。更别提添加、移除和更新那一大堆的entities、保存context、按不同环境创建不同的Core Data堆栈等等。当然，我很喜欢Core Data，但是苹果真的可以把它更好地简化一下——使用MagicalRecord方式。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0130e5bb0_middle.jpg" alt="3" /></p>

<p>MagicalRecord就像是给Core Data提供了一层外包装，隐藏掉所有不相关的东西。如果你曾经使用过active record模式（比如Ruby on Rails），你就知道了。倾情推荐，在应用中使用Core Data的童鞋们可一定要试试。</p>

<h3>4. <a href="https://github.com/ViccAlexander/Chameleon" target="_blank" title=“Chameleon”>Chameleon</a></h3>

<p>如果你已经看到这里了，我猜你更有可能是个程序猿，而不是设计狮。这里有个东东很适合你。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae02035ca71_middle.jpg" alt="4" /></p>

<p>Chameleon是一个iOS的色彩框架。它运用现代化flat color将UIColor扩展地非常美观。我们还可以通过它运用自定义颜色创建调色板。它还有很多功用，请浏览readme。如果你想要应用美观的话，一定要把这个库加到项目里。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0212f22c6_middle.jpg" alt="4-1" /></p>

<h3>5. <a href="https://github.com/Alamofire/Alamofire" target="_blank" title=“Alamofire”>Alamofire</a></h3>

<p>Alamofire是一个简洁的网络库，用Swift语言编写。你是否曾经使用过AFNetworking呢？Alamofire是它的小弟。更年轻更时尚，当然（AFNetworking是用Objective-C编写的）。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae024c07d47_middle.jpg" alt="5" /></p>

<p>如果你需要进行网络的相关工作，诸如下载、上传与获取JSONs等等的话，Alamofire正是你所需要的。GitHub上8000人次推荐，一定不会错。</p>

<h3>6. <a href="https://github.com/raulriera/TextFieldEffects" target="_blank" title=“TextFieldEffects”>TextFieldEffects</a></h3>

<p>你不觉得标准的UITextField有些枯燥么？我也这样想——来认识一下TextFieldEffects吧！废话不多说，只要看几个例子：</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae048484702.jpg" alt="6" /></p>

<p>是啊，都是些简单的dropin控制器。你甚至可以在storyboard中使用IBDesignables。</p>

<p>不幸地是：这个库不支持CocoaPods（如果你来自未来，而这一情况什么时候会改变的话，一定要在Twitter上告诉我），但是它支持Carthage。你只管从GitHub上下载项目，把它放入你的workspace就行了。</p>

<h3>7. <a href="https://github.com/BradLarson/GPUImage" target="_blank" title=“GPUImage”>GPUImage</a></h3>

<p>你曾经写过照相机应用吗？如果没有的话，很快你一定会遇到这个库的。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae04fe94fc8.jpg" alt="7" /></p>

<p>GPUImage为我们提供了一个GPU加速的照相机效果（同时支持照片与视频），而且处理速度飞快。在App Store中，使用这个库的应用数以百计。我有一个应用也用到了GPUImage。 它在GitHub上获得了8869个star，而且还在增长。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae053f548d5_middle.jpg" alt="7-1" /></p>

<h3>8. <a href="https://github.com/nicklockwood/iRate" target="_blank" title=“iRate”>iRate</a></h3>

<p>想要在App Store中获得更多评论的最佳方式是什么？想要回答这个问题，我缺乏切实数据，但如果必须猜一下的话，我会建议问问用户。也许这样做有点老套——大多开发者现在都有创建定制的应用内置alert。</p>

<p>但是如果你没有时间，或者不想从头实现的话，最好用一下iRata。这个就是iRata——一个小型库——你可以把它放入项目中，把问卷调查什么的都忘记吧，iRate会在恰当的时候为你解决这个问题。</p>

<h3>9. <a href="https://github.com/nihalahmed/GameCenterManager" target="_blank" title=“GameCenterManager”>GameCenterManager</a></h3>

<p>无论你喜不喜欢单例模式，管理一个GameCenter都比我们已知的其他相反模式要好很多。（你的游戏只有一个GameCenter，对吗？）</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae05bd3f99e_middle.jpg" alt="9" /></p>

<p>说实话，在iOS上管理GameCenter vanilla并不算难，但是有了这个库会更简单也更快。好上加好不是更好么。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae05c9cba37_middle.jpg" alt="9-1" /></p>

<p>我在我一个游戏中用到了这个，体验很好。</p>

<h3>10. <a href="https://github.com/pkluz/PKRevealController" target="_blank" title=“PKRevealController 2”>PKRevealController 2</a></h3>

<p>这个要注意，真的很棒！是我最喜爱的iOS控件之一。PKRevealController是一个可以滑动的侧边栏菜单（可向左、向右或者同时向两侧），只需手指轻轻一点（或者按一下按钮，但是这样滑动时不够炫酷）。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae067bd3b6b.jpg" alt="2" /></p>

<p>我试过一些可以提供这类控制的其他库，而PKRevealController是最棒的。安装简便，高度定制且对手势识别良好。可以当做一个标准控件用在iOS SDK中。</p>

<h3>11. <a href="https://github.com/slackhq/SlackTextViewController" target="_blank" title=“SlackTextViewController”>SlackTextViewController</a></h3>

<p>你曾经用过Slack iOS应用吗？如果你在较大的软件公司工作，也许会用过。对那些没用过的人呢？—?Slack令人激动。用到Slack的应用也是这样，尤其是用作极佳、定制的文本输入控制时。这时你有了一个现成可用在应用中的代码。</p>

<p>自适应文本区域？试一下。</p>

<p>手势识别、自动填充、多媒体合并？试一下。</p>

<p>快速drop-in解决方案？试一下。</p>

<p>其他还想要什么？</p>

<h3>12. <a href="https://github.com/romaonthego/RETableViewManager" target="_blank" title=“RETableViewManager”>RETableViewManager</a></h3>

<p>RETableViewManager可以帮助你进行动态创建与管理table views。它给我们提供了预定义cells（bool类型、文本、日期等等——请看下面的截图），但是你还可以创建自定义views，并与默认视图一同使用。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0702088ab_middle.jpg" alt="12" /></p>

<p>左侧截图显得非常古板！在storyboard中没有这个库的时候，你能做的就是这些了，但是有时候代码比可视化编辑器要好。</p>

<h3>13. <a href="https://github.com/nickoneill/PermissionScope" target="_blank" title=“PermissionScope”>PermissionScope</a></h3>

<p>用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—>更多活跃用户->更高的留存率->数据更好->下载率更高。墙裂推荐pod。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0733b6110_middle.jpg" alt="13" /></p>

<h3>14. <a href="https://github.com/TransitApp/SVProgressHUD" target="_blank" title=“SVProgressHUD”>SVProgressHUD</a></h3>

<p>这张图片在正常加载，无需等待太久或者刷新页面。这正是SVProgressHUD在你的应用中的表现。如果你需要定制化的等待提示器，这个就是了（也许是最好的）。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae077d15432.jpg" alt="14" /></p>

<h3>15. <a href="https://github.com/PrideChung/FontAwesomeKit" target="_blank" title=“FontAwesomeKit”>FontAwesomeKit</a></h3>

<p>Font Awesome很棒，有了它你可以很容易地给项目加字体，使用方式繁多。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae07a34b492_middle.jpg" alt="15" /></p>

<h3>16. <a href="https://github.com/SnapKit/SnapKit" target="_blank" title=“SnapKit”>SnapKit</a></h3>

<p>喜欢自动布局吗？当然喜欢！至少在storyboard中创建时会喜欢。 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae07ebf3c2c_middle.jpg" alt="16" /></p>

<h3>17. <a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" title=“MGSwipeTableCell”>MGSwipeTableCell</a></h3>

<p>这是另一个常见于很多应用中的UI组件，苹果应该考虑在标准的iOS SDK中加入一些类似的内容。Swipeable表格cell是这个pod的最佳描述，也是最好的。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0953304a9.jpg" alt="17" /></p>

<p>这只是其中三个动画类型，还有更多变化，请查看readme。</p>

<h3>18. <a href="https://github.com/Quick/Quick" target="_blank" title=“Quick”>Quick</a></h3>

<p>用于Swift中的单元测试（也可用于Objective-C），与Xcode整合在一起。如果你是Objective-C的粉丝，我建议用Specta代替这个，但是对Swift使用者来说，Quick是最佳选择。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0a6012068_middle.jpg" alt="18" /></p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0a767198e_middle.jpg" alt="181" /></p>

<h3>19. <a href="https://github.com/saturngod/IAPHelper" target="_blank" title=“IAPHelper”>IAPHelper</a></h3>

<p>应用内付费给我们提供了很多样本代码，而这个库丢掉了那些代码，将金钱交易相关的大多通用任务做了简单的封装。</p>

<h3>20. <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" title=“ReactiveCocoa”>ReactiveCocoa</a></h3>

<p>好吧，这是个小怪物。</p>

<p>ReactiveCocoa并不像列表中其他库一样，它不是小型的drop-in项目。ReactiveCocoa给我们带来了一个迥异的编程风格与结构，它是基于信号与数据流的。首先你需要忘掉已知的一切，才能理解它的工作方式。很有难度，但是价值不斐。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0acf1f0dc_middle.jpg" alt="20" /></p>

<p>在这里教ReactiveCocoa有点不合适，但是如果你感兴趣的话，我会提供一些好源：</p>

<ul>
<li><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank" title=“Getting Started with ReactiveCocoa”>Getting Started with ReactiveCocoa</a></li>
<li><a href="http://nshipster.com/reactivecocoa/" target="_blank" title=“Mattt Thompson：Reactive​Cocoa”>Mattt Thompson：Reactive​Cocoa</a></li>
<li><a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" title=“ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2”>ReactiveCocoa Tutorial – The Definitive Introduction: Part &frac12;</a></li>
</ul>


<p>注意：对我们iOS开发社区的朋友来说，这会是一个稍微有些技术含量的活儿。</p>

<h3>21. <a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" title=“SwiftyJSON”>SwiftyJSON</a></h3>

<p>使Swift的JSON解析变得简单。</p>

<h3>22. <a href="https://github.com/MengTo/Spring" target="_blank" title=“Spring”>Spring</a></h3>

<p>使动画在简单性、可链接性与声明性方面有所提高。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0dfe58b6c_middle.jpg" alt="22" /></p>

<h3>23. <a href="https://github.com/ArtSabintsev/FontBlaster" target="_blank" title=“FontBlaster”>FontBlaster</a></h3>

<p>载入定制字体时更简单。</p>

<h3>24. <a href="https://github.com/JanC/TAPromotee" target="_blank" title=“TAPromotee”>TAPromotee</a></h3>

<p>交叉推广应用是你可以免费实现的最佳市场推广策略之一。使用这个库做起来非常简单，不用都不可能——将TAPromotee加入你的podfile中，免费配置与享受更多下载吧。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0e81d6464_middle.jpg" alt="24" /></p>

<h3>25. <a href="https://github.com/contentful-labs/Concorde" target="_blank" title=“Concorde”>Concorde</a></h3>

<p>你在应用中载入了一堆jpeg吗？有了Concorde，你可以用更好的方式来解决，这是一个很大的进步。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae11e47390e.jpg" alt="25" /></p>

<h3>26. <a href="https://github.com/kishikawakatsumi/KeychainAccess" target="_blank" title=“KeychainAccess”>KeychainAccess</a></h3>

<p>管理Keychain接入的小助手。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0f198a4dc_middle.jpg" alt="26" /></p>

<h3>27. <a href="https://github.com/danielgindi/ios-charts" target="_blank" title=“iOS-charts”>iOS-charts</a></h3>

<p>最后一个，但绝不是最不重要的——iOS图表库！非常有用而且美观，这里我无需赘言。向下看，你就知道用它可以做什么了。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0f6715aec_middle.jpg" alt="27" /></p>

<p>没错，一切都变成了drop-in组件了（也许是“code-in组件）。</p>

<p><img src="http://img.ptcms.csdn.net/article/201507/21/55ae0f7ec6743_middle.jpg" alt="271" /></p>

<p>不幸的是，它还不支持CocoaPods，所以你得手动把它拽到你的Xcode workspace里面去。</p>

<p>超长慎入列表：</p>

<ol>
<li><a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" title=“DZNEmptyDataSet”>DZNEmptyDataSet</a>（UI，空表格视图解算器）</li>
<li><a href="https://github.com/jivesoftware/PDTSimpleCalendar" target="_blank" title=“PDTSimpleCalendar”>PDTSimpleCalendar</a>（UI，drop-in日历组件）</li>
<li><a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" title=“MagicalRecord”>MagicalRecord</a>（实施活跃记录模式的Core Data助手）</li>
<li><a href="https://github.com/ViccAlexander/Chameleon" target="_blank" title=“Chameleon”>Chameleon</a>（UI，色彩框架）</li>
<li><a href="https://github.com/Alamofire/Alamofire" target="_blank" title=“Alamofire”>Alamofire</a>（Swift 网络）</li>
<li><a href="https://github.com/raulriera/TextFieldEffects" target="_blank" title=“TextFieldEffects”>TextFieldEffects</a> （UI，自定义外观的文本区域）</li>
<li><a href="https://github.com/BradLarson/GPUImage" target="_blank" title=“GPUImage”>GPUImage</a>（快速图片处理）</li>
<li><a href="https://github.com/nicklockwood/iRate" target="_blank" title=“iRate”>iRate</a>（获取用户评价）</li>
<li><a href="https://github.com/nihalahmed/GameCenterManager" target="_blank" title=“GameCenterManager”>GameCenterManager</a>（快速管理游戏中心）</li>
<li><a href="https://github.com/pkluz/PKRevealController" target="_blank" title=“PKRevealController 2”>PKRevealController 2</a>（UI，滑动侧边栏菜单）</li>
<li><a href="https://github.com/slackhq/SlackTextViewController" target="_blank" title=“SlackTextViewController”>SlackTextViewController</a>（UI，高度可定制的自定义文本区域）</li>
<li><a href="https://github.com/romaonthego/RETableViewManager" target="_blank" title=“RETableViewManager”>RETableViewManager</a>（自动以代码创建表格视图）</li>
<li><a href="https://github.com/nickoneill/PermissionScope" target="_blank" title=“PermissionScope”>PermissionScope</a>（UI，预询问用户系统权限的友好体验）</li>
<li><a href="https://github.com/TransitApp/SVProgressHUD" target="_blank" title=“SVProgressHUD”>SVProgressHUD</a> （UI，自定义等待进度条）</li>
<li><a href="https://github.com/PrideChung/FontAwesomeKit" target="_blank" title=“FontAwesomeKit”>FontAwesomeKit</a> （快速添加Awesome字体）</li>
<li><a href="https://github.com/SnapKit/SnapKit" target="_blank" title=“SnapKit”>SnapKit</a>（在代码中快速自动布局）</li>
<li><a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" title=“MGSwipeTableCell”>MGSwipeTableCell</a> （UI，可滑动的表格视图cell）</li>
<li><a href="https://github.com/Quick/Quick" target="_blank" title=“Quick”>Quick</a>（Swift单元测试框架）</li>
<li><a href="https://github.com/saturngod/IAPHelper" target="_blank" title=“IAPHelper”>IAPHelper</a>（应用内购买助手封装）</li>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" title=“ReactiveCocoa”>ReactiveCocoa</a>（FRP框架）</li>
<li><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" title=“SwiftyJSON”>SwiftyJSON</a>（Swift JSON库）</li>
<li><a href="https://github.com/MengTo/Spring" target="_blank" title=“Spring”>Spring</a>（动画框架）</li>
<li><a href="https://github.com/ArtSabintsev/FontBlaster" target="_blank" title=“FontBlaster”>FontBlaster</a>（在应用中快速载入个性化字体）</li>
<li><a href="https://github.com/JanC/TAPromotee" target="_blank" title=“TAPromotee”>TAPromotee</a>（使用drop-in视图交叉推广应用）</li>
<li><a href="https://github.com/contentful-labs/Concorde" target="_blank" title=“Concorde”>Concorde</a>（下载解码渐进式jpeg）</li>
<li><a href="https://github.com/kishikawakatsumi/KeychainAccess" target="_blank" title=“KeychainAccess”>KeychainAccess</a>（简便管理keychain）</li>
<li><a href="https://github.com/danielgindi/ios-charts" target="_blank" title=“iOS-charts”>iOS-charts</a>（美观的图表库）</li>
</ol>


<p>文章来源：<a href="https://medium.com/app-coder-io/27-ios-open-source-libraries-to-skyrocket-your-development-301b67d3124c" target="_blank" title=“Medium”>Medium</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之获取沙盒路径]]></title>
    <link href="http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing/"/>
    <updated>2015-07-22T01:02:41+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/22/ioskai-fa-zhi-huo-qu-sha-he-lu-jing</id>
    <content type="html"><![CDATA[<p><a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">iOS开发之沙盒机制（SandBox)</a>详细讲解了沙盒的一些机制。在开发中，我们需要对沙盒进行操作，所以我们需要获取到沙盒路径。</p>

<p>沙盒里的文件夹包括Documents、Library、tmp。这三个文件夹的作用请点击<a href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-%28sandbox/">这里</a>。接下来我们来讲解如何获取Documents、Library、tmp的路径。</p>

<h3>获取沙盒根目录</h3>

<p>获取沙盒根目录，直接调用NSHomeDirectory()：</p>

<pre><code>//获取沙盒根目录
NSString *directory = NSHomeDirectory();
NSLog(@"directory:%@", directory);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:40:16.185 iOSStrongDemo[1605:555658] directory:/var/mobile/Containers/Data/Application/F9418815-51A9-4A0A-A76C-6FD37C400928
</code></pre>

<p>这个是真机的路径，大家有时间的话可以看看模拟器的根目录路径。</p>

<h3>获取Documents路径</h3>

<p>获取Documents路径如下：</p>

<pre><code>//获取Documents路径
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *path = [paths objectAtIndex:0];
NSLog(@"path:%@", path);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:41:41.397 iOSStrongDemo[1613:556159] path:/var/mobile/Containers/Data/Application/A62B886B-A8F0-4215-B59D-1F505C3997BD/Documents
</code></pre>

<p>获取Documents文件夹目录,第一个参数是说明获取Doucments文件夹目录，第二个参数说明是在当前应用沙盒中获取。</p>

<h3>获取Library路径</h3>

<pre><code>//获取Library路径
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
NSString *path = [paths objectAtIndex:0];
NSLog(@"path：%@", path);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:43:15.803 iOSStrongDemo[1619:556638] /var/mobile/Containers/Data/Application/17300507-4643-4DE7-BC68-E13DB19C8D98/Library
</code></pre>

<h3>获取Caches路径</h3>

<pre><code>//获取Caches路径
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
NSString *path = [paths objectAtIndex:0];
NSLog(@"path：%@", path);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:44:31.383 iOSStrongDemo[1626:557083] path：/var/mobile/Containers/Data/Application/1E945B52-E29D-4041-A489-1AA1B11BB960/Library/Caches
</code></pre>

<h3>获取tmp路径</h3>

<pre><code>NSString *tmp = NSTemporaryDirectory();
NSLog(@"tmp：%@", tmp);
</code></pre>

<p>控制台输出：</p>

<pre><code>2015-07-22 00:46:07.846 iOSStrongDemo[1632:557537] tmp：/private/var/mobile/Containers/Data/Application/4BE02307-1CC5-47E8-BEA8-CEBB7ED5A402/tmp/
</code></pre>

<p>以上是iOS开发中获取沙盒路径的方法，也许还有更好的获取方法等待我们去发现。后面我们还会讲到关于在沙盒里进行读写文件操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[报错：failed to Get the Task for Process 1285（解决方案）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/21/bao-cuo-:process-launch-failed-failed-to-get-the-task-for-process-1285(jie-jue-fang-an-)/"/>
    <updated>2015-07-21T00:16:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/21/bao-cuo-:process-launch-failed-failed-to-get-the-task-for-process-1285(jie-jue-fang-an-)</id>
    <content type="html"><![CDATA[<h2>你遇到的问题别人也遇到过</h2>

<p>初接触iOS开发的童鞋估计会被真机调试搞的稀里糊涂的。在模拟器上运行什么问题没有，真机调试就会碰到各种各样的问题。</p>

<p>不用担心。记住：你碰到的问题别人肯定都已经碰到过了。我们不是有百度和谷歌嘛，把你的问题描述出来，一定有解决方案的。还可以在<a href="http://zhannei.superqq.com/">刚刚在线站内搜索</a>里搜索，说不定也能帮你解决不少问题呢。</p>

<p>我会经常把自己开发过程中碰到的调试问题，一一总结出来。一来是帮助自己在下一次碰到同样问题时，可以游刃有余。二来是帮助大家再碰到类似问题的时候，有一个参考的作用。</p>

<h2>failed to get the task for process 1285</h2>

<p>这一次碰到的问题是这样的：模拟器上运行正常。我在iPhone 6上运行，程序编译正常，但是跑起来之后，大概一两秒的时间，就闪退（代码是没有问题的）。这个时候，Xcode6.4弹出这样的提示：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/fixbug12850.jpg" alt="fixbug1285" /></p>

<pre><code>Could not launch “iOSStrongDemo”
process launch failed: failed to get the task for process 1285
</code></pre>

<h2>错误分析</h2>

<p>我看了一下Build Settings里的Code Signing配置，发现Provisioning Profile选择的是XC Ad Hoc: *。如下图所示：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/fixbug.jpg" alt="fixbug" /></p>

<p>Ad Hoc是用来实现发布前的用户测试的，也就是通过Ad Hoc将未发布的App给其他人提前使用。显然这是不对的，我们是要真机调试。</p>

<h2>解决方案</h2>

<p>解决方法很简单，将Provisioning Profile换成用开发证书创建的Provisioning Profile即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之沙盒机制（SandBox)]]></title>
    <link href="http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-(sandbox/"/>
    <updated>2015-07-20T00:36:13+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/20/ioskai-fa-zhi-sha-he-ji-zhi-(sandbox</id>
    <content type="html"><![CDATA[<p>iOS APP可以在自己的沙盒里读写文件，但是，不可以访问其他APP的沙盒。每一个APP都是一个信息孤岛，相互是不可以进行通信的，唯独可以通过<a href="http://www.superqq.com/blog/2015/07/14/xcode6-dot-4zhu-ce-url-schemebu-zou-xiang-jie/">URL Scheme</a>。沙盒里面的文件可以是照片、声音文件、文本、属性列表等。</p>

<h2>沙盒机制简介</h2>

<p><strong>沙盒简述：</strong></p>

<ol>
<li>每一个APP都有一个存储空间，就是沙盒。</li>
<li>APP之间不能相互通信。</li>
<li>沙盒根目录结构：Documents、Library、temp。</li>
</ol>


<p>简述一下Documents、Library、tmp的区别：</p>

<ol>
<li><strong>Documents：</strong>用于存储用户数据，iTunes备份和恢复的时候会包括此目录，所以，苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下。</li>
<li><strong>Library：</strong>包含两个子目录：Caches 和 Preferences。Caches用来存放用户需要换成的文件。Preferences是APP的偏好设置，可以通过NSUserDefaults来读取和设置。</li>
<li><strong>tmp：</strong> 用于存放临时文件，这个可以放一些当APP退出后不再需要的文件。</li>
</ol>


<h2>打开模拟器沙盒方法</h2>

<p><strong>方法一：前往文件夹打开</strong></p>

<pre><code>/Users/ligang/Library/Application Support/iPhone Simulator/ 
</code></pre>

<p>直接在Finder->前往->前往文件夹，输入上面的内容即可。记住将ligang换成你的电脑用户名。</p>

<p><strong>方法二：通过Finder一步步查找</strong></p>

<p>模拟器上的APP的沙盒实在用户目录下的资源库里面，但是资源库是隐藏文件夹。所以查看沙盒之前，现将隐藏文件夹显示出来。显示隐藏文件的命令：</p>

<pre><code>defaults write com.apple.finder AppleShowAllFiles -bool true
</code></pre>

<p>用心的童鞋会发现，隐藏隐藏文件的命令：</p>

<pre><code>defaults write com.apple.finder AppleShowAllFiles -bool false
</code></pre>

<p>查找步骤请看图：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/sandbox.jpg" alt="sandbox" /></p>

<p>关于沙盒机制（SandBox)的介绍大概就是这样，以后面试的时候万一碰到你就可以这么回答。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员头条：程序员关心的，才是头条！]]></title>
    <link href="http://www.superqq.com/blog/2015/07/19/cheng-xu-yuan-tou-tiao-:cheng-xu-yuan-guan-xin-de-,cai-shi-tou-tiao-!/"/>
    <updated>2015-07-19T10:19:17+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/19/cheng-xu-yuan-tou-tiao-:cheng-xu-yuan-guan-xin-de-,cai-shi-tou-tiao-!</id>
    <content type="html"><![CDATA[<p>看到这个标题，你是不是很熟悉。你肯定能想到今日头条。《今日头条》是一款会自动学习的资讯软件,它会聪明地分析你的兴趣爱好,自动为你推荐喜欢的内容,并且越用越懂你.你关心的,才是头条!</p>

<h2>我想做什么？</h2>

<p>也许你的手机上装的就有今日头条，我也装的有，但是不经常看。今天我不是来为今日头条代言的，我是想告诉大家我想做什么。</p>

<p>作为程序员，我们更关心的是高质量的技术文章。有时一篇优秀的文章，可以让我们技术得到提高，思维得到开拓。</p>

<p>如何找到优秀的技术文章，成为了摆在我们面前的问题。虽然，有很多程序员门户网站，但是想在上面找到一篇好的文章还是挺不容易的。</p>

<p>所以，我决定为大家挖掘优秀的文章。农夫山泉有句广告语：我不生产水,我只是大自然的搬运工。这句广告语也非常适合我即将要做的程序员头条。</p>

<h2>程序员头条简介</h2>

<p>网站名称：程序员头条；slogan：程序员关心的，才是头条！如果你有非常棒的slogan，请直接回复我。域名：<a href="wwww.90159.com">wwww.90159.com</a>，是不是觉得域名还不错，别忘了我之前炒过域名噢！</p>

<p>我希望程序员头条能成为高质量技术文章聚合网站。时间充裕的情况下，我还将推出程序员头条APP，方便大家手机阅读。</p>

<p>我每天将拿出1-2个小时的时间来找文章。当然，我一个人的力量是渺小的，我希望发动大家的力量，一起为发现优秀的技术文章而努力。具体投稿方式请往下看。</p>

<h2>投稿方式</h2>

<p>你可以将自己的优秀文章链接发给我，你也可以将你发现的优秀文章链接发给我。</p>

<ol>
<li><p>标题上一定要加上【投稿】二字，邮件太多，以免误删。</p></li>
<li><p>投稿邮箱： <strong>worldligang@163.com</strong></p></li>
</ol>


<p>凡是投稿过来的文章，我都会加上原文链接，来增加你的网站或博客的访问量。</p>

<h2>招聘一名小编</h2>

<p>期望：</p>

<ol>
<li>你有一颗积极向上心</li>
<li>你会用markdown</li>
<li>有较强的协调能力、应变能力和外联能力、做事有条理、工作效率高。</li>
</ol>


<p>如果你符合上述条件，请加入我们吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[禅与Objective-C编程艺术(译)]]></title>
    <link href="http://www.superqq.com/blog/2015/07/18/ios/"/>
    <updated>2015-07-18T23:15:26+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/18/ios</id>
    <content type="html"><![CDATA[<p>禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）</p>

<p>原文 <a href="https://github.com/objc-zen/objc-zen-book">https://github.com/objc-zen/objc-zen-book</a></p>

<p><img src="https://github.com/objc-zen/objc-zen-book/raw/master/images/zen-logo-thumb.png" alt="" /></p>

<h1>前言</h1>

<p>我们在 2013 年 11 月份开始写这本书，最初的目标是提供一份如何编写干净漂亮的 Objective-C 代码的指南：现在虽然有很多指南，但是它们都是有一些问题的。我们不想介绍一些死板的规定，我们想提供一个在开发者们之间写更一致的代码的途径。随时间的推移，这本书开始转向介绍如何设计和构建优秀的代码。</p>

<p>这本书的观点是代码不仅是可以编译的，同时应该是 “有效” 的。好的代码有一些特性：简明，自我解释，优秀的组织，良好的文档，良好的命名，优秀的设计以及可以被久经考验。
本书的一个理念是是代码的清晰性优先于性能，同时阐述为什么应该这么做。
虽然所有的代码都是 Objective-C 写的，但是一些主题是通用的，并且独立于编程语言。</p>

<h2>Swift</h2>

<p>在 2014 年 6 月 6 日，苹果发布了面向 iOS 和 Mac 开发的新语言： Swift。
这个新语言与 Objective-C 截然不同。所以，我们改变了写这本书的计划。我们决定发布这本书当前的状态，而不是继续书写我们原来计划写下去的主题。
Objective-C 没有消失，但是现在用一个慢慢失去关注的语言来继续写这本书并不是一个明智的选择。</p>

<h2>贡献给社区</h2>

<p>我们将这本书免费发布并且贡献给社区，因为我们希望提供给读者一些有价值的内容。如果你能学到至少一条最佳实践，我们的目的就达到了。</p>

<p>我们已经非常用心地打磨了这些文字，但是仍然可能有一些拼写或者其他错误。我们非常希望读者给我们一个反馈或者建议，以来改善本书。所以如果有什么问题的话，请联系我们。我们非常欢迎各种 pull-request。</p>

<h2>作者</h2>

<p><strong>Luca Bernardi</strong></p>

<ul>
<li><a href="http://lucabernardi.com">http://lucabernardi.com</a></li>
<li>@luka_bernardi</li>
<li><a href="http://github.com/lukabernardi">http://github.com/lukabernardi</a></li>
</ul>


<p><strong>Alberto De Bortoli</strong></p>

<ul>
<li><a href="http://albertodebortoli.com">http://albertodebortoli.com</a></li>
<li>@albertodebo</li>
<li><a href="http://github.com/albertodebortoli">http://github.com/albertodebortoli</a></li>
</ul>


<h2>关于中文翻译</h2>

<p>译者</p>

<p><strong>林翔宇</strong>
- <a href="http://linxiangyu.org">http://linxiangyu.org</a>
- <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#108;&#x69;&#x6e;&#120;&#105;&#97;&#110;&#x67;&#121;&#x75;&#64;&#x6e;&#x75;&#112;&#x74;&#101;&#114;&#46;&#111;&#114;&#x67;">&#x6c;&#x69;&#x6e;&#x78;&#105;&#x61;&#x6e;&#103;&#x79;&#x75;&#64;&#110;&#117;&#112;&#x74;&#x65;&#x72;&#46;&#x6f;&#114;&#103;</a>
- <a href="http://github.com/oa414">http://github.com/oa414</a></p>

<p><strong>庞博</strong>
- <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#98;&#x6f;&#112;&#97;&#110;&#x67;&#x40;&#115;&#x6f;&#104;&#117;&#45;&#x69;&#x6e;&#99;&#46;&#x63;&#x6f;&#x6d;">&#98;&#x6f;&#112;&#x61;&#110;&#103;&#64;&#115;&#111;&#104;&#x75;&#x2d;&#x69;&#110;&#99;&#x2e;&#99;&#x6f;&#109;</a>
- <a href="https://github.com/heistings">https://github.com/heistings</a></p>

<p>翻译已得到原作者许可，并且会在更加完善后申请合并到原文仓库。</p>

<p><strong>部分译文表达可能存在不妥之处，非常欢迎各种修订建议和校队。 请直接 fork 本仓库，在 README.md 文件中修改，并申请 pull request 到 <a href="https://github.com/oa414/objc-zen-book-cn/">https://github.com/oa414/objc-zen-book-cn/</a>。</strong></p>

<h1>条件语句</h1>

<p>为了避免错误，条件语句体应该总是被大括号包围，即使可以不这样做（比如，条件语句体只有一行内容）。可能的错误是：多加了第二行，并且误以为它是 if 语句体里面的。此外，更危险的是，如果把 if 语句体里的一行注释掉了，之后的一行代码会成为 if 语句里的代码。</p>

<p><strong>推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) {
</span><span class='line'>    return success;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error)
</span><span class='line'>    return success;</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (!error) return success;</span></code></pre></td></tr></table></div></figure>


<p>在 2014年2月 苹果的 SSL/TLS 实现里面发现了知名的 <a href="https://gotofail.com/">goto fail</a> 错误。</p>

<p>代码在这里：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static OSStatus
</span><span class='line'>SSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa, SSLBuffer signedParams,
</span><span class='line'>                                 uint8_t *signature, UInt16 signatureLen)
</span><span class='line'>{
</span><span class='line'>  OSStatus        err;
</span><span class='line'>  ...
</span><span class='line'>
</span><span class='line'>  if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)
</span><span class='line'>    goto fail;
</span><span class='line'>  if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
</span><span class='line'>    goto fail;
</span><span class='line'>    goto fail;
</span><span class='line'>  if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)
</span><span class='line'>    goto fail;
</span><span class='line'>  ...
</span><span class='line'>
</span><span class='line'>fail:
</span><span class='line'>  SSLFreeBuffer(&signedHashes);
</span><span class='line'>  SSLFreeBuffer(&hashCtx);
</span><span class='line'>  return err;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>显而易见，这里有没有括号包围的2行连续的 <code>goto fail;</code> 。我们当然不希望写出上面的代码导致错误。</p>

<p>此外，在其他条件语句里面也应该按照这种风格统一，这样更便于检查。</p>

<h2>尤达表达式</h2>

<p>不要使用尤达表达式。尤达表达式是指，拿一个常量去和变量比较而不是拿变量去和常量比较。它就像是在表达 “蓝色是不是天空的颜色” 或者 “高个是不是这个男人的属性” 而不是  “天空是不是蓝的” 或者 “这个男人是不是高个子的”</p>

<p><img src="./images/yoda.png" alt="Yoda" /></p>

<p>（译者注：名字起源于星球大战中尤达大师的讲话方式，总是用倒装的语序）</p>

<p><strong>推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ([myValue isEqual:@42]) { ...</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ([@42 isEqual:myValue]) { ...</span></code></pre></td></tr></table></div></figure>


<h2>nil 和 BOOL 检查</h2>

<p>类似于 Yoda 表达式，nil 检查的方式也是存在争议的。一些 notous 库像这样检查对象是否为 nil：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (nil == myValue) { ...</span></code></pre></td></tr></table></div></figure>


<p>或许有人会提出这是错的，因为在 nil 作为一个常量的情况下，这样做就像 Yoda 表达式了。 但是一些程序员这么做的原因是为了避免调试的困难，看下面的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (myValue == nil) { ...</span></code></pre></td></tr></table></div></figure>


<p>如果程序员敲错成这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (myValue = nil) { ...</span></code></pre></td></tr></table></div></figure>


<p>这是合法的语句，但是即使你是一个丰富经验的程序员，即使盯着眼睛瞧上好多遍也很难调试出错误。但是如果把 nil 放在左边，因为它不能被赋值，所以就不会发生这样的错误。 如果程序员这样做，他/她就可以轻松检查出可能的原因，比一遍遍检查敲下的代码要好很多。</p>

<p>为了避免这些奇怪的问题，可以用感叹号来作为运算符。因为 nil 是 解释到 NO，所以没必要在条件语句里面把它和其他值比较。同时，不要直接把它和 <code>YES</code> 比较，因为 <code>YES</code> 的定义是 1， 而 <code>BOOL</code> 是 8 bit的，实际上是 char 类型。</p>

<p><strong>推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (someObject) { ...
</span><span class='line'>if (![someObject boolValue]) { ...
</span><span class='line'>if (!someObject) { ...</span></code></pre></td></tr></table></div></figure>


<p><strong>不推荐:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (someObject == YES) { ... // Wrong
</span><span class='line'>if (myRawValue == YES) { ... // Never do this.
</span><span class='line'>if ([someObject boolValue] == NO) { ...</span></code></pre></td></tr></table></div></figure>


<p>同时这样也能提高一致性，以及提升可读性。</p>

<p>原文 <a href="https://github.com/objc-zen/objc-zen-book">https://github.com/objc-zen/objc-zen-book</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我这个站长是怎么炼成的]]></title>
    <link href="http://www.superqq.com/blog/2015/07/17/wo-zhe-ge-zhan-chang-shi-zen-yao-lian-cheng-de/"/>
    <updated>2015-07-17T23:16:16+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/17/wo-zhe-ge-zhan-chang-shi-zen-yao-lian-cheng-de</id>
    <content type="html"><![CDATA[<p>我是一个喜欢折腾的人，不喜欢就这么平平淡淡度过，但是想改变也不是那么容易的。现在的我已经成了一个彻头彻尾的程序员、白领，也许有人会羡慕这样的生活。但我却厌倦了，这并不是我所想要的人生。</p>

<h2>想改变没那么简单</h2>

<p>曾几何时，我也想有一份稳定的工作，就像现在一样。但是当我真正身处其中时，这样的生活、这样的工作显得是那么的廉价，让我没有一丝珍惜的意愿。</p>

<p>所以我想改变，这个想法从来没有停止过。</p>

<p>我一直是做iOS开发，平时没事总想倒腾个什么出来。做什么呢？想法很多，但很少付出行动，有的行动了，效果也一般，所以每次都不了了之。</p>

<h2>swift论坛起落</h2>

<p>2014年6月，苹果在WWDC大会上发布了swift语言。公司同事讨论激烈，有人提议做个论坛出来，肯定可以火起来的。</p>

<p>这一次说干就干。刚好我有服务器。光有服务器也不行，还需要有域名。我查了一下跟swift相关的域名，很多都被注册了，看来中国人真是够多的，抢注的这么快。最后我注册了<a href="http://www.iswifting.com/">www.iswifting.com</a></p>

<p>很快网站就被搭建起来了，这算是我踏入站长行列的第一步。</p>

<p>我非常认真地对待它，经常找一些优秀的文章。我也学着推广，在别的论坛里，QQ群里。每天也有一些人访问，注册会员也有几百人了。</p>

<p>尽管这样，我也看不到网站的前途在哪。刚好赶上服务器到期，我就放弃了这个论坛。虽然这个论坛没给我带来什么盈利，但是这次的站长经历着实让我过了一把瘾。</p>

<p>前段时间，我再次启用了这个域名<a href="http://www.iswifting.com/">www.iswifting.com</a>，做一个<a href="http://www.iswifting.com/">swift开发</a>，以后还会在这里分享一些关于swift的优秀文章。算是对上一个论坛的延续吧。</p>

<h2>刚刚在线正式上线</h2>

<p>论坛没了，又开始每天漫无目的的逛游。无意间我发现一个iOS开发的人叫唐巧，也许你也听说过。他有一个个人博客网站做的不错，<a href="http://blog.devtang.com/">唐巧的技术博客</a>，里面都是他自己写的iOS开发技术文章和一些琐事。</p>

<p>看一个网站好不好就看他的访问量多少，排名如何。我那个时候查的时候，他的博客就有上千UV。在中国排名也不错，有得公司官网可能就没有他的排名高。</p>

<p>虽然我的技术不如巧哥那么厉害，但是我也想在茫茫互联网中找到自己的一席之地。所以我也想做一个类似的网站。名字我都想好了，叫<a href="http://www.superqq.com/">刚刚在线</a>，刚好我手里有域名：www.superqq.com。这个域名还不错吧，偷偷的告诉你，我以前还做过域名的生意，赚了点儿小钱而已。</p>

<p>做个网站应该没什么难的吧，但是对于没做过网站的我来说，还真是个问题。我告诉自己不能退缩，要找方法。刚好公司有个同事之前弄过网站。</p>

<p>在公司同事的帮助下，很快我们用octopress把网站搭建起来了。而且这一切都是免费的，所以再也不会存在关闭的问题啦。我非常激动的在我的网站上发了一篇文章：<a href="http://www.superqq.com/blog/2014/09/26/ios/">刚刚在线正式上线</a> 。</p>

<p>我再一次踏入站长行列。这一次或许我能走的更远。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSString的八条实用技巧]]></title>
    <link href="http://www.superqq.com/blog/2015/07/16/nsstringde-ba-tiao-shi-yong-ji-qiao/"/>
    <updated>2015-07-16T23:07:57+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/16/nsstringde-ba-tiao-shi-yong-ji-qiao</id>
    <content type="html"><![CDATA[<p>有一篇文章写了：<a href="http://www.superqq.com/blog/2015/07/11/ioskai-fa-zhi-nsstringde-ji-tiao-shi-yong-ji-qiao/">iOS开发之NSString的几条实用技巧</a> ， 今天这篇，我们讲讲NSString的八条实用技巧。大家可以收藏起来，方便开发随时可以复制粘贴。</p>

<h2>0.首字母大写</h2>

<p>代码：</p>

<pre><code>//首字母大写
NSString *string = @"ligang";
NSLog(@"string: %@",[string capitalizedString]);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 23:06:11.652 iOSStrongDemo[10279:3062010] string: Ligang
</code></pre>

<h2>1.分割字符串</h2>

<p>代码：</p>

<pre><code>//分割字符串
NSString *string = @"This is a iOSDevTip";
NSArray *array = [string componentsSeparatedByString:@"a"];
NSString *string1 = [array objectAtIndex:0];
NSString *string2 = [array objectAtIndex:1];
NSLog(@"string1:%@  string2:%@",string1,string2);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:40:39.559 iOSStrongDemo[10165:3055448] string1:This is   string2: iOSDevTip
</code></pre>

<h2>2.追加字符串</h2>

<p>代码：</p>

<pre><code>//追加字符串
NSMutableString *string = [[NSMutableString alloc] initWithString:@"I Love "];
[string appendString:@"China"];
NSLog(@"string:%@",string);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:42:32.305 iOSStrongDemo[10189:3056410] string:I Love China
</code></pre>

<h2>3.插入字符串</h2>

<p>代码：</p>

<pre><code>//插入字符串
NSMutableString *string = [[NSMutableString alloc] initWithString:@"I China"];
[string insertString:@"Love " atIndex:2];
NSLog(@"string: %@",string);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:44:10.706 iOSStrongDemo[10206:3057014] string: I Love China
</code></pre>

<h2>4.删除字符串</h2>

<p>代码：</p>

<pre><code>//删除字符串
NSMutableString *string = [[NSMutableString alloc] initWithString:@"I love China"];
[string deleteCharactersInRange:NSMakeRange(2, 4)];
NSLog(@"String1: %@",string);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:46:58.437 iOSStrongDemo[10219:3057749] String1: I  China
</code></pre>

<h2>5.判断是否包含前后缀</h2>

<p>代码：</p>

<pre><code>//判断是否包含前后缀
NSString *string = @"I love China";
BOOL isHasI = [string hasPrefix:@"I"];
BOOL isHasChina = [string hasSuffix:@"China"];
</code></pre>

<h2>6.替换字符串</h2>

<p>代码：</p>

<pre><code>//替换字符串
NSString *string = @"I love China";
NSString *replaceString = [string stringByReplacingOccurrencesOfString:@"love" withString:@"like"];
NSLog(@"replaceString:  %@",replaceString);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 22:56:07.405 iOSStrongDemo[10236:3059503] replaceString:  I like China
</code></pre>

<h2>7.去除字符串首尾的空格和换行符</h2>

<p>代码：</p>

<pre><code>//去除字符串首尾的空格和换行符
NSString *string = @" I love China ";
NSString *text = [string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
NSLog(@"text:%@",text);
</code></pre>

<p>打印：</p>

<pre><code>2015-07-16 23:00:47.845 iOSStrongDemo[10265:3061013] text:I love China
</code></pre>

<p>代码已经更新，demo下载地址：<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员：选对方向持续努力]]></title>
    <link href="http://www.superqq.com/blog/2015/07/16/cheng-xu-yuan-:xuan-dui-fang-xiang-chi-xu-nu-li/"/>
    <updated>2015-07-16T22:24:25+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/16/cheng-xu-yuan-:xuan-dui-fang-xiang-chi-xu-nu-li</id>
    <content type="html"><![CDATA[<p>今天下班的时候，乘电梯的空打开了一篇文章：一个人，2年时间，做了一个价值1亿美金的网站。文章写得很精彩，非常吸引我。不一会电梯就到了，我依然抱着手机边走边看。</p>

<p>到了我的小电动车旁边（公司离家不远，经常骑电动车上班），文章还没有看完。我就坐在电动车上，依然爱不释手的看着。边看边想：创始人真是太厉害了。</p>

<p>能够吸引我的文章不少，能够这么吸引我的文章不多。建议大家抽时间也看看这篇文章，或许能激发出你的灵感，成就一番事业也说不定。</p>

<h2>方向正确持续努力</h2>

<p>文章里说的网站是：<strong>viralnova.com</strong> 只有创始人一个是全职员工，其他两位是兼职的。网站成立大概两年时间，每天有200万独立访问用户，月入十万美金。世界排名376位。</p>

<p>看到这样的数据真的令人振奋，如果我有一个这样的网站，那就不用上班啦。这也不是没有可能。在国内也有个人做网站比较厉害的，比如说：<strong>卢松松</strong> 国内独立博客大牛。估计每个月也能赚不少钱吧。</p>

<p>不能只看到他们的成绩，更要了解他们背后两年如一日、六年如一日的坚持和努力。有想法的人也许很多，能够坚持将想法付出行动的人就不多了。所以成功者总是少数。选对方向持续努力也许就是成功不二法则。</p>

<p>作为一名程序员你的方向是什么呢？我们都应该这样问一下自己，不能每天漫无目的的坚持。马云不是说了嘛：梦想还是要有的，万一实现了呢。</p>
]]></content>
  </entry>
  
</feed>
