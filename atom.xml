<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刚刚在线]]></title>
  <link href="http://www.superqq.com/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2016-03-08T21:51:41+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C和Swift混编的一些经验]]></title>
    <link href="http://www.superqq.com/blog/2016/03/07/objective-c-swift-study/"/>
    <updated>2016-03-07T22:38:41+08:00</updated>
    <id>http://www.superqq.com/blog/2016/03/07/objective-c-swift-study</id>
    <content type="html"><![CDATA[<blockquote><p>阿里云iOS客户端2.1.0版本中开始尝试使用Swift来写新的业务，磕磕绊绊总算是发布了新版，总结一下开发过程中得到的经验和踩过的坑吧。</p></blockquote>

<h2>CocoaPods</h2>

<p>使用Swift作为主要的开发语言，很难避免引入Swift编写的库。2.1.0版本引入了SwiftyJSON和Charts这两个Swift写的库，分别用于处理JSON数据和画监控图。</p>

<p>苹果要求使用Swift写的库，必须通过动态链接库引入，其实这一点我也是不太理解的，因为静态库也是可以依赖动态库的符号的，不存在导入多个Swift动态库的问题。允许App使用自带的动态库从iOS8才开始支持，因此必须将App支持的iOS版本升到iOS8。阿里云iOS客户端iOS7的用户不到4%，所以放弃了对iOS7的支持。</p>

<p>Cocoapods支持将依赖的组件编译成动态库，只需要在Podfile顶部加上&#8221;use_frameworks!&ldquo;。开启这个选项之后，所有以源码引入的pod都会编译成动态链接库，而以fake framework引入的pod仍然会编译到主App里面。动态库都放在App里面的Frameworks目录，可以看到Swift相关的动态库也都拷贝进来了，所以支持Swift会导致包变大。我没有记下2.0.0版本的大小，导致没法对比2.1.0放大了多少，这是一个失误。</p>

<pre><code>[~/Library/Developer/Xcode/Archives/2015-12-17/CloudConsoleApp 15-12-17 下午9.24.xcarchive/Products/Applications/CloudConsoleApp.app/Frameworks]$ tree
.
├── Charts.framework
│   ├── Charts
│   ├── Info.plist
│   └── _CodeSignature
│       └── CodeResources
├── EAIntroView.framework
│   ├── EAIntroView
│   ├── Info.plist
│   └── _CodeSignature
│       └── CodeResources
├── FMDB.framework
│   ├── FMDB
│   ├── Info.plist
│   └── _CodeSignature
│       └── CodeResources
├── FTCoreText.framework
│   ├── FTCoreText
│   ├── Info.plist
│   └── _CodeSignature
│       └── CodeResources
├── JSBadgeView.framework
│   ├── Info.plist
│   ├── JSBadgeView
│   ├── JSBadgeView.bundle
│   └── _CodeSignature
│       └── CodeResources
├── MBProgressHUD.framework
│   ├── Info.plist
│   ├── MBProgressHUD
│   └── _CodeSignature
│       └── CodeResources
├── MFSideMenu.framework
│   ├── Info.plist
│   ├── MFSideMenu
│   └── _CodeSignature
│       └── CodeResources
├── PFormanceKit.framework
│   ├── Info.plist
│   ├── PFormanceKit
│   └── _CodeSignature
│       └── CodeResources
├── Reachability.framework
│   ├── Info.plist
│   ├── Reachability
│   └── _CodeSignature
│       └── CodeResources
├── RegexKitLite.framework
│   ├── Info.plist
│   ├── RegexKitLite
│   └── _CodeSignature
│       └── CodeResources
├── SSZipArchive.framework
│   ├── Info.plist
│   ├── SSZipArchive
│   └── _CodeSignature
│       └── CodeResources
├── SnapKit.framework
│   ├── Info.plist
│   ├── SnapKit
│   └── _CodeSignature
│       └── CodeResources
├── SwiftyJSON.framework
│   ├── Info.plist
│   ├── SwiftyJSON
│   └── _CodeSignature
│       └── CodeResources
├── libswiftContacts.dylib
├── libswiftCore.dylib
├── libswiftCoreData.dylib
├── libswiftCoreGraphics.dylib
├── libswiftCoreImage.dylib
├── libswiftDarwin.dylib
├── libswiftDispatch.dylib
├── libswiftFoundation.dylib
├── libswiftObjectiveC.dylib
└── libswiftUIKit.dylib

27 directories, 49 files

$ file Charts 
Charts: Mach-O universal binary with 2 architectures
Charts (for architecture armv7):    Mach-O dynamically linked shared library arm
Charts (for architecture arm64):    Mach-O 64-bit dynamically linked shared library
</code></pre>

<p>因为fake framework和源代码pod分别会编译成静态库和动态库，这样会导致一个问题，就是如果源码pod又依赖fake framework，那就没办法了。CocoaPods发现这种情况会提示下面这个错误。</p>

<pre><code>target has transitive dependencies that include static binaries: (xxx.framework, xxx.framework)
</code></pre>

<p>pod install时会把静态库编译到App里面，源码编译成的动态库没法依赖它。最终的解决方案只能是CocoaPods对fake framework和源码pod一视同仁，都编译成动态库，这样彼此才能依赖。不知道CocoaPods什么时候会支持这样。</p>

<h2>混编</h2>

<ul>
<li>Swift使用Objective-C</li>
</ul>


<p>这种情况占绝大多数。只需要在CloudConsoleApp-Bridging-Header.h这个头文件中包含相关的头文件就行。pod组件另外一种引入的方式是通过@import引入。比如SDWebImage可以通过下面两种方式引入。</p>

<pre><code>//在Bridging头文件包含下面这个头文件
#import &lt;SDWebImage/UIImageView+WebCache.h&gt;

//另外一种办法，在Swift文件中引入。
import SDWebImage
</code></pre>

<p>Objective-C写的类和方法都会被改成Swift的使用方式，下面是两个很典型的例子。使用的时候需要尝试一下才能找到翻译的Swift方法。</p>

<pre><code>//Objective-C
titleLabel.lineBreakMode = NSLineBreakByWordWrapping;
titleLabel.numberOfLines = 0;

//Swift
cell.nameLabel?.lineBreakMode = .ByWordWrapping //全写是 NSLineBreakMode.ByWordWrapping
cell.nameLabel?.numberOfLines = 0

//Objective-C
UIImage *image = [UIImage imageNamed:@"abc"];

//Swift
let image = UIImage(named: "abc")
</code></pre>

<ul>
<li>Objective-C使用Swift</li>
</ul>


<p>Xcode会生成一个虚拟的头文件CloudConsoleApp-Swift.h，在工程里面是找不到这个头文件的，但是可以包含，并且跳转进去。这个文件里面包含了所有从Swift导出来的符号，比如下面这个view controller就是用Swift写的。可以看出来Objectivew-C看到的名称跟Swift源码里面的名称是一样的，但是Swift会对类做demangling，变成了_TtC15CloudConsoleApp31YWSResourceDetailViewController这样的，跟C++有点类似。</p>

<pre><code>SWIFT_CLASS("_TtC15CloudConsoleApp31YWSResourceDetailViewController")
@interface YWSResourceDetailViewController : UIPageViewController
@property (nonatomic, strong) NSArray * __nonnull vcs;
@property (nonatomic, copy) NSString * __null_unspecified pluginId;
@property (nonatomic, strong) YWSSegmentedControl * __nonnull segmentedControl;
@property (nonatomic, strong) YWSInstanceListViewController * __nonnull instanceListViewController;
@property (nonatomic, strong) YWSMetricConcernedViewController * __nonnull metricConcernedViewController;
@property (nonatomic, weak) IBOutlet UIBarButtonItem * __null_unspecified addMetricBarButton;
- (void)viewDidLoad;
- (void)initSegmentedControl;
- (void)indexChanged:(id __nonnull)sender;
- (void)onNavigationBack:(id __nonnull)sender;
- (void)prepareForSegue:(UIStoryboardSegue * __nonnull)segue sender:(id __nullable)sender;
- (nonnull instancetype)initWithTransitionStyle:(UIPageViewControllerTransitionStyle)style navigationOrientation:(UIPageViewControllerNavigationOrientation)navigationOrientation options:(NSDictionary&lt;NSString *, id&gt; * __nullable)options OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * __nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end
</code></pre>

<h2>Swift的优缺点</h2>

<p>这个项目刚起步，用Swift的经验尚浅，所以都是一些比较浅薄的理解，后面有更深刻的理解再补上。</p>

<h3>优点</h3>

<ul>
<li>代码简洁。类的声明和实现在一个文件中。</li>
<li>统一对属性和方法的调用，都用.。</li>
<li>如果不加额外的访问控制，所有的符号都是整个项目可见，无需考虑头文件的问题。</li>
<li><p>字符串处理太方便了。</p>

<p>  //字符串比较和拼接实在是太方便了
  let foo = &ldquo;abc&rdquo;
  let bar = &ldquo;abc&rdquo;</p>

<p>  if foo == bar {
      //blablabla
  }</p>

<p>  print(&ldquo;====(foo)+(bar)&rdquo;)</p></li>
<li><p>语言上支持延迟加载。</p>

<p>  lazy var imageView : UIImageView = {
      var imageView = UIImageView(image: UIImage(named: &ldquo;empty_hint&rdquo;))
      imageView.contentMode = .ScaleAspectFit</p>

<pre><code>  return imageView
</code></pre>

<p>  }()</p>

<p>  lazy var infoLabel : UILabel = {
      var infoLabel = UILabel()
      infoLabel.lineBreakMode = .ByWordWrapping //支持换行
      infoLabel.numberOfLines = 0</p>

<pre><code>  return infoLabel
</code></pre>

<p>  }()</p>

<p>  lazy var button : UIButton = {
      var button = UIButton()
      button.titleLabel?.font = UIFont.systemFontOfSize(15)
      button.setTitleColor(UIColor.darkGrayColor(), forState: .Normal)
      button.setBackgroundImage(UIImage(named: &ldquo;buy_instance_hint_button&rdquo;), forState: .Normal)
      button.hidden = true</p>

<pre><code>  return button
</code></pre>

<p>  }()</p></li>
<li><p>多返回值。比如下面这个函数，如果使用Objective-C写还是比较麻烦的。</p>

<p>  //将 &ldquo;创建中&amp;#FA8C35&rdquo; 翻译成对应的 &ldquo;(字符串对象, 颜色对象)&rdquo;
  func YWSTranslateRichText (str : String) -> (text : String, color : UIColor) {
      let statusArray = str.componentsSeparatedByString(&ldquo;&amp;&rdquo;)</p>

<pre><code>  if statusArray.count == 0 {
      return ("", UIColor.lightGrayColor())
  }

  if statusArray.count == 1 {
      return (statusArray[0], UIColor.lightGrayColor())
  }

  return (statusArray[0], UIColor.fromHexString(statusArray[1]))
</code></pre>

<p>  }</p>

<p>  //使用方式如下
  let (text, color) = YWSTranslateRichText(instanceStatusConf)</p></li>
<li><p>支持字符串作为枚举值。</p>

<p>  enum YWSECSInstanceStatus : String {
      case Starting = &ldquo;Starting&rdquo;
      case Running = &ldquo;Running&rdquo;
      case Stopping = &ldquo;Stopping&rdquo;
      case Stopped = &ldquo;Stopped&rdquo;
  }</p>

<p>  //使用方法
  cell.ECSInstanceStatus = YWSECSInstanceStatus(rawValue: instanceStatus!)</p>

<p>  //转换成字符串
  textDetailLabel.text = YWSECSInstanceStatus.Starting.rawValue</p></li>
<li><p>selector类型实现了 StringLiteralConvertible，使用起来更加简单。</p>

<p>  self.button.addTarget(self, action: &ldquo;introduceResources:&rdquo;, forControlEvents: .TouchUpInside)</p></li>
<li><p>不再需要引入libextobjc这个Pod，因为Swift支持更方便的用法。在block开始的时候，在数组里面weak所有要用到的对象。</p>

<p>  inputViewController.finishBlock = { [weak inputViewController, weak cell, weak self] () -> Void in
  }</p></li>
<li><p>函数支持默认参数。比如下面这个函数，有五个参数，其中三个有默认参数，用户需要设置的参数只有两个。</p>

<p>  convenience init(text: String, textColor: UIColor = UIColor.whiteColor(), bgColor: UIColor, font: UIFont = UIFont.systemFontOfSize(10), inset: UIEdgeInsets = UIEdgeInsetsMake(0, 3, 0, 3)) {
      //blabla
  }</p>

<p>  lazy var vipLabel : YWSInsetsTextLabel! = YWSInsetsTextLabel(text: &ldquo;vip&rdquo;, bgColor: UIColor.orangeColor())</p></li>
<li><p>通过减少动态性，使用vtable替换原有的objc_msgSend，获取更高的性能。新增了final、private等关键字，编译器可以对代码做更多优化，提升性能并减少内存的使用。比如final方法不用放入虚表中，节省内存；跳转时不用查表，性能更佳；private的类如果发现有方法只在本文件中使用，可以直接内联，提高性能。</p></li>
<li><p>在Playground工程里面练习Swift编程非常之方便，尤其是测试VFL语句的时候。</p></li>
</ul>


<p><img src="http://upload-images.jianshu.io/upload_images/1376176-76d2627719e67fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<h2>缺点</h2>

<ul>
<li>Optional让人头疼，大量的?和!，没处理好很容易导致崩溃。</li>
<li>强类型和Optional，给JSON解释带来了灾难。</li>
<li><p>目前Xcode不支持对Swift写的代码做重构。</p></li>
<li><p>Build Settings里面设置Treat Warnings as Errors对Swift代码无效。</p></li>
</ul>


<h2>坑</h2>

<p>用private修饰的类，如果使用KVC来给属性设置值，编译不会报错，运行时也不会报错，但就是设置不上。去掉private就好了。</p>

<h2>crash分析</h2>

<p>手解crash可以看到具体崩溃代码的行号。</p>

<pre><code>$ symbolicatecrash ~/Downloads/034dc058c5d4ff1f717ec7a05d4d55b8 CloudConsoleApp.app.dSYM

Exception Type:  SIGTRAP
Exception Codes: #0 at 0x1001c09b4
Crashed Thread:  0

Thread 0 Crashed:
0   CloudConsoleApp                     0x00000001001c09b4 YWSInstanceListViewController.goToBuyPage() -&gt; () (YWSInstanceListViewController.swift:701)
1   CloudConsoleApp                     0x00000001001c92cc specialized YWSInstanceListViewController.introduceResources(AnyObject) -&gt; () (YWSInstanceListViewController.swift:689)
2   CloudConsoleApp                     0x00000001001c029c @objc YWSInstanceListViewController.introduceResources(AnyObject) -&gt; () (YWSInstanceListViewController.swift:0)
3   UIKit                               0x000000018601be50 0x185fd0000 + 310864
4   UIKit                               0x000000018601bdcc 0x185fd0000 + 310732
5   UIKit                               0x0000000186003a88 0x185fd0000 + 211592
6   UIKit                               0x000000018601b6e4 0x185fd0000 + 308964
7   UIKit                               0x000000018601b314 0x185fd0000 + 307988
8   UIKit                               0x0000000186013e30 0x185fd0000 + 278064
9   UIKit                               0x0000000185fe44cc 0x185fd0000 + 83148
10  UIKit                               0x0000000185fe2794 0x185fd0000 + 75668
11  CoreFoundation                      0x00000001812a8efc 0x1811cc000 + 904956
12  CoreFoundation                      0x00000001812a8990 0x1811cc000 + 903568
13  CoreFoundation                      0x00000001812a6690 0x1811cc000 + 894608
14  CoreFoundation                      0x00000001811d5680 0x1811cc000 + 38528
15  GraphicsServices                    0x00000001826e4088 0x1826d8000 + 49288
16  UIKit                               0x000000018604cd90 0x185fd0000 + 511376
17  CloudConsoleApp                     0x000000010014b4e0 main (main.m:16)
18  libdyld.dylib                       0x0000000180d768b8 0x180d74000 + 10424

//不过我对着这行代码分析了好久，实在想不出来崩溃的原因。没有任何crash提示信息。
//这个版本Swift代码只有这样一个crash
//后面再看看新crash会不会也是这样
self.resourceType = YWSXXX.shareInstance().getXXXByXXX(self.XXX.pluginId)
</code></pre>

<p>实际证明Swift的crash信息非常不准确，能知道崩溃的文件和函数，行号不准确，也不会输出Application Specific Information。比如下面这个crash。</p>

<pre><code>Incident Identifier: 54087A46-D37D-454B-9305-22ED5420B58B
CrashReporter Key:   TODO
Hardware Model:      iPhone6,2
Process:             CloudConsoleApp [696]
Path:                /var/mobile/Containers/Bundle/Application/E8E24C8B-A47B-425E-863F-A871F273FCA2/CloudConsoleApp.app/CloudConsoleApp
Identifier:          com.aliyun.wstudio.amc.AliyunMobileApp
Version:             2.2.0 (2169)
Code Type:           ARM-64
Parent Process:      ??? [1]

Date/Time:           2016-01-25 10:44:56 +0000
OS Version:          iPhone OS 9.2.1 (13D15)
Report Version:      104

Exception Type:  SIGTRAP
Exception Codes: #0 at 0x100139e80
Triggered by Thread:  0

Thread 0 Crashed:
0   CloudConsoleApp                 0x0000000100139e80 __TFC15CloudConsoleApp24YWSTouchIDViewController14viewWillAppearfS0_FSbT_ (in CloudConsoleApp) + 1304
1   CloudConsoleApp                 0x0000000100139eb0 __TToFC15CloudConsoleApp24YWSTouchIDViewController14viewWillAppearfS0_FSbT_ (in CloudConsoleApp) + 44
2   UIKit                           0x000000018722c74c 0x0000000187200000 + 182092
3   UIKit                           0x000000018722c4c0 0x0000000187200000 + 181440
4   UIKit                           0x00000001872d3130 0x0000000187200000 + 864560
5   UIKit                           0x00000001872d2a6c 0x0000000187200000 + 862828
6   UIKit                           0x00000001872d2694 0x0000000187200000 + 861844
7   UIKit                           0x00000001872d25fc 0x0000000187200000 + 861692
8   UIKit                           0x000000018720f778 0x0000000187200000 + 63352
9   QuartzCore                      0x0000000184c1eb2c 0x0000000184c10000 + 60204
10  QuartzCore                      0x0000000184c19738 0x0000000184c10000 + 38712
11  QuartzCore                      0x0000000184c195f8 0x0000000184c10000 + 38392
12  QuartzCore                      0x0000000184c18c94 0x0000000184c10000 + 35988
13  QuartzCore                      0x0000000184c189dc 0x0000000184c10000 + 35292
14  QuartzCore                      0x0000000184c120cc 0x0000000184c10000 + 8396
15  CoreFoundation                  0x00000001824d8588 0x00000001823fc000 + 902536
16  CoreFoundation                  0x00000001824d632c 0x00000001823fc000 + 893740
17  CoreFoundation                  0x00000001824d675c 0x00000001823fc000 + 894812
18  CoreFoundation                  0x0000000182405680 0x00000001823fc000 + 38528
19  GraphicsServices                0x0000000183914088 0x0000000183908000 + 49288
20  UIKit                           0x000000018727cd90 0x0000000187200000 + 511376
21  CloudConsoleApp                 0x000000010007f988 main (in CloudConsoleApp) (main.m:16)
22  libdyld.dylib                   0x0000000181fa68b8 0x0000000181fa4000 + 10424

//确实崩溃在viewWillAppear函数中，但是是97行的 as! 导致的，在crash信息里面这两个重要的信息没有暴露出来。
override func viewWillAppear(animated: Bool) {
    super.viewWillAppear(animated)

    //let urlString = YWSXXX.sharedInstance().get("userIcon") as! String

    //因为2.1.0重构过登录模块，新的登录模块才会保存 userIcon 这个值
    //所以2.2.0覆盖2.1.0之前的版本用 as! 会崩溃，这里改成 as? 了
    if let urlString = YWSXXX.sharedInstance().get("userIcon") as? String {
    }
}
</code></pre>

<h2>总结</h2>

<p>Swift 2.1版本已经非常稳定，苹果将其开源，也表明对Swift的质量和可靠性有足够的信心。开源社区开始涌现一批优秀的Swift库，比如Charts，这个画图的组件很不错。StackOverflow的答案中很多人会同时提供Objective-C和Swift两个版本。目前来看唯一美中不足的问题就是解出来的crash没有Objective-C那么直观了，很多时候都得靠猜。</p>

<pre><code>文／阿呆少爷（简书作者）
原文链接：http://www.jianshu.com/p/a5e6e574145b
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[刚刚在线-让学习iOS开发更简单]]></title>
    <link href="http://www.superqq.com/blog/2016/03/02/ggteach-learn-ios-simply/"/>
    <updated>2016-03-02T20:49:56+08:00</updated>
    <id>http://www.superqq.com/blog/2016/03/02/ggteach-learn-ios-simply</id>
    <content type="html"><![CDATA[<p>非常兴奋的告诉大家一个好消息：刚刚在线官网正式上线啦！欢迎大家访问！官网地址：</p>

<pre><code>www.ggteach.com
</code></pre>

<p>刚刚在线的使命-让学习iOS开发更简单！我们的团队有30多位实战讲师，将为大家提供更多的技术分享、视频直播、实战项目等等。</p>

<h2>本周六技术分享</h2>

<p>好消息接连不断，技术分享说来就来！本周六晚上8点，注意时间噢！可以提前关注<strong>刚刚在线教育</strong>直播间，以免到时候找不到。</p>

<h3>技术分享简介：</h3>

<pre><code>斗鱼技术分享课程
主题：《App Thinng》
时间：2016-03-5（周六）晚8：00 至 9：00
斗鱼房间：刚刚在线教育
地址：http://www.douyutv.com/ggteach
大家可以提前关注。 
</code></pre>

<p>&mdash;&mdash;美丽的分割线&mdash;&mdash;&ndash;</p>

<h2>编程是一种生活方式</h2>

<p>今天在回来的路上看到一个好朋友分享了一篇文章《美国监狱新趋势&ndash;学编程》</p>

<p><img src="http://www.superqq.com/images/ggteach01.jpg" alt="1" /></p>

<p>是的，不可思议。有网友表示：想去美国监狱，包吃住还免费学编程！令人震惊的是：“他们中没有人因再次犯罪而重返监狱，他们走了一条正确的路。”</p>

<p>很多美国人已经意识到编程的重要性！编程不再是一项找工作的技能，而是一种生活方式，每个人都多少应该懂一点编程。</p>

<p><img src="http://www.superqq.com/images/ggteach02.jpg" alt="2" /></p>

<p>为了呼吁美国人民学习编程知识，奥巴马甚至还亲自挽起袖子写了一段javascript代码，这也让他成为美国历史上第一位会写代码的总统。（虽然写得不怎么样）</p>

<h2>国内编程现状</h2>

<p>在中国的大学里面，计算机课程只是讲一些理论知识。很多大学生（包括计算机系）毕业之后，很难靠自己掌握的编程知识找到一份工作。这是一件何其可悲的事情。</p>

<p>很多同学无奈之下，会选择线下的培训班，但是培训班的费用高的让人望而却步。有的同学因为昂贵的费用，这一生可能就与编程无缘；</p>

<p>有的同学可能会咬牙坚持贷款2万甚至更多，来学习一项编程的技能。还未入社会，就要背负着为银行打工的重担。</p>

<h2>刚刚在线的诞生</h2>

<p>刚刚在线的诞生就是为了帮助广大iOS开发爱好者，让学习iOS开发更简单！</p>

<p>刚刚在线推出iOS开发技术直播课程，直播课程将免费开放，直播课程涉及iOS开发常用的控件、网络请求、第三方类库等。</p>

<p>同时，刚刚在线推出iOS开发社群。为社群成员提供高级进阶、在线答疑、实战项目、面试技巧、独立博客、职位推荐等服务。</p>

<p>刚刚在线团队成员来自北京、上海、广州、美国、日本等地方，每一位讲师都是实战派！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[女程序员做了个梦，众网友的神回复]]></title>
    <link href="http://www.superqq.com/blog/2016/03/01/female-coder-dream-reply/"/>
    <updated>2016-03-01T23:16:18+08:00</updated>
    <id>http://www.superqq.com/blog/2016/03/01/female-coder-dream-reply</id>
    <content type="html"><![CDATA[<p>女程序员发的一条微博：</p>

<p>“昨晚梦见男朋友和别的女人在逛街，梦里我的第一反应就是查源代码，结果调试半天查不出来为什么显示的那个女人不是我，最后含泪把那个女人注释掉了，再一运行就是我男朋友自己逛街了。”
众网友的神回复：</p>

<p>1、把那个女人的指针指向你即可； (:з」∠)</p>

<p>2、谁让你把男朋友设成public的？；Σ(っ °Д °;)っ</p>

<p>3、加个断点看看那女人是谁； (ಡωಡ)</p>

<p>4、心真软，就应该把他的接口屏蔽掉； (눈_눈)</p>

<p>5、Protected逛街(youOnly)； (ง•̀_•́)ง</p>

<p>6、设计问题，应该采用单例模式； (๑•́ωก̀๑)</p>

<p>7、没做回归测试； ヽ( ￣д￣;)ノ</p>

<p>8、标准做法是做个断言； (๑•̀ㅂ•́) ✧</p>

<p>9、注释掉了，逛街的参数不用改吗？； (＠￣ー￣＠)</p>

<p>10、最后含泪把那个女人给注释掉了，再一运行就是我男朋友自己逛街了—>很明显是变量名作用域的问题，改个名就行了(๑•̀ㅂ•́) ✧</p>

<p>11、还可以有个多线程的算法，把你的优先级设成99，一个idle线程的优先级设成50，把那个女人的优先级设成49。酱紫就永远都调度不到啦 (๑•́ωก̀๑)</p>

<p>12、那也没关系，那就老调用那个女人。。。你BF放在那里不动。。。养着 (ಡωಡ)</p>

<p>13、上绝招，用goto，做个死循环，让他们逛死 (๑•̀ㅂ•́) ✧</p>

<p>14、善心点，别goto了，调用exit函数结束进程吧，冤冤相报何时了啊 ヽ( ￣д￣;)ノ</p>

<p>15、查一下Log，仅仅只有逛街吗？ԅ(¯ㅂ¯ԅ)</p>

<pre><code>来自：http://www.wtoutiao.com/p/Xa51bf.html
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XMPP客户端登录开发详解]]></title>
    <link href="http://www.superqq.com/blog/2016/01/31/xmpp-client-login-dev/"/>
    <updated>2016-01-31T20:28:20+08:00</updated>
    <id>http://www.superqq.com/blog/2016/01/31/xmpp-client-login-dev</id>
    <content type="html"><![CDATA[<p>由上篇文章将了如何在MAC本地搭建一个Openfire服务器，今天我们就要着手使用 XMPPFramework来开发 基于XMPP 协议的即时通讯IOS 客户端系统。今天主要看登录功能开发，可能有人会质疑，我们都没有开发注册功能，怎么开发登录功能。注册账号我们有捷径，服务器都在本地，当然很好做了。另外就是通过MAC 自带的客户端 Messages 进行注册。</p>

<p>首先，我们需要搭建起来IOS 的工程，并且将XMPPFramework 引入到我们的工程中来,当然我们可以使用源码 直接导入，也可以使用cocoapods来进行依赖。本文直接使用源码来进行开发。由于在Github上的源码有一些问题，所以大家可以来<a href="https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient/ThirdTools/XMPPFrameworkio">https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient/ThirdTools/XMPPFrameworkio</a>下载相关的XMPPFramework相关的代码。</p>

<p>下载关于XMPPFramework的代码之后,我们需要做的是 创建一个工程，然后将源代码导入到我们的工程中去。当然直接导入并且编译会出现libxml找不到的问题。我们需要在工程中导入libxml2.tbd(ios 9之后的名称) 以及 libresolv.9.tbd(ios 9之后的后缀)。然后在Build Setting的Head search 中加上 头文件的链接地址</p>

<pre><code>${SDKROOT}/usr/include/libxml2
</code></pre>

<p>这之后，重新编译工程即可编译成功。后面，我们需要做的就是开发登录功能了，在开始之前，我们还是先看一下怎么注册一个账号吧；登录Openfire后台，创建一个用户。</p>

<p>通过在浏览器中输入 (前提 是 openfire服务器以及mysql服务器都已经启动了)</p>

<pre><code>127.0.0.1:9090     
</code></pre>

<p>进入如下界面</p>

<p><img src="http://images.90159.com/1601/1.png" alt="1" /></p>

<p>点击左上角用户/组 进入用户管理界面</p>

<p><img src="http://images.90159.com/1601/2.png" alt="2" /></p>

<p>然后点击 左侧 导航栏中的新建用户 填写好用户信息就可以了。</p>

<p><img src="http://images.90159.com/1601/3.png" alt="3" /></p>

<p>到这边基本上用户注册环节 已经结束了。</p>

<p>开发 登录功能，基本上包括 登录界面的开发、XMPP登录逻辑的开发。登录界面我们可以 随便搭建一个登录界面就可以了。我今天主要是说一下 XMPP登录部分。</p>

<p>首先，创建关于XMPPLoginManager类，实现XMPPStreamDelegate，我定义了自己的一个宏，表示使用的Openfire服务器的地址 以及 端口号</p>

<pre><code>#define LocalOpenfire 1

#if LocalOpenfire

#define HOST_NAME @"127.0.0.1"
#define HOST_PORT 5222
#define CONNECT_IDENTIFIER @"@"

#endif

#define TIME_OUT 20
</code></pre>

<p>然后 定义XMPPStream、XMPPReconnect实例，并且初始化</p>

<pre><code>- (void)initXMPPStream {
    self.loginXmppStream = [[XMPPStream alloc] init];
    [self.loginXmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];
}

- (void)initXMPPReconnect {
    self.loginReconnectManager = [[XMPPReconnect alloc] init];
    [self.loginReconnectManager activate:self.loginXmppStream];
    // You can also optionally add delegates to the module.
    [self.loginReconnectManager addDelegate:self delegateQueue:dispatch_get_main_queue()];
}
</code></pre>

<p>定义 Login按钮点击之后的点击事件调用 XMPPLoginManager中的如下方法进行连接：</p>

<pre><code>#pragma mark -- connect xmpp method for login viewController
- (void)connectXMPPServer:(NSString *)userName password:(NSString *)password {
    self.userName = userName;
    self.password = password;

    NSString *myJid = [NSString stringWithFormat:@"%@%@%@", userName, CONNECT_IDENTIFIER, HOST_NAME];
    self.loginXmppStream.myJID = [XMPPJID jidWithString:myJid];

    self.loginXmppStream.hostName = HOST_NAME;
    self.loginXmppStream.hostPort = HOST_PORT;

    NSError *connectError = nil;
    [self.loginXmppStream connectWithTimeout:TIME_OUT error:&amp;connectError];

    if (connectError) {
        NSLog(@"%@", connectError);
        [self.loginDelegate loginXMPPConnectError:connectError];
    }
}
</code></pre>

<p>后面就是处理XMPPStream的各种回调就可以了</p>

<pre><code>#pragma mark -- xmppstream delegate
//连接xmpp成功之后,使用密码认证
- (void)xmppStreamDidConnect:(XMPPStream *)sender {

    NSError *authError = nil;
    [self.loginXmppStream authenticateWithPassword:self.password error:&amp;authError];

    if (authError) {
        NSLog(@"%@", authError);
        [self.loginDelegate loginXMPPDidNotAuthenticate];
    }
}

//认证通过之后的处理
- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender {
    NSLog(@"%@", @"认证通过");
    [self.loginDelegate loginXMPPDidAuthenticate];
}

//连接服务器的超时处理
- (void)xmppStreamConnectDidTimeout:(XMPPStream *)sender {
    NSLog(@"连接超时");
    [self.loginDelegate loginXMPPConnectDidTimeout];
}

//认证没有通过处理
- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(DDXMLElement *)error {
    NSLog(@"认证失败");
    [self.loginDelegate loginXMPPDidNotAuthenticate];
}
</code></pre>

<p>基本上这样就可以登录了，登录成功之后，可以跳转到相应的界面。提一下我们 能看到的XMPP交互流程 包括：</p>

<p>1、XMPP 使用用户名去连接服务器；</p>

<p>2、XMPP 连接成功之后，通过密码去服务器认证</p>

<p>3、认证成功之后，处理自己想处理的一下事情。</p>

<p>但其实XMPP 报文交互包括好几步，我就从别人那边摘录一点交互细节过来，就不自己一个个的抓包看了。</p>

<pre><code>C1: 客户端初始化流给服务器 

&lt;stream:stream to="127.0.0.1" xmlns="jabber:client" 
xmlns:stream="http://etherx.jabber.org/streams" version="1.0"&gt; S1: 服务器向客户端发送流标签作为应答: 
&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;stream:stream 
xmlns:stream="http://etherx.jabber.org/streams" xmlns="jabber:client" from="192.168.1.185" id="fb0cfcad" xml:lang="en" version="1.0"&gt; 

S2: 发送 STARTTLS范围 

&lt;stream:features&gt; 
&lt;starttls xmlns="urn:ietf:params:xml:ns: xmpp-tls"&gt;&lt;/starttls&gt; &lt;mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt; 
&lt;mechanism&gt;PLAIN&lt;/mechanism&gt; &lt;mechanism&gt;CRAM-MD5&lt;/mechanism&gt; &lt;mechanism&gt;ANONYMOUS&lt;/mechanism&gt; &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt; &lt;mechanism&gt;JIVE-SHAREDSECRET&lt;/mechanism&gt; &lt;/mechanisms&gt; 
&lt;compression xmlns="http://jabber.org/features/compress"&gt; 
&lt;method&gt;zlib&lt;/method&gt; &lt;/compression&gt; 
&lt;auth xmlns="http://jabber.org/features/iq-auth"/&gt; 
&lt;register xmlns="http://jabber.org/features/iq-register"/&gt; &lt;/stream:features&gt;  

C2:客户端发送 STARTTLS 命令给服务器: 

&lt;starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt; 

S3:服务器通知客户端可以继续进行: 

&lt;proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&gt; 

C3：TLS 握手成功, 客户端初始化一个新的流给服务器

&lt;stream:stream to="192.168.1.185" xmlns="jabber:client" 
xmlns:stream="http://etherx.jabber.org/streams" version="1.0"&gt;  

S4：服务器通知客户端可用的验证机制: 

&lt;?xml version='1.0' encoding='UTF-8'?&gt; 
&lt;stream:stream xmlns:stream="http://etherx.jabber.org/streams" 
xmlns="jabber:client" from="192.168.1.185" id="ad6f53e8" xml:lang="en" version="1.0"&gt; &lt;stream:features&gt; 
&lt;mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt; &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt; &lt;mechanism&gt;PLAIN&lt;/mechanism&gt; 
&lt;mechanism&gt;ANONYMOUS&lt;/mechanism&gt; &lt;mechanism&gt;CRAM-MD5&lt;/mechanism&gt; &lt;/mechanisms&gt; 
&lt;compression xmlns="http://jabber.org/features/compress"&gt; &lt;method&gt;zlib&lt;/method&gt; &lt;/compression&gt; 
&lt;auth xmlns="http://jabber.org/features/iq-auth"/&gt; 
&lt;register xmlns="http://jabber.org/features/iq-register"/&gt; &lt;/stream:features&gt; 

C4: 客户端选择一个验证机制: 

&lt;auth mechanism="DIGEST-MD5" xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;&lt;/auth&gt; 

S5:服务器发送一个 [BASE64] 编码的挑战给客户端: 

&lt;challenge xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;cmVhbG09IjE5Mi4xNjguMS4xODUiLG5vbmNlPSJlcEJaZlBxU1p0WGlLYzBqdGpwT0I1a01HMHdiY0hsUmNhOE52ZE9SIixxb3A9ImF1dGgiLGNoYXJzZXQ9dXRmLTgsYWxnb3JpdGhtPW1kNS1zZXNz&lt;/challenge&gt;  C5:客户端发送一个[BASE64]编码的回应这个挑战: 
&lt;response xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;Y2hhcnNldD11dGYtOCx1c2VybmFtZT0iYWRtaW4iLHJlYWxtPSIxOTIuMTY4LjEuMTg1Iixub25jZT0iZXBCWmZQcVNadFhpS2MwanRqcE9CNWtNRzB3YmNIbFJjYThOdmRPUiIsbmM9MDAwMDAwMDEsY25vbmNlPSJMNDJ1SE1XK2piemh6N1hzdWRndHN1V1VIT2hNZmFLVUJpcU5iR1p2IixkaWdlc3QtdXJpPSJ4bXBwLzE5Mi4xNjguMS4xODUiLG1heGJ1Zj02NTUzNixyZXNwb25zZT1hN2JhMWZlOThiMDc2ZjUzZWUzNTczM2Q5NDMwODJlYSxxb3A9YXV0aCxhdXRoemlkPSJhZG1pbiI=&lt;/response&gt; 

S6:服务器通知客户端验证成功 

&lt;success xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;cnNwYXV0aD0yNDZlZDcyOTQ3ZjVhYzFiNWQ2ZDc4ZTkxM2QzMmFjMQ==&lt;/success&gt; 

C6客户端初始化一个新流给服务器： 

&lt;stream:stream to="192.168.1.185" xmlns="jabber:client" 
xmlns:stream="http://etherx.jabber.org/streams" version="1.0"&gt;
</code></pre>

<p>基本上XMPP的登录细节就已经清楚了。后面我们看一下 注册相关的模块 以及 联系人请求模块的开发。如果想获取源码的话，请转到<a href="https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient">https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient</a></p>

<pre><code>本文作者：Terry 专注于技术开发；打滚于IOS 技术领域，偶尔也会迈出脚步探索其他领域
地址：http://www.terrylmay.com/terrylmay.github.io/2016/01/31/XMPP%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%99%BB%E5%BD%95%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[海外工作机会：高薪招聘iOS开发工程师]]></title>
    <link href="http://www.superqq.com/blog/2016/01/01/ad/"/>
    <updated>2016-01-01T21:19:26+08:00</updated>
    <id>http://www.superqq.com/blog/2016/01/01/ad</id>
    <content type="html"><![CDATA[<p>英雄帖
海外华人娱乐游戏工作室因移动互联网时代之大势所趋，诚邀以下英雄组团鏖战。iOS开发工程师：具有独立开发APP能力，有1年以上IOS开发经验，并有开发案例（月薪15000至20000人民币）产品经理：1年以上项目管理和产品规划经验，敏锐的商业意识，具备客户需求分析、挖能力，独立负责过一款以上互联网产品，知名产品更优，策划能力、沟通能力优秀，时间观念强，善用各类产品制作软件(软件只是体现思维的工具)，有较强的创新以及逻辑能力，善于分析和发现问题，性格开朗外向，充满激情，乐于接受挑战（月薪10000至15000）<strong>地点：菲律宾马尼拉</strong>其它待遇：有业绩奖金。开发产品利润占成，包吃住，食有中国菜，住在富人区，治安良好，环境优雅，配有健身房，游泳池，马尼拉常年温度28度以上，空气质量极佳，诗云：“面朝大海，春暖花开”，是广大程序猿、攻城狮极佳的栖息之地。要求：专科及以上学历，有IT相关教育及从业经验，有过1年以上IOS开发经验，具有独立开发和解决问题的能力，需要APP开发案例及有相关经验或案例，公司在菲律宾及中国大陆均有团队，目前所招岗位需在菲律宾工作，并能接受随时调遣中国大陆-菲律宾两地工作。</p>

<pre><code>请发送简历至：hellomlxsj@gmail.com
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐：iOS开发面试题整理（一）]]></title>
    <link href="http://www.superqq.com/blog/2015/12/15/ios-dev-interview/"/>
    <updated>2015-12-15T23:09:50+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/15/ios-dev-interview</id>
    <content type="html"><![CDATA[<p>年底了估计有朋友已经坐不住了，前面有一篇文章介绍<a href="http://mp.weixin.qq.com/s?__biz=MzA3NzM0NzkxMQ==&amp;mid=402358456&amp;idx=1&amp;sn=0494a7313998527e7950f936a24e9ce7#rd">《 年底程序猿迁徙的5大理由，你占了几个？ 》</a>。你是不是也占几个呢？</p>

<p>跳槽不可避免会遇到面试，有些公司会找一些奇葩的面试题来坑我们。所以我们不得不做好防备、提前备战，怎么感觉跟备考一样呢？</p>

<p>我不得不遗憾的告诉你，这比备考重要多了。面试题做不好，很有可能错过一次大好机会。很早之前我收集了很多面试题，以后都分享出来。大家如果手里有不错的面试题目，可以直接发给我，我的邮箱：<strong>worldligang@163.com</strong>，我也会分享给大家！</p>

<p>本文挡会持续更新，欢迎关注公众号iOS开发：iOSDevTip 关注之后回复：面试</p>

<p><img src="http://images.90159.com/icon/newteiba.png" alt="newteiba.png" /></p>

<h2>1. Object-C有多继承吗？没有的话用什么代替？</h2>

<p>cocoa 中所有的类都是NSObject 的子类</p>

<p>多继承在这里是用protocol 委托代理 来实现的 你不用去考虑繁琐的多继承 ,虚基类的概念. ood的多态特性 在 obj-c 中通过委托来实现.</p>

<h2>2. Object-C有私有方法吗？私有变量呢？</h2>

<p>objective-c – 类里面的方法只有两种, 静态方法和实例方法. 这似乎就不是完整的面向对象了,按照OO的原则就是一个对象只暴露有用的东西. 如果没有了私有方法的话, 对于一些小范围的代码重用就不那么顺手了.</p>

<p>在类里面声名一个私有方法</p>

<pre><code>@interface Controller : NSObject { NSString *something; } 
+ (void)thisIsAStaticMethod; – (void)thisIsAnInstanceMethod;
 @end

@interface Controller (private) 
- (void)thisIsAPrivateMethod; 
- @end
</code></pre>

<p>@private可以用来修饰私有变量</p>

<p>在Objective‐C中，所有实例变量默认都是私有的，所有实例方法默认都是公有的</p>

<h2>3. #import和#include的区别，@class代表什么？</h2>

<p>@class一般用于头文件中需要声明该类的某个实例变量的时候用到，在m文件中还是需要使用#import‘</p>

<p>而#import比起#include的好处就是不会引起重复包含</p>

<h2>4. 线程和进程的区别？</h2>

<p>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</p>

<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>

<h2>5. 堆和栈的区别？</h2>

<p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。 申请大小：</p>

<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>

<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>

<p>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</p>

<p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</p>

<h2>6. Object-C的内存管理？</h2>

<p>1.当你使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当你不再使用该对象时,你要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.</p>

<p>2.当你通过任何其他方法获得一个对象时,则假设该对象的保留计数器值为1,而且已经被设置为自动释放,你不需要执行任何操作来确保该对象被清理.如果你打算在一段时间内拥有该对象,则需要保留它并确保在操作完成时释放它.</p>

<p>3.如果你保留了某个对象,你需要(最终)释放或自动释放该对象.必须保持retain方法和release方法的使用次数相等.</p>

<h2>7 浅复制和深复制的区别？</h2>

<p>答案：浅层复制：只复制指向对象的指针，而不复制引用对象本身。</p>

<p>深层复制：复制引用对象本身。</p>

<p>意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源
还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了
两份独立对象本身。</p>

<p>用网上一哥们通俗的话将就是：</p>

<p>浅复制好比你和你的影子，你完蛋，你的影子也完蛋</p>

<p>深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我已经写了48年代码了，我感觉我还能写下去]]></title>
    <link href="http://www.superqq.com/blog/2015/12/12/write-code-48-year/"/>
    <updated>2015-12-12T19:52:50+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/12/write-code-48-year</id>
    <content type="html"><![CDATA[<p>这是来自quroa的问题：Why-aren&rsquo;t-there-a-lot-of-old-programmers-at-software-companies下的一个回答。</p>

<p>很多人会疑问是不是程序员最后只能转管理，是不是到了中年之后就应该放弃编程。看到这个回答后很受触动，尽力翻译出来，有不恰当的地方欢迎指出。</p>

<p>下 个星期我就69岁了。我从1967年开始编程。到现在已经48年了，从COBOL一直写到jQuery。我已经忘掉的编程语言比很多程序员这辈子遇到的还 多。我现在自己接一些项目，因为作为一个员工我完全是个工作狂，即使在我已经三十多岁的时候。我永远不会再去做一份每天工作8小时的传统编程工作。</p>

<p>我 已经写了两三百万行或者四百万行代码，我觉得我至少要写到&hellip;额，算了，无所谓。代码写的再多也没有什么意义，除非，这个代码对你关心的人们产生了好的 影响。（原文是： a positive impact on people I care about，和《硅谷》里的make world a better place 真是异曲同工）</p>

<p>变老带来的一个好处是，我不会再相信那些有一个点子就能改变世界的二逼想法。我只想把我应该做的工作做好，然后交给用户一个体验更好的产品。</p>

<p>但 是一个老年程序员有一个非常明显的缺点。这个世界变化的非常快，而且越来越快。15年前，我投身C++，然后我很精通它。大概4年前，我开始沉迷于 jQuery，同时学习怎么把jQuery和C#混在一起（hook jQuery and C#）去快速实现一个用户界面。3年前我从公司退休，于是我又开始关注C#并且沉迷于WordPress。现在是Drupal（php的一个框架）。趋势 就是学习一样新东西对我而言越来越难。我现在还在尝试用本地存储和 Web Workers写一个WordPress插件，调试这些真的让我有点累。</p>

<p>但是我真正要坚持的是要不断的编程，不要停，因为我真的热爱编程，其实我也只会这么一件事。不像人际交往、建立社交圈是我最近二十几年才开始尝试去做。</p>

<p>所以左脑用于编程，右脑用于处理人际关系让我保持着生活的平衡。这肯定因为我已经和一个美丽的女人结婚四十多年，我和我的三个孩子也有着非常和睦的关系。</p>

<p>我给自己设立了一个目标，至少要写50年（到2017年6月）。然后在70岁的时候成为Mankind Project &amp; New Warriors Training Adventure项目联合领袖。非常有挑战性。几年以后你可以再来看看我做的怎么样。</p>

<p>来自：<a href="http://www.jianshu.com/p/285421a867c9">http://www.jianshu.com/p/285421a867c9</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[苹果公司即将放假8天暂停APP提交审核]]></title>
    <link href="http://www.superqq.com/blog/2015/12/12/apple-commit-7-day/"/>
    <updated>2015-12-12T19:52:50+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/12/apple-commit-7-day</id>
    <content type="html"><![CDATA[<p>圣诞节对于美国人来说是一个重要的节日。每年的圣诞节苹果公司都会全员放假8天时间，时间2015年12月22日之2015年12月29日。今年也不例外。</p>

<p>昨天登录苹果开发者平台: <a href="http://developer.apple.com">http://developer.apple.com</a> 就有提示：</p>

<p><img src="http://images.90159.com/12/AppStore.png" alt="dev" /></p>

<p>提示的很清楚：</p>

<pre><code>我们将于这段时间休假。在此期间，我们会停用一些功能，如 APP 提交等...
</code></pre>

<p>在放假这段时间里，苹果将会暂停AppStore推荐、审核、提交、更新等工作。所以这段时间内更新、上架都会受到影响。</p>

<p>元旦之前，想要上架的朋友，必须得抓紧时间啦！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非常棒的特效-MBMotion]]></title>
    <link href="http://www.superqq.com/blog/2015/12/11/mbmotion-great-effect/"/>
    <updated>2015-12-11T23:21:50+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/11/mbmotion-great-effect</id>
    <content type="html"><![CDATA[<p>随便实现的特效，正在不断丰富中…</p>

<p>目前实现的效果列表</p>

<p>MBMotionActionSheet</p>

<p>设计效果如下：</p>

<p><img src="https://github.com/mmoaay/MBMotion/raw/master/20.gif" alt="master" /></p>

<p>实现效果如下：</p>

<p><img src="https://github.com/mmoaay/MBMotion/raw/master/MBMotion.gif" alt="MBMotion" /></p>

<p>地址：</p>

<pre><code>https://github.com/mmoaay/MBMotion
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[半年的iOS代码生活]]></title>
    <link href="http://www.superqq.com/blog/2015/12/10/ios-code-life-half-year/"/>
    <updated>2015-12-10T21:16:24+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/10/ios-code-life-half-year</id>
    <content type="html"><![CDATA[<p>在高考大军中拼杀过，也在大学校园中荒芜过，曾经低迷消沉，也常满怀壮志…… 但是最多的还是被称为小伙子以及自称为iOS工程师！博主就是这种喜闻乐见的这类人，实习一年后在2015年的毕业季顺利拿到了自己向往的一家创业公司的offer，也许相比很多毕业季的同学职场上顺利许多，但当深夜来临，显示器熄灭后望着荧幕出神的时候，毕业季我错过了很多也许一辈子都不会再相见的同学们的合影。半年里真正领略到了企业项目的开发的艰辛，以及团队协作的魅力，有太多太多的要说，终将其汇成一句话：哥加班半年后终于回来了！</p>

<p><img src="http://daiweilai.github.io/img/post/2015-11-11-pic1.png" alt="1" /></p>

<p>半年时间，反正撸啊撸段位已经是万劫不复了，iOS9一发布加班的觉悟早有了，潜伏的XCodeGhost也被拎出来了，各种被脱裤的同行大佬们也是尿了一地，哥也被吓了一哆嗦，赶忙修改了1024的账号密码…… 2015年就是伴随这些琐事发展着，但是博主作为一个初入职场半年的工作总结当然不会是简单地流水账。</p>

<p>我知道你们都惦记着什么是1024，1024就是，呵呵，就是一款妈妈都说好玩的游戏啊~。</p>

<h2>学习</h2>

<pre><code>干挨踢的学会学习远比你死背一个功能的代码来的有用。
</code></pre>

<p>在iOS学习中去尝试体会Cocoa模式，多留意Cocoa中的框架的类，他们的命名都有规范，相似抽象的对象会有相似的方法或者写法，比如：Mutable的类可能都有addXX、appendXX方法，Set、Array类型的类可能都会有enumerateXX的遍历方法……，又比如一个类的功能如果注重过程的话，苹果会选择使用delegate的方式，注重结果的话则会使用block ，学会总结比较、触类旁通、举一反三！</p>

<p>如果你能做到对Cocoa模式很熟悉的话，那么最新的3DTouch功能直接看类的头文件就会用了。</p>

<p>并且，第三方优秀的、热门的库都会遵循这一套编写规范，所以使用起来或者修改起来也才能够游刃有余！除了<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>之流除外。。</p>

<pre><code>学习时候看一本书远没有敲一个项目来的有效果。
</code></pre>

<p>看书的时候总是会犯一个毛病，就是一看就懂，一写就懵。所以学习技术，我更推荐的是实践检真知！敲出来的代码才是学习到的，因为你在电脑前，你遇到不懂的你可以立刻Google，看到感兴趣的新类可以直接option+左键查看文档或者command+左键直接摆出头文件一览无遗！</p>

<p>当然<a href="https://developer.apple.com/wwdc/">WWDC</a>别忘了看看，这是iOS最前沿的技术教学，即使听不懂也没关系，把音频外放，同事问你：哇，你听得懂呀。你微微一笑答道：听不懂。留下认真聆听却似享受的一道背影给同事，那可是满满的逼格。。呵呵，其实不然，视频中有大量PPT，有关键字，拿出来Google一番，再敲打一番，肯定你心中会觉得不虚此举哈，这样也锻炼了英文水平，这样的一波绝逼不亏呀。</p>

<p>说到英文，这个是技术进阶的基础，不要畏惧，刚开始看一篇英文文档可能花费你一天的时间，但是这才是第一手资料！国内译者的水平毕竟参差不齐，谬误在所难免，而且二手的资料，对于充满处女情结的你能接受么？能忍么？所以百度还是用来搜搜绯闻、床照之流就好，技术索引真不是它的强项，搜出来的东西都是deprecated的，实在浪费感情。</p>

<p><a href="http://nshipster.com/">NSHipster</a>、<a href="https://www.objc.io/">Objc.io</a> ……都是不错的去处，大量的紧巴巴的干货，他们都有中文版，但是最新的资料的中文版还是会相对滞后。</p>

<p>再一个就是大婶们的博客，一天不读都浑身难受！</p>

<p>之前拜阅<a href="http://blog.devtang.com/">唐巧Boy</a>的新书的时候，有一个博客列表非常不错，强势插入我的Feedly列表，我自己也有一些关注的大婶也加入了列表当中，这里给出分享OPML拿去玩。</p>

<p>沙龙、研讨什么的可以适当参加，看看荧幕外的世界，不要老说没有搞iOS的姑娘。</p>

<h2>团队</h2>

<p>讲一个故事：从前有个产品经理，他修改了3次需求，第二天他死了。</p>

<p>博主只想说的是，若不是博主心慈，我想我公司的产品经理已经死完后投胎又死一百次了。</p>

<p>我们都知道项目完成的水平直接由团队中是否有高效的协作而决定，也许有很多程序员长期的孤高冷艳惯了，他们说自己不需要团队！自己一个人就可以搞定一切，自己是UI、UE、产品、编码、测试甚至后端一条龙拿下，但是你将没有女朋友！！！</p>

<p>团队协作远比个人的英雄主义更有魅力，个人认为！</p>

<p>当下的快速迭代的大环境下，企业级开发下英雄主义是不太可取也不太可行的，所以融入团队，学会交流是工作顺利进展的保证；</p>

<p>当然团队协作中是否高效是否愉快就需要交流技巧了，每个人都有自恋的情节，即使是自己的工作技能也是如此，所以世界上存在着各种鄙视链</p>

<p><img src="http://daiweilai.github.io/img/post/2015-11-11-pic2.jpg" alt="2" /></p>

<p>举一个简单地例子吧</p>

<p>公司常见撕逼的三个部门：研发部、产品部、市场部</p>

<p>研发的看不起产品、市场，觉得他们都不懂技术，只是天马行空，遇到Bug还大惊小怪……</p>

<p>产品的觉得自己的设计是天才的设定，参考了社会伦理学，色彩心理学，严格的人体工学设计……反驳自己的都是傻逼……</p>

<p>市场的觉得自己深入客户，自己才是最了解这个产品市场的，所产品应该按自己的市场为导向，颜色不对，字体客户肯定不喜欢，改改改……</p>

<p>在排除消极因素，投机倒把的极个别人存在，团队中的成员还是希望共同的目标能够完美的实现的，也就是说其实我们的“争吵”也是为了更好的产品，但是“争吵”的度确实很难把握，难免就因为工作却伤了私下的感情，这也是离职中众多原因之一，频繁的离职却会使得你的职业生涯成长增加时间成本，所以更好的工作方式是“学会交流”。</p>

<p>“学会交流”不单单是工作中用到，这也是我们的一生的学问！</p>

<p>例如有时候，产品部门不是很负责任的频繁变更需求，这可苦了研发的成员，你便可以玩笑似的给他讲一个故事：从前有个产品经理，他修改了3次需求……，我想这样的诙谐即会是的工作氛围愉悦许多也可能让产品的同事知道自己不负责任行为的影响。</p>

<p>但是需求变更，这个是研发一直要面对课题，所以你必须学会“预置性开发”，预置性包括使用一些优秀的设计模式的使用降低模块间的耦合，增加系统维护的灵活性，也可以有类似Placeholder的编码技巧，来随时应对不期而遇的需求变更，具体的做法，这也许需要另开一篇博文来讲述。</p>

<h2>健康</h2>

<p>如果还没有升职加薪，当上总经理，出任CTO，迎娶白富美，走向人生巅峰。却出师未捷身先死，这个都不太好玩，身边的同事以及博主自己都有或多或少的职业病产生了，博主躬亲力行地验证了一个道理：樯橹灰飞烟灭！别说撸代码还真的很带感，根本停不下来，所以最后颈椎，肩膀就是各种不适。说多都是泪，不过后来博主秉承了国人”先污染后治理”的方针，总算把身子调过来了，秘笈如下：</p>

<ul>
<li>练此功，不强制自宫</li>
<li>好吧，这才是第一条，”不可久坐”x循环3次！！很重要，久坐流入脑子的血液会增加，从而造成下肢浮肿。由于久坐只限于局部肌肉活动，缺乏全身较大肌群动作，时间一长，久不动作的肌肉会逐步萎缩，机能衰退，还会使心、肺的后备能力降低，不能适应肌肉活动对血液循环和氧气供应的要求，一动就会心跳气急。肌肉长期不活动，热量消耗少，会加重脂肪和糖的代谢障碍，导致身体过分肥胖、动脉硬化及糖尿病。而且久坐一般皮肤质量较差，长时间静坐，受压血液流通不畅，易引起臂部瘙痒和隐痛，伏案工作者更甚，长期下去易导致颈椎炎，肩周炎，腰椎突出，脊柱变弯……我编不下去了，就问你怕不怕！！！所以多起身活动往非技术部走走，不然就会生病的哟(认不出雌性生物了)。</li>
<li>坐姿</li>
</ul>


<p><img src="http://daiweilai.github.io/img/post/2015-11-11-pic3.jpg" alt="3" /></p>

<ul>
<li>尝试全键盘操作，多记记几个快捷键世界就安静了，反正博主的magic mouse干电池已扣，什么你的是最新款的鼠标没干电池？那为了你的健康着想拿给博主用吧，可减少手腕以及肩膀劳损的风险。这里分享一个Mac屏幕效率工具SizeUp 可减少鼠标的使用！</li>
<li>运动运动运动！不要在被人黑了，老是被黑码农，油头垢面，肾虚患者……有意思么？我们是改变世界的工程师！不要再穿拖鞋上班了！！大家薪水都不低，穿得体面点吧。你可以和博主一样帅的。</li>
<li>努力陪伴回你身边一直陪伴着你的人，那使你的精神最远是最佳的状态！什么？那就多打打电话给你妈妈吧，那是最美的人。</li>
</ul>


<h2>追求</h2>

<p>不要担心30岁要转行，不要认为30K就是终点，不要一天工作30个小时。保持初心。</p>

<pre><code>O ever youthful,O ever weeping.
</code></pre>

<h2>后记</h2>

<p>博主新开了一个博客系统，托管在了Github.io上，喜闻乐见的Jekll加借鉴<del>(抄袭)</del>的精美主题构建而成，反正样子应该还看得过去，如果有朋友有兴趣想了解iOS程序员为何日撸万行代码？数百奇巧淫技如何施展？无数干货为何频频送出？究竟编译器背后又隐藏着什么？这一切的背后是技术与生活的碰撞还是高效与投机的权衡？我真TM编不下去了，欢迎前往 [任意门]围观。</p>

<p>严肃地，如果你刚开始学习iOS开发或许可以从博主这里得到一些半干货。</p>

<p>生活愉快！</p>

<blockquote><p>来自戴伟来的投稿</p>

<p>博客地址：<a href="http://daiweilai.github.io/">http://daiweilai.github.io/</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员的幽默你一定懂得]]></title>
    <link href="http://www.superqq.com/blog/2015/12/09/programmer-must-humor/"/>
    <updated>2015-12-09T21:54:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/09/programmer-must-humor</id>
    <content type="html"><![CDATA[<p>以下是关于程序员的一些笑话，据说看懂的人都还在加班中。</p>

<ol>
<li><p>老婆给当程序员的老公打电话：下班顺路买十个包子，如果看到卖西瓜的，买一个。当晚老公手捧一个包子进了家门。老婆怒道：你怎么只买一个包子？！老公甚恐，喃喃道：因为我真看到卖西瓜的了。”</p></li>
<li><p>一程序员去面试，面试官问：“你毕业才两年，这三年工作经验是怎么来的？！”程序员答：“加班。”</p></li>
<li><p>某程序员对书法十分感兴趣，退休后决定在这方面有所建树。于是花重金购买了上等的文房四宝。一日，饭后突生雅兴，一番磨墨拟纸，并点上了上好的檀香，颇有王羲之风范，又具颜真卿气势，定神片刻，泼墨挥毫，郑重地写下一行字：hello world。</p></li>
</ol>


<p><img src="http://images.90159.com/12/humor.jpg" alt="https" /></p>

<ol>
<li><p>问：程序员最讨厌康熙的哪个儿子。答：胤禩。因为他是八阿哥（bug）</p></li>
<li><p>程序猿要了3个孩子，分别取名叫Ctrl、Alt 和Delete，如果他们不听话，程序猿就只要同时敲他们一下就会好的。</p></li>
<li><p>今天在公司听到一句惨绝人寰骂人的话：“你TM就是一个没有对象的野指针！”</p></li>
<li><p>程xx遭遇车祸成植物人，医生说她活下来的希望只有万分之一，唤醒更为渺茫。她的同事和亲人没放弃，并根据程xx对testing痴迷的作风，每天都在她身边念：“你测的模块上线后回滚了。”奇迹发生了，程xx醒来第一句话：确认那模块是我测的？</p></li>
<li><p>一个程序员在海滨游泳时溺水身亡。他死前拼命的呼救，当时海滩上有许多救生员，但是没有人救他。因为他一直大喊“F1!”“F1!”，谁都不知道“F1”究竟是什么意思。</p></li>
<li><p>世界上最远的距离，是我在if里你在else里，虽然经常一起出现，但却永不结伴执行。</p></li>
<li><p>正在码代码ing，医院回来的同事一脸的苦逼样子，问他怎么了？他回答：得了类风湿性关节炎了，我怕会遗传给下一代啊。我一脸的问号：谁说类风湿性关节炎能遗传的？丫一脸诧异：类不是继承的吗？</p></li>
<li><p>我很奇怪客栈这个词，难道后入住的必须先退房吗？</p></li>
<li><p>话说，决定一个程序员跳槽与否的关键因素是他前同事的现工资。</p></li>
<li><p>程序员最憋屈的事情就是：你辛辛苦苦熬夜写了一个风格优雅的源文件，被一个代码风格极差的同事改了且没署名，以至于别人都以为你是写的。</p></li>
<li><p>前端工程师说，我去交友网站找女朋友去了。朋友问，找到了么？工程师说，找到了他们页面的一个bug。</p></li>
<li><p>C程序员看不起C++程序员， C++程序员看不起Java程序员， Java程序员看不起C#程序员，C#程序员看不起美工，周末了，美工带着妹子出去约会了，一群程序员还在加班！</p></li>
<li><p>据说一老外年轻的时候，立志要当一名伟大的作家。怎么才算伟大呢？他说：我写的东西全世界都要看到！看完他们必定会歇斯底里！会火冒三丈！会痛苦万分！结果，他成功了，他在微软公司负责写系统蓝屏时的报错提示信息。</p></li>
<li><p>程序员应聘必备词汇：了解＝听过名字；熟悉＝知道是啥；熟练＝用过；精通＝做过东西。</p></li>
<li><p>两程序员聊天，程序员甲抱怨：“做程序员太辛苦了，我想换行……我该怎么办？”程序员乙：“敲一下回车。”</p></li>
<li><p>程序员最讨厌的四件事：写注释、写文档、别人不写注释、别人不写文档……</p></li>
<li><p>假如生活欺骗了你，找50个程序员问问为什么编程；假如生活让你想死，找50个程序员问问Bug改完了没有；假如你觉得生活拮据，找50个程序员问问工资涨了没有；假如你觉得活着无聊，找50个程序员问问他们一天都干了什么！</p></li>
<li><p>男人要记住，与女人吵架的要领是，要像在安装软件或注册网站时阅读“服务条款”那样，直接忽略所有的内容，到最后面勾选“我同意”，然后点击“确定”。</p></li>
<li><p>朋友今天遇到的真事：客户说我们设备卡，死活找不到原因，工程师赶到现场，给客户换了个鼠标垫，故障排除……</p></li>
<li><p>产品经理：“你明白吧，这里向右划可以出菜单，然后需要一个闪烁的动画，还有，我想这个tab可以拉下来，你懂吧？ 设计师：“别废话，把你要抄的产品给我看下。”</p></li>
<li><p>百度研发的无人驾驶汽车，你会发现有些地方你是去不了的。腾讯研发的无人驾驶汽车，你会发现很多地方你要去是要黄钻会员的。当然，谷歌研发的无人驾驶汽车，你会发现查无此车。</p></li>
<li><p>话说昨天是周日，程序猿跟产品经理一起看电视。每个节目看到一半程序猿就换台，看到一半就换台，几次之后产品经理终于忍无可忍的咆哮：老子刚看出点意思你就换、刚看出点意思你就换，到底还让不让人看啦？！程序猿淡定的盯着电视道：你半路改需求的时候我可没吱过声！</p></li>
<li><p>“为什么删除手机上的图标的时候它们会抖？” “它们怕被删除呗。” “那为什么电话短信之类系统自带的删不掉的也在抖呢？” “那是它们在得瑟…”</p></li>
<li><p>有时候觉得，电脑就像一个高贵冷艳的妹纸。</p></li>
</ol>


<p>400，是她冷冰冰地说：“我听不懂你在说什么”；</p>

<p>401，是她无情地转身：“我不认识你，别说那些奇怪的话”；</p>

<p>403，是她残酷的拒绝：“我听懂你的话，也认出你的脸，可我不爱你”；</p>

<p>404，是她紧闭心门：“我这儿没有你想要的东西”；</p>

<p>503，是“呵呵我去洗澡”。</p>

<ol>
<li><p>问：为何软件正在占领全世界，而程序员得不到尊重？答曰：遍身罗绮者，不是养蚕人。</p></li>
<li><p>她来例假了肚子疼，他坐着她旁边，看了她一眼，拿出手机玩游戏，她看在眼里，心里凉了半截。两分钟后，她实在坐不下去了，正准备离开，只见他默默地递过来他的小米手机说：拿去捂着。</p></li>
<li><p>惊闻微软要裁员1.8万人。他们就不能让这些员工们“在后台运行”吗？</p></li>
<li><p>今天看到我同事在笔记本电脑上实现“滑动解锁”！真的，看到我当场就震精了，异常碉堡……你知道吗？！他的电脑开机解锁密码是“ASDFGHJKL;’”，然后唰得一下过去最后一个键落在回车上，就，就解锁了！</p></li>
<li><p>骗子网站太特么多了，你一打开，必定跳出一个很下流的游戏广告！——但这还不是最关键的，关键是如果你忍不住点击进入游戏之后，就会发现这些下流的元素全都不见了！这也太没有职业道德了吧！</p></li>
<li><p>最近发现自己陷入了一种状态，叫开机迷失。开电脑前，该做什么清清楚楚。但只要一登录，随手开个网页，刷下新闻微博甚至仅仅是音乐网站，然后再回过神来， 已经到了深夜，要做的事一项没做。而最痛苦的是，在睡前闭眼的时候，整个被浪费的白天和那些被耽误的正事，总会掺杂着负罪感，无比清晰地浮现。</p></li>
<li><p>我要设计一个新的智能机应用程序叫做&#8221;惊慌&#8221;，只要你一说 老婆 这两个字, 它就会关闭所有网页, 隐藏所有跟女性的聊天以及怪怪的文件夹, 并且把我老婆的照片设为墙纸。</p></li>
<li><p>我从苹果手机的背面知道了一个好地方叫做加利福尼亚，据说那里有阳光和沙滩，还有Google和Tesla。据说那里的人经常讨论怎么创业，而不是怎么移民。我虽然在中国，但也去过那里，不是在梦中，而是通过VPN。</p></li>
<li><p>边上工位的妹纸叫柳依依，她的爸爸也是位程序员，依依的大姐叫玲玲，二姐叫玲依，三姐叫依玲。</p></li>
</ol>


<p>整理自网络</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于启用 HTTPS 的一些经验分享]]></title>
    <link href="http://www.superqq.com/blog/2015/12/08/some-experiences-https/"/>
    <updated>2015-12-08T21:54:20+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/08/some-experiences-https</id>
    <content type="html"><![CDATA[<p><img src="http://images.90159.com/12/https.jpg" alt="https" /></p>

<p>随着国内网络环境的持续恶化，各种篡改和劫持层出不穷，越来越多的网站选择了全站 HTTPS。HTTPS 通过 TLS 层和证书机制提供了内容加密、身份认证和数据完整性三大功能，可以有效防止数据被查看或篡改，以及防止中间人冒充。本文分享一些启用 HTTPS 过程中的经验，重点是如何与一些新出的安全规范配合使用。至于 HTTPS 的部署及优化，之前写过很多，本文不重复了。</p>

<h2>理解 Mixed Content</h2>

<p>HTTPS 网页中加载的 HTTP 资源被称之为 Mixed Content(混合内容)，不同浏览器对 Mixed Content 有不一样的处理规则。</p>

<h2>早期的 IE</h2>

<p>早期的 IE 在发现 Mixed Content 请求时，会弹出「是否只查看安全传送的网页内容?」这样一个模态对话框，一旦用户选择「是」，所有 Mixed Content 资源都不会加载;选择「否」，所有资源都加载。</p>

<h2>比较新的 IE</h2>

<p>比较新的 IE 将模态对话框改为页面底部的提示条，没有之前那么干扰用户。而且默认会加载图片类 Mixed Content，其它如 JavaScript、CSS 等资源还是会根据用户选择来决定是否加载。</p>

<h2>现代浏览器</h2>

<p>现代浏览器(Chrome、Firefox、Safari、Microsoft Edge)，基本上都遵守了 W3C 的 Mixed Content 规范，将 Mixed Content 分为Optionally-blockable 和 Blockable 两类：</p>

<p>Optionally-blockable 类 Mixed Content 包含那些危险较小，即使被中间人篡改也无大碍的资源。现代浏览器默认会加载这类资源，同时会在控制台打印警告信息。这类资源包括：</p>

<pre><code>通过  标签加载的图片(包括 SVG 图片);

通过 &lt;img&gt; 标签加载的图片（包括 SVG 图片）；

通过 &lt;video&gt; / &lt;audio&gt; 和 &lt;source&gt; 标签加载的视频或音频；

预读的（Prefetched）资源；
</code></pre>

<h2>预读的(Prefetched)资源;</h2>

<p>除此之外所有的 Mixed Content 都是 Blockable，浏览器必须禁止加载这类资源。所以现代浏览器中，对于 HTTPS 页面中的 JavaScript、CSS 等 HTTP 资源，一律不加载，直接在控制台打印错误信息。</p>

<h2>移动浏览器</h2>

<p>前面所说都是桌面浏览器的行为，移动端情况比较复杂，当前大部分移动浏览器默认都允许加载 Mixed Content。也就是说，对于移动浏览器来说，HTTPS 中的 HTTP 资源，无论是图片还是 JavaScript、CSS，默认都会加载。</p>

<p>一般选择了全站 HTTPS，就要避免出现 Mixed Content，页面所有资源请求都走 HTTPS 协议才能保证所有平台所有浏览器下都没有问题。</p>

<h2>合理使用 CSP</h2>

<p>CSP，全称是 Content Security Policy，它有非常多的指令，用来实现各种各样与页面内容安全相关的功能。</p>

<pre><code>block-all-mixed-content
</code></pre>

<p>前面说过，对于 HTTPS 中的图片等 Optionally-blockable 类 HTTP 资源，现代浏览器默认会加载。图片类资源被劫持，通常不会有太大的问题，但也有一些风险，例如很多网页按钮是用图片实现的，中间人把这些图片改掉，也会干扰用户使用。</p>

<p>通过 CSP 的 block-all-mixed-content 指令，可以让页面进入对混合内容的严格检测(Strict Mixed Content Checking)模式。在这种模式下，所有非 HTTPS 资源都不允许加载。跟其它所有 CSP 规则一样，可以通过以下两种方式启用这个指令：</p>

<h2>HTTP 响应头方式：</h2>

<pre><code>Content-Security-Policy: block-all-mixed-content 
</code></pre>

<p><meta>标签方式：</p>

<pre><code>&lt;meta http-equiv="Content-Security-Policy" content="block-all-mixed-content"&gt; 


upgrade-insecure-requests
</code></pre>

<p>历史悠久的大站在往 HTTPS 迁移的过程中，工作量往往非常巨大，尤其是将所有资源都替换为 HTTPS 这一步，很容易产生疏漏。即使所有代码都确认没有问题，很可能某些从数据库读取的字段中还存在 HTTP 链接。</p>

<p>而通过 upgrade-insecure-requests 这个 CSP 指令，可以让浏览器帮忙做这个转换。启用这个策略后，有两个变化：</p>

<pre><code>页面所有 HTTP 资源，会被替换为 HTTPS 地址再发起请求;

页面所有站内链接，点击后会被替换为 HTTPS 地址再跳转;
</code></pre>

<p>跟其它所有 CSP 规则一样，这个指令也有两种方式来启用，具体格式请参考上一节。需要注意的是 upgrade-insecure-requests 只替换协议部分，所以只适用于 HTTP/HTTPS 域名和路径完全一致的场景。</p>

<h2>合理使用 HSTS</h2>

<p>在网站全站 HTTPS 后，如果用户手动敲入网站的 HTTP 地址，或者从其它地方点击了网站的 HTTP 链接，依赖于服务端 301/302 跳转才能使用 HTTPS 服务。而第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。</p>

<h2>HSTS 基本使用</h2>

<p>这个问题可以通过 HSTS(HTTP Strict Transport Security，RFC6797)来解决。HSTS 是一个响应头，格式如下：</p>

<pre><code>Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload] 
</code></pre>

<p>max-age，单位是秒，用来告诉浏览器在指定时间内，这个网站必须通过 HTTPS 协议来访问。也就是对于这个网站的 HTTP 地址，浏览器需要先在本地替换为 HTTPS 之后再发送请求。</p>

<p>includeSubDomains，可选参数，如果指定这个参数，表明这个网站所有子域名也必须通过 HTTPS 协议来访问。</p>

<p>preload，可选参数，后面再介绍它的作用。</p>

<p>HSTS 这个响应头只能用于 HTTPS 响应;网站必须使用默认的 443 端口;必须使用域名，不能是 IP。而且启用 HSTS 之后，一旦网站证书错误，用户无法选择忽略。</p>

<p>HSTS Preload List</p>

<p>可以看到 HSTS 可以很好的解决 HTTPS 降级攻击，但是对于 HSTS 生效前的首次 HTTP 请求，依然无法避免被劫持。浏览器厂商们为了解决这个问题，提出了 HSTS Preload List 方案：内置一份列表，对于列表中的域名，即使用户之前没有访问过，也会使用 HTTPS 协议;列表可以定期更新。</p>

<p>目前这个 Preload List 由 Google Chrome 维护，Chrome、Firefox、Safari、IE 11 和 Microsoft Edge 都在使用。如果要想把自己的域名加进这个列表，首先需要满足以下条件：</p>

<pre><code>拥有合法的证书(如果使用 SHA-1 证书，过期时间必须早于 2016 年);

将所有 HTTP 流量重定向到 HTTPS;

确保所有子域名都启用了 HTTPS;

输出 HSTS 响应头：

max-age 不能低于 18 周(10886400 秒);

必须指定 includeSubdomains 参数;

必须指定 preload 参数;
</code></pre>

<p>即便满足了上述所有条件，也不一定能进入 HSTS Preload Lis。通过 Chrome 的 chrome://net-internals/#hsts 工具，可以查询某个网站是否在 Preload List 之中，还可以手动把某个域名加到本机 Preload List。</p>

<p>对于 HSTS 以及 HSTS Preload List，我的建议是只要你不能确保永远提供 HTTPS 服务，就不要启用。因为一旦 HSTS 生效，你再想把网站重定向为 HTTP，之前的老用户会被无限重定向，唯一的办法是换新域名。</p>

<h2>CDN 安全</h2>

<p>对于大站来说，全站迁移到 HTTPS 后还是得用 CDN，只是必须选择支持 HTTPS 的 CDN 了。如果使用第三方 CDN，安全方面有一些需要考虑的地方。</p>

<h2>合理使用 SRI</h2>

<p>HTTPS 可以防止数据在传输中被篡改，合法的证书也可以起到验证服务器身份的作用，但是如果 CDN 服务器被入侵，导致静态文件在服务器上被篡改，HTTPS 也无能为力。</p>

<p>W3C 的 SRI(Subresource Integrity)规范可以用来解决这个问题。SRI 通过在页面引用资源时指定资源的摘要签名，来实现让浏览器验证资源是否被篡改的目的。只要页面不被篡改，SRI 策略就是可靠的。</p>

<p>SRI 并不是 HTTPS 专用，但如果主页面被劫持，攻击者可以轻松去掉资源摘要，从而失去浏览器的 SRI 校验机制。</p>

<h2>了解 Keyless SSL</h2>

<p>另外一个问题是，在使用第三方 CDN 的 HTTPS 服务时，如果要使用自己的域名，需要把对应的证书私钥给第三方，这也是一件风险很高的事情。</p>

<p>CloudFlare 公司针对这种场景研发了 Keyless SSL 技术。你可以不把证书私钥给第三方，改为提供一台实时计算的 Key Server 即可。CDN 要用到私钥时，通过加密通道将必要的参数传给 Key Server，由 Key Server 算出结果并返回即可。整个过程中，私钥都保管在自己的 Key Server 之中，不会暴露给第三方。</p>

<p>CloudFlare 的这套机制已经开源，如需了解详情，可以查看他们官方博客的这篇文章：Keyless SSL: The Nitty Gritty Technical Details。</p>

<p>好了，本文先就写到这里，需要注意的是本文提到的 CSP、HSTS 以及 SRI 等策略都只有最新的浏览器才支持，详细的支持度可以去 CanIUse 查。切换到 HTTPS 之后，在性能优化上有很多新工作要做，这部分内容我在之前的博客中写过很多，这里不再重复，只说最重要的一点：既然都 HTTPS 了，赶紧上 HTTP/2 才是正道。</p>

<p>内容来源：Jerry Qu的小站</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9横竖屏设置的处理方法和实例讲解]]></title>
    <link href="http://www.superqq.com/blog/2015/12/07/ios9-interface-orientation/"/>
    <updated>2015-12-07T23:30:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/07/ios9-interface-orientation</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://www.superqq.com/blog/2015/12/07/ios9-interface-orientation/">http://www.superqq.com/blog/2015/12/07/ios9-interface-orientation/</a></p>

<p>在一般的视频类APP播放的时候都会支持横屏，这样做的好处就是便于观看。你的项目中支持横屏吗？我们一起了解一下，在iOS9中横竖屏设置的处理方法吧！</p>

<h2>支持横竖屏配置</h2>

<p>在iOS6以后，如果APP需要支持横屏，需要在xcode设置中General里面进行勾选配置：</p>

<!--more-->


<p><img src="http://images.90159.com/12/orientation1.png" alt="orientation1" /></p>

<p>配置完成之后，我们可以看一下Info.plist里面的Supported interface orientations选项也相应的改变了。如下图：</p>

<p><img src="http://images.90159.com/12/orientation2.png" alt="orientation2" /></p>

<p>当然，我们也可以直接在Info.plist进行配置。</p>

<h2>支持横竖屏方法</h2>

<p>在iOS6之前我们可以直接用这个方法进行配置：</p>

<pre><code>- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0) __TVOS_PROHIBITED;
</code></pre>

<p>在iOS6之后，这个方法被NS_DEPRECATED_IOS，也就是废弃掉了。废弃了这个方法，苹果相应的也给出了新的方法来代替：</p>

<pre><code>// New Autorotation support.
- (BOOL)shouldAutorotate NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;
- (UIInterfaceOrientationMask)supportedInterfaceOrientations NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;
</code></pre>

<p>我们可以看到iOS6之前是一个方法，在iOS6之后变成两个方法了，一个是是否旋转的方法，一个是支持的方向的方法。</p>

<h2>实例一：</h2>

<p>假设：我们ViewController是直接加载window的self.window.rootViewController上面的。代码如下：</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    ViewController *vc = [[ViewController alloc] init];
    self.window.rootViewController = vc;
    [self.window makeKeyAndVisible];
    return YES;
}
</code></pre>

<p>如果我们要是想支持上面General里勾选的方向（竖屏、横屏向左已经横屏向右）该如何实现呢？首先，我们应该设置让他支持旋转，然后在设置支持的方向。代码如下：</p>

<pre><code>//支持旋转
-(BOOL)shouldAutorotate{
   return YES;
}
//支持的方向
- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    return UIInterfaceOrientationMaskAllButUpsideDown;
}
</code></pre>

<p>其中UIInterfaceOrientationMask是一个枚举：</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {
    UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait),
    UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft),
    UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight),
    UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown),
    UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),
    UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown),
    UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),
} __TVOS_PROHIBITED;    
</code></pre>

<p>可以根据自己的需求来选择。上面我们说了假设这个条件，如果rootViewController上导航，我们直接在ViewController里面设置，这个方法就不灵了。（大家可以自己测试一下）</p>

<h2>实例二：</h2>

<p>为什么是导航上面的方法就不灵了呢？原因很简单，我们没有设置导航支持的方向。别忘了UINavigationController也是UIViewController的子类。需要受到同样的待遇的。</p>

<p>如何设置呢？我们可以创建一个UINavigationController的子类，假设叫GGPublicNavigationViewController。然后，我们在GGPublicNavigationViewController.m文件里面也实现着两个方法：</p>

<pre><code>//支持旋转
-(BOOL)shouldAutorotate{
   return YES;
}
//支持的方向
- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    return UIInterfaceOrientationMaskAllButUpsideDown;
}
</code></pre>

<p>这样设置之后，即使我们push进去的UIViewController没有实现上面的连个方法，也是可以支持横屏的。也就是说，我们push的所有都支持横屏。这个做法是不是很暴力！</p>

<h2>实例三：</h2>

<p>有些童鞋会问了，如何控制每个界面支持的方向呢？这也是可以办到的，在GGPublicNavigationViewController不能写死支持哪个。我们可以这么写：</p>

<pre><code>-(BOOL)shouldAutorotate{
    return [self.topViewController shouldAutorotate];
}
//支持的方向
- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    return [self.topViewController supportedInterfaceOrientations];;
}
</code></pre>

<p>self.topViewController是当前导航显示的UIViewController，这样就可以控制每个UIViewController所支持的方向啦！</p>

<p>好啦，关于iOS9中横竖屏的处理就说这么多吧！（其实iOS7、iOS8也是这么设置的）如果你觉得文章还不错，分享一下吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个弹性侧滑菜单]]></title>
    <link href="http://www.superqq.com/blog/2015/12/06/an-elastic-sliding-menu/"/>
    <updated>2015-12-06T20:19:51+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/06/an-elastic-sliding-menu</id>
    <content type="html"><![CDATA[<pre><code>地址：https://github.com/lilei644/LLSlideMenu

作者lilei644
</code></pre>

<h1>LLSlideMenu</h1>

<p>This is a spring slide menu for iOS apps<br>
一个弹性侧滑菜单<br><br>
弹性动画原理借鉴该<a href="https://github.com/KittenYang/KYAnimatedPageControl">项目</a>中阻尼函数实现</p>

<!--more-->


<h2>Preview预览</h2>

<p><img src="http://images.90159.com/12/sliding.gif" alt="Preview" /></p>

<h2>Installation &nbsp;安装</h2>

<ul>
<li>pod</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.pod "LLSlideMenu"
</span><span class='line'>2.pod install       // 若获取失败请重新 pod setup
</span><span class='line'>3.#import "LLSlideMenu.h"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Common</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.Add "LLSlideMenu" files to your Project   // 直接导入“LLSlideMenu”文件夹到项目中
</span><span class='line'>2.#import "LLSlideMenu.h"</span></code></pre></td></tr></table></div></figure>


<h2>Usage &nbsp;用法</h2>

<ul>
<li>Init &nbsp;初始化</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LLSlideMune *slideMenu = [[LLSlideMune alloc] init];
</span><span class='line'>[self.view addSubview:slideMenu];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Base Property &nbsp;基本属性</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 设置菜单宽度  menu width
</span><span class='line'>_slideMenu.ll_menuWidth = 200.f;
</span><span class='line'>
</span><span class='line'>// 设置菜单背景色  background color
</span><span class='line'>_slideMenu.ll_menuBackgroundColor = [UIColor redColor];
</span><span class='line'>
</span><span class='line'>// 设置菜单背景图片  background image
</span><span class='line'>_slideMenu.ll_menuBackgroundImage = [UIImage imageNamed:@"image"];
</span><span class='line'>
</span><span class='line'>// 背景色或背景图片设置一个即可  background image and color select one
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Open or Close &nbsp;打开或关闭</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[_slideMenu ll_openSlideMenu];      // 打开  open
</span><span class='line'>[_slideMenu ll_closeSlideMenu];     // 关闭  close</span></code></pre></td></tr></table></div></figure>


<ul>
<li>GestureRecognizer &nbsp;手势监听</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_slideMenu.ll_distance = 100.f;     // 拉伸距离  pulling distance</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Spring and Frames &nbsp;弹力和关键帧设置（可控制弹性效果和时间）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_slideMenu.ll_springDamping = 20;       // 阻力
</span><span class='line'>_slideMenu.ll_springVelocity = 15;      // 速度
</span><span class='line'>_slideMenu.ll_springFramesNum = 60;     // 关键帧数量</span></code></pre></td></tr></table></div></figure>


<h2>Requirements &nbsp;版本要求</h2>

<p>IOS 6.0 Above</p>

<h2>License</h2>

<p>LLSlideMenu is provided under the MIT license. See LICENSE file for details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VIP群福利：Git使用教程（视频+PPT）]]></title>
    <link href="http://www.superqq.com/blog/2015/12/05/git-use-video-ppt/"/>
    <updated>2015-12-05T20:07:12+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/05/git-use-video-ppt</id>
    <content type="html"><![CDATA[<p>天才帝一步应用源代码分享到<a href="http://www.superqq.com/blog/2015/11/19/create-high-efficiency-ios-group/">iOS开发实战交流VIP群</a>，已经有不少朋友下载。这个APP也是一个小小的想法，希望能激发大家的灵感，做出更多有意义的属于自己的APP。</p>

<p>iOS开发实战交流VIP群已经有几百位朋友加入，这里是一个非常不错的交流平台，欢迎更多朋友加入！详情点击这里。</p>

<p>愿大家除了思维上、技术上有所提高，更能成为网络上无话不谈的知心朋友！</p>

<p>今天给大家分享Git使用教程：</p>

<h2>Git是什么？</h2>

<!--more-->


<p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。作为一名iOS开发者，应该掌握！当然，也有朋友用SVN来管理，SVN也是有相应的命令。</p>

<p>在使用Git之前，我还用过最笨的办法通过手动来管理代码。管理起来相当不便，尤其是团队多人开发时，根本无法用手动来管理代码。</p>

<p>直到接触的Git，才感受到它的强大。Git其实没有大家想象的那么难，刚开始接触的时候，可能不知道如何下手。当你真正的用一段时间之后，你会掌握一些常用的命令，比如：git status、git commit -m “message”、也会理解里面的一些术语，比如仓库、分支等等。</p>

<h2>Git视频教程</h2>

<p>为了帮助大家快速上手Git，上周录制了一期视频教程《Git使用教程》已经上传到iOS开发实战交流VIP群。欢迎大家到群文件里面下载。</p>

<p>视频里面有讲到用Homebrew来安装Git，大家电脑上如果没有装Homebrew，可以通过下面的命令来安装：</p>

<pre><code>ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></pre>

<p>Homebrew的官方：</p>

<pre><code>http://brew.sh/
</code></pre>

<p>如果在看视频教程中，遇到问题，可以到VIP群里讨论。来吧，一起征服Git！</p>

<h2>PPT截图</h2>

<p>PPT里面整理了Git的常用命令、别名设置、一些资料网站等等，我把PPT里面的内容整理出来，大家一起学习：</p>

<p><img src="http://images.90159.com/git/1.png" alt="1" />
<img src="http://images.90159.com/git/2.png" alt="1" />
<img src="http://images.90159.com/git/3.png" alt="1" />
<img src="http://images.90159.com/git/4.png" alt="1" />
<img src="http://images.90159.com/git/5.png" alt="1" />
<img src="http://images.90159.com/git/6.png" alt="1" />
<img src="http://images.90159.com/git/7.png" alt="1" />
<img src="http://images.90159.com/git/8.png" alt="1" />
<img src="http://images.90159.com/git/9.png" alt="1" />
<img src="http://images.90159.com/git/10.png" alt="1" />
<img src="http://images.90159.com/git/11.png" alt="1" />
<img src="http://images.90159.com/git/12.png" alt="1" />
<img src="http://images.90159.com/git/13.png" alt="1" />
<img src="http://images.90159.com/git/14.png" alt="1" />
<img src="http://images.90159.com/git/15.png" alt="1" />
<img src="http://images.90159.com/git/16.png" alt="1" />
<img src="http://images.90159.com/git/17.png" alt="1" />
<img src="http://images.90159.com/git/18.png" alt="1" />
<img src="http://images.90159.com/git/19.png" alt="1" />
<img src="http://images.90159.com/git/20.png" alt="1" />
<img src="http://images.90159.com/git/21.png" alt="1" />
<img src="http://images.90159.com/git/22.png" alt="1" />
<img src="http://images.90159.com/git/23.png" alt="1" />
<img src="http://images.90159.com/git/24.png" alt="1" />
<img src="http://images.90159.com/git/25.png" alt="1" />
<img src="http://images.90159.com/git/26.png" alt="1" />
<img src="http://images.90159.com/git/27.png" alt="1" />
<img src="http://images.90159.com/git/28.png" alt="1" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift开源一天Github收获15000多star]]></title>
    <link href="http://www.superqq.com/blog/2015/12/04/swift-source-code/"/>
    <updated>2015-12-04T22:10:48+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/04/swift-source-code</id>
    <content type="html"><![CDATA[<p>快，快，快！动动您的小手，分享给更多朋友！</p>

<p>苹果去年推出了全新的编程语言Swift，试图让iOS开发更简单，也承诺开源Swift代码。</p>

<p>昨天，苹果宣布：开源Swift，引起不少轰动，短短一天不到得时间，github上就有9000多star。对于广大开发者来说，真是一大福利！大家快取看看吧，一睹真容！</p>

<p>swift开源地址：<a href="https://github.com/apple/swift">https://github.com/apple/swift</a></p>

<p>官方Linux版本：<a href="https://swift.org/blog/swift-linux-port/">https://swift.org/blog/swift-linux-port/</a></p>

<p>苹果官方github地址：<a href="https://github.com/apple">https://github.com/apple</a></p>

<p><a href="https://swift.org">https://swift.org</a> 是苹果官方的开发者社区，这里有Swift开发教程和指南。是个学习的好地方！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级Xcode7之后VVDocumenter-Xcode不能用的解决办法]]></title>
    <link href="http://www.superqq.com/blog/2015/12/03/vvdocumenter-xcode7-not-work/"/>
    <updated>2015-12-03T22:24:57+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/03/vvdocumenter-xcode7-not-work</id>
    <content type="html"><![CDATA[<p>VVDocumenter-Xcode是Xcode上一款快速添加标准注释，并可以自动生成文档的插件。有了VVDocumenter-Xcode，规范化的注释，只需要输入三个斜线“///”就可以搞定，非常方面实用，目前已经支持Swift。</p>

<p>Objective-C效果图：</p>

<p><img src="http://images.90159.com/11/vvdocumenter1.gif" alt="VVDocumenter1" /></p>

<p>Swift效果图：</p>

<p><img src="http://images.90159.com/11/vvdocumenter2.gif" alt="VVDocumenter1" /></p>

<p>从Xcode 5开始，苹果要求加入UUID证书从而保证插件的稳定性。因此Xcode版本更新之后需要在VVDocumenter-Xcode的Info.plist文件中添加Xcode的UUID。</p>

<h2>步骤如下：</h2>

<h3>一、查看Xcode的UUID</h3>

<h4>方式1</h4>

<p>在终端执行</p>

<pre><code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID
</code></pre>

<p><img src="http://images.90159.com/11/vvdocumenter3.jpg" alt="VVDocumenter1" /></p>

<p>拷贝选中的字符串。</p>

<h4>方式2</h4>

<p>在/Applications目录中找到Xcode.app，右键”显示包内容”，进入Contents文件夹，双击Info.plist打开，找到DVTPlugInCompatibilityUUID，拷贝后面的字符串。</p>

<h3>二、添加Xcode的UUID到VVDocumenter-Xcode的Info.plist文件</h3>

<h4>方式1&ndash;插件已经安装完成</h4>

<p>1、打开xcode插件所在的目录：~/Library/Application Support/Developer/Shared/Xcode/Plug-ins；</p>

<p>2、选择已经安装的插件例如VVDocumenter-Xcode，右键”显示包内容”；</p>

<p>3、找到info.plist 文件，找到DVTPlugInCompatibilityUUIDs的项目，添加一个Item，Value的值为之前Xcode的UUID，保存。</p>

<p><img src="http://images.90159.com/11/vvdocumenter4.jpg" alt="VVDocumenter1" /></p>

<h4>方式2&ndash;插件还未安装/重新安装</h4>

<p>1、从GitHub克隆仓库到本地，在Xcode中打开项目，选择项目名称，在TAGETS下选中VVDocumenter-Xcode；</p>

<p>2、选择Info，找到DVTPlugInCompatibilityUUIDs的项目，添加一个Item，Value的值为之前Xcode的UUID；</p>

<p>3、Build项目，VVDocumenter-Xcode会自动安装。</p>

<h3>三、重启Xcode</h3>

<p>Xcode 6之后，重启Xcode时会提示“Load bundle”、 “Skip Bundle”，这里必须选择“Load bundle”，不然插件无法使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之如何跳到系统设置里的各种设置界面]]></title>
    <link href="http://www.superqq.com/blog/2015/12/01/jump-setting-per-page/"/>
    <updated>2015-12-01T22:12:54+08:00</updated>
    <id>http://www.superqq.com/blog/2015/12/01/jump-setting-per-page</id>
    <content type="html"><![CDATA[<p>昨天的文章<a href="http://www.superqq.com/blog/2015/11/30/jump-to-setting-wifi/">《iOS开发之如何跳到系统设置里的WiFi界面》</a>介绍了如何从APP里跳到WiFi设置界面，很多朋友非常喜欢这样的小功能，还有朋友正想做这个功能刚好看见啦！</p>

<h2>跳到更多设置界面</h2>

<p>除了跳到WiFi设置界面，能不能跳到其他的设置界面呢？比如：定位服务、FaceTime、音乐等等。都是可以的，一起来看看如何实现的！</p>

<!--more-->


<h2>定位服务</h2>

<p>定位服务有很多APP都有，如果用户关闭了定位，那么，我们在APP里面可以提示用户打开定位服务。点击到设置界面设置，直接跳到定位服务设置界面。代码如下：</p>

<pre><code>//定位服务设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=LOCATION_SERVICES"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<p>这样就可以跳到系统设置的定位服务界面啦！我们继续看几个列子。</p>

<h2>FaceTime</h2>

<pre><code>//FaceTime设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=FACETIME"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>音乐</h2>

<pre><code>//音乐设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=MUSIC"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>墙纸设置界面</h2>

<pre><code>//墙纸设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=Wallpaper"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>蓝牙设置界面</h2>

<pre><code>//蓝牙设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=Bluetooth"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
   [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>iCloud设置界面</h2>

<pre><code>//iCloud设置界面
NSURL *url = [NSURL URLWithString:@"prefs:root=CASTLE"];
if ([[UIApplication sharedApplication] canOpenURL:url]
{
   [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>参数配置</h2>

<p>看到这几个例子，大家有没有发现，想跳到哪个设置界面只需要prefs:root=后面的值即可！是的，就是这样的。</p>

<p>我在网上找到一个列表，可以跳到这些界面的参数配置：</p>

<pre><code>About — prefs:root=General&amp;path=About
Accessibility — prefs:root=General&amp;path=ACCESSIBILITY
Airplane Mode On — prefs:root=AIRPLANE_MODE
Auto-Lock — prefs:root=General&amp;path=AUTOLOCK
Brightness — prefs:root=Brightness
Bluetooth — prefs:root=General&amp;path=Bluetooth
Date &amp; Time — prefs:root=General&amp;path=DATE_AND_TIME
FaceTime — prefs:root=FACETIME
General — prefs:root=General
Keyboard — prefs:root=General&amp;path=Keyboard
iCloud — prefs:root=CASTLE
iCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP
International — prefs:root=General&amp;path=INTERNATIONAL
Location Services — prefs:root=LOCATION_SERVICES
Music — prefs:root=MUSIC
Music Equalizer — prefs:root=MUSIC&amp;path=EQ
Music Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimit
Network — prefs:root=General&amp;path=Network
Nike + iPod — prefs:root=NIKE_PLUS_IPOD
Notes — prefs:root=NOTES
Notification — prefs:root=NOTIFICATIONS_ID
Phone — prefs:root=Phone
Photos — prefs:root=Photos
Profile — prefs:root=General&amp;path=ManagedConfigurationList
Reset — prefs:root=General&amp;path=Reset
Safari — prefs:root=Safari
Siri — prefs:root=General&amp;path=Assistant
Sounds — prefs:root=Sounds
Software Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK
Store — prefs:root=STORE
Twitter — prefs:root=TWITTER
Usage — prefs:root=General&amp;path=USAGE
VPN — prefs:root=General&amp;path=Network/VPN
Wallpaper — prefs:root=Wallpaper
Wi-Fi — prefs:root=WIFI
</code></pre>

<p>大家可以根据自己的需求，跳到不同的设置界面。如果你喜欢这篇文章的话，欢迎分享给更多的朋友，也可以收藏起来，以备不时之需！</p>

<p><a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之如何跳到系统设置里的WiFi界面]]></title>
    <link href="http://www.superqq.com/blog/2015/11/30/jump-to-setting-wifi/"/>
    <updated>2015-11-30T22:14:58+08:00</updated>
    <id>http://www.superqq.com/blog/2015/11/30/jump-to-setting-wifi</id>
    <content type="html"><![CDATA[<p>之前以为，苹果不支持直接从应用跳到系统设置里的WiFi界面。后来发现，这个小功能是可以实现的，而且实现起来并不麻烦。让我们一起来看看吧！</p>

<h2>需求</h2>

<p>从应用跳到系统设置里的WiFi界面有这个需求存在吗？答案是肯定的。比如以下两个例子：</p>

<p>在没有网的状态下，你可能想提醒用户去设置界面连接WiFi。如果不能跳到WiFi界面，只能在APP里面做出文字提示。这样很多小白用户可能不会看提示，只会觉得APP没有做好。</p>

<p>还有一种情况，做智能家居的APP，智能硬件设备自带WiFi（局域网）。如果用户没有连接设备的WiFi进入APP时，需要提示用户去设置界面连接WiFi。</p>

<p>以上这两种情况只是举个例子，这个小功能的用处还是很多的，大家可以自行探索。</p>

<!--more-->


<h2>实现</h2>

<h3>info里面设置</h3>

<p>在项目中的info.plist中添加 URL types 并设置一项URL Schemes为prefs，如下图：</p>

<p><img src="http://images.90159.com/12/wifi1.png" alt="wifi1" /></p>

<h3>实现代码</h3>

<pre><code>NSURL *url = [NSURL URLWithString:@"prefs:root=WIFI"];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h2>代码已上传iOSStrongDemo</h2>

<p>代码已经push到<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>，大家可以clone下来测试一下。</p>

<p>我在这里抛砖迎玉，大家还想跳到系统设置的什么界面，可以评论留言告诉我，或者大家动手来实现更多的跳转功能！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一组功能丰富的iOS组件:YYKit]]></title>
    <link href="http://www.superqq.com/blog/2015/11/27/ios-rich-components-yykit/"/>
    <updated>2015-11-27T23:27:37+08:00</updated>
    <id>http://www.superqq.com/blog/2015/11/27/ios-rich-components-yykit</id>
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/ibireme/YYKit">https://github.com/ibireme/YYKit</a></p>

<h1>中文介绍</h1>

<p>YYKit 是一组庞大、功能丰富的 iOS 组件。</p>

<p>为了尽量复用代码，这个项目中的某些组件之间有比较强的依赖关系。为了方便其他开发者使用，我从中拆分出以下独立组件：</p>

<ul>
<li><a href="https://github.com/ibireme/YYModel">YYModel</a> — 高性能的 iOS JSON 模型框架。</li>
<li><a href="https://github.com/ibireme/YYCache">YYCache</a> — 高性能的 iOS 缓存框架。</li>
<li><a href="https://github.com/ibireme/YYImage">YYImage</a> — 功能强大的 iOS 图像框架。</li>
<li><a href="https://github.com/ibireme/YYWebImage">YYWebImage</a> — 高性能的 iOS 异步图像加载框架。</li>
<li><a href="https://github.com/ibireme/YYText">YYText</a> — 功能强大的 iOS 富文本框架。</li>
<li></li>
<li><a href="https://github.com/ibireme/YYKeyboardManager">YYKeyboardManager</a> — iOS 键盘监听管理工具。</li>
<li><a href="https://github.com/ibireme/YYDispatchQueuePool">YYDispatchQueuePool</a> — iOS 全局并发队列管理工具。</li>
<li><a href="https://github.com/ibireme/YYAsyncLayer">YYAsyncLayer</a> — iOS 异步绘制与显示的工具。</li>
<li><a href="https://github.com/ibireme/YYCategories">YYCategories</a> — 功能丰富的 Category 类型工具库。</li>
</ul>


<!--more-->


<h1>演示项目</h1>

<p>查看并运行 <code>Demo/YYKitDemo.xcodeproj</code></p>

<p><img src="https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/twitter.png" width="320"><br/>
<img src="https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/weibo.png" width="320"> <img src="https://raw.github.com/ibireme/YYKit/master/Demo/Snapshots/weibo_compose.png" width="320"></p>

<h1>安装</h1>

<h3>CocoaPods</h3>

<ol>
<li>在 Podfile 中添加  <code>pod "YYKit"</code>。</li>
<li>执行 <code>pod install</code> 或 <code>pod update</code>。</li>
<li>导入 \&lt;YYKit/YYKit.h>。</li>
</ol>


<h3>Carthage</h3>

<ol>
<li>在 Cartfile 中添加 <code>github "ibireme/YYKit"</code>。</li>
<li>执行 <code>carthage update --platform ios</code> 并将生成的 framework 添加到你的工程。</li>
<li>导入 \&lt;YYKit/YYKit.h>。</li>
<li>注意: carthage framework 并没有包含 webp 组件。如果你需要支持 webp，可以用 CocoaPods 安装，或者手动安装。</li>
</ol>


<h3>手动安装</h3>

<ol>
<li>下载 YYKit 文件夹内的所有内容。</li>
<li>将 YYKit 内的源文件添加(拖放)到你的工程。</li>
<li>为 <code>NSObject+YYAddForARC.m</code> 和 <code>NSThread+YYAdd.m</code> 添加编译参数 <code>-fno-objc-arc</code>。</li>
<li>链接以下 frameworks:

<ul>
<li>UIKit</li>
<li>CoreFoundation</li>
<li>CoreText</li>
<li>CoreGraphics</li>
<li>CoreImage</li>
<li>QuartzCore</li>
<li>ImageIO</li>
<li>AssetsLibrary</li>
<li>Accelerate</li>
<li>MobileCoreServices</li>
<li>SystemConfiguration</li>
<li>sqlite3</li>
<li>libz</li>
</ul>
</li>
<li>如果你需要支持 WebP，可以将 <code>Vendor/WebP.framework</code>(静态库) 加入你的工程。</li>
<li>导入 <code>YYKit.h</code>。</li>
</ol>


<h1>文档</h1>

<p>你可以在 <a href="http://cocoadocs.org/docsets/YYKit/">CocoaDocs</a> 查看在线 API 文档，也可以用 <a href="https://github.com/tomaz/appledoc">appledoc</a> 本地生成文档。</p>

<h1>系统要求</h1>

<p>该项目最低支持 iOS 6.0。</p>

<h1>关于</h1>

<p>我希望调用 API 时，有着和调用系统自带 API 一样的体验，所以我并没有为 Category 方法添加前缀。我已经用工具扫描过这个项目中的 API，确保没有对系统 API 产生影响。我知道没有前缀的 Category 可能会带来麻烦，所以如果你只需要其中部分功能，请先查看上面那些拆分出来的子项目。</p>

<h1>许可证</h1>

<p>YYKit 使用 MIT 许可证，详情见 LICENSE 文件。</p>
]]></content>
  </entry>
  
</feed>
