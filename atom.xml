<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刚刚在线]]></title>
  <link href="http://www.superqq.com/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-09-29T15:09:51+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[报错：You Must Rebuild It With Bitcode Enabled (Xcode Setting ENABLE_BITCODE)（解决方案）]]></title>
    <link href="http://www.superqq.com/blog/2015/09/29/rebuild-bitcode-enable/"/>
    <updated>2015-09-29T15:08:00+08:00</updated>
    <id>http://www.superqq.com/blog/2015/09/29/rebuild-bitcode-enable</id>
    <content type="html"><![CDATA[<p>马上就要十一放假啦！大家是不是都很期待这一天到来，哈哈。相信有不少人跟我一样，早就请三天假回家了吧。希望大家十一都玩的开心噢！</p>

<p>今天在家里闲来无事，我就用Xcode7.0建一个项目。然后，引入一个第三方库，竟然运行不起来。报错如下：</p>

<p><img src="http://images.90159.com/09/error1.png" alt="1" /></p>

<p>我把错误提示复制出来，方便大家搜索：</p>

<pre><code>ld: 'XXX' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>

<p>Xcode7.0默认是开启Enable Bitcode的，如果你导入的一些第三方库在编译的时候没有Enable Bitcode 的话，就会导致报错。</p>

<p>解决方法有两种：</p>

<p>方法一：使用Enable Bitcode的第三方库</p>

<p>方法二：将工程中的Enable Bitcode设置为NO</p>

<p><img src="http://images.90159.com/09/error2.png" alt="1" /></p>

<p>如果你有更好的解决方法，记得告诉我噢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有关 XcodeGhost 的问题和解答]]></title>
    <link href="http://www.superqq.com/blog/2015/09/24/apple-xcodeghost-answer/"/>
    <updated>2015-09-24T00:09:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/09/24/apple-xcodeghost-answer</id>
    <content type="html"><![CDATA[<p><strong>我听说了由 XcodeGhost 开发的恶意 app — 这是怎么回事？</strong></p>

<p>我们一直建议开发者使用由我们提供的免费、安全的工具，包括 Xcode，从而确保他们为 App Store 的用户创造出安全的 app。一些开发者下载了已被恶意软件感染的盗版 Xcode，由此开发的 app 也同样受到感染。</p>

<p>Apple 特意使用诸如 Gatekeeper 等技术，以防止安装从非 App Store 渠道下载的应用程序，和 / 或安装包括 Xcode 在内的未签名的应用程序。当开发者为了能安装类似 XcodeGhost 等恶意程序时，这些保护措施会被刻意地禁用。</p>

<p>作为 Apple 向开发者提供的业界先进工具之一，以下措施可以确保软件未被篡改：</p>

<pre><code>Xcode app 有 Apple 的代码签名。
从 Mac App Store 下载 Xcode 时，开发者的电脑系统自动对 Xcode 的代码签名会进行检查和验证。
从 Apple Developer Program 网站下载 Xcode 时，只要 Gatekeeper 没有被禁用，默认开发者的电脑系统对 Xcode 代码签名自动进行检查和验证。
</code></pre>

<h3>为什么开发者会不顾用户的安全下载盗版软件？</h3>

<p>为了更快下载我们的开发者工具，开发者有时会从其他非 Apple 站点搜寻。</p>

<h3>这会对我有什么影响吗？如何得知我的设备是否受到了影响？</h3>

<p>我们目前没有任何信息表明这些恶意软件与任何恶意事件相关，也没有信息表明这些软件被使用在传播任何个人身份信息的用途上。</p>

<p>我们目前没有看到任何客户个人身份信息受到影响，而且代码无法通过用户身份请求来获取 iCloud 或其他服务的密码。</p>

<p>只要一经发现这些 app 有可能通过恶意代码开发，我们就对其进行下架处理。开发者们正在快速更新他们的 app，以便用户使用。</p>

<!--more-->


<p>恶意代码只能提供一些基本信息，比如 app 和一般系统信息。</p>

<h3>从 Apps Store 下载 app 是否安全？</h3>

<p>我们已将由该盗版软件开发的 apps 从 App Store 中撤下，并拦截了通过该恶意软件开发的新 app 进入 App Store。</p>

<p>我们正与开发者紧密协作，以确保受到影响的 app 尽快回到 App Store 供用户使用。</p>

<p>我们将在支持页面上列出受此影响的前 25 个 apps，方便用户验证他们是否已将这些 app 更新到了最新版本。</p>

<p>用户还将会收到更多信息，以便了解他们下载的某 app 是否会存在问题。一旦开发者更新了他们的 app，用户可以通过在设备上运行更新解决存在的问题。</p>

<p>我们正努力让中国的开发者可以用更快的速度下载 Xcode 测试版本。开发者也可以通过 developer.apple.com 列出的步骤来验证他们的 Xcode 是否被篡改过。</p>

<h2>XcodeGhost Q&amp;A</h2>

<p><strong>I’ve heard about malicious apps created by XcodeGhost — what does this mean?</strong></p>

<p>We always recommend developers using the free, secure tools we provide them — including Xcode — to ensure they’re creating the most secure apps for App Store customers. Some developers downloaded counterfeit versions of Xcode that have been infected with malware and created apps that were just as infected.</p>

<p>Apple incorporates technologies like Gatekeeper expressly to prevent non-App Store and/or unsigned versions of programs, including Xcode, from being installed. Those protections had to have been deliberately disabled by the developer for something like XcodeGhost to successfully install.</p>

<p>As part of providing developers the industry&rsquo;s most advanced tools, Apple provides developers the following checks to ensure software is untampered:</p>

<pre><code>The Xcode app is code-signed by Apple.
When you download Xcode from the Mac App Store the code signature for Xcode is automatically checked and validated by your system.
When you download Xcode from the Apple Developer Program web site, the code signature for Xcode is automatically checked and validated by your system by default as long as Gatekeeper is not disabled.
</code></pre>

<h3>Why would a developer put customers at risk by downloading counterfeit software?</h3>

<p>Sometimes developers search for our tools on other, non-Apple sites in an effort to find faster downloads of developer tools.</p>

<h3>How does this affect me? How do I know if my device has been compromised?</h3>

<p>We have no information to suggest that the malware has been used to do anything malicious or that this exploit would have delivered any personally identifiable information had it been used.</p>

<p>We’re not aware of personally identifiable customer data being impacted and the code also did not have the ability to request customer credentials to gain iCloud and other service passwords.</p>

<p>As soon as we recognized these apps were using potentially malicious code we took them down. Developers are quickly updating their apps for users.</p>

<p>Malicious code could only have been able to deliver some general information such as the apps and general system information.</p>

<h3>Is it safe for me to download apps from App Store?</h3>

<p>We have removed the apps from the App Store that we know have been created with this counterfeit software and are blocking submissions of new apps that contain this malware from entering the App Store.</p>

<p>We’re working closely with developers to get impacted apps back on the App Store as quickly as possible for customers to enjoy.</p>

<p>A list of the top 25 most popular apps impacted will be listed soon so users can easily verify if they have downloaded the latest versions of these apps. After the top 25 impacted apps, the number of impacted users drops significantly.</p>

<p>Customers will be receiving more information letting them know if they’ve downloaded an app/apps that could have been compromised. Once a developer updates their app, that will fix the issue on the user’s device once they apply that update.</p>

<p>We’re working to make it faster for developers in China to download Xcode betas. To verify that their version of Xcode has not been altered, they can take the following steps posted at &lt;developer.apple.com>.</p>

<p>文章来自：<a href="http://www.apple.com/cn/xcodeghost/">http://www.apple.com/cn/xcodeghost/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员月入过万已经不再是神话]]></title>
    <link href="http://www.superqq.com/blog/2015/09/02/manicure-salary-heigher-programmer/"/>
    <updated>2015-09-02T11:15:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/09/02/manicure-salary-heigher-programmer</id>
    <content type="html"><![CDATA[<h2>创业英雄汇</h2>

<p>最近看了CCTV 2 财经频道的《创业英雄汇》，可能有人还没有看过这个节目。简单介绍一下：《CCTV中国青年创业实战公开课—创业英雄汇》这是一档全新模式、极致化表达的新型创业服务节目。播出时段：财经频道 周五22：10～23：10。建议有创业想法的童鞋，可以好好看一下，说不定可以激发一些灵感！</p>

<p>我看的这一期是20150821。创业导师分别是聚美优品的CEO陈欧和英才杂志社的社长宋立新。陈欧最经典的一句话应该就是：我是陈欧，我为自己代言！之前，没有认真了解过陈欧，只是简答的看了一下关于陈欧的创业故事。通过这次《创业英雄汇》节目，感觉的陈欧确实挺有个人魅力。</p>

<h2>美甲师 VS 程序员</h2>

<p>第一位上台的创业者叫于明山，一位大叔界别的创业者。他的项目是“美道家”，致力于打造专业上门美容服务平台。服务对线就是女性，美容师也都是女性。美女美容师上门服务，听起来就是一个不错的项目。（我们这些屌丝程序员，估计享受不到这种服务啦！）</p>

<p>在导师考核环节，陈欧大概了解了一下“美道家”的美容师上的收入大概是多少。随后，陈欧说：一个好的美甲师，或者一个美容师，挣的钱甚至比一个程序员还高。我前一段时间听说有一个美甲师，甚至挣到五万到七万，这基本上是一个CEO的工资了。</p>

<p>一个美甲师能月入五万到七万，那还干什么程序员啊。想想就觉得还是程序员苦逼，以后再也不说程序员的工资高了。都不好意思说了，人家美甲师就比你高，而且人家还是自由职业者。</p>

<p>前段时间，听人说他们做优步一月轻轻松松月入五六万。优步每个月做够规定的单数，额外奖励7000元。经常在新闻上看到，哪里的司机刷单也你能月入多少多少。（不公平啊！）</p>

<h2>出路在哪里？</h2>

<p>真的是三百六十行，行行出状元啊！作为程序员，三四年工作经验，大概也就是一两万的工资吧。也许你的工资很高，但是加班肯定也不少。</p>

<p>在这个全名创业的浪潮下，我们程序员不能再闲着了。有想法就去干吧，说不定能闯出一片天地。</p>

<p>明天要不要辞职呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITablView上下滑动控制底部按钮的出现和消失]]></title>
    <link href="http://www.superqq.com/blog/2015/09/01/uitablview-up-down-slide/"/>
    <updated>2015-09-01T00:49:19+08:00</updated>
    <id>http://www.superqq.com/blog/2015/09/01/uitablview-up-down-slide</id>
    <content type="html"><![CDATA[<p>今天我们一起来做一个好玩的功能，通过UITablView上下滑动控制底部按钮的出现和消失。先来看看效果：</p>

<p><img src="http://images.90159.com/09/bottombutton.gif" alt="1" /></p>

<h2>需求分析</h2>

<p>要做一个这样的功能，对你来说应该不难，实现的方式也有很多。我们来分析一下要实现那几个小功能点：</p>

<ul>
<li>UITablView向上滑动，底部按钮消失</li>
<li>UITablView向下滑动，底部按钮出现</li>
<li>UITablView滑动到底部，底部按钮出现</li>
</ul>


<p>主要就是这三个小功能点。那么很简单，我们只需要判断UITablView是往上滑动，还是往下滑动，以及判断UITablView是否滑动到底部即可。</p>

<h2>代码实现</h2>

<h3>创建一个底部按钮</h3>

<pre><code>self.bottomButton = [UIButton buttonWithType:UIButtonTypeCustom];
self.bottomButton.frame = CGRectMake(SCREEN.width / 2 - 25, SCREEN.height - 50, 50, 50);
[self.bottomButton setBackgroundImage:[UIImage imageNamed:@"bottom"] forState:UIControlStateNormal];
[self.view addSubview:self.bottomButton];
</code></pre>

<p>既然是控制按钮的出现和消失，首先要创建一个底部按钮。SCREEN是个宏定义：</p>

<pre><code>#define SCREEN [UIScreen mainScreen].bounds.size
</code></pre>

<h3>判断UITablView上下滑动</h3>

<p>我们都知道，UITablView是继承UIScrollView的。所以UIScrollView的代理方法在UITablView是可以使用的。要判断UITablView上下滑动，我们需要实现UIScrollView的scrollViewDidScroll:代理方法：</p>

<pre><code>-(void)scrollViewDidScroll:(UIScrollView *)scrollView{
    if (scrollView.contentOffset.y &gt; self.offsetY &amp;&amp; scrollView.contentOffset.y &gt; 0) {//向上滑动

    }else if (scrollView.contentOffset.y &lt; self.offsetY ){//向上滑动

    }
    self.offsetY = scrollView.contentOffset.y;//将当前位移变成缓存位移
}
</code></pre>

<!--more-->


<h3>判断UITablView滑动到底部</h3>

<p>也是在scrollViewDidScroll:这个方法里面判断：</p>

<pre><code> //判断滑动到底部
if (scrollView.contentOffset.y == scrollView.contentSize.height - self.tableView.frame.size.height) {

}
</code></pre>

<h3>按钮消失和出现</h3>

<pre><code>//按钮消失
[UIView transitionWithView:self.bottomButton duration:0.1 options:UIViewAnimationOptionTransitionNone animations:^{
            self.bottomButton.frame = CGRectMake(SCREEN.width / 2 - 25, SCREEN.height, 50, 50);
        } completion:NULL];

//按钮出现        
[UIView transitionWithView:self.bottomButton duration:0.1 options:UIViewAnimationOptionTransitionNone animations:^{
  self.bottomButton.frame = CGRectMake(SCREEN.width / 2 - 25, SCREEN.height - 50, 50, 50);
  } completion:NULL];
</code></pre>

<p>按钮消失其实就是移除屏幕，这里我加了一个旋转的过度动画，需要什么动画效果都可以选择。按钮出现就是把按钮的frame设置到初始化时候的frame即可。</p>

<p>这样我们就实现了通过UITablView上下滑动控制底部按钮的出现和消失。代码我已经上传的github，下载地址还是<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>

<p>如果你觉得文章还不错，请分享给你的同学和朋友，欢迎推荐他们关注iOS开发：iOSDevTip 公众号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2012年MacBook更换SSD固态硬盘和16G内存条]]></title>
    <link href="http://www.superqq.com/blog/2015/08/27/macbook-replace-ssd-solid-state/"/>
    <updated>2015-08-27T10:42:34+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/27/macbook-replace-ssd-solid-state</id>
    <content type="html"><![CDATA[<h2>我的2012年MacBook</h2>

<p>我的电脑是2012年的MacBook Pro（13-inch, 2012 年中），是那种比较厚的一款。当时买的时候官网，标价是8888元。我是在新蛋网上买的，新蛋网有活动只需要7888元即可购买。</p>

<p>电脑配置：处理器是2.5 GHz Intel Core i5，内存是两个2G，也就是4G。配置在现在来看，那简直是太Low了。但是对于当时一直用黑苹果的我来说，这就是圣物。贴个图给大家看看：</p>

<p><img src="http://images.90159.com/08/ssdsave1.jpg" alt="ssdsave1" /></p>

<p>这就是比较厚的13-inch的电脑，看起来还是比较笨重的。我用电脑还是比较爱惜的，一直保护的很好。基本上没有什么损伤。</p>

<p>但是，随之使用年限的增长，电脑反应速度越来越慢了。打开xcode、火狐、Chrome、印象比较、QQ等几个软件，电脑反应速度明显很慢。</p>

<p>有时候调试个程序，反应好半天。想想就是一件痛苦的事情，大好时光都浪费在等电脑反应上。浏览器也经常卡死，有时候编辑好的东西没来得及保持，浏览器突然就没有反应了。</p>

<p>总之，电脑性能差的一塌糊涂。最近听朋友说换个SSD固态硬盘电脑反应会快很多，如果是2012年的电脑还可以升级内存。</p>

<p>本来我是准备把这个笔记本处理掉，再买一个配置好一些的笔记本。听朋友这样一说，觉得还是自己买个SSD固态硬盘换上，比较换算。</p>

<h2>购买SSD固态硬盘和内存条</h2>

<p>说换就换吧，于是在京东和淘宝上查了查，品类太多看的我都晕晕乎乎的。网上买东西其实我一点都不喜欢，选来选去不知道选哪一个好。</p>

<p>最后，在朋友的推荐下。我买的是牌子是创见（Transcend）240G的SSD固态硬盘，价格是999元。内存条我看了苹果官网的介绍，说的是MacBook Pro（13 英寸，2012 年中）最大支持8G内存。但是网上有人说，他们装了16G的，没有什么兼容上的问题。所以我也买了金士顿苹果专用内存条两个8G，一共638元。</p>

<p><img src="http://images.90159.com/08/ssdsave2.jpg" alt="ssdsave1" /></p>

<p>我不是来给创见和金士顿大广告的，只是告诉大家我用的是什么。收到货之后，夜里下班回到家里，就开始折腾我的电脑。</p>

<!--more-->


<h2>替换SSD固态硬盘</h2>

<p>拆开创见的SSD固态硬盘，里面自带的有小螺丝刀，还有硬盘的外接壳。我先把硬盘装进外接壳，然后连接电脑。可以识别出来，此时这就是一个移动硬盘。</p>

<p>我想把原来电脑的资料通过磁盘工具恢复到新买的创见硬盘上，但是发现我电脑里面存的资料已经远大于240G。于是，我想先把硬盘换上吧。以后慢慢把有用的资料拷贝过来。</p>

<p>我简单说一下替换SSD固态硬盘的步骤吧</p>

<h3>拆卸后盖</h3>

<p>用创见送的螺丝刀，把后盖上所有的螺丝都卸掉。MacBook后盖上有10个螺丝，不知道苹果设计是个有何寓意，难道是十全十美的意思，我只是猜测的。</p>

<h3>取出原有硬盘</h3>

<p>电脑后盖卸掉之后，找到硬盘的位置。在硬盘的侧面有一个固定的小架子，上面有两个小螺丝。卸掉这两个小螺丝之后，拿掉小架子。慢慢拽硬盘上预留的带子，拔掉硬盘前面的线，一定要慢慢的。</p>

<h3>安装SSD固态硬盘</h3>

<p>既然可以取出来，那么安装的方法也很简单。接头插好，把硬盘放入正确的位置。最后，别忘了用小架子把硬盘给固定住。</p>

<p>更换SSD固态硬盘没有什么难度。但是换内存条的时候，还是有一些小难度的。可能是因为我很少或者说从来都没有接触过的原因。</p>

<h2>替换内存条</h2>

<p>我没有看网上替换内存跳的教程，因为我觉得应该没有什么难度。苹果电脑的内存条紧挨着电池的位置，我看到内存条上面也有个小架子。于是，我很熟练的把上面的两个螺丝卸掉，然后试图去拿掉小架子，这个时候我发现根本拿不动。</p>

<p>再仔细看看，发现内存条两侧分别有一个固定的小条子。上下拉动没有反应。直接去口内存条也扣不掉。既然拿不掉也不能硬拿，搜了一下苹果官方的教程MacBook Pro：如何拆卸或安装内存<a href="https://support.apple.com/zh-cn/HT1270" target="_blank" title=“https://support.apple.com/zh-cn/HT1270”><a href="https://support.apple.com/zh-cn/HT1270">https://support.apple.com/zh-cn/HT1270</a></a></p>

<p>步骤很详细，安装苹果官方的教程，我把两个内存条替换好了。别高兴太早，事情远没有想象的那么简单。新装的SSD固态硬盘是没有系统的。</p>

<h2>装系统</h2>

<p>我对装系统不是特别了解，一开始我尝试直接启动电脑，同时按住command+option+r会进入苹果官方的安装界面。这个需要下驱动，还需要下载苹果系统，整个过程估计没有个大半条肯定是搞不定的。</p>

<p>接着尝试，把老硬盘的系统恢复的新的SSD固态硬盘上。由于老硬盘里面的东西比较多，于是我进入老硬盘的系统删了很多资料。让他能够小于240G。然后对老硬盘进行分区，试了很多次，分区一直失败。最终不得不放弃这个方法。</p>

<p>最后一招，做个启动盘。这里有教程<a href="http://bbs.feng.com/read-htm-tid-7057977.html" target="_blank" title=“http://bbs.feng.com/read-htm-tid-7057977.html”><a href="http://bbs.feng.com/read-htm-tid-7057977.html">http://bbs.feng.com/read-htm-tid-7057977.html</a></a></p>

<p>有5个多G，幸亏我家是100M得光纤，下载速度还挺快。下载完成之后，我把新的SSD固态硬盘分了一个10几G的空间出来，做启动盘使用。</p>

<p>利用磁盘工具的恢复功能，把你下载的系统恢复到新的分区上。记住：磁盘源选择你下载的系统，目的磁盘是新的分区。</p>

<p>完成之后，重启电脑，接下来都是傻瓜式操作。用了大概半个小时左右才把系统装好。这个时候看看，抬头看看电脑右上角的时间，发现已经2点了。
试用一下</p>

<p>花了一两千块和几个小时的时间折腾出来的电脑反应到底怎么样呢？其实我也迫不及待看一看，完全没有困意。简单使用了一下：速度确实很快，基本上没有遇到卡的情况。基本上达到我的要求，不枉费我花得钱和时间。</p>

<p>前面说MacBook Pro（13 英寸，2012 年中）最大支持8G内存，我特意看了一下内存：</p>

<p><img src="http://images.90159.com/08/ssdsave3.jpg" alt="ssdsave1" /></p>

<p>在看看存储：</p>

<p><img src="http://images.90159.com/08/ssdsave4.jpg" alt="ssdsave1" /></p>

<p>终于搞定了，这下子电脑速度提高了不少，也节省了买电脑的钱，真心不错！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVFoundation和 GPUImage初探]]></title>
    <link href="http://www.superqq.com/blog/2015/08/24/avfoundation-gpuimage-find/"/>
    <updated>2015-08-24T11:21:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/24/avfoundation-gpuimage-find</id>
    <content type="html"><![CDATA[<p>文章来自：<a href="http://vonglo.me/2014/08/24/AVFoundation%E5%92%8C-GPUImage%E5%88%9D%E6%8E%A2/" target="_blank" title=“AVFoundation和 GPUImage初探”>AVFoundation和 GPUImage初探</a></p>

<p>最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。</p>

<h3>AVFoundation的一些基本概念</h3>

<p>根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。</p>

<p><img src="http://images.90159.com/08/frameworksBlockDiagram_2x.png" alt="1" /></p>

<h4>相关类</h4>

<ul>
<li><code>AVAsset</code></li>
<li><code>AVAssetTrack</code></li>
<li><code>AVComposition</code></li>
<li><code>AVVideoComposition</code></li>
<li><code>AVAudioMix</code></li>
<li><code>AVMutableAudioMixInputParameter</code></li>
<li><code>AVMutableVideoCompositionInstrution</code></li>
<li><code>AVMutableVideoCompositionLayerInstrution</code></li>
</ul>


<p>简单的播放可以使用MPMoviePlayerController或者MPMovieViewController就行,简单的录
制可以直接使用UIImagePickerController。同样简单的声音播放直接使用AVAudioPlayer，简单的录制直接使用AVAduioRecorder。如果你想要有更多的操作，可使用各种复杂的方式来控制播放，比如在同一时刻为同一个asset的不同片段使用不同的分辨率渲染，playitem来管理asset的呈现状态和方式,playitemtrack管理asset中的轨道（track）状态。</p>

<!--more-->


<p>在AVFoudation框架中最核心的类就是AVAsset，他是由一系列的媒体数据组成的，包括但不限于:时间、大小(size)、标题、字幕等。其中每一个单独的媒体数据称为轨道(track)。同样剪辑操作中，AVMutableComposition是一个核心类。</p>

<p><img src="http://images.90159.com/08/asset-track.png" alt="4" /></p>

<p>这里又一个重要的东西就是CMTime,它是一个结构体，定义如下:</p>

<p>typedef struct
{
    CMTimeValue    value;      <br/>
    CMTimeScale    timescale;  <br/>
    CMTimeFlags    flags;      <br/>
    CMTimeEpoch    epoch;      <br/>
} CMTime;
通常时间是等于value/timescale的，所以两个有相同时间的CMTime它们的timescale并不一定相同。关于更多CMTime的内容可以看<a href="https://developer.apple.com/library/ios/documentation/CoreMedia/Reference/CMTime/Reference/reference.html#//apple_ref/doc/uid/TP40009748">这里</a>。</p>

<h3>进阶</h3>

<h4>视频的录制</h4>

<p>这里用的是系统原生录制,关于录制通常用到的几个类就是AVCaptureDevice、
AVCaptureSession、AVCaptureDeviceInput、AVCaptureOutput,同样，来看一张图。</p>

<p><img src="http://images.90159.com/08/capture.png" alt="2" /></p>

<p>一般来说，如果你想修改视频的相关信息，如拍摄地点等，可以拿到output的metadata来修改。大致代码如下:</p>

<pre><code>NSMutableArray *array = [output.metadta mutableCopy];
AVMutableMetadataItem *item = [[AVMutableMetadataItem alloc] init];
item.keyspace = ...;
item.key = ...;
item.value = ...;
[array addObject:item];
output.metadata = array;
</code></pre>

<p>如果录制时候想要得到指定的视频size必须先指定分辨率，像这样</p>

<pre><code>if ([session canSetSessionPreset:AVCaptureSessionPreset640x480]){ 

    session.sessionPreset = AVCaptureSessionPreset640x480;
}
else {
    //设置失败
}
</code></pre>

<p>切换摄像头或其他输入源必须在beginConfiguration和commitConfiguration之间来处理，大致是这样</p>

<pre><code>[session beginConfiguration];
//移除某个输入源
//再添加某个输入源
//再为新添加的输入源进行必要的相关设置
//...其他操作
[session commitConfiguration];
</code></pre>

<p>如果想对实时视频帧进行相关的渲染操作,通过 setSampleBufferDelegate:queue:方法来为output设置代理，同时必须指定queue，代理方法将会在这些queue上面被调用。可以在自己的类里面实现AVCaptureVideoDataOutput的协议方法,通过实现
captureOutput:didOutputSampleBuffer:fromConnection:来拿到视频的每一帧，默认情况下这些视频帧会被用最有效的格式来输出到output,当然也可以在拍摄之前就为output进行相关设置。</p>

<pre><code>AVCaptureVideoDataOutput *videoDataOutput = [AVCaptureVideoDataOutput new];
NSDictionary *newSettings =@{ (NSString *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) };
videoDataOutput.videoSettings = newSettings;
</code></pre>

<p>说了这么多，感觉很虚，还是直接上代码，将以上部分衔接起来</p>

<pre><code>//自定义方法，小演示只添加了视频，没有添加声音，添加声音类似
- (void)yourCustomMethodName{
    AVCaptureSession *session = [[AVCaptureSession alloc] init];
    if ([session canSetSessionPreset:AVCaptureSessionPreset640x480]){ 

            session.sessionPreset = AVCaptureSessionPreset640x480;
        }
        else {
            //设置失败
        }
    AVCaptureDevice *device =
            [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];

    NSError *error = nil;
    AVCaptureDeviceInput *input =
            [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error];
    if (!input) {
        // Handle the error appropriately.
    }
    if(session canAddInput:input){
        [session addInput:input];
    }
    AVCaptureVideoDataOutput *output = [[AVCaptureVideoDataOutput alloc] init];
    if(session canAddOutput:output){
        [session addOutput:output];
    }
    output.videoSettings =@{ (NSString *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) };
    //设置帧率(FPS),每秒15帧
    output.minFrameDuration = CMTimeMake(1, 15);
    dispatch_queue_t queue = dispatch_queue_create("CustomQueue", NULL);
    [output setSampleBufferDelegate:self queue:queue];
    dispatch_release(queue)
    NSString *mediaType = AVMediaTypeVideo;

 //用来显示录制的实时画面
    AVCaptureVideoPreviewLayer *captureVideoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:session];
    [self.view.layer addSublayer:captureVideoPreviewLayer];

    //用户是否允许启用摄像头
    [AVCaptureDevice requestAccessForMediaType:mediaType completionHandler:^(BOOL granted) {
        if (granted)
        {
            //Granted access to mediaType
            [self setDeviceAuthorized:YES];
            [session startRunning];
        }
        else
        {
            //Not granted access to mediaType
            dispatch_async(dispatch_get_main_queue(), ^{
            [[[UIAlertView alloc] initWithTitle:@"AVCam!"
                                        message:@"AVCam doesn't have permission to use Camera, please change privacy settings"
                                       delegate:self
                              cancelButtonTitle:@"OK"
                              otherButtonTitles:nil] show];
                    [self setDeviceAuthorized:NO];
            });
        }
    }];
}

//协议方法,获取每一帧，将每一帧转换成图片，你也可以进行其他的渲染操作
- (void)captureOutput:(AVCaptureOutput *)captureOutput
         didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer
         fromConnection:(AVCaptureConnection *)connection {

    UIImage *image = imageFromSampleBuffer(sampleBuffer);
}
</code></pre>

<p>上面演示了如何取得每一帧实时画面,如果想要直接存成视频可使用AVCaptureMovieFileOutput,如下</p>

<pre><code>AVCaptureMovieFileOutput *movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];
NSURL *fileURL = ...;    //存放位置
//指定代理
[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:delete];
//也可以为其指定outputSettings
同样代理必须实现协议方法captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:,
</code></pre>

<p>当然还有其他各种具体的设置，如对焦、曝光、闪光灯以及白平衡等等均可以通过KVO来设置，每次设置前都加一个判断，是否支持指定模式,在这里不做详细叙述了,这里你可以看到<a href="https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/04_MediaCapture.html#//apple_ref/doc/uid/TP40010188-CH5-SW14">更多</a>。</p>

<h4>视频的剪辑</h4>

<p>视频的剪辑包括但不限于:裁剪、旋转(改变transform)、添加水印、添加字幕、合并等。关于剪辑，无非就是取出视频中的轨道(视频和音频),然后对轨道进行一系列的操作变可以得到各种想要的效果。首先我们先来看下面一张图</p>

<p><img src="http://images.90159.com/08/composition.png" alt="3" /></p>

<p>AVMutableComposition是整个视频剪辑过程中的一个核心，下面着重讲解这个类。AVMutableComposition和AVAsset一样含有多个视/音频轨道，但是更重要的是，它可以将多个AVAssetTrack合并到一起，比如在视频合并时，可以直接将多段视频拼接到一个轨道(AVMutableCompositonTrcak)，音频也一样。通过借助AVMutableVideoComposition和AVMutableAudioMix来设置每一段的视/音频的属性，从而达到想要的视听效果，比如视频切换处的淡入淡出，声音的渐变，字幕等等。
关于上图的解释:首先通过将asset里面的轨道加载到composition的各轨道，然后通过audioMix和videoComposition对某个轨道进行对应操作,设置其相关属性。其中要用到的具体方法可以参见<a href="https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/03_Editing.html#//apple_ref/doc/uid/TP40010188-CH8-SW1">这里</a>。</p>

<p>其中图中1，2，3用到的方法为</p>

<pre><code>[1]
[mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid]
[2]
[AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack];`
[3]
[AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack]
</code></pre>

<p>关于视频的剪辑的代码可以参见苹果给出的官方<a href="https://developer.apple.com/library/ios/samplecode/AVSimpleEditoriOS/Introduction/Intro.html#//apple_ref/doc/uid/DTS40012797">Demo</a>以及Raywendrich上的两篇文章<a href="http://www.raywenderlich.com/13418/how-to-play-record-edit-videos-in-ios">1</a>,<a href="http://www.raywenderlich.com/30200/avfoundation-tutorial-adding-overlays-and-animations-to-videos">2</a>。</p>

<h3>GPUImage</h3>

<p>什么?!你没听说过GPUImage?!那你赶紧去看看它的<a href="https://github.com/BradLarson/GPUImage/blob/master/README.md#overview">相关介绍</a>。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>

<h4>分段录制</h4>

<p>在使用GPUImageVideoCamera来录制的时候,可能需要分段录制,在GPUImage给出的视频录制Demo中直接只是录制一次，然而有时候需求可能是要录制多次，如果此时按照Demo的方法每次录制都要创建一个movieWriter,这样子的话每次都会在重新创建movieWriter并将它设置为videoCamera的audioEncodingTarget时候，界面都会卡顿一下，这是什么原因呢？因为videoCamera默认是不录制声音的，而每次创建movieWriter的时候都用到了movieWriter.hasAudioTrack = YES;,吊用这个之后videoCamera会自动去添加声音输入源,准备一些数据，所以这个过程会导致界面卡顿一下？这该怎么办呢？如果你有进到videoCamera的头文件去看的话你会发现这么一个方法和它的注释</p>

<pre><code>//Add audio capture to the session. Adding inputs and outputs freezes 
//the capture session momentarily, so you can use this method to add 
//the audio inputs and outputs early, if you’re going to set the 
//audioEncodingTarget later. Returns YES is the audio inputs and 
//outputs were added, or NO if they had already been added.

-(BOOL)addAudioInputsAndOutputs;
</code></pre>

<p>注释的大意是:录制的时候添加声音,添加输入源和输出源会暂时会使录制暂时卡住,所以在要使用声音的情况下要先调用该方法来防止录制被卡住。这不刚好就解决了上面的这个问题吗？所以问题就迎刃而解了,因为没看到这个,走了不少弯路,浪费了好长时间。</p>

<p>关于分段录制,可能有这么一个需求就是所有片段都是存于一个文件中而不是录制完成后将各段合并到一个视频文件中。这两个东西或许会帮到你<a href="http://blog.csdn.net/whf727/article/details/18702643">分段录制的实现</a>,<a href="https://github.com/leanlyne/GPUImageExtend">GPUImageExtend</a>。前者是基于系统的分段录制的实现,后者是GPUImageMoiveWriter的一个子类。</p>

<h4>所见即所得</h4>

<p>在录制的时候,使用GPUImageView来显示,因为给GPUImageView设置的大小是320*320的,如果不设置它的填充模式(fillMode)它是默认使用kGPUImageFillModePreserveAspectRatio即保持长宽比,其余空白处使用背景色填充,如果要设置成方形就得使用kGPUImageFillModePreserveAspectRatioAndFill,但是这个时候问题又来了假设你是用的录制分辨率是960x540,显示的画面则只会显示中间的540x540的画面,这个时候如果movieWriter的size设置为540x540,则最后保存的视频是失真的因为960被压到了540，整个画面变扁了。这个时候有两种解决方案</p>

<ul>
<li>1.使用GPUImageCropFilter,通过设置其cropRegion来裁出中间540x540部分。关于cropRegion要注意它是一个CGRect,它对坐标系做了一个归一化处理,所以让所有的取值都在0.0~1.0范围内,比如960x540裁剪至中间540x540部分则cropRegion为(0,((960-540)/2)/960,1,540/960)</li>
<li>2.改变videoComposition的perferTransfom使其只显示中间的540x540。
这样就完成了所见即所得。</li>
</ul>


<p>关于GPUImage的实时滤镜添加或给已存在的视频添加滤镜,Demo都给出了详细过程,依葫芦画瓢即可。有一点要注意的是,在一些操作完成的时候注意removeTarget,还有就是在使用movieFile来播放已存在视频并添加滤镜的时候是没有声音的,这是这个库的一个缺陷,Github上有人提了这个<a href="https://github.com/BradLarson/GPUImage/issues/458">issue</a>和<a href="https://gist.github.com/pgodino/3819907">一些解决办法</a>。同时在用movieFile处理视频的时候在切换滤镜的时候最好先cancelProcessing不然会有黑屏或卡顿现象出现。同样如果你是用老版本的GPUImage的时候,可能会遇到第一帧是红色的现象,有人提出这个issue后,作者修复了这个bug,切换到最新版的时候就不会有这种情况发生。发生这种情况的原因是视频掉帧,导致音频和视频不同步。</p>

<h3>总结</h3>

<p>AVFoundation还是有很多东西去做深层次的挖掘,GPUImage也是一样,有了这个强大的库,解决一些事情节省了大量时间。这次仅仅是一个小小的尝试,对于很多东西都是浅尝则止,文中难免会有错误,欢迎在评论中指正。如果你在使用GPUImage和AVFoundation有什么好的心得或者对一些问题有相应的解决方案,不妨在评论中分享一下。</p>

<hr />

<p>版权声明：我已将本文在微信公众平台的发表权「独家代理」给 iOS开发（ iOSDevTip ） 微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://images.90159.com/icon/iOSDevTip.jpg" alt="iOSDevTip" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS/Android开发社交SDK列表]]></title>
    <link href="http://www.superqq.com/blog/2015/08/23/ios-android-social-sdk/"/>
    <updated>2015-08-23T11:48:48+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/23/ios-android-social-sdk</id>
    <content type="html"><![CDATA[<h3>友盟社会化分享</h3>

<p><a href="http://www.umeng.com/social"target="_blank"title="进入官网">进入官网</a></p>

<p>友盟社会化分享组件，可以让移动应用快速具备社会化分享、登录、评论、喜欢等功能，并提供实时、全面的社会化数据统计分析服务。指南将会手把手教你使用社会化组件SDK，用5分钟为APP增加新浪微博、腾讯微博、人人网分享功能。</p>

<h2></br></h2>

<h3>ShareSDK</h3>

<p><a href="www.mob.com"target="_blank"title="进入官网">进入官网</a></p>

<p>ShareSDK是为iOS、Android的App提供社会化功能的一个组件，开发者仅需10分钟即可集成到自己的App中，它不仅支持国内外40多家的主流社交平台，帮助开发者轻松实现社会化分享、登录、关注、获得用户资料、获取好友列表等主流的社会化功能，还有强大的社会化统计分析管理后台，可以实时了解用户、信息流、回流率、传播效率等数据，有效地指导移动App的日常运营与推广，同时为App引入更多的社会化流量</p>

<h2></br></h2>

<h3>百度社会化分享</h3>

<p><a href="http://developer.baidu.com/soc/share"target="_blank"title="进入官网">进入官网</a></p>

<p>百度社会化分享组件集成多种热门社会化媒体平台，开发者可将此组件集成到自己的移动应用中，用户即可方便地对应用中的内容分享到新浪微博、Qzone、腾讯微博、开心网等各大热门社会化媒体平台中。</p>

<!--more-->


<h2></br></h2>

<h3>微信开放平台</h3>

<p><a href="https://open.weixin.qq.com/cgi-bin/frame?t=home/app_tmpl&lang=zh_CN"target="_blank"title="进入官网">进入官网</a></p>

<p>微信是腾讯公司于2011年1月21日推出的一款通过网络快速发送语音短信、视频、图片和文字，支持多人群聊的手机聊天软件。用户可以通过微信与好友进行形式上更加丰富的类似于短信、彩信等方式的联系。微信软件本身完全免费，使用任何功能都不会收取费用，微信时产生的上网流量费由网络运营商收取。</p>

<h2></br></h2>

<h3>新浪微博</h3>

<p><a href="http://open.weibo.com/wiki/%E9%A6%96%E9%A1%B5"target="_blank"title="进入官网">进入官网</a></p>

<p>新浪微博开放平台（Weibo Open Platform）是基于新浪微博海量用户和强大的传播能力，接入第三方合作伙伴服务，向用户提供丰富应用和完善服务的开放平台。将你的服务接入微博平台，有助于推广产品，增加网站/应用的流量、拓展新用户，获得收益。</p>

<h2></br></h2>

<h3>bShare</h3>

<p><a href="http://www.bshare.cn/"target="_blank"title="进入官网">进入官网</a></p>

<p>bShare是中国最专业、最强大的社会化分享服务商，提供能分享到QQ空间、新浪微博、人人网等的分享功能。目前bShare已与130+家合作平台，赢得 150000+家网站 的信任。长期以来，我们专注于在社会化分享领域深耕细作，为千万家网站注入社交功能，导入巨大流量的同时，也提供专业的用户分享数据统计，并致力于打造最专业的社会化分享服务。</p>

<h2></br></h2>

<h3>LeanCloud</h3>

<p><a href="https://cn.avoscloud.com/docs/sns.html"target="_blank"title="进入官网">进入官网</a></p>

<p>LeanCloud 社交分享提供强大的用户管理功能，包括密码加密、邮箱验证等。并且用户通过 LeanCloud 的 SDK，可轻松实现微博、微信等账号绑定和信息分享。</p>

<h2></br></h2>

<p>有<a href="http://www.superqq.com/">刚刚在线</a>整理，转载请注明来源。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发征稿启示（打赏归作者所有）]]></title>
    <link href="http://www.superqq.com/blog/2015/08/22/development-ios-reward/"/>
    <updated>2015-08-22T00:45:26+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/22/development-ios-reward</id>
    <content type="html"><![CDATA[<h2>iOS开发订阅用户突破10000人</h2>

<p>首先，非常感谢您的支持和一路陪伴！经过一年多的发展，iOS开发（iOSDevTip）微信公众号的订阅用户越来越多，已经超过10000人。这是一件好事，也是对iOS开发公众号价值的体现。</p>

<p>这一年多的时间里，我每天都在为寻求一篇好的iOS开发文章而努力。这个过程有快乐也有艰辛。每天做一件事，说起来不难，真要坚持下来，不是那么容易的一件事情。我说这些，并不是要证明自己有多厉害。为了寻求好的文章，我会经常阅读大量的博文，上各大程序员门户网站。有时，会因为发现一篇好的文章而庆幸不已；有时，也会因为找不到文章而心里焦急。</p>

<p>后来，我建立了自己的博客<a href="http://www.superqq.com/">刚刚在线</a>：www.superqq.com 。有时间，我就会写一些技术文章分享在上面。也会把文章同步到iOS开发公众号上。</p>

<p>随着订阅用户的增多，大家对文章内容的需求也越来越高。由于我一个人的力量毕竟有限，可能无法满足所有人的需求。订阅iOS开发的用户不乏一些大牛，所以我想发动大家的力量，一起来为优质的iOS开发文章而努力。</p>

<h2>毕洪博投稿文章情况</h2>

<p>七夕那天，作者毕洪博投稿<a href="http://www.superqq.com/blog/2015/08/21/sina-animation/"> 一句代码添加新浪弹出框动画 </a>得到了不错的反响，我把主数据给大家看看：</p>

<pre><code>图文阅读：1695
原文阅读：19   
转发+收藏：193
文章发布日期：2015-08-20
评论人数：5
赞赏人数：3
赞赏金额：9元
</code></pre>

<p>从阅读量上来看，还是挺不错的。虽然赞赏金额不多吧，但也算是有一点点回报。七夕那天夜里，我找到作者毕洪博给他发了一个红包。哈哈！</p>

<p>如果您是一名iOS开发者，如果您有自己的博客，如果您喜欢分享，那就快行动吧！把您的优秀文章投稿给我，我将会把您的文章推送在iOS开发微信公众号上，分享给更多的iOS开发者。</p>

<!--more-->


<h2>投稿方式</h2>

<pre><code>投稿邮箱：worldligang@163.com
个人微信：chinaligang
投稿格式：markdown格式
博主联盟群：364679270
</code></pre>

<p>因为微信上面不方便阅读代码，但是支持markdown语法转换。所以投稿的时候，最好是markdown格式的。投稿之后，请记得加我的个人微信，以便我将打赏的钱转账给您。如果你有自己的博客，欢迎加入博主联盟群。</p>

<h2>版权申明</h2>

<ul>
<li><p>微信公众号规定打赏必须是原创文章，所以希望您能将你的文章在微信公众平台的发表权「独家代理」iOS开发（ iOSDevTip ） 微信公众号。这样我就可以对您的文章申明原创和开通打赏功能。文章的版权依然归您所有，你可以将文章发布在你的博客、微博上。</p></li>
<li><p>为了证明我得到您的授权，您需要在您的文章底部加上如下申明：</p>

<p>  版权声明：我已将本文在微信公众平台的发表权「独家代理」给 iOS开发（ iOSDevTip ） 微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p>  <img src="http://images.90159.com/icon/iOSDevTip.jpg" alt="iOSDevTip" /></p></li>
</ul>


<p>申明markdown格式为：</p>

<pre><code>    版权声明：我已将本文在微信公众平台的发表权「独家代理」给 iOS开发（ iOSDevTip ） 微信公众号。扫下方二维码即可关注「iOS 开发」：

    ![iOSDevTip](http://images.90159.com/icon/iOSDevTip.jpg)    
</code></pre>

<p>如果对投稿有什么疑问，欢迎加我微信：chinaligang，详细了解一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一句代码添加新浪弹出框动画]]></title>
    <link href="http://www.superqq.com/blog/2015/08/21/sina-animation/"/>
    <updated>2015-08-21T11:16:07+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/21/sina-animation</id>
    <content type="html"><![CDATA[<p>新浪微博中的“加号按钮”点击后的弹出动画很有意思，每当一个人孤单寂寞冷的时候总会不停的点这个动画，终于忍不住自己撸了一个。废话不多说，直接上效果图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation1.gif" alt="演示1" /></p>

<p>首先说一下通过这个动画制作过程给大家分享的技术问题：
1.背景的毛玻璃效果
2.弹性动画
3.动画进行时对用户交互的处理
4.<code>UIControl</code> 的 <code>event</code> 类型</p>

<h2>一、背景的毛玻璃效果</h2>

<p>对新浪微博中弹出动画背景的思路分析：</p>

<p>  新浪的背景动画效果是有一个透明渐变的过程，并且最终渐变停止之后显示的是一个带有毛玻璃（半透明模糊）效果的视图。我的模仿思路是当准备要弹出动画的时候对整个视图进行截屏操作，将截屏后的图片进行毛玻璃效果渲染，然后在视图上加一个背景 <code>UIImageView</code> 来显示这张图片，然后通过 <code>alpha</code> 动画来由透明逐渐渐变出来。</p>

<h3>1.对视图进行截屏：</h3>

<pre><code>    UIGraphics BeginImageContextWithOptions(size, NO, scale);
    [view.layer renderInContext:UIGraphicsGetCurrentContext()];
    UIImage * image = UIGraphicsGetImageFromCurrentImageContext();
</code></pre>

<h3>2.截屏后加上毛玻璃效果：</h3>

<p>制作毛玻璃效果有三种选择，一是 <code>iOS8</code> 后推出的 <code>UIBlurEffect</code> 和 <code>UIVisualEffectView</code> 来直接显示一个带有毛玻璃效果的 <code>View</code> 不过这种方式并不能直接生成一张带有毛玻璃效果的图片，而且它的模糊程度设置方法非常有限只有那几个枚举类型，无法满足需求。</p>

<p>第二种是通过 <code>CoreImage</code> 添加滤镜的方式来实现毛玻璃效果，不过这种方式有个缺点如果滤镜使用频繁会对主线程产生影响，如果我不断频繁的重复动画效果就必须要做判断看滤镜是否正在起作用，否则会经常出现崩溃和内存泄漏问题。</p>

<p>第三种我们使用苹果13年 <code>WWDC</code> 上发布的官方 <code>sample</code> 一个 <code>UIImage</code> 的分类 <code>UIImage+ImageEffects.h</code> ,它不但可以制作毛玻璃效果图片，而且可以调整模糊程度和颜色渲染。下面给出代码：</p>

<pre><code>    image = [image bhb_applyBlurWithRadius:15 
                                 tintColor:tintColor 
                     saturationDeltaFactor:1 
                                 maskImage:nil];//因为OC没有命名空间，避免你的程序中使用到了这个分类导致冲突，我加了前缀
</code></pre>

<!--more-->


<p>最终的显示效果很不错，我将模糊程度尽量的调节到与新浪微博一致了，不过在这个过程中，我发现当我频繁的进行弹出操作时，内存会不断攀升如下图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation3.png" alt="演示3" />
内存暴增的原因肯定是因为刚才的截图或者毛玻璃效果导致的，我们来用 <code>Instruments</code> 的 <code>Allocations</code> 来进行内存分析，找出元凶。
Xcode -> Product -> Profile -> Allocations， 开启之后我们来使用右下角的 <code>Mark generation</code>（内存快照功能，进一步了解请移步[这片文章][1]）
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation4.png" alt="演示4" />
在弹出 <code>View</code> 和移除 <code>View</code> 的两个时间点加 <code>Mark generation</code>。
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation5.png" alt="演示5" />
可以观察到，两个时间点竟然相差了4.31M，这是一个相当恐怖的数字，怪不得我点击几次弹出功能之后内存会暴增，让我们继续跟踪：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation6.png" alt="演示6" />
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation7.png" alt="演示7" />
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation8.png" alt="演示8" />
跟踪到最后，我们发现大部分未释放的内存来自于绘图和位图的创建，回想我们当初做的截图操作，图片上下文开启后并没有进行关闭操作，所以在程序不断截图的过程中开启了无数的图片上下文而且不会被释放，添加下面这句关键的代码就可以解决问题（NC的我竟然连这个都忘了加-.-）：</p>

<pre><code>        UIGraphicsEndImageContext();
</code></pre>

<h2>二、弹性动画</h2>

<p>新浪动画中，按钮弹出的动画为弹性效果，按钮到达最终位置后不会直接停止，而是做类似弹簧的一种阻尼运动，要实现这种动画也很简单 <code>iOS7</code> 后苹果非常给力的添加了 <code>spring</code> 弹性动画的快速创建方式：</p>

<pre><code>    [UIView animateWithDuration:(NSTimeInterval) 
                          delay:(NSTimeInterval) 
         usingSpringWithDamping:(CGFloat) 
          initialSpringVelocity:(CGFloat) 
                        options:(UIViewAnimationOptions) 
                     animations:^{} 
                     completion:^(BOOL finished) {}];
</code></pre>

<p>通过对 <code>Damping</code> 阻力和 <code>Velocity</code> 初速度的设置可以实现弹性动画动画效果如下图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/threeballs.gif" alt="摘自MotionDesign" /></p>

<p>当然实现弹性动画还可以使用[Jonathan Willing][2]大大的 <code>JNWSpringAnimation</code> ,你可以像使用 <code>CABasicAnimation</code> 一样轻松的使用它，通过改变关键的3个属性 <code>Damping</code> 阻力， <code>stiffness</code> 硬直, <code>mass</code> 质量来改变弹性动画的效果代码如下：</p>

<pre><code>    JNWSpringAnimation *scale = [JNWSpringAnimation
    animationWithKeyPath:@"transform.translation.x"];
    scale.damping = 7;
    scale.stiffness = 7;
    scale.mass = 1;

    scale.fromValue = @(0);
    scale.toValue = @(400);

    [redBall.layer addAnimation:scale forKey:scale.keyPath];
    redBall.transform = CGAffineTransformMakeTranslation(400, 0);
</code></pre>

<p>关键的三个属性对动画的影响如下图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/jnwdemo.gif" alt="摘自MotionDesign" /></p>

<p>为了减轻项目对第三方框架的依赖，我使用了 <code>iOS7</code> 原生的 <code>spring</code> 动画，如果你想要兼容以前版本，替换成 <code>JNWSpringAnimation</code> 即可。回到新浪动画的制作，动画是6个按钮按照顺序依次出现和消失，并且点击 <code>more</code> 按钮后可以向左平移到第二屏幕，并且在第二屏幕点击 <code>叉号</code> 按钮动画会加在第二屏幕的6个按钮上。
效果如图：
<img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation2.gif" alt="演示2" /></p>

<p>对此我使用了一个 <code>UIScrollView</code> 来承载这些按钮，并声明2个数组用来保存所有的按钮和正在显示的按钮（在屏幕上，并且需要做动画）:</p>

<pre><code>    @property (nonatomic,strong) NSMutableArray * visableArray;//屏幕显示的按钮数组
    @property (nonatomic,strong) NSMutableArray * itemsArray;//所有按钮的数组
</code></pre>

<p>这样我在给这些按钮加动画的时候就不会浪费性能，只把动画加在当前显示在屏幕的按钮上。动画依次按照一定的时间差来执行，解决的办法我是用的 <code>GCD</code> :</p>

<pre><code>    [self.visableArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        BHBCustomBtn * btn = obj;
        CGFloat x = btn.frame.origin.x;
        CGFloat y = btn.frame.origin.y;
        CGFloat width = btn.frame.size.width;
        CGFloat height = btn.frame.size.height;
        btn.frame = CGRectMake(x, [UIScreen mainScreen].bounds.size.height + y - self.frame.origin.y, width, height);
        btn.alpha = 0.0;
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(idx * 0.03 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:0.35 delay:0 usingSpringWithDamping:0.85 initialSpringVelocity:25 options:UIViewAnimationOptionCurveEaseIn animations:^{
                btn.alpha = 1;
                btn.frame = CGRectMake(x, y, width, height);
            } completion:^(BOOL finished) {
                if ([btn isEqual:[self.visableArray lastObject]]) {
                    self.superview.superview.userInteractionEnabled = YES;
                }
            }];
        });
    }];
</code></pre>

<p>这样按钮就会依次以弹性动画的形式弹动出来了，是不是很简单，对于动画结束后所作的处理我将在下一节中说明。</p>

<h2>三、动画进行时对用户交互的处理</h2>

<p>动画过程中，处理用户交互的问题相当关键，视图动画中默认自动停止响应用户交互，因此当按钮进行弹性动画时，触摸它并不会生成任何事件。
但是当你触摸加号按钮的时候，会再次进行弹出框动画，这时就会弹出两个弹出框，这是我们不希望看到的，我们可以将加号按钮的 <code>enable</code> 属性设置为 <code>YES</code> 但是这样做我们要在封装的视图内部获取外部的加号按钮，这一点违背了封装性原则，并不是一个好的设计。所以我在所有按钮的弹性动画开始时，设置：</p>

<pre><code>    self.superview.superview.userInteractionEnabled = NO;
</code></pre>

<p>注意视图的层级关系，我所设计的 <code>BHBPopView</code> 内部装着一个 <code>UIScrollView</code>，而它上面放着这些按钮，所以你要找到父视图的父视图才能够统一屏蔽用户的交互行为，当所有的按钮弹性动画结束时，也就是 <code>visableArray</code> 数组最后一个按钮动画结束时，我们恢复用户的交互：</p>

<pre><code>    self.superview.superview.userInteractionEnabled = YES;
</code></pre>

<p>这样当动画进行过程中，屏蔽了用户的交互，避免发生一些意外的情况。</p>

<h2>四、<code>UIControl</code> 的 <code>event</code> 类型</h2>

<p>注意到新浪动画里面按钮有一个放大效果，并且当你手指放上去的时候放大，手指稍微挪动，便恢复原始大小。让我们先来看一下动画：</p>

<p><img src="http://7xkdhe.com1.z0.glb.clouddn.com/sinaAnimation9.gif" alt="演示9" /></p>

<p>要实现这个效果只需要做一个形变动画就可以了，关键是我们如何控制它放大和恢复大小。
思路如下：按钮是继承自 <code>UIControl</code> ，<code>UIControl</code> 有不同的事件状态：</p>

<pre><code>    UIControlEventTouchDown           = 1 &lt;&lt;  0,      // 手指落在按钮的一瞬间触发
    UIControlEventTouchDownRepeat     = 1 &lt;&lt;  1,      // 多点触碰的时候，当第二根以上的手指触摸瞬间出发
    UIControlEventTouchDragInside     = 1 &lt;&lt;  2,      // 手指在视图范围内拖动触发
    UIControlEventTouchDragOutside    = 1 &lt;&lt;  3,      // 手指在视图范围外拖动触发
    UIControlEventTouchDragEnter      = 1 &lt;&lt;  4,      // 手指从视图外拖动到视图内时触发
    UIControlEventTouchDragExit       = 1 &lt;&lt;  5,      // 手指从视图内部拖动到视图外时触发
    UIControlEventTouchUpInside       = 1 &lt;&lt;  6,      // 手指在视图内部抬起时触发
    UIControlEventTouchUpOutside      = 1 &lt;&lt;  7,      // 手指在视图外部抬起时触发
    UIControlEventTouchCancel         = 1 &lt;&lt;  8,      // 取消事件，放上了太多手指或者被上锁或者电话呼叫打断。

    UIControlEventValueChanged        = 1 &lt;&lt; 12,      // 当视图的值发生改变时，发送通知。

    UIControlEventEditingDidBegin     = 1 &lt;&lt; 16,     // UITextField
    UIControlEventEditingChanged      = 1 &lt;&lt; 17,
    UIControlEventEditingDidEnd       = 1 &lt;&lt; 18,
    UIControlEventEditingDidEndOnExit = 1 &lt;&lt; 19,     // 'return key' ending editing

    UIControlEventAllTouchEvents      = 0x00000FFF,  // for touch events
    UIControlEventAllEditingEvents    = 0x000F0000,  // for UITextField
    UIControlEventApplicationReserved = 0x0F000000,  // range available for application use
    UIControlEventSystemReserved      = 0xF0000000,  // range reserved for internal framework use
    UIControlEventAllEvents           = 0xFFFFFFFF
</code></pre>

<p>我们所用到的事件是 <code>TouchDown</code> 和 <code>DragInside</code>，手指放上去触发 <code>TouchDown</code> 放大视图，在视图内部移动 <code>DragInside</code> 时恢复视图，注意按钮的作用范围是整个矩形区域包含了图片和文字，当你的手指移出图片的时候并非一定会移出按钮作用范围，所以依然会触发 <code>TouchUpInsite</code> 事件，这时候我们需要做一个属性来记录用户拖拽之后取消按钮的 <code>TouchUpInsite</code> 执行。</p>

<pre><code>    @property (nonatomic,assign) BOOL btnCanceled;
</code></pre>

<p>这样我们就可以实现动画效果了，具体代码如下：</p>

<pre><code>    //处理按钮有效的点击事件，当前按钮放大消失，其他按钮缩小消失，回调点击事件
    [btn addTarget:self action:@selector(didClickBtn:) forControlEvents:UIControlEventTouchUpInside];
    //处理手指按下事件，放大按钮
    [btn addTarget:self action:@selector(didTouchBtn:) forControlEvents:UIControlEventTouchDown];
    //处理手指拖动事件，恢复按钮大小
    [btn addTarget:self action:@selector(didCancelBtn:) forControlEvents:UIControlEventTouchDragInside];
</code></pre>

<h2>总结：</h2>

<p>制作类似新浪微博这种弹出框动画，我的思路是先分析逻辑，这些特效都由哪些组成，毛玻璃背景，加顶部一个 <code>logo</code> ，加中间 <code>UIScrollView</code>和上面的很多按钮,加底部工具条。研究透彻动画的执行顺序，动画执行结果有哪些分支。然后针对特效中的难点，比如毛玻璃，按钮弹性动画等等进行逐一研究攻破，最后将这些组件整合在一起变成一个好玩的动画，最后不要忘了动画的内存和性能测试。这次我模仿的新浪微博动画弹性效果并不是太理想，比起新浪原生来说不是特别一致，也希望有兴趣的你来给我一些建议优化它。最终在你的项目中加入我的弹出框动画真的只需要一句话哦：</p>

<pre><code>    /**
    *  直接显示一个popView在某个view上
    *
    *  @param view       父view
    *  @param imageArray 图标数组
    *  @param titles     标题数组
    *  @param block      回调
    *  @return pop视图
    */
    + (BHB_INSTANCETYPE)showToView:(UIView *)view andImages:(NSArray *)imageArray andTitles:(NSArray *)titles andSelectBlock:(DidSelectItemBlock)block;
    /**
    *  如果显示一个带more功能的，请使用此方法
    *
    *  @param view  父view
    *  @param array BHBItem类型的集合
    *  @param block 回调
    *  @return pop视图
    */
    + (BHB_INSTANCETYPE)showToView:(UIView *)view withItems:(NSArray *)array andSelectBlock:(DidSelectItemBlock)block;
</code></pre>

<p>hexo出点问题修复到下半夜啊（升级到3.0太蛋疼了），现在脑子晕晕的，明天还要去新公司入职，动画中还有很多细节我不能一一分享了，欢迎大家来搞我的<a href="https://github.com/bb-coder/BHBPopView">Demo</a></p>

<p>good luck!</p>

<p>本文由<a href="http://www.90159.com/">程序员头条</a>管理员毕洪博原创文章，转载务必注明出处。</p>

<p>版权声明：我已将本文在微信公众平台的发表权「独家代理」给 iOS开发（ iOSDevTip ） 微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://images.90159.com/icon/iOSDevTip.jpg" alt="iOSDevTip" /></p>

<p>原文链接：<a href="http://bihongbo.com/2015/08/19/sinaAnimation/">http://bihongbo.com/2015/08/19/sinaAnimation/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发小技巧：刷新UITableView]]></title>
    <link href="http://www.superqq.com/blog/2015/08/18/ios-development-refresh-uitableview/"/>
    <updated>2015-08-18T15:25:58+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/18/ios-development-refresh-uitableview</id>
    <content type="html"><![CDATA[<blockquote><p>我创建了iOS开发博主联盟群：<strong>364679270</strong>，有博客的朋友欢迎加入。一起打造一个优质的iOS技术分享社群。</p></blockquote>

<p>UITableView对于iOS开发者来说一定不会陌生，很有可能你的APP很多界面都用到它。关于UITableView的文章，想必已经不计其数，没事可以多看看。特别是UITableView优化的文章，非常值得仔细琢磨一番。</p>

<p>今天我们来看看如何刷新UITableView的，一般情况下，刷新UITableView，我们会直接调用reloadData方法。</p>

<h2>刷新UITableView</h2>

<pre><code>[self.tableView reloadData];
</code></pre>

<p>reloadData是刷新整个UITableView，有时候，我们可能需要局部刷新。比如：只刷新一个cell、只刷新一个section等等。这个时候在调用reloadData方法，虽然用户看不出来，但是有些浪费资源。</p>

<h2>刷新局部cell</h2>

<pre><code> NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:0];
 [self.tableView reloadRowsAtIndexPaths:[NSArray arrayWithObjects:indexPath,nil] withRowAnimation:UITableViewRowAnimationFade];
</code></pre>

<p>这样就可以很方便的刷新第一个section的第一个cell。虽然看起来代码多了，但是确实比较节省资源。尽量少的刷新，也是UITableView的一种优化。</p>

<h2>局部刷新section</h2>

<pre><code>NSIndexSet *indexSet = [[NSIndexSet alloc] initWithIndex:0];
[self.tableView reloadSections:indexSet withRowAnimation:UITableViewRowAnimationFade];
</code></pre>

<p>上面这段代码是刷新第0个section。</p>

<!--more-->


<h2>刷新动画</h2>

<p>刷新UITableView还有几个动画：</p>

<pre><code>typedef NS_ENUM(NSInteger, UITableViewRowAnimation) {
    UITableViewRowAnimationFade,   //淡入淡出
    UITableViewRowAnimationRight,  //从右滑入         // slide in from right (or out to right)
    UITableViewRowAnimationLeft,   //从左滑入
    UITableViewRowAnimationTop,     //从上滑入
    UITableViewRowAnimationBottom,  //从下滑入
    UITableViewRowAnimationNone,            // available in iOS 3.0
    UITableViewRowAnimationMiddle,          // available in iOS 3.2.  attempts to keep cell centered in the space it will/did occupy
    UITableViewRowAnimationAutomatic = 100  // available in iOS 5.0.  chooses an appropriate animation style for you
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[环形渐变进度条实现]]></title>
    <link href="http://www.superqq.com/blog/2015/08/12/realization-circular-gradient-progress/"/>
    <updated>2015-08-12T01:12:05+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/12/realization-circular-gradient-progress</id>
    <content type="html"><![CDATA[<p>之前有人在找渐变进度条的效果，闲来无事就顺手写了一个，然后画了视图层级，方便讲解。</p>

<p>环境信息：</p>

<p>Mac OS X 10.10.3</p>

<p>Xcode 6.3.1</p>

<p>iOS 8.3</p>

<p>效果图：</p>

<p><img src="http://images.90159.com/08/result.gif" alt="1" /></p>

<p>源码下载地址：<a href="https://github.com/saitjr/LoopProgressDemo.git">LoopProgressDemo</a></p>

<p>正文</p>

<h2>一、视图层级</h2>

<p>首先需要搞定的就是视图层级关系。可以看到，</p>

<pre><code>1. 背景是有透明度的蓝色(blueView)

2. 需要一个从绿-&gt;黄-&gt;红的渐变色，那个这里我采用的是Layer(colorLayer)

3. blueView和colorLayer他们的表现状态都是环形的，所以还需要环形的遮罩

4. 蓝色的环并没有变，而渐变色的环却在时刻变化，所以需要两个遮罩，一个给蓝色(blueMaskLayer)，一个给渐变色(colorMaskLayer)
</code></pre>

<p>从上面的分析可以看出，现在需要几个变量以及他们的关系如下：</p>

<pre><code>[viewController.view addSubView:blueView];
[blueView.layer addSubLayer:colorLayer];
colorLayer.mask = colorMaskLayer;
blueView.layer.mask = blueMaskLayer;
</code></pre>

<!--more-->


<p>视图层级图如下：</p>

<p><img src="http://images.90159.com/08/ios-implement-loop-progress-1.png" alt="1" /></p>

<h2>二、根据视图层级来实现</h2>

<p>搞清楚了层级，接着就应该逐个实现了。</p>

<ol>
<li>有透明度的蓝色视图blueView</li>
</ol>


<p>ViewController.m</p>

<p>BlueView *blueView = [[BlueView alloc] initWithFrame:CGRectMake(0, 0, 300, 300)];
blueView.center = self.view.center;
blueView.backgroundColor = [UIColor blueColor]; // 我这里没有给透明度
[self.view addSubView:blueView];</p>

<ol>
<li>渐变图层colorLayer</li>
</ol>


<p>因为系统没有提供根据路径渐变的实现方法，所以只能采用曲线救国的方式来画。那么我所使用的方法是：在左边画一个从下往上为绿->黄的渐变Layer（leftLayer），然后右边画一个从下往上为红->黄的渐变Layer（rightLayer）。</p>

<p>效果图如下：</p>

<p><img src="http://images.90159.com/08/ios-implement-loop-progress-2.png" alt="1" /></p>

<p>渐变色</p>

<p>但是这种方式效果不是很好，因为黄绿色和橘红色的分界太明显，所以最好设置一个渐变的范围。</p>

<p>效果图如下：</p>

<p><img src="http://images.90159.com/08/ios-implement-loop-progress-3.png" alt="1" /></p>

<p>设置渐变范围的渐变色</p>

<p>实现代码：</p>

<p>BlueView.m</p>

<pre><code>- (void)setupColorLayer {
    self.colorLayer = [CAShapeLayer layer];
    self.colorLayer.frame = self.bounds;
    [self.layer addSublayer:self.colorLayer];

    CAGradientLayer *leftLayer = [CAGradientLayer layer];
    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);
    // 分段设置渐变色
    leftLayer.locations = @[@0.3, @0.9, @1];
    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];
    [self.colorLayer addSublayer:leftLayer];

    CAGradientLayer *rightLayer = [CAGradientLayer layer];
    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);
    rightLayer.locations = @[@0.3, @0.9, @1];
    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];
    [self.colorLayer addSublayer:rightLayer];
}
</code></pre>

<ol>
<li>渐变图层的环形遮罩colorMaskLayer</li>
</ol>


<p>因为渐变图层环形遮罩和蓝色视图的环形遮罩样式都是一样的，所以可以将环形遮罩的创建代码封装出来：</p>

<p>BlueView.m</p>

<pre><code>- (CAShapeLayer *)generateMaskLayer {

    CAShapeLayer *layer = [CAShapeLayer layer];
    layer.frame = self.bounds;

    // 创建一个圆心为父视图中点的圆，半径为父视图宽的2/5，起始角度是从-240°到60°
    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(self.bounds.size.width / 2, self.bounds.size.height / 2) radius:self.bounds.size.width / 2.5 startAngle:-3 / 4 * M_PI endAngle:1 / 3 * M_PI clockwise:YES];
    layer.lineWidth = 20;
    layer.path = path.CGPath;
    layer.fillColor = [UIColor clearColor].CGColor; // 填充色为透明（不设置为黑色）
    layer.strokeColor = [UIColor blackColor].CGColor; // 随便设置一个边框颜色
    layer.lineCap = kCALineCapRound; // 设置线为圆角
    return layer;
}
</code></pre>

<p>设置渐变色环形遮罩层</p>

<p>BlueView.m</p>

<pre><code>- (void)setupColorMaskLayer {

    CAShapeLayer *layer = [self generateMaskLayer];
    layer.lineWidth = 20.5; // 渐变遮罩线宽较大，防止蓝色遮罩有边露出来
    self.colorLayer.mask = layer;

    self.colorMaskLayer = [CAShapeLayer layer];
    self.colorMaskLayer = layer;
}
</code></pre>

<ol>
<li>blueView的环形遮罩blueMaskLayer</li>
</ol>


<p>BlueView.m</p>

<pre><code>- (void)setupBlueMaskLayer {

    CAShapeLayer *layer = [self generateMaskLayer];
    self.layer.mask = layer;
    self.blueMaskLayer = layer;
}
</code></pre>

<ol>
<li>设置百分比</li>
</ol>


<p>设置渐变色所占的百分比，其实就是改变colorMaskLayer的范围，系统提供了一个方法可以直接根据百分比来修改。</p>

<pre><code>self.colorMaskLayer.strokeEnd = 0.5;
</code></pre>

<p>到此，整个效果就已经完成了，接下来说一下回弹动画。</p>

<h2>三、设置回弹动画</h2>

<p>我所使用的是pop库中的POPSpringAnimation，这个效果比较Q弹，加在进度条上刚好。要加动画，只需要把上面的修改strokeEnd的代码换成一下方法就可以了：</p>

<pre><code>- (void)animationWithStrokeEnd:(CGFloat)strokeEnd {

    POPSpringAnimation *strokeAnimation = [POPSpringAnimation animationWithPropertyNamed:kPOPShapeLayerStrokeEnd];
    strokeAnimation.toValue = @(strokeEnd);
    strokeAnimation.springBounciness = 12.f;
    strokeAnimation.removedOnCompletion = NO;
    [self.colorMaskLayer pop_addAnimation:strokeAnimation forKey:@"layerStrokeAnimation"];
}
</code></pre>

<p>来源：<a href="http://www.brighttj.com/ios/ios-implement-loop-progress.html">http://www.brighttj.com/ios/ios-implement-loop-progress.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[彩色TabBar切换动画实现]]></title>
    <link href="http://www.superqq.com/blog/2015/08/11/color-tabbar-switch-animation/"/>
    <updated>2015-08-11T00:38:31+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/11/color-tabbar-switch-animation</id>
    <content type="html"><![CDATA[<p>无意间看到一个彩色TabBar切换的设计图，感觉很不错，有空就把他实现了。
环境信息
Mac OS X 10.10.4
Xcode 6.4
iOS 8.4
效果图：</p>

<p><img src="http://images.90159.com/08/1.1TabBar-1.gif" alt="1.1TabBar-1.gif" /></p>

<p>源码下载地址：
<a href="https://github.com/saitjr/TColorfulTabBar.git">https://github.com/saitjr/TColorfulTabBar.git</a></p>

<h2>一、实现分析</h2>

<p>看到这个彩色切换效果的时候，我第一个反应就是在TabBar上有一个彩色的View，然后每个色块的显示都是通过mask来显示的。最终，我的具体实现也是根据这个思路来的。</p>

<h4>1. 设计思想</h4>

<p>为了减少侵入性（耦合），我采取的是继承UITabBar来实现，所以要集成的时候，只需要将系统的TabBar换成我写的TColorfulTabBar就可以了。</p>

<p><img src="http://images.90159.com/08/1.2TabBar-2.png" alt="1.2TabBar-2.png" /></p>

<h4>2. 视图层级图</h4>

<h2>二、效果实现</h2>

<h4>1. 添加彩色视图colorfulView</h4>

<p>TColorfulTabBar.m</p>

<pre><code>- (void)setupColorView {

    // 初始化彩色视图，并将它加在tabbar上
    UIView *colorView = [[UIView alloc] initWithFrame:self.bounds];
    [self addSubview:colorView];
    self.colorfulView = colorView;

    // 彩色视图的五种颜色，这是一个UIColor数组，
    NSArray *colors = self.itemColors;
    CGFloat itemWidth = self.bounds.size.width / self.itemCount;

    for (int i = 0; i &lt; self.itemCount; i ++) {

        UIView *view = [[UIView alloc] initWithFrame:CGRectMake(itemWidth * i, 0, itemWidth, self.bounds.size.height)]; 
        view.backgroundColor = colors[i]; 
        [self.colorfulView addSubview:view]; 
    } 
}
</code></pre>

<!--more-->


<h4>2. 添加彩色视图的遮罩colorfulMaskView</h4>

<p>之所以这里的遮罩使用的是UIView而不是CAShapeLayer或者CALayer，原因如下：</p>

<ul>
<li>遮罩是矩形，没必要使用路径，所以不用CAShapeLayer</li>
<li>通过设计图可以看到，在位移动画之前，有一个遮罩单向变宽（向左或向右）的效果。如果使用CALayer，那么改变bounds的时候，是双向改变，想要单向就必须加锚点，太麻烦</li>
<li>如果使用UIView，那么向右变宽只需要x不变，width变长就行；向左变宽只需要x-value，width+value就行，要方便的多</li>
<li>最后一点就是在做动画的时候，Layer要用到CABaseAnimation，然而UIView使用UIView的Animation就行</li>
</ul>


<p>在设置遮罩的时候，将colorfulMaskView的layer设置为colorfulView的mask就可以了。
代码实现如下：
TColorfulTabBar.m</p>

<pre><code>- (void)setupMaskLayer {

    // 获取每个item的宽度
    CGFloat itemWidth = self.bounds.size.width / self.itemCount;

    // 初始化colorMaskView，并将colorMaskView的layer设置成彩色视图的遮罩
    UIView *colorMaskView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, itemWidth, self.bounds.size.height)];
    colorMaskView.backgroundColor = [UIColor blackColor];
    self.colorfulMaskView = colorMaskView;
    self.colorfulView.layer.mask = self.colorfulMaskView.layer;
}
</code></pre>

<h4>3. 设置代理，获取当前点击的下标</h4>

<p>UITabBar并没有获取点击下标的接口，但是UITabBarDelegate有，这个协议默认被UITabBarController遵守。为了降低耦合性，采用UITabBar自己获取下标，所以，需要UITabBar自己实现自己的delegate。
<strong>值得注意的是，不能在UITabBar的初始化方法中去设置self.delegate = self，因为即使设置了，也会被UITabBarController覆盖。最终解决方案是当UITabBar加载到父视图上是，在修改delegate为self。</strong></p>

<pre><code>- (void)didMoveToSuperview {
    [super didMoveToSuperview];
    self.delegate = self;
}
</code></pre>

<p>因为每次的移动位置与方向都和上次的下标与这次的下标有关，所以需要使用到属性来记录这两个下标的值。
    - (void)tabBar:(UITabBar <em>)tabBar didSelectItem:(UITabBarItem </em>)item {</p>

<pre><code>    NSInteger index = [self.items indexOfObject:item];
    self.fromeIndex = self.toIndex;
    self.toIndex = index;
    // 拿到下标以后执行动画
    [self animation];
}
</code></pre>

<h4>4. 移动遮罩，显示不同的色块</h4>

<p>在做动画的时候，需要考虑到效果的平滑性。整个动画有两个动画组成，一个是宽度放大的动画，一个是缩小到原来大小和位移动画。整个动画是EaseInOut的效果，所以拆开来看，就应该第一个动画EaseIn，第二个动画EaseOut。
一图胜千言：</p>

<p><img src="http://images.90159.com/08/1.3TabBar-3.png" alt="1.3TabBar-3.png" /></p>

<pre><code>- (void)animation {

    CGFloat itemWidth = self.bounds.size.width / self.itemCount;
    // 为了效果看起来更平滑，所以根据两次下标的差值来计算需要放大的距离
    CGFloat extraWidth = ABS(self.toIndex - self.fromeIndex) * itemWidth / 4;

    // 放大的大小
    CGRect scaleFrame = CGRectMake(self.colorfulMaskView.x, 0, itemWidth + extraWidth, self.bounds.size.height);
    // 最终大的大小与位置
    CGRect toFrame = CGRectMake(self.toIndex * itemWidth, 0, itemWidth, self.bounds.size.height);

    // 如果是向左移动，那修改x轴的坐标
    if (self.fromeIndex &gt; self.toIndex) {

        scaleFrame = CGRectMake(self.colorfulMaskView.x - extraWidth, 0, itemWidth + extraWidth, self.bounds.size.height);
    }

    // 两个动画加起来是一个EaseInOut的效果，所以第一个动画就应该是EaseIn，第二个动画是EaseOut
    // 先进行放大
    [UIView animateWithDuration:ANIMATION_DURATION delay:0 options:UIViewAnimationOptionCurveEaseIn animations:^{

        self.colorfulMaskView.frame = scaleFrame;
    } completion:^(BOOL finished) {

        // 再进行缩小和位移
        [UIView animateWithDuration:ANIMATION_DURATION delay:0 options:UIViewAnimationOptionCurveEaseOut animations:^{

            self.colorfulMaskView.frame = toFrame;
        } completion:NULL];
    }];
}
</code></pre>

<p>原文:<a href="http://www.brighttj.com/ios/ios-colorful-tabbar-implement.html">http://www.brighttj.com/ios/ios-colorful-tabbar-implement.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreMotion框架中加速度计使用简明教程]]></title>
    <link href="http://www.superqq.com/blog/2015/08/10/coremotion-framework-use-accelerometer/"/>
    <updated>2015-08-10T00:37:33+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/10/coremotion-framework-use-accelerometer</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>之前有人通过iPhone的加速度计做出一个手机防盗APP，而且正是通过这个防盗APP拿到天使投资。从此以后华丽转身，公司发展的有声有色。虽然这个项目最后不怎么样，但是，确实是一个不错的想法。</p>

<p>也许你不知道，每一台iPhone都内置的有加速度计。这样当用户操作手机的的时候，比如旋转手机，内置的加速度计就会做出反应。</p>

<p>在iOS4之前加速度计是由<code>UIAccelerometer</code>来采集数据的，现在都是用<code>CoreMotion</code>来处理。两种使用都比较简单，相对来说<code>UIAccelerometer</code>更简单一些。本文将分享两者的用法。</p>

<h2>加速度计原理</h2>

<p><img src="http://images.90159.com/08/Accelerometer.png" alt="Accelerometer.png" /></p>

<p>来自网络</p>

<p>iPhone的加速度计有三个轴，分别是x轴、y轴、z轴，如上图所示。这是一个三维立体空间，可以捕获用户每一个角度的操作。通过这三个轴可以计算iPhone倾斜的角度，从而计算出加速度。</p>

<h2>UIAccelerometer使用</h2>

<p><code>UIAccelerometer</code>的使用比较简单，需要实现<code>UIAccelerometerDelegate</code>的代理方法，具体代码如下：</p>

<pre><code>UIAccelerometer *accelerometer = [UIAccelerometer sharedAccelerometer];
accelerometer.delegate = self;
accelerometer.updateInterval = 0.1;
</code></pre>

<p>实现<code>UIAccelerometerDelegate</code>代理方法：</p>

<pre><code>- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration NS_DEPRECATED_IOS(2_0, 5_0)
{
    NSLog(@"x -&gt; %f y - &gt; %f z -&gt; %f",accelerometer.x,accelerometer.y,accelerometer.z);
}
</code></pre>

<!--more-->


<h2>CoreMotion加速度计</h2>

<p>首先需要引入<code>#import &lt;CoreMotion/CoreMotion.h&gt;</code>，直接通过<code>block</code>回调，然后处理三个轴的数据。代码如下：</p>

<pre><code>CMMotionManager *motionManager = [[CMMotionManager alloc] init];
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
//加速计
if (motionManager.accelerometerAvailable) {
    motionManager.accelerometerUpdateInterval = 0.1;
    [motionManager startAccelerometerUpdatesToQueue:queue withHandler:^(CMAccelerometerData *accelerometerData,NSError *error){
        if (error) {
            [motionManager stopAccelerometerUpdates];
            NSLog(@"error");
        }else{
            NSLog(@"x -&gt; %f y - &gt; %f z -&gt; %f",accelerometerData.acceleration.x,accelerometerData.acceleration.y,accelerometerData.acceleration.z);
        }
    }];
}else{
    NSLog(@"This device has no accelerometer");
}
</code></pre>

<p>以上就是关于<code>UIAccelerometer</code>和<code>CoreMotion</code>的使用，加速度计确实是iPhone手机的亮点功能。具体用途，需要我们发散思维，说不定哪一天你也有一个很牛的创意。屌丝逆袭也许就在下一刻。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一次对MKMapView的性能优化]]></title>
    <link href="http://www.superqq.com/blog/2015/08/09/performance-optimization-of-mkmapview/"/>
    <updated>2015-08-09T13:18:21+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/09/performance-optimization-of-mkmapview</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近做的项目主要是LBS这块 主打成员定位功能 我们的UI设计是这样的</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-1.png" alt="Pic-MK-1" /></p>

<p>乍一看上去是挺好挺美观的 不同的人会显示不同的头像 可是当人扎堆的时候 问题就来了</p>

<!--more-->


<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-2.png" alt="Pic-MK-2" /></p>

<p>当人多的时候(例如上图所示) 地图滑动起来就能感觉到明显顿卡 那种不流畅感能折磨死人 所以 自然我们要解决这个问题(等等 先不要吐槽为什么不用地图聚合 因为这已经是地图放到最大了 聚合不适合这次的问题讨论)</p>

<h2>分析</h2>

<p>首先看下我是怎么实现这个annotationView的 由于这个annotationsView是异形的(也就是无法通过设置圆角直接得到) 而且里面的图片还因用户而异 所以解决方案就是使用layer.mask来进行遮罩 代码如下</p>

<pre><code>@implementation MMAnnotationView

- (instancetype)initWithAnnotation:(id&lt;MKAnnotation&gt;)annotation reuseIdentifier:(NSString *)reuseIdentifier
{
    self = [super initWithAnnotation:annotation reuseIdentifier:reuseIdentifier];
    if ( self )
    {
        self.frame = CGRectMake(0, 0, TRACK_ANNOTATION_SIZE.width, TRACK_ANNOTATION_SIZE.height);
        self.centerOffset = CGPointMake(0, -(TRACK_ANNOTATION_SIZE.height-3)/2);
        self.canShowCallout = NO;

        self.avatarView = [[UIImageView alloc] initWithFrame:self.bounds];
        [self addSubview:self.avatarView];
        self.avatarView.contentMode = UIViewContentModeScaleAspectFill;

        CAShapeLayer *shapelayer = [CAShapeLayer layer];
        shapelayer.frame = self.bounds;
        shapelayer.path = self.framePath.CGPath;
        self.avatarView.layer.mask = shapelayer;

        self.layer.shadowPath = self.framePath.CGPath;
        self.layer.shadowRadius = 1.0f;
        self.layer.shadowColor = [UIColor colorWithHex:0x666666FF].CGColor;
        self.layer.shadowOpacity = 1.0f;
        self.layer.shadowOffset = CGSizeMake(0, 0);
        self.layer.masksToBounds = NO;
    }
    return self;
}

//mask路径
- (UIBezierPath *)framePath
{
    if ( !_framePath )
    {
        CGFloat arrowWidth = 14;

        CGMutablePathRef path = CGPathCreateMutable();

        CGRect rectangle = CGRectInset(CGRectMake(0, 0, CGRectGetWidth(self.bounds), CGRectGetWidth(self.bounds)), 3,3);

        CGPoint p[3] = {
        {CGRectGetMidX(self.bounds)-arrowWidth/2, CGRectGetWidth(self.bounds)-6},
        {CGRectGetMidX(self.bounds)+arrowWidth/2, CGRectGetWidth(self.bounds)-6},
        {CGRectGetMidX(self.bounds), CGRectGetHeight(self.bounds)-4}
        };

        CGPathAddRoundedRect(path, NULL, rectangle, 5, 5);
        CGPathAddLines(path, NULL, p, 3);

        CGPathCloseSubpath(path);

        _framePath = [UIBezierPath bezierPathWithCGPath:path];

        CGPathRelease(path);
    }

    return _framePath;
}
</code></pre>

<p>我用代码生成了形状路径 并以此生成了layer的mask和shadowPath
使用时 只要直接用SDWebImage设置头像就行了</p>

<pre><code>[annotationView.avatarView sd_setImageWithURL:[NSURL URLWithString:avatarURL] placeholderImage:placeHolderImage];
</code></pre>

<p>接下来用工具分析一下问题出来哪 分析性能当然是选择Instrments(用法在这里就不做介绍了) 打开Core Animation 然后运行程序 滑动地图 可以看到性能分析如下</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-3.jpg" alt="Pic-MK-3" /></p>

<p>原来平均帧数只有不到30帧 这离我们的目标60帧差得实在太远</p>

<p>再使用Debug Option来深入分析一下</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-4.png" alt="Pic-MK-4" /></p>

<p>由于MKMapView的原因 这里我们主要关心这几个选项</p>

<ul>
<li>Color Blended Layers</li>
<li>Color Misaligned Images</li>
<li>Color Offscreen-Rendered Yellow</li>
</ul>


<p>分别打开这几个选项 结果如下</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-5.png" alt="Pic-MK-5" /></p>

<p>可以看到</p>

<ul>
<li>Color Blended Layers没有问题 不过这也是正常的 由于使用了mask 没有透明的地方</li>
<li>Color Misaligned Images除了默认头像外全中 这是因为服务器上的图片大小跟显示的大小不一致 导致缩放 而默认头像则是一致的 所以没问题</li>
<li>Color Offscreen-Rendered Yellow全中 由于使用了mask 导致大量的离屏渲染 这也是性能下降的主要原因</li>
</ul>


<h2>解决</h2>

<p>问题的原因找到了 那么接下来该如何解决呢?</p>

<ul>
<li>首先mask是肯定不能用了</li>
<li><p>其次下载下来的图片我们要预处理成实际大小
那么 直接把下载下来的图片合成为我们要显示的最终结果不就ok了吗? 试试看</p>

<pre><code>  - (void)loadAnnotationImageWithURL:(NSString*)url imageView:(UIImageView*)imageView
  {
      //将合成后的图片缓存起来
      NSString *annoImageURL = url;
      NSString *annoImageCacheURL = [annoImageURL stringByAppendingString:@"cache"];

      UIImage *cacheImage = [[SDImageCache sharedImageCache] imageFromDiskCacheForKey:annoImageCacheURL];
      if ( cacheImage )
      {
          //LLLog(@"hit cache");
          imageView.image = cacheImage;
      }
      else
      {
          //LLLog(@"no cache");
          [imageView sd_setImageWithURL:[NSURL URLWithString:annoImageURL]
          placeholderImage:placeHolderImage
          completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {
          if (!error)
          {
              UIImage *annoImage = [image annotationImage];
              imageView.image = annoImage;

              [[SDImageCache sharedImageCache] storeImage:annoImage forKey:annoImageCacheURL];
              }
          }];
      }
  }

  @implementation UIImage (LJC)
  - (UIImage*) annotationImage
  {
      static UIView *snapshotView = nil;
      static UIImageView *imageView = nil;

      if ( !snapshotView )
      {
          snapshotView = [UIView new];
          snapshotView.frame = CGRectMake(0, 0, TRACK_ANNOTATION_SIZE.width, TRACK_ANNOTATION_SIZE.height);

          imageView = [UIImageView new];
          [snapshotView addSubview:imageView];
          imageView.clipsToBounds = YES;
          imageView.frame = snapshotView.bounds;
          imageView.contentMode = UIViewContentModeScaleAspectFill;

          CGFloat arrowWidth = 14;

          CGMutablePathRef path = CGPathCreateMutable();

          CGRect rectangle = CGRectInset(CGRectMake(0, 0, CGRectGetWidth(imageView.bounds), CGRectGetWidth(imageView.bounds)), 3,3);

          CGPoint p[3] = {
              {CGRectGetMidX(imageView.bounds)-arrowWidth/2, CGRectGetWidth(imageView.bounds)-6},
              {CGRectGetMidX(imageView.bounds)+arrowWidth/2, CGRectGetWidth(imageView.bounds)-6},
              {CGRectGetMidX(imageView.bounds), CGRectGetHeight(imageView.bounds)-4}
          };

          CGPathAddRoundedRect(path, NULL, rectangle, 5, 5);
          CGPathAddLines(path, NULL, p, 3);

          CGPathCloseSubpath(path);

          CAShapeLayer *shapelayer = [CAShapeLayer layer];
          shapelayer.frame = imageView.bounds;
          shapelayer.path = path;

          imageView.layer.mask = shapelayer;

          snapshotView.layer.shadowPath = path;
          snapshotView.layer.shadowRadius = 1.0f;
          snapshotView.layer.shadowColor = [UIColor colorWithHex:0x666666FF].CGColor;
          snapshotView.layer.shadowOpacity = 1.0f;
          snapshotView.layer.shadowOffset = CGSizeMake(0, 0);

          CGPathRelease(path);
      }

      imageView.image = self;

      UIGraphicsBeginImageContextWithOptions(TRACK_ANNOTATION_SIZE, NO, 0);

      [snapshotView.layer renderInContext:UIGraphicsGetCurrentContext()];

      UIImage *copied = UIGraphicsGetImageFromCurrentImageContext();
      UIGraphicsEndImageContext();

      return copied;
  }
  @end
</code></pre></li>
</ul>


<p>然后使用的时候 只要简单的如下调用就OK了</p>

<pre><code>[self loadAnnotationImageWithURL:avatarURL imageView:annotationView.avatarView];
</code></pre>

<p>看看修改之后的Instruments表现如何</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-6.png" alt="Pic-MK-6" /></p>

<ul>
<li>Color Blended Layers全中 这也是无可避免的 因为显示的就是一张带透明度的图 但是由于地图的特殊性(头像的位置变化间隔较长 所以不会经常引发合成 也没有动画) 所以这里也不是问题</li>
<li>Color Misaligned Images没问题了 因为头像已被缩放成了相同大小</li>
<li>Color Offscreen-Rendered Yellow没问题了 因为只是简单的显示了一张图片 而并没有需要离屏渲染的东西了</li>
</ul>


<p>再来看下帧数情况</p>

<p><img src="http://7xkkjz.com1.z0.glb.clouddn.com/MK-7.jpg" alt="Pic-MK-7" /></p>

<p>Oh-Yeah~ 不光帧数达到了我们的目标60帧(由于还有业务逻辑线程在后台跑 所以没有那么的稳定) 就连平均运行耗时都下降了不少 就算地图上再多显示几十个人 也不成问题了</p>

<p>原文连接：<a href="http://adad184.com/2015/07/13/improve-performance-with-mkmapview/">http://adad184.com/2015/07/13/improve-performance-with-mkmapview/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《招聘一个靠谱的iOS》面试题参考答案（上）]]></title>
    <link href="http://www.superqq.com/blog/2015/08/08/interview-ios-question-answer/"/>
    <updated>2015-08-08T00:16:38+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/08/interview-ios-question-answer</id>
    <content type="html"><![CDATA[<blockquote><p>推荐理由：最近比较🔥的关于iOS开发面试题的文章。简单喵了一眼，感觉很不错，作者sunnyxx也是个大牛。特此推荐！</p></blockquote>

<p><a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/">《招聘一个靠谱的 iOS》</a>—参考答案（上）</p>

<p>说明：面试题来源是<a href="http://weibo.com/u/1364395395">微博@我就叫Sunny怎么了</a>的这篇博文：<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>

<!--more-->


<p>出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>

<p>答案为<a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a>指正。</p>

<hr />

<h3>1. 风格纠错题</h3>

<p><img src="http://i.imgur.com/O7Zev94.png" alt="enter image description here" />
修改完的代码：</p>

<p>修改方法有很多种，现给出一种做示例：</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readonly) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<p>下面对具体修改的地方，分两部分做下介绍：<strong><em>硬伤部分</em></strong>和<strong><em>优化部分</em></strong>
。因为<strong><em>硬伤部分</em></strong>没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看<strong><em>优化部分</em></strong>。</p>

<h4><strong><em>优化部分</em></strong></h4>

<ol>
<li><p>enum建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html">Adopting Modern Objective-C</a> 一文：</p>

<p>//定义一个枚举
typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};</p></li>
<li><p>age属性的类型：应避免使用基本类型，建议使Foundation数据类型，对应关系如下：</p>

<p>int -> NSInteger
unsigned -> NSUInteger
float -> CGFloat
动画时间 -> NSTimeInterval</p></li>
</ol>


<p>同时考虑到age的特点，应使用NSUInteger，而非int。
这样做的是基于64-bit 适配考虑，详情可参考出题者的博文<a href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/">《64-bit Tips》</a>。</p>

<ol>
<li>如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。</li>
<li>doLogIn方法不应写在该类中：虽然<code>LogIn</code>的命名不太清晰，但笔者猜测是login的意思，而登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：</li>
</ol>


<blockquote><p>无论是MVC模式还是MVVM模式，业务逻辑都不应当写在Model里。</p></blockquote>

<p> （如果抛开命名规范，假设该类真的是MVVM模式里的 ViewModel ，那么UserModel这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如：login对应的应当是注册并登录的一个Button，出现login方法也可能是合理的。）</p>

<ol>
<li>doLogIn方法命名不规范：添加了多余的动词前缀。
请牢记：</li>
</ol>


<blockquote><p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用<code>do</code>，<code>does</code>这种多余的关键字，动词本身的暗示就足够了。
 11. <code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中不要用<code>with</code>来连接两个参数:<code>withAge:</code>应当换为<code>age:</code>，<code>age:</code>已经足以清晰说明参数的作用，也不建议用<code>andAge:</code>：通常情况下，即使有类似<code>withA:withB:</code>的命名需求，也通常是使用<code>withA:andB:</code>这种命名，用来表示方法执行了两个相对独立的操作（<em>从设计上来说，这时候也可以拆分成两个独立的方法</em>），它不应该用作阐明有多个参数，比如下面的：</p></blockquote>

<pre><code>//错误，不要使用"and"来连接参数
- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;
//错误，不要使用"and"来阐明有多个参数
- (instancetype)initWithName:(CGFloat)width andAge:(CGFloat)height;
//正确，使用"and"来表示两个相对独立的操作
- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;
</code></pre>

<ol>
<li>由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为copy。(原因在下文有详细论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？</em></strong>)</li>
<li>“性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？</li>
</ol>


<p> Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：</p>

<pre><code>// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
//

@implementation CYLUser

- (instancetype)initWithName:(NSString *)name
                         age:(NSUInteger)age
                         sex:(CYLSex)sex {
    if(self = [super init]) {
        _name = [name copy];
        _age = age;
        _sex = sex;
    }
    return self;
}

- (instancetype)initWithName:(NSString *)name
                         age:(NSUInteger)age {
    return [self initWithName:name age:age sex:nil];
}

@end
</code></pre>

<p> 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。</p>

<p>  因为出题者没有给出.m文件，所以有两种猜测：1：本来打算只设计一个designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为readwrite属性，最终给出的修改代码应该是：</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 第二种修改方法（基于第一种修改方法的基础上）

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readwrite) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<p> .h中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳&ndash;》 <a href="http://is.gd/OQ49zk"><strong><em>《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》</em></strong></a>。）</p>

<ol>
<li>按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为instancetype，为保持一致性，init方法和快捷构造方法的返回类型最好都用instancetype。</li>
<li><p>如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:
那么在设计对应@property时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样</p>

<pre><code>  @property (nonatomic, copy, readonly) NSString *name;
  @property (nonatomic, assign, readonly) NSUInter age;
  @property (nonatomic, assign, readonly) CYLSex sex;
由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。
</code></pre></li>
<li><code>initUserModelWithUserName</code>如果改为<code>initWithName</code>会更加简洁，而且足够清晰。</li>
<li><code>UserModel</code>如果改为<code>User</code>会更加简洁，而且足够清晰。</li>
<li><code>UserSex</code>如果改为<code>Sex</code>会更加简洁，而且足够清晰。</li>
</ol>


<h4><strong><em>硬伤部分</em></strong></h4>

<ol>
<li>在-和(void)之间应该有一个空格</li>
<li>enum中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。</li>
<li>enum左括号前加一个空格，或者将左括号换到下一行</li>
<li>enum右括号后加一个空格</li>
<li><code>UserModel :NSObject</code> 应为<code>UserModel : NSObject</code>，也就是<code>:</code>右侧少了一个空格。</li>
<li>@interface与@property属性声明中间应当间隔一行。</li>
<li>两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。</li>
<li><p><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中方法名与参数之间多了空格。而且<code>-</code> 与<code>(id)</code>之间少了空格。</p></li>
<li><p><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中方法名与参数之间多了空格：<code>(NSString*)name</code>前多了空格。</p></li>
<li><p><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中<code>(NSString*)name</code>,应为<code>(NSString *)name</code>，少了空格。</p></li>
<li>doLogIn方法命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。</li>
<li>第二个@property中assign和nonatomic调换位置。</li>
</ol>


<h3>2. 什么情况使用 weak 关键字，相比 assign 有什么不同？</h3>

<p>什么情况使用 weak 关键字？</p>

<ol>
<li><p>在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性</p></li>
<li><p>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong。在下文也有论述：<strong><em>《IBOutlet连出来的视图属性为什么可以被设置成weak?》</em></strong></p></li>
</ol>


<p>不同点：</p>

<ol>
<li><p><code>weak</code> 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，
然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。
而 <code>assign</code> 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或
NSlnteger 等)的简单赋值操作。</p></li>
<li><p>assigin 可以用非OC对象,而weak必须用于OC对象</p></li>
</ol>


<h3>3. 怎么用 copy 关键字？</h3>

<p>用途：</p>

<ol>
<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>
<li>block也经常使用copy关键字，具体原因见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12">官方文档：<strong><em>Objects Use Properties to Keep Track of Blocks</em></strong></a>：</li>
</ol>


<p> block使用copy是从MRC遗留下来的“传统”,在MRC中,方法内部的block是在栈区的,使用copy可以把它放到堆区.在ARC中写不写都行：对于block使用copy还是strong效果是一样的，但写上copy也无伤大雅，还能时刻提醒我们：编译器自动对block进行了copy操作。</p>

<p> <img src="http://i.imgur.com/VlVKl8L.png" alt="enter image description here" /></p>

<p>下面做下解释：
copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>

<blockquote><p>用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote>

<p>该问题在下文中也有论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</em></strong></p>

<h3>4. 这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></h3>

<p>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为copy就是复制一个不可变NSArray的对象；2、使用了atomic属性会严重影响性能 ；</p>

<p>第1条的相关原因在下文中有论述<strong><em>《用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？》</em></strong> 以及上文<strong><em>《怎么用 copy 关键字？》</em></strong>也有论述。</p>

<p>比如下面的代码就会发生崩溃</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 下面的代码就会发生崩溃

@property (nonatomic, copy) NSMutableArray *mutableArray;



// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 下面的代码就会发生崩溃

NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];
self.mutableArray = array;
[self.mutableArray removeObjectAtIndex:0];
</code></pre>

<p>接下来就会奔溃：</p>

<pre><code>-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460
</code></pre>

<p>第2条原因，如下：</p>

<blockquote><p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明nonatomic可以节省这些虽然很小但是不必要额外开销。</p></blockquote>

<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备nonatomic特质，那它就是“原子的”(atomic))。</p>

<p>在iOS开发中，你会发现，几乎所有属性都声明为nonatomic。</p>

<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。</p>

<p>因此，开发iOS程序时一般都会使用nonatomic属性。但是在开发Mac OS X程序时，使用
atomic属性通常都不会有性能瓶颈。</p>

<h3>5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3>

<blockquote><p>若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopyiog与NSMutableCopying协议。</p></blockquote>

<p>具体步骤：</p>

<ol>
<li>需声明该类遵从NSCopying协议</li>
<li><p>实现NSCopying协议。该协议只有一个方法:</p>

<ul>
<li>(id)copyWithZone: (NSZone*) zone</li>
</ul>
</li>
</ol>


<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是“copyWithZone”方法。</p>

<p>以第一题的代码为例：</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 修改完的代码

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readonly) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

@end
</code></pre>

<p>然后实现协议中规定的方法：</p>

<pre><code>- (id)copyWithZone:(NSZone *)zone {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    return copy;
}
</code></pre>

<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如CYLUser中含有一个数组，与其他CYLUser对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 以第一题《风格纠错题》里的代码为例

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, copy, readonly) NSString *name;
@property (nonatomic, assign, readonly) NSUInteger age;
@property (nonatomic, assign, readonly) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
- (void)addFriend:(CYLUser *)user;
- (void)removeFriend:(CYLUser *)user;

@end
</code></pre>

<p>// .m文件</p>

<pre><code>// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 

@implementation CYLUser {
    NSMutableSet *_friends;
}

- (void)setName:(NSString *)name {
    _name = [name copy];
}

- (instancetype)initWithName:(NSString *)name 
                             age:(NSUInteger)age 
                             sex:(CYLSex)sex {
     if(self = [super init]) {
        _name = [name copy];
        _age = age;
        _sex = sex;
        _friends = [[NSMutableSet alloc] init];
     }
     return self;
}

- (void)addFriend:(CYLUser *)user {
    [_friends addObject:user];
}

- (void)removeFriend:(CYLUser *)user {
    [_friends removeObject:person];
}

- (id)copyWithZone:(NSZone *)zone {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    copy-&gt;_friends = [_friends mutableCopy];
    return copy;
}

- (id)deepCopy {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends 
                                             copyItems:YES];
    return copy;
}

@end
</code></pre>

<p>以上做法能满足基本的需求，但是也有缺陷：</p>

<blockquote><p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p></blockquote>

<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</em></strong>】</p>

<p>在例子中，存放朋友对象的set是用“copyWithZooe:”方法来拷贝的，这种浅拷贝方式不会逐个复制set中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>

<pre><code>- (id)deepCopy {
    CYLUser *copy = [[[self copy] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends 
                                             copyItems:YES];
    return copy;
}
</code></pre>

<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>

<p>如果抛开本例来回答的话，如下：</p>

<pre><code>- (void)setName:(NSString *)name {
    _name = [name copy];
}
</code></pre>

<p>如果单单就上文的代码而言，我们不需要也不能重写name的 setter ：由于是name是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”&ndash;copy，是因为：如果不写copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效。）。</p>

<p>那如何确保name被copy？在初始化方法(initializer)中做：</p>

<pre><code>- (instancetype)initWithName:(NSString *)name 
                             age:(NSUInteger)age 
                             sex:(CYLSex)sex {
     if(self = [super init]) {
        _name = [name copy];
        _age = age;
        _sex = sex;
        _friends = [[NSMutableSet alloc] init];
     }
     return self;
}
</code></pre>

<h3>6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3>

<p><strong>@property 的本质是什么？</strong></p>

<blockquote><p>@property = ivar + getter + setter;</p></blockquote>

<p>下面解释下：</p>

<blockquote><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p></blockquote>

<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为<code>Objective-C 2.0</code>的一部分。
而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。
正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>

<blockquote><p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。
所以你也可以这么说：</p>

<p>@property = getter + setter;</p></blockquote>

<p>例如下面这个类：</p>

<pre><code>@interface Person : NSObject 
@property NSString *firstName; 
@property NSString *lastName; 
@end 
</code></pre>

<p>上述代码写出来的类与下面这种写法等效：</p>

<pre><code>@interface Person : NSObject 
- (NSString *)firstName; 
- (void)setFirstName:(NSString *)firstName; 
- (NSString *)lastName; 
- (void)setLastName:(NSString *)lastName; 
@end 
</code></pre>

<p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>

<blockquote><p>“自动合成”( autosynthesis)</p></blockquote>

<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”( autosynthesis)。需要强调的是，这个过程由编译
器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为
<code>_firstName</code>与<code>_lastName</code>。也可以在类的实现代码里通过
@synthesize语法来指定实例变量的名字.</p>

<pre><code>@implementation Person 
@synthesize firstName = _myFirstName; 
@synthesize lastName = myLastName; 
@end 
</code></pre>

<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>

<ol>
<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter与getter方法对应的实现函数</li>
<li><code>ivar_list</code> ：成员变量列表</li>
<li><code>method_list</code> ：方法列表</li>
<li><code>prop_list</code> ：属性列表</li>
</ol>


<p>也就是说我们每次在增加一个属性,系统都会在<code>ivar_list</code>中添加一个成员变量的描述,在<code>method_list</code>中增加setter与getter方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出setter与getter方法对应的实现,在setter方法中从偏移量的位置开始赋值,在getter方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>

<h3>7. @protocol 和 category 中如何使用 @property</h3>

<ol>
<li>在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>
<li><p>category 使用 @property 也是只会生成setter和getter方法的声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数：</p></li>
<li><p><code>objc_setAssociatedObject</code></p></li>
<li><code>objc_getAssociatedObject</code></li>
</ol>


<h3>8. runtime 如何实现 weak 属性</h3>

<p>要实现weak属性，首先要搞清楚weak属性的特点：</p>

<blockquote><p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<p>那么runtime如何实现weak变量的自动置nil？</p>

<blockquote><p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p></blockquote>

<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>

<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>

<p><code>objc_storeWeak</code>函数把第二个参数&ndash;赋值对象（b）的内存地址作为键值key，将第一个参数&ndash;weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>

<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>

<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>

<p>而如果a是由assign修饰的，则：
在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>

<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>

<pre><code>// 使用伪代码模拟：runtime如何实现weak属性
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong

 id obj1;
 objc_initWeak(&amp;obj1, obj);
/*obj引用计数变为0，变量作用域结束*/
 objc_destroyWeak(&amp;obj1);
</code></pre>

<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>

<p>总体说来，作用是：
通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>

<p>下面分别介绍下方法的内部实现：</p>

<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<pre><code>obj1 = 0；
obj_storeWeak(&amp;obj1, obj);
</code></pre>

<p>也就是说：</p>

<blockquote><p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p></blockquote>

<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>

<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>

<p>前面的源代码与下列源代码相同。</p>

<pre><code>// 使用伪代码模拟：runtime如何实现weak属性
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong

id obj1;
obj1 = 0;
objc_storeWeak(&amp;obj1, obj);
/* ... obj的引用计数变为0，被置nil ... */
objc_storeWeak(&amp;obj1, 0);
</code></pre>

<p><code>objc_storeWeak</code>函数把第二个参数&ndash;赋值对象（obj）的内存地址作为键值，将第一个参数&ndash;weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除，在后面的相关一题会详解。</p>

<p>使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：</p>

<blockquote><p>如何让不使用weak修饰的@property，拥有weak的效果。</p></blockquote>

<p>我们从setter方法入手：</p>

<pre><code>- (void)setObject:(NSObject *)object
{
    objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
    [object cyl_runAtDealloc:^{
        _object = nil;
    }];
}
</code></pre>

<p>也就是有两个步骤：</p>

<ol>
<li><p>在setter方法中做如下设置：</p>

<pre><code>objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
</code></pre></li>
<li><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助runtime：</p>

<p>//要销毁的目标对象
id objectToBeDeallocated;
//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。
id objectWeWantToBeReleasedWhenThatHappens;
objc_setAssociatedObject(objectToBeDeallocted,
                         someUniqueKey,
                         objectWeWantToBeReleasedWhenThatHappens,
                         OBJC_ASSOCIATION_RETAIN);</p></li>
</ol>


<p>知道了思路，我们就开始实现<code>cyl_runAtDealloc</code>方法，实现过程分两部分：</p>

<p>第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</p>

<pre><code>// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。

typedef void (^voidBlock)(void);

@interface CYLBlockExecutor : NSObject 

- (id)initWithBlock:(voidBlock)block;

@end


// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。

#import "CYLBlockExecutor.h"

@interface CYLBlockExecutor() {
    voidBlock _block;
}
@implementation CYLBlockExecutor

- (id)initWithBlock:(voidBlock)aBlock
{
    self = [super init];

    if (self) {
        _block = [aBlock copy];
    }

    return self;
}

- (void)dealloc
{
    _block ? _block() : nil;
}

@end
</code></pre>

<p>第二部分：核心代码：利用runtime实现<code>cyl_runAtDealloc</code>方法</p>

<pre><code>// CYLNSObject+RunAtDealloc.h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 利用runtime实现cyl_runAtDealloc方法

#import "CYLBlockExecutor.h"

const void *runAtDeallocBlockKey = &amp;runAtDeallocBlockKey;

@interface NSObject (CYLRunAtDealloc)

- (void)cyl_runAtDealloc:(voidBlock)block;

@end


// CYLNSObject+RunAtDealloc.m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 利用runtime实现cyl_runAtDealloc方法

#import "CYLNSObject+RunAtDealloc.h"
#import "CYLBlockExecutor.h"

@implementation NSObject (CYLRunAtDealloc)

- (void)cyl_runAtDealloc:(voidBlock)block
{
    if (block) {
        CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];

        objc_setAssociatedObject(self,
                                 runAtDeallocBlockKey,
                                 executor,
                                 OBJC_ASSOCIATION_RETAIN);
    }
}

@end
</code></pre>

<p>使用方法：
导入</p>

<pre><code>#import "CYLNSObject+RunAtDealloc.h"
</code></pre>

<p>然后就可以使用了：</p>

<pre><code>    NSObject *foo = [[NSObject alloc] init];

    [foo cyl_runAtDealloc:^{
        NSLog(@"正在释放foo!");
    }];
</code></pre>

<p>如果对<code>cyl_runAtDealloc</code>的实现原理有兴趣，可以看下这篇博文 <a href="http://stackoverflow.com/a/31560217/3395008"><strong><em>Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object</em></strong></a></p>

<h3>9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h3>

<p>属性可以拥有的特质分为四类:</p>

<ol>
<li><p>原子性&mdash;<code>nonatomic</code>特质</p>

<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备nonatomic特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p></li>
<li><p>读/写权限&mdash;<code>readwrite(读写)</code>、<code>readooly (只读)</code></p></li>
<li>内存管理语义&mdash;<code>assign</code>、<code>strong</code>、 <code>weak</code>、<code>unsafe_unretained</code>、<code>copy</code></li>
<li>方法名&mdash;<code>getter=&lt;name&gt;</code> 、<code>setter=&lt;name&gt;</code></li>
</ol>


<p>  <code>getter=&lt;name&gt;</code>的样式：</p>

<pre><code>    @property (nonatomic, getter=isOn) BOOL on;
</code></pre>

<p>（ <code>setter=&lt;name&gt;</code>这种不常用，也不推荐使用。故不在这里给出写法。）
 3. 不常用的：<code>nonnull</code>,<code>null_resettable</code>,<code>nullable</code></p>

<h3>10. weak属性需要在dealloc中置nil么？</h3>

<p>不需要。</p>

<blockquote><p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</p></blockquote>

<p>即便是编译器不帮我们做这些，weak也不需要在dealloc中置nil：</p>

<p>正如上文的：<strong><em>runtime 如何实现 weak 属性</em></strong> 中提到的：</p>

<p>我们模拟下weak的setter方法，应该如下：</p>

<pre><code>- (void)setObject:(NSObject *)object
{
    objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
    [object cyl_runAtDealloc:^{
        _object = nil;
    }];
}
</code></pre>

<p>也即:</p>

<blockquote><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p></blockquote>

<h3>11. @synthesize和@dynamic分别有什么作用？</h3>

<ol>
<li>@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是<code>@syntheszie var = _var;</code></li>
<li>@synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic告诉编译器：属性的setter与getter方法由用户自己实现，不自动生成。（当然对于readonly的属性只需提供getter即可）。假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到<code>instance.var = someVar</code>，由于缺setter方法会导致程序崩溃；或者当运行到 <code>someVar = var</code>时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ol>


<h3>12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3>

<ol>
<li>对应基本数据类型默认关键字是</li>
</ol>


<p> atomic,readwrite,assign
 2. 对于普通的OC对象</p>

<p> atomic,readwrite,strong</p>

<p>参考链接：</p>

<ol>
<li><p><a href="http://stackoverflow.com/a/15541801/3395008"> <strong><em>Objective-C ARC: strong vs retain and weak vs assign</em></strong> </a></p></li>
<li><p><a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html"> <strong><em>Variable property attributes or Modifiers in iOS</em></strong> </a></p></li>
</ol>


<h3>13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3>

<ol>
<li>因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li>如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</li>
</ol>


<p>copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>

<p>为了理解这种做法，首先要知道，对非集合类对象的copy操作：</p>

<p>在非集合类对象中：对immutable对象进行copy操作，是指针复制，mutableCopy操作时内容复制；对mutable对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：</p>

<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>


<p>比如以下代码：</p>

<pre><code>NSMutableString *string = [NSMutableString stringWithString:@"origin"];//copy
NSString *stringCopy = [string copy]; 
</code></pre>

<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>

<pre><code>[string appendString:@"origion!"]
</code></pre>

<p>stringCopy的值也不会因此改变，但是如果不使用copy，stringCopy的值就会被改变。
  集合类对象以此类推。
所以，</p>

<blockquote><p>用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote>

<p>参考链接：<a href="https://www.zybuluo.com/MicroCai/note/50592">iOS 集合的深复制与浅复制</a></p>

<h3>14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为<code>_foo</code>的实例变量，那么还会自动合成新变量么？</h3>

<p>在回答之前先说明下一个概念：</p>

<blockquote><p>实例变量 = 成员变量 ＝ ivar</p></blockquote>

<p>这些说法，笔者下文中，可能都会用到，指的是一个东西。</p>

<p>正如
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6">Apple官方文档 <strong><em>You Can Customize Synthesized Instance Variable Names</em></strong></a> 所说：
<img src="http://i.imgur.com/D6d0zGJ.png" alt="enter image description here" /></p>

<p>如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</p>

<pre><code>@interface CYLPerson : NSObject 
@property NSString *firstName; 
@property NSString *lastName; 
@end
</code></pre>

<p>在上例中，会生成两个实例变量，其名称分别为
<code>_firstName</code>与<code>_lastName</code>。也可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字:</p>

<pre><code>@implementation CYLPerson 
@synthesize firstName = _myFirstName; 
@synthesize lastName = _myLastName; 
@end 
</code></pre>

<p>上述语法会将生成的实例变量命名为<code>_myFirstName</code>与<code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>

<p>总结下@synthesize合成实例变量的规则，有以下几点：</p>

<ol>
<li><p>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,</p></li>
<li><p>如果这个成员已经存在了就不再生成了.</p></li>
<li>如果是 <code>@synthesize foo;</code> 还会生成一个名称为foo的成员变量，也就是说：</li>
</ol>


<blockquote><p>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,</p></blockquote>

<ol>
<li>如果是 <code>@synthesize foo = _foo;</code> 就不会生成成员变量了.</li>
</ol>


<p>假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？
不会。如下图：</p>

<p><img src="http://i.imgur.com/t28ge4W.png" alt="enter image description here" /></p>

<h3>15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3>

<p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p>

<ol>
<li>同时重写了setter和getter时</li>
<li>重写了只读属性的getter时</li>
<li>使用了@dynamic时</li>
<li>在 @protocol 中定义的所有属性</li>
<li>在 category 中定义的所有属性</li>
<li>重载的属性</li>
</ol>


<p> 当你在子类中重载了父类中的属性，你必须 使用<code>@synthesize</code>来手动合成ivar。</p>

<p>除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理@property的所有内容时，你就会尝试通过实现@property的所有“存取方法”（the accessor methods）或者使用<code>@dynamic</code>来达到这个目的，这时编译器就会认为你打算手动管理@property，于是编译器就禁用了autosynthesis（自动合成）。</p>

<p>因为有了autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于autosynthesis（自动合成），但是一旦你需要使用ivar，而autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助<code>@synthesize</code>来手动合成ivar。</p>

<p>其实，<code>@synthesize</code>语法还有一个应用场景，但是不太建议大家使用：</p>

<p>可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字:</p>

<pre><code>@implementation CYLPerson 
@synthesize firstName = _myFirstName; 
@synthesize lastName = _myLastName; 
@end 
</code></pre>

<p>上述语法会将生成的实例变量命名为<code>_myFirstName</code>与<code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>

<p>举例说明：应用场景：</p>

<pre><code>//
// .m文件
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 打开第14行和第17行中任意一行，就可编译成功

@import Foundation;

@interface CYLObject : NSObject
@property (nonatomic, copy) NSString *title;
@end

@implementation CYLObject {
//    NSString *_title;
}

//@synthesize title = _title;

- (instancetype)init
{
    self = [super init];
    if (self) {
        _title = @"微博@iOS程序犭袁";
    }
    return self;
}

- (NSString *)title {
    return _title;
}

- (void)setTitle:(NSString *)title {
    _title = [title copy];
}

@end
</code></pre>

<p>结果编译器报错：
<img src="http://i.imgur.com/fAEGHIo.png" alt="enter image description here" /></p>

<p>当你同时重写了setter和getter时，系统就不会生成ivar（实例变量/成员变量）。这时候有两种选择：</p>

<ol>
<li>要么如第14行：手动创建ivar</li>
<li>要么如第17行：使用<code>@synthesize foo = _foo;</code> ，关联@property与ivar。</li>
</ol>


<p>更多信息，请戳- 》<a href="http://stackoverflow.com/a/19821816/3395008"> <strong><em>When should I use @synthesize explicitly?</em></strong> </a></p>

<h3>16. objc中向一个nil对象发送消息将会发生什么？</h3>

<p>在Objective-C中向nil发送消息是完全有效的——只是在运行时不会有任何作用:</p>

<ol>
<li><p>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：</p>

<p>Person * motherInlaw = [[aPerson spouse] mother];</p></li>
</ol>


<p> 如果spouse对象为nil，那么发送给nil的消息mother也将返回nil。
 2. 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。
 2. 如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0。
 2. 如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。</p>

<p>具体原因如下：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>

<pre><code>// runtime.h（类在runtime中的定义）
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong

struct objc_class {
  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object
  #if !__OBJC2__
  Class super_class OBJC2_UNAVAILABLE; // 父类
  const char *name OBJC2_UNAVAILABLE; // 类名
  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0
  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识
  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小
  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表
  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表
  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。
  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表
  #endif
  } OBJC2_UNAVAILABLE;
</code></pre>

<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。
那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>

<h3>17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h3>

<p>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.如果我没有记错的大概是这样的：</p>

<pre><code>((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName("foo"));
</code></pre>

<p>也就是说：</p>

<blockquote><p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p></blockquote>

<h3>18. 什么时候会报unrecognized selector的异常？</h3>

<p>简单来说：</p>

<blockquote><p>当使用某对象上的某个方法,而该对象上没有实现这个方法的时候，
可以通过“消息转发”进行解决。</p></blockquote>

<p>简单的流程如下，在上一题中也提到过：</p>

<blockquote><p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p></blockquote>

<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>

<ol>
<li>Method resolution</li>
</ol>


<p> objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回 YES，那运行时系统就会重新启动一次消息发送的过程，如果 resolve 方法返回 NO ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>

<ol>
<li>Fast forwarding</li>
</ol>


<p> 如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。
这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。
 3. Normal forwarding</p>

<p> 这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>

<h3>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3>

<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li><p>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</p></li>
<li><p>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</p></li>
<li>成员变量的列表,</li>
<li>属性列表,</li>
</ul>


<p> 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>

<p> <img src="http://i.imgur.com/7mJlUj1.png" alt="enter image description here" /></p>

<ul>
<li><p>根对象就是NSobject，它的superclass指针指向nil</p></li>
<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p></li>
</ul>


<p>如图:
<img src="http://i.imgur.com/w6tzFxz.png" alt="enter image description here" /></p>

<h3>20. 一个objc对象的isa的指针指向什么？有什么作用？</h3>

<p>指向他的类对象,从而可以找到对象上的方法</p>

<h3>21. 下面的代码输出什么？</h3>

<pre><code>@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
</code></pre>

<p><strong>答案：</strong></p>

<p>都输出 Son</p>

<pre><code>NSStringFromClass([self class]) = Son
NSStringFromClass([super class]) = Son
</code></pre>

<p><strong>解惑：</strong></p>

<p>（以下解惑部分摘自<a href="http://weibo.com/junbbcom">微博@Chun_iOS</a>的博文<a href="http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1">刨根问底Objective－C Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)）</p>

<p>这个题目主要是考察关于objc中对 self 和 super 的理解。</p>

<p>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。</p>

<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>

<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>

<p>真的是这样吗？继续看：</p>

<p>使用clang重写命令:</p>

<pre><code>$ clang -rewrite-objc test.m
</code></pre>

<p>发现上述代码被转化为:</p>

<pre><code>NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName("class"))));

NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass("Son")) }, sel_registerName("class"))));
</code></pre>

<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>

<pre><code>id objc_msgSend(id self, SEL op, ...)
</code></pre>

<p>我们把 self 做为第一个参数传递进去。</p>

<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>

<pre><code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</code></pre>

<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>

<pre><code>struct objc_super {
   __unsafe_unretained id receiver;
   __unsafe_unretained Class super_class;
};
</code></pre>

<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>

<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>

<p>objc Runtime开源代码对- (Class)class方法的实现:</p>

<pre><code>- (Class)class {
    return object_getClass(self);
}
</code></pre>

<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。
第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。
第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，
此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>

<h3>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3>

<p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>

<h3>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3>

<ul>
<li>在ARC下不需要。</li>
<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>
</ul>


<blockquote><p>无论在MRC下还是ARC下均不需要。</p></blockquote>

<p><a href="https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html"> <strong><em>2011年版本的Apple API 官方文档 - Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>

<pre><code>// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 摘自2011年版本的Apple API 官方文档 - Associative References 

static char overviewKey;

NSArray *array =
    [[NSArray alloc] initWithObjects:@"One", @"Two", @"Three", nil];
// For the purposes of illustration, use initWithFormat: to ensure
// the string can be deallocated
NSString *overview =
    [[NSString alloc] initWithFormat:@"%@", @"First three numbers"];

objc_setAssociatedObject (
    array,
    &amp;overviewKey,
    overview,
    OBJC_ASSOCIATION_RETAIN
);

[overview release];
// (1) overview valid
[array release];
// (2) overview invalid
</code></pre>

<p>文档指出</p>

<blockquote><p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p></blockquote>

<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>

<p>既然会被销毁，那么具体在什么时间点？</p>

<blockquote><p>根据<a href="https://developer.apple.com/videos/wwdc/2011/#322-video"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p></blockquote>

<p>对象的内存销毁时间表，分四个步骤：</p>

<pre><code>// 对象的内存销毁时间表
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 

// 1. 调用 -release ：引用计数变为零
//     * 对象正在被销毁，生命周期即将结束.
//     * 不能再有新的 __weak 弱引用， 否则将指向 nil.
//     * 调用 [self dealloc] 
// 2. 父类 调用 -dealloc
//     * 继承关系中最底层的父类 在调用 -dealloc
//     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）
//     * 继承关系中每一层的父类 都在调用 -dealloc
// 3. NSObject 调 -dealloc
//     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法
// 4. 调用 object_dispose()
//     * 为 C++ 的实例变量们（iVars）调用 destructors 
//     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
//     * 解除所有使用 runtime Associate方法关联的对象
//     * 解除所有 __weak 引用
//     * 调用 free()
</code></pre>

<p>（<a href="http://stackoverflow.com/a/10843510/3395008">对象的内存销毁时间表参考链接</a>）</p>

<h3>24. objc中的类方法和实例方法有什么本质区别和联系？</h3>

<p>类方法：</p>

<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ol>


<p>实例方法：</p>

<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>


<h2>下一篇文章将发布在<a href="https://github.com/ChenYilong/iOSInterviewQuestions">这里</a>，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注<a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a></h2>

<p>@property部分主要参考
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2">Apple官方文档：Properties Encapsulate an Object’s Values</a>
runtime部分主要参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html">Apple官方文档：Declared Properties</a></p>

<h3>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3>

<h3>26. runtime如何实现weak变量的自动置nil？</h3>

<h3>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3>

<h3>28. runloop和线程有什么关系？</h3>

<h3>29. runloop的mode作用是什么？</h3>

<h3>30. 以+ scheduledTimerWithTimeInterval&hellip;的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3>

<h3>31. 猜想runloop内部是如何实现的？</h3>

<h3>32. objc使用什么机制管理对象内存？</h3>

<h3>33. ARC通过什么方式帮助开发者管理内存？</h3>

<h3>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3>

<h3>35. <code>BAD_ACCESS</code>在什么情况下出现？</h3>

<h3>36. 苹果是如何实现autoreleasepool的？</h3>

<h3>37. 使用block时什么情况会发生引用循环，如何解决？</h3>

<h3>38. 在block内如何修改block外部变量？</h3>

<h3>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3>

<h3>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3>

<h3>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3>

<h3>42. <code>dispatch_barrier_async</code>的作用是什么？</h3>

<h3>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3>

<h3>44. 以下代码运行结果如何？</h3>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
</code></pre>

<h3>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3>

<h3>46. 如何手动触发一个value的KVO</h3>

<h3>47. 若一个类有实例变量<code>NSString *_foo</code>，调用setValue:forKey:时，可以以foo还是<code>_foo</code>作为key？</h3>

<h3>48. KVC的keyPath中的集合运算符如何使用？</h3>

<h3>49. KVC和KVO的keyPath一定是属性么？</h3>

<h3>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3>

<h3>51. apple用什么方式实现对一个对象的KVO？</h3>

<h3>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3>

<h3>53. IB中User Defined Runtime Attributes如何使用？</h3>

<h3>54. 如何调试<code>BAD_ACCESS</code>错误</h3>

<h3>55. lldb（gdb）常用的调试命令？</h3>

<hr />

<p>Posted by <a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a><br/>
原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">Creative Commons BY-NC-ND 3.0</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现placeholder属性的UITextView]]></title>
    <link href="http://www.superqq.com/blog/2015/08/07/implement-uitextview-placeholder/"/>
    <updated>2015-08-07T00:27:43+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/07/implement-uitextview-placeholder</id>
    <content type="html"><![CDATA[<p>iOS开发微信公众号上的iOS技术文章，都将发布在<a href="http://www.superqq.com/">刚刚在线</a>。所以大家可以到我的网站上查看之前的文章，也可以在底部的精彩文章查看历史文章。</p>

<p>上一篇文章<a href="http://www.superqq.com/blog/2015/08/06/uitextview-placeholder-practice/">UITextView实现placeholder的猥琐做法</a>讲了关于<code>UITextView</code>的<code>placeholder</code>实现原理。大家都一致认为做法比较猥琐。</p>

<!--more-->


<p>那么，这一次我将简单的封装一个<code>UITextView</code>。暂且取名叫<code>GGPlaceholderTextView</code>，GG前缀看着有点任性的哈。</p>

<h2>GGPlaceholderTextView简介</h2>

<p><code>GGPlaceholderTextView</code>也是对<code>text</code>操作，具体逻辑如下：</p>

<ol>
<li>继承<code>UITextView</code>，并设置<code>placeholder</code>属性</li>
<li>注册开始编辑和结束编辑通知，然后对<code>text</code>做相应的操作</li>
<li>通过<code>UIApplicationWillTerminateNotification</code>通知，在APP退出的时候移除通知。</li>
</ol>


<p>我把<code>GGPlaceholderTextView</code>写在下面。不过，微信里看代码还是不太方便，我已经把代码push到:<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a>。你可以下载下来。</p>

<h2>GGPlaceholderTextView.h</h2>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface GGPlaceholderTextView : UITextView
@property(nonatomic, strong) NSString *placeholder;

@end
</code></pre>

<p>定义<code>placeholder</code>属性，类似于<code>UITextField</code>。</p>

<h2>GGPlaceholderTextView.m</h2>

<pre><code>#import "GGPlaceholderTextView.h"

@implementation GGPlaceholderTextView

- (id)initWithFrame:(CGRect)frame {
    if (self = [super initWithFrame:frame]) {
        [self addObserver];
    }
    return self;
}

- (id)init {
    if (self = [super init]) {
        [self addObserver];
    }
    return self;
}

- (void)setPlaceholder:(NSString *)placeholder
{
    _placeholder = placeholder;
    self.text = placeholder;
    self.textColor = [UIColor grayColor];
}

-(void)addObserver
{
    //注册通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didBeginEditing:) name:UITextViewTextDidBeginEditingNotification object:self];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didEndEditing:) name:UITextViewTextDidEndEditingNotification object:self];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(terminate:) name:UIApplicationWillTerminateNotification object:[UIApplication sharedApplication]];
}

- (void)terminate:(NSNotification *)notification {
    //移除通知
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

- (void)didBeginEditing:(NSNotification *)notification {
    if ([self.text isEqualToString:self.placeholder]) {
        self.text = @"";
        self.textColor = [UIColor blackColor];
    }
}

- (void)didEndEditing:(NSNotification *)notification {
    if (self.text.length&lt;1) {
        self.text = self.placeholder;
        self.textColor = [UIColor grayColor];
    }
}

@end
</code></pre>

<p>以上就是关于<code>GGPlaceholderTextView</code>的实现，如果你有类似需求，直接拿去用吧！具体用法请往下看。</p>

<h2>实践</h2>

<pre><code>GGPlaceholderTextView *textView = [[GGPlaceholderTextView alloc] initWithFrame:CGRectMake(0, 64, SCREEN.width , 200)];
textView.backgroundColor = [UIColor whiteColor];
textView.placeholder = @"关注微信公众号iOS开发：iOSDevTip";
[self.view addSubview:textView];
</code></pre>

<p>经过封装后的<code>GGPlaceholderTextView</code>，使用起来是不是跟<code>UITextField</code>非常相似。当然，我封装的比较简单，github上也有一些朋友封装带<code>placeholder</code>属性的<code>UITextView</code>。比如：TextViewPlaceholder。感兴趣的童鞋可以去试用一下。</p>

<p><strong>广告时间</strong></p>

<p>你的分享就是对我最大的支持，希望你能把iOS开发推荐给你的朋友，不甚感激！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITextView实现placeholder的猥琐做法]]></title>
    <link href="http://www.superqq.com/blog/2015/08/06/uitextview-placeholder-practice/"/>
    <updated>2015-08-06T21:37:38+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/06/uitextview-placeholder-practice</id>
    <content type="html"><![CDATA[<p>我经常写一些<a href="http://www.superqq.com/">iOS开发</a>的小技巧，为了在自己需要的时候能用得上，也希望能对正在看文章的你一些帮助，亦或是引发一些思考。</p>

<p>如果你觉得文章对你有帮助，请多多分享。你身边一定有很多做iOS开发的朋友，希望你能把我的iOS开发：<strong>iOSDevTip</strong>推荐给你的朋友。不甚感激！</p>

<p>我们都知道iOS开发中的<code>UITextField</code>有个<code>placeholder</code>属性，<code>placeholder</code>可以很方便引导用户输入。但是<code>UITextView</code>却没有<code>placeholder</code>属性。</p>

<h2>猥琐法分析</h2>

<p>如何让<code>UITextView</code>也有<code>placeholder</code>功能呢？今天给各位分享一个比较猥琐的做法。思路大概是这样的：</p>

<ol>
<li>把<code>UITextView</code>的<code>text</code>当<code>placeholder</code>使用。</li>
<li>在开始编辑的代理方法里清除<code>placeholder</code>。</li>
<li>在结束编辑的代理方法里在设置<code>placeholder</code>。</li>
</ol>


<!--more-->


<h2>实现方法</h2>

<h3>创建UITextView</h3>

<pre><code>UITextView *textViewPlaceholder = [[UITextView alloc] initWithFrame:CGRectMake(20, 70, SCREEN.width - 40, 100)];
textViewPlaceholder.backgroundColor = [UIColor whiteColor];
textViewPlaceholder.text = @"关注微信公众号iOS开发：iOSDevTip";
textViewPlaceholder.textColor = [UIColor grayColor];
textViewPlaceholder.delegate = self;
[self.view addSubview:textViewPlaceholder];
</code></pre>

<p>初始化<code>UITextView</code>，给<code>UITextView</code>的<code>text</code>赋值，并且给<code>UITextView</code>的<code>textColor</code>属性设置成灰色，让其看起来更像<code>placeholder</code>。</p>

<p>别忘了设置<code>UITextView</code>的代理，因为后面我们要用到<code>UITextView</code>的两个代理方法。</p>

<h3>开始编辑的代理方法</h3>

<pre><code>- (void)textViewDidBeginEditing:(UITextView *)textView {

    if ([textView.text isEqualToString:@"关注微信公众号iOS开发：iOSDevTip"]) {
        textView.text = @"";
        textView.textColor = [UIColor blackColor];
    }
}
</code></pre>

<p>在开始编辑的代理方法里面，判断如果是<code>UITextView</code>的<code>text</code>的值是<code>placeholder</code>，那么，就清空<code>text</code>，并且把<code>textColor</code>设置成真正的内容颜色，假设是黑色。</p>

<h3>结束编辑的代理方法</h3>

<pre><code>- (void)textViewDidEndEditing:(UITextView *)textView {
    if (textView.text.length&lt;1) {
        textView.text = @"关注微信公众号iOS开发：iOSDevTip";
        textView.textColor = [UIColor grayColor];
    }
}
</code></pre>

<p>在结束编辑的代理方法里，判断如果<code>UITextView</code>的<code>text</code>值为空，那么，就要把需要设置的<code>placeholder</code>赋值给<code>UITextView</code>的<code>text</code>，并且将<code>textColor</code>属性设置成灰色。</p>

<h2>添加轻击手势</h2>

<pre><code>UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapGesture:)];
tapGesture.numberOfTapsRequired = 1; //点击次数
tapGesture.numberOfTouchesRequired = 1; //点击手指数
[self.view addGestureRecognizer:tapGesture];

//轻击手势触发方法
-(void)tapGesture:(UITapGestureRecognizer *)sender
{
    [self.view endEditing:YES];
}
</code></pre>

<p>至此，就很猥琐的实现了<code>placeholder</code>功能。为了方便测试，我加了一个手势。作用是用键盘消失，这样可以测试结束编辑的时候<code>placeholder</code>会不会显示。demo地址：Demo地址:<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a></p>

<p>添加手势的方法很简单，关于iOS开发中的手势汇总，你可以看这篇文章<a href="http://www.superqq.com/blog/2015/01/14/ioskai-fa-zhi-shou-shi-shi-bie-hui-zong/">iOS开发之手势识别汇总</a>。</p>

<p>我看了网上一些实现<code>UITextView</code>的<code>placeholder</code>功能的更猥琐的做法，在<code>UITextView</code>上面盖一个<code>UILabel</code>，然后在<code>UITextView</code>的代理方法里控制<code>UILabel</code>的值。还有用两个<code>UITextView</code>实现的。</p>

<p>在这里，我只是抛砖引玉，如果你有更好的实现方法欢迎投稿给我：<strong>worldligang@163.com</strong>，下一篇文章，我将会封装一个带有<code>placeholder</code>属性的<code>UITextView</code>，敬请期待！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多个UIImage合并成一个UIImage]]></title>
    <link href="http://www.superqq.com/blog/2015/08/05/multiple-uiimage-merged/"/>
    <updated>2015-08-05T17:43:53+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/05/multiple-uiimage-merged</id>
    <content type="html"><![CDATA[<p>写了两篇关于照片保存的文章：</p>

<ol>
<li><a href="http://www.superqq.com/blog/2015/08/03/ioskai-fa-zhi-bao-cun-zhao-pian-dao-xi-tong-xiang-ce-%28photo-album%29/">iOS开发之保存照片到系统相册（Photo Album）</a></li>
<li><a href="http://www.superqq.com/blog/2015/08/04/save-photo-to-own-album/">iOS开发之保存照片到自己创建的相簿</a></li>
</ol>


<p>介绍了如何将图片保存到系统相册，也可以将照片保存到自己的相簿。里面还介绍了一个第三方<code>ALAssetsLibrary+CustomPhotoAlbum</code>保存照片的方法。</p>

<p>本篇文章将会介绍如何将多个<code>UIImage</code>合并成一个<code>UIImage</code>。听起来似乎有点晕晕乎乎的，这个可以合并吗？答案是肯定的。我们拿两个<code>UIImage</code>来举例。</p>

<!--more-->


<h2>创建两个UIImage</h2>

<pre><code>UIImage *image1 = [UIImage imageNamed:@"iOSDevTip"];
UIImage *image2 = [UIImage imageNamed:@"CodePush"];
</code></pre>

<p>创建<code>UIImage</code>的方法有很多种，我们就简单的通过<code>imageNamed:</code>方法来创建。</p>

<h2>合并之后的size</h2>

<pre><code>CGSize size = CGSizeMake(image1.size.width + image2.size.width, image1.size.height);
</code></pre>

<p>合并两个<code>UIImage</code>，需要计算合并之后的<code>size</code>。假设这两个<code>UIImage</code>的高度是是相同的，把他们的宽度相加，得到合并之后的<code>UIImage</code>的<code>size</code>。</p>

<h2>合并方法</h2>

<p>有了<code>UIImage</code>和<code>size</code>接下来就是把两个<code>UIImage</code>合并，方法如下：</p>

<pre><code> UIGraphicsBeginImageContext(size);
[image1 drawInRect:CGRectMake(0, 0, image1.size.width, size.height)];
[image2 drawInRect:CGRectMake(image1.size.width, 0, image2.size.width, size.height)];
UIImage *togetherImage = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
</code></pre>

<p>通过上述的代码，就可以实现两个<code>UIImage</code>的合并。` 这个小功能还挺有用的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之保存照片到自己创建的相簿]]></title>
    <link href="http://www.superqq.com/blog/2015/08/04/save-photo-to-own-album/"/>
    <updated>2015-08-04T22:41:08+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/04/save-photo-to-own-album</id>
    <content type="html"><![CDATA[<p>在<a href="http://www.superqq.com/">刚刚在线</a>上一篇文章<a href="http://www.superqq.com/blog/2015/08/03/ioskai-fa-zhi-bao-cun-zhao-pian-dao-xi-tong-xiang-ce-%28photo-album%29/">iOS开发之保存照片到系统相册（Photo Album）</a>，我们讲到了如何保持照片系统相册。还有其他保存的方法吗？</p>

<p>保存照片还可以用<code>ALAssetsLibrary</code>，<code>ALAssetsLibrary</code>提供了我们对iOS设备中的相片、视频的访问，是连接应用程序和相册之间访问的一个桥梁。</p>

<p>接下来，我们来详细讲解一下关于系统相册权限获取、保存照片、创建自己的相簿等等功能。</p>

<!--more-->


<h2>创建自己的相簿</h2>

<p>这也是一种比较创建的作法，创建自己的相簿，然后把照片或者视频保存到自己的相簿中。相关代码如下：</p>

<pre><code>  ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
[library addAssetsGroupAlbumWithName:@"test" resultBlock:^(ALAssetsGroup *group) {

    //创建相簿成功

} failureBlock:^(NSError *error) {
    //失败
}];
</code></pre>

<h2>保存照片</h2>

<p>这个方法也是将照片保存到系统相簿里面，不是保存到自己创建的相簿里面。代码如下：</p>

<pre><code> ALAssetsLibrary *library = [[ALAssetsLibrary alloc]init];
[library writeImageToSavedPhotosAlbum:image.CGImage orientation:(ALAssetOrientation)image.imageOrientation completionBlock:^(NSURL *asSetUrl,NSError *error){
    if (error) {
       //失败
    }else{
        UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"存储成功"
                                                       message:nil
                                                      delegate:nil
                                             cancelButtonTitle:@"确定"
                                             otherButtonTitles:nil, nil];
        [alert show];

    }
}];
</code></pre>

<h2>获取权限</h2>

<p>在保存照片之前，如果用户关闭相册权限，这个时候是保存失败的。如果你不做任何处理，用户是不会知道自己保存失败了。所以，我们可以在保存照片之前，做出相应的提示。如何获取这个权限呢？一般有两种方法：</p>

<ol>
<li><p>创建相簿失败</p></li>
<li><p>保存照片失败</p></li>
</ol>


<p>在上面两个方法<strong>创建自己的相簿</strong>和<strong>保存照片</strong>的失败结果里，我们可以弹出获取照片权限失败的提示。我们拿第一个创建相簿失败来举例：</p>

<pre><code>ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
[library addAssetsGroupAlbumWithName:@"test" resultBlock:^(ALAssetsGroup *group)    {

      //创建相簿成功

} failureBlock:^(NSError *error) {
    UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"存储失败"
                                                       message:@"请打开 设置-隐私-照片 来进行设置"
                                                      delegate:nil
                                             cancelButtonTitle:@"确定"
                                             otherButtonTitles:nil, nil];
    [alert show];
}];
</code></pre>

<p>在保存照片失败的结果里，我们也可以弹出相应的提示，让用户打开应用程序的相册权限。</p>

<h2>保存照片到自己的相簿</h2>

<p>下面这段代码是在大谷歌里面找到的，亲自测试过是可以用的，整理如下：</p>

<pre><code>#pragma mark - 创建相册
- (void)createAlbum
{
    ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];
    NSMutableArray *groups=[[NSMutableArray alloc]init];
    ALAssetsLibraryGroupsEnumerationResultsBlock listGroupBlock = ^(ALAssetsGroup *group, BOOL *stop)
    {
        if (group)
        {
            [groups addObject:group];
        }

        else
        {
            BOOL haveHDRGroup = NO;

            for (ALAssetsGroup *gp in groups)
            {
                NSString *name =[gp valueForProperty:ALAssetsGroupPropertyName];

                if ([name isEqualToString:@"iOSDevTip"])
                {
                    haveHDRGroup = YES;
                }
            }

            if (!haveHDRGroup)
            {
                //do add a group named "XXXX"
                [assetsLibrary addAssetsGroupAlbumWithName:@"iOSDevTip"
                                               resultBlock:^(ALAssetsGroup *group)
                 {
                     [groups addObject:group];

                 }
                                              failureBlock:nil];
                haveHDRGroup = YES;
            }
        }

    };
    //创建相簿
    [assetsLibrary enumerateGroupsWithTypes:ALAssetsGroupAlbum usingBlock:listGroupBlock failureBlock:nil];

    [self saveToAlbumWithMetadata:nil imageData:UIImagePNGRepresentation(self.image) customAlbumName:@"iOSDevTip" completionBlock:^
     {
         //这里可以创建添加成功的方法

     }
                     failureBlock:^(NSError *error)
     {
         //处理添加失败的方法显示alert让它回到主线程执行，不然那个框框死活不肯弹出来
         dispatch_async(dispatch_get_main_queue(), ^{

             //添加失败一般是由用户不允许应用访问相册造成的，这边可以取出这种情况加以判断一下
             if([error.localizedDescription rangeOfString:@"User denied access"].location != NSNotFound ||[error.localizedDescription rangeOfString:@"用户拒绝访问"].location!=NSNotFound){
                 UIAlertView *alert=[[UIAlertView alloc]initWithTitle:error.localizedDescription message:error.localizedFailureReason delegate:nil cancelButtonTitle:NSLocalizedString(@"ok", nil) otherButtonTitles: nil];

                 [alert show];
             }
         });
     }];
}

- (void)saveToAlbumWithMetadata:(NSDictionary *)metadata
                      imageData:(NSData *)imageData
                customAlbumName:(NSString *)customAlbumName
                completionBlock:(void (^)(void))completionBlock
                   failureBlock:(void (^)(NSError *error))failureBlock
{

    ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];
    __weak ALAssetsLibrary *weakSelf = assetsLibrary;
    void (^AddAsset)(ALAssetsLibrary *, NSURL *) = ^(ALAssetsLibrary *assetsLibrary, NSURL *assetURL) {
        [assetsLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
            [assetsLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {

                if ([[group valueForProperty:ALAssetsGroupPropertyName] isEqualToString:customAlbumName]) {
                    [group addAsset:asset];
                    if (completionBlock) {
                        completionBlock();
                    }
                }
            } failureBlock:^(NSError *error) {
                if (failureBlock) {
                    failureBlock(error);
                }
            }];
        } failureBlock:^(NSError *error) {
            if (failureBlock) {
                failureBlock(error);
            }
        }];
    };
    [assetsLibrary writeImageDataToSavedPhotosAlbum:imageData metadata:metadata completionBlock:^(NSURL *assetURL, NSError *error) {
        if (customAlbumName) {
            [assetsLibrary addAssetsGroupAlbumWithName:customAlbumName resultBlock:^(ALAssetsGroup *group) {
                if (group) {
                    [weakSelf assetForURL:assetURL resultBlock:^(ALAsset *asset) {
                        [group addAsset:asset];
                        if (completionBlock) {
                            completionBlock();
                        }
                    } failureBlock:^(NSError *error) {
                        if (failureBlock) {
                            failureBlock(error);
                        }
                    }];
                } else {
                    AddAsset(weakSelf, assetURL);
                }
            } failureBlock:^(NSError *error) {
                AddAsset(weakSelf, assetURL);
            }];
        } else {
            if (completionBlock) {
                completionBlock();
            }
        }
    }];
}
</code></pre>

<h2>ALAssetsLibrary+CustomPhotoAlbum保存照片</h2>

<p><code>github</code>上有一个项目<a href="https://github.com/Kjuly/ALAssetsLibrary-CustomPhotoAlbum">ALAssetsLibrary+CustomPhotoAlbum</a>，讲保存照片做了很好的封装。使用之前记得先导入头文件：</p>

<pre><code>#import "ALAssetsLibrary+CustomPhotoAlbum.h"
</code></pre>

<p>保存照片到自己的相簿，直接调用：</p>

<pre><code>ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
[library saveImage:self.image toAlbum:@"gang" completion:^(NSURL *assetURL, NSError *error) {
    if (!error) {

    }
} failure:^(NSError *error) {

}];
</code></pre>

<p><code>ALAssetsLibrary+CustomPhotoAlbum</code>对保存视频的封装也是非常好的。我现在项目中用的也是这个第三方来保存照片和视频。因为不错，所以推荐给大家使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之保存照片到系统相册（Photo Album）]]></title>
    <link href="http://www.superqq.com/blog/2015/08/03/ioskai-fa-zhi-bao-cun-zhao-pian-dao-xi-tong-xiang-ce-(photo-album)/"/>
    <updated>2015-08-03T21:43:34+08:00</updated>
    <id>http://www.superqq.com/blog/2015/08/03/ioskai-fa-zhi-bao-cun-zhao-pian-dao-xi-tong-xiang-ce-(photo-album)</id>
    <content type="html"><![CDATA[<p>保存照片到系统相册这个功能很多社交类的APP都有的，今天我们简单讲解一下，如何将图片保存到系统相册（Photo Album）。</p>

<h2>创建UIImageView</h2>

<p>创建<code>UIImageView</code>是为了将照片展示出来，我们是要把<code>UIImage</code>保存到系统相册（Photo Album）:</p>

<pre><code>#define SCREEN [UIScreen mainScreen].bounds.size

self.image = [UIImage imageNamed:@"iOSDevTip"];
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake((SCREEN.width - 300) / 2, 70, 300, 150)];
imageView.image = self.image;
[self.view addSubview:imageView];
</code></pre>

<!--more-->


<h2>创建UIButton</h2>

<p>创建<code>UIButton</code>并绑定<code>actionClick:</code>事件:</p>

<pre><code>UIButton *button = [[UIButton alloc] init];
button.frame = CGRectMake( 100, 300, SCREEN.width - 200, 40);
[button addTarget:self action:@selector(actionClick:) forControlEvents:UIControlEventTouchUpInside];
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
[button setBackgroundColor:[UIColor orangeColor]];
[button setTitle:@"SavePhoto" forState:UIControlStateNormal];
[self.view addSubview:button];


- (void)actionClick:(UIButton *)button
{

}
</code></pre>

<h2>保存照片到系统相册（Photo Album）</h2>

<p>在<code>actionClick:</code>方法里调用：</p>

<pre><code>UIImageWriteToSavedPhotosAlbum(self.image, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL);
</code></pre>

<p>这个时候，我们想知道保存是否成功，所以需要制定回调方法</p>

<pre><code>// 指定回调方法
- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo
{
    if(!error){
        NSLog(@"save success");
    }else{
        NSLog(@"save failed");
    }
}
</code></pre>

<p>在这个方法里，我们就知道照片是否保存成功。然后，根据需求来刷新UI线程。用户第一次使用APP的时候，点击<code>SavePhoto</code>按钮的时候，系统会询问权限：</p>

<p><img src="http://7xkkk9.com1.z0.glb.clouddn.com/46869740F32868C1F9769ED5FED1C7D0.png" alt="photo" /></p>

<p>Demo地址:<a href="https://github.com/worldligang/iOSStrongDemo">iOSStrongDemo</a> 下一篇文章，将会讲如何创建自己的相册并保存照片。</p>
]]></content>
  </entry>
  
</feed>
