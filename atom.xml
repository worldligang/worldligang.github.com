<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[刚刚在线]]></title>
  <link href="http://www.superqq.com/atom.xml" rel="self"/>
  <link href="http://www.superqq.com/"/>
  <updated>2015-07-09T17:41:34+08:00</updated>
  <id>http://www.superqq.com/</id>
  <author>
    <name><![CDATA[李刚]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UIWebView用法详解及代码分享]]></title>
    <link href="http://www.superqq.com/blog/2015/07/08/uiwebviewyong-fa-xiang-jie/"/>
    <updated>2015-07-08T23:52:34+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/08/uiwebviewyong-fa-xiang-jie</id>
    <content type="html"><![CDATA[<p>今天加入一个QQ群，也算是一个圈子，群主的要求是满足他的三个条件。经过与群主的沟通，终于得到通过，顺利加入。</p>

<p>群主是一个93年的小伙，而且是河南的老乡。没想到小伙子这么有号召力。我也是偶然在我的空间发现他的，看他每天发的文章，还挺有意思。</p>

<p><strong>90后的小伙子都这么厉害了，有什么理由不努力奋斗呢！</strong>多加入以下圈子，认识一下身边的牛人。说不定会有意外的收获。</p>

<p>今天我们来详细UIWebView用法。UIWebView是iOS内置的浏览器控件，可以浏览网页、打开文档等 能够加载html/htm、pdf、docx、txt等格式的文件.</p>

<p>用UIWebView我们就可以做一个简易的浏览器。效果如下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/webview1.png" alt="1" /></p>

<h2>创建UIWebView</h2>

<p>首先创建UIWebView，这个不难，设置frame，然后添加到self.view上即可：</p>

<pre><code>UIWebView *webView = [[UIWebView alloc] initWithFrame:self.view.bounds];
webView.scalesPageToFit = YES;//自动对页面进行缩放以适应屏幕
[self.view addSubview:webView];
</code></pre>

<h2>UIWebView加载网络地址</h2>

<p>用UIWebView来加载网络地址，那我的博客：<strong><a href="http://www.superqq.com">http://www.superqq.com</a></strong> 来举例。代码如下：</p>

<pre><code>NSURLRequest *request =[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.superqq.com"]];
[self.view addSubview:webView];
[webView loadRequest:request];
</code></pre>

<h2>UIWebView加载本地资源</h2>

<h3>通过NSURLRequest加载</h3>

<pre><code>NSString *path = [[NSBundle mainBundle] pathForResource:@"swift" ofType:@"html"];
NSURL* url = [NSURL   fileURLWithPath:path];//创建URL
NSURLRequest* request = [NSURLRequest requestWithURL:url];//创建NSURLRequest
[webView loadRequest:request];//加载
</code></pre>

<h3>通过NSString加载</h3>

<p>UIWebView 还支持将一个NSString对象作为源来加载。你可以为其提供一个基础URL，来指导UIWebView对象如何跟随链接和加载远程资源：</p>

<pre><code>NSString *path = [[NSBundle mainBundle] pathForResource:@"index" ofType:@"html"];
NSString *htmlString = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];
[webView loadHTMLString:htmlString baseURL:[NSURL URLWithString:path]];
</code></pre>

<h2>自动检测电话</h2>

<p>设置这个属性，如果在加载的网页中遇到电话号码，直接单击就可以拨打，非常方便：</p>

<pre><code>webView.dataDetectorTypes = UIDataDetectorTypePhoneNumber;//自动检测网页上的电话号码，单击可以拨打
</code></pre>

<h2>设置代理和代理方法</h2>

<p>UIWebView有五个代理方法，我们可以在不同的代理方法中，完成不同的需求。</p>

<pre><code>//设置代理
webView.delegate = self;

//代理方法
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
{
    //返回YES，进行加载。通过UIWebViewNavigationType可以得到请求发起的原因
    return YES;
}

- (void)webViewDidStartLoad:(UIWebView *)webView
{
    //开始加载，可以加上风火轮（也叫菊花）
}

- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //完成加载
}

- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error
{
    //加载出错
}
</code></pre>

<h2>创建加载他、停止、后退、前进按钮</h2>

<p>创建四个按钮，分别是加载按钮、停止按钮、返回按钮、前进按钮：</p>

<pre><code>NSArray *array = [NSArray arrayWithObjects:@"加载",@"停止",@"返回",@"前进", nil];
    int far = (SCREEN.width - 200)/5;
    for (int i = 0; i &lt; array.count; i++) {
        UIButton *button = [[UIButton alloc] init];
        button.frame = CGRectMake( (i + 1) * far + 50 * i, SCREEN.height - 60, 50, 40);
        button.tag = 200 + i;
        [button addTarget:self action:@selector(actionClick:) forControlEvents:UIControlEventTouchUpInside];
        [button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
        [button setBackgroundColor:[UIColor orangeColor]];
        [button setTitle:array[i] forState:UIControlStateNormal];
        [self.view addSubview:button];
    }
</code></pre>

<h2>前进后退</h2>

<p>给四个按钮绑定事件，根据tag值来区分每一个点击事件：</p>

<pre><code>- (void)actionClick:(UIButton *)button
{
    switch (button.tag) {
        case 200:
        {
            [self.webView reload];//加载
        }
            break;
        case 201:
        {
            [self.webView stopLoading];//停止加载
        }
            break;
        case 202:
        {
            [self.webView goBack];//返回
        }
            break;
        case 203:
        {
            [self.webView goForward];//前进
        }
            break;
        default:
            break;
    }
}
</code></pre>

<p>大功告成，再来看看效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/webview2.png" alt="2" /></p>

<p>以上分享的内容我做了一个demo，需要的话可以点击这里下载：<a href="https://github.com/worldligang/UIWebViewDemo">UIWebView用法详解</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSLocale的重要性和用法简介]]></title>
    <link href="http://www.superqq.com/blog/2015/07/07/nslocalede-zhong-yao-xing-he-yong-fa-jian-jie/"/>
    <updated>2015-07-07T22:33:47+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/07/nslocalede-zhong-yao-xing-he-yong-fa-jian-jie</id>
    <content type="html"><![CDATA[<p>股票还在努力的往下跌，怎么办呢？我这真是杞人忧天啊。谁说我不着急呢？我的模拟炒股都亏的过半了吧。你想想那些真真炒股的人该有多担心。</p>

<p>罢了罢了，我还是滚去撸代码，消灭bug吧。</p>

<h2>上百万APP你用过几个？</h2>

<p>随着iPhone的日趋强盛，随着AppStore的不断壮大，海量的应用如潮水般涌来。据统计AppStore上的应用早已过120万，Google Play Store更是超于AppStore，达到150万。</p>

<p>知道120万、150万是什么概念吗？人生不过短短两三万天。也就是说，如果你一天用一个APP的话，AppStore够你用40辈子，Google Play Store够你用50辈子，前提是，你必须生下来就开始玩手机。</p>

<p>这么多应用，不知道有没有你的贡献。估计正在看文章的你也贡献了好几个了吧。AppStore里面也有我的贡献。😊</p>

<p>开发一个APP不是那么容易的一件事，有很多坑等着你去踩。今天我们就抛出一个格式化时间的坑。</p>

<h2>NSDateFormatter格式化时间</h2>

<p>之前的文章，讲到过：<a href="http://www.superqq.com/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan/">NSDate和NSString相互转换</a>。里面提到过如何讲NSDate转化成NSString。代码如下：</p>

<pre><code>//获取系统当前时间
NSDate *currentDate = [NSDate date];
//用于格式化NSDate对象
NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
//设置格式：zzz表示时区
[dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
//NSDate转NSString
NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
//输出currentDateString
NSLog(@"%@",currentDateString);
</code></pre>

<p>运行起来，看看打印的内容：</p>

<pre><code>2015-07-07 22:08:57.422 TestDemo[6756:1555205] 2015-07-07 22:08:57
</code></pre>

<p>这样写是不是没有什么问题。看着应该是没什么问题，其实问题很大。但是如果你改一下系统设置：语言设置成印度尼西亚文，时间设置成12小时制。</p>

<p>大家应该知道如何去设置吧，不会设置的请不要告诉我你是一名<a href="http://www.superqq.com/blog/2015/06/25/ru-he-cheng-wei-%5B%3F%5D-ming-you-xiu-de-ioskai-fa-gong-cheng-shi/">iOS开发工程师</a>。再次编译起来，看看打印内容如下：</p>

<pre><code>2015-07-07 22:09:14.928 TestDemo[6762:1555466] 2015-07-07 10.09.14 PM
</code></pre>

<p>是不是愣住了，怎么会这么奇葩，时间怎么是.呢？还有更奇葩的呢，你去设置设置其他语言试试，也许有更多的收获。</p>

<h2>如何正确的格式化时间</h2>

<p>这也是我们这两天遇到的问题，跟用户几经沟通之后，终于抓到log，发现问题竟然是格式化导致的。怎么解决呢？</p>

<p>这个时候NSLocale的重要性就体现出来了。NSLocale作为大家都不常用的一个类，NSLocale类是将与国家和语言相关的信息进行简单的组合，包括货币、语言、国家等的信息。</p>

<p>所以很简单，我们把dateFormatter的locale属性改一下即可解决这个问题。将下面代码放在dateFormatter初始化之后：</p>

<pre><code>NSLocale *usLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US"];
dateFormatter.locale = usLocale;
</code></pre>

<p>看看问题解决没有，编译一下：</p>

<pre><code>2015-07-07 22:20:08.411 TestDemo[6769:1556968] 2015-07-07 22:20:08
</code></pre>

<p>果然，问题得到完美解决了。</p>

<h2>NSLocale用法简介</h2>

<h3>获取国家、货币、语言地区编码</h3>

<p>既然谈到NSLocale，我们就来简单了解一下：</p>

<pre><code>+ ISOCountryCodes// 所有的ISO定义的国家地区编码
+ ISOCurrencyCodes// 所有的ISO定义的货币编码
+ ISOLanguageCodes// 所有ISO定义的语言编码
</code></pre>

<p>以上我们可以用NSLog打印出来看一看。</p>

<h3>监听用户本地化的设置信息</h3>

<pre><code>FOUNDATION_EXPORT NSString * const NSCurrentLocaleDidChangeNotification NS_AVAILABLE(10_5, 2_0);
</code></pre>

<h3>获取当前系统设置语言的标识符</h3>

<pre><code>[[NSLocale currentLocale] localeIdentifier];
</code></pre>

<p>还有很多关于NSLocale的用法，自己动手多尝试。还有一个小问题。</p>

<h2>NSLocale怎么读？</h2>

<p>看了这么久的NSLocale了，你知道NSLocale怎么读吗？不要翻译噢，看看你读的到底对不对？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发自定义时间选取器]]></title>
    <link href="http://www.superqq.com/blog/2015/07/06/ioskai-fa-zi-ding-yi-shi-jian-xuan-qu-qi/"/>
    <updated>2015-07-06T23:40:21+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/06/ioskai-fa-zi-ding-yi-shi-jian-xuan-qu-qi</id>
    <content type="html"><![CDATA[<p>又是一年的暑假日期而至，小孩子放假，都会到在外打工的父母身边。孩子想父母，父母也思念着自己的孩子。我身边的亲戚朋友的孩子 也都来了。这个暑假又该热闹起来。</p>

<h2>努力什么时候都不晚</h2>

<p>我有一个表妹，今年参加完高考，对自己的成绩不是特别满意。上次我回老家，刚好她给我一起来上海。准备来上海锻炼一下。</p>

<p>车上我问她，准备去哪上学？她说不想上了，想打工。我没有怎么劝她，我想让她体验一下打工的生活，她就知道还是上学好。</p>

<p>一个高中生，出来找工作，困难可想而知。经姐姐介绍，进了一家餐厅工作。工资也不是很高。干了两天，我问她怎么样？她说，高二要是来让我体验一下，我一定能考上一本。</p>

<p>也许真的如她所说的那样，但是谁知道呢？时间也不会倒流，她也不再可能再参加一次高考了。人只有吃过苦头，才知道努力。这是件好事，大学好好把握也是一样的。</p>

<p><strong>无论处于什么困境，只要知道努力，我觉得什么时候都不晚。</strong>关注<a href="http://www.superqq.com/">iOS开发</a>微信公众号：<strong>iOSDevTip</strong></p>

<h2>自定义时间选取器</h2>

<p>每天都随便扯扯，回到正题。今天我们做一个时间选取器，很简单，效果如下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/time.png" alt="time" /></p>

<p>我们自定义一个LGDatePickerView，在LGDatePickerView里面实现。</p>

<h2>背景半透明</h2>

<p>背景是半透明的，点击的灰色背景的时候，时间选取器消失。在LGDatePickerView初始化方法里，代码如下：</p>

<pre><code>- (id)init
{
    self = [super init];
    if (self) {
  //背景半透明，绑定取消方法
    UIControl *control = [[UIControl alloc] initWithFrame:SCREEN_BOUNDS];
    control.backgroundColor = [UIColor colorWithRed:0.0/255.0 green:0.0/255.0 blue:0.0/255.0 alpha:0.5f];
    [self addSubview:control];
    [control addTarget:self action:@selector(actionCancel:) forControlEvents:UIControlEventTouchUpInside];     
     }
    return self;
}
</code></pre>

<p>绑定的actionCancel方法：</p>

<pre><code>- (void)actionCancel:(id)sender
{
    [self removeFromSuperview];
}
</code></pre>

<h2>确定取消按钮</h2>

<p>看到上面的确定取消按钮，你会怎么做，写一个UIView上面放两个UIButton。这样做也是可以实现的。我们还可以用UIToolbar。在LGDatePickerView初始化方法里加上下面这段代码：</p>

<pre><code> // Toolbar
UIToolbar *toolbar = [[UIToolbar alloc] initWithFrame:CGRectMake(0, SCREEN.height - 250, SCREEN.width, 50)];
toolbar.autoresizingMask = UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleWidth;
UIBarButtonItem *itemCancelDone = [[UIBarButtonItem alloc] initWithTitle:@"确定" style:UIBarButtonItemStylePlain target:self action:@selector(actionConfirm:)];
UIBarButtonItem *itemCancel = [[UIBarButtonItem alloc] initWithTitle:@"取消" style:UIBarButtonItemStylePlain target:self action:@selector(actionCancel:)];
UIBarButtonItem *space = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];
[toolbar setItems:[NSArray arrayWithObjects:itemCancel,space,itemCancelDone, nil]];
[control addSubview:toolbar];
</code></pre>

<p>actionCancel上面已经实现了。下面实现actionConfirm方法。它有什么作用呢？</p>

<ul>
<li>点击的时候获取到时间，然后通过代理代理出去</li>
<li><p>时间选取器消失</p>

<pre><code>  - (void)actionConfirm:(id)sender
  {
      if ([self.delegate respondsToSelector:@selector(datePickerView:didSelectTime:)]) {
          [self.delegate datePickerView:self didSelectTime:self.datePicker.date];
      }
      [self removeFromSuperview];
  }
</code></pre></li>
</ul>


<h2>代理方法</h2>

<p>在LGDatePickerView.h</p>

<pre><code>@protocol LGDatePickerViewDelegate &lt;NSObject&gt;

- (void)datePickerView:(LGDatePickerView *)datepicker didSelectTime:(NSDate *)time;

@end
</code></pre>

<h2>创建UIDatePicker</h2>

<p>在LGDatePickerView.h定义一个全局变量：</p>

<pre><code>@property (nonatomic, strong) UIDatePicker *datePicker;
</code></pre>

<p>在LGDatePickerView初始化方法里加上下面这段代码：</p>

<pre><code>UIDatePicker *datePicker = [[UIDatePicker alloc] init];
datePicker.backgroundColor = [UIColor whiteColor];
datePicker.datePickerMode = UIDatePickerModeCountDownTimer;
datePicker.date = [NSDate date];
datePicker.frame = CGRectMake(0, SCREEN.height - 200, SCREEN.width, 220);
[control addSubview:datePicker];
self.datePicker = datePicker;
</code></pre>

<h2>使用LGDatePickerView</h2>

<p>使用起来很简单，创建一下，然后加载self.view上面即可：</p>

<pre><code>    LGDatePickerView *datePicker = [[LGDatePickerView alloc] init];
    datePicker.delegate = self;
    datePicker.datePicker.date = [NSDate date];
    datePicker.frame = self.view.bounds;
    [self.view addSubview:datePicker];
</code></pre>

<p>以上就实现了iOS开发自定义时间选取器，代码不难，有什么问题，欢迎提问哈。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员屌丝逆袭之路不是炒股]]></title>
    <link href="http://www.superqq.com/blog/2015/07/05/cheng-xu-yuan-diao-si-ni-xi-zhi-lu-bu-shi-chao-gu/"/>
    <updated>2015-07-05T23:35:57+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/05/cheng-xu-yuan-diao-si-ni-xi-zhi-lu-bu-shi-chao-gu</id>
    <content type="html"><![CDATA[<p>最近这一段时间，你身边是不是大多数人都在谈论股票？那就对了，无论走到哪都能听到，今天又绿了，我的股票跌停了，冲上5000点啦，等等之类的话。</p>

<p>我还不是一个股民，一直都不是。因为不懂，不敢入市；因为有人跳楼，害怕入市；最主要的原因是，因为手里没有人民币。</p>

<p>人们常说：股市有风险，入市需谨慎。但是还是很多人挤破头皮，往里进。站着进去，趴着出来；笑着进去，哭着出来。</p>

<p>作为一名屌丝，谁不想逆袭呢，谁不想通过炒股赚钱呢？</p>

<h2>前同事炒股翻倍</h2>

<p>最近群里，有个前同事做后台的。他进了一家证劵公司，做后台。应该是年初进去上班的，刚好赶上一波牛市。他买了几只股，好像都不错。</p>

<p>其中有一只股，买的时候是30左右。在60几出的。赚了几万块钱吧。想想真的很不错，啥都不干白赚几万块钱，谁看了不心动呢。说实话，我也心动。</p>

<p>估计是受到他的影响，公司里有些同事也开始炒股了。当然，有的人可能早就在炒股，只是之前股市不景气，大家都不谈论罢了。</p>

<p>看着别人赚钱容易，到自己了估计就难了。真的是这样，尤其是股市里面的钱，真的不是那么好赚的。通过炒股走上逆袭之路，那更是难上加难。</p>

<h2>我的模拟炒股之路</h2>

<p>大家都在谈论股票，我也不能闲着啊。就Appstore里面找了一个模拟炒股软件，试着玩玩看。说不定能赚。</p>

<p>里面有100万，是用来模拟炒股的。反正，是假的，就随便挑了几只股票入手。一共投了30多万吧。还别说，当天就赚了一万多。突然发现自己有成为股神的潜质，哈哈。</p>

<p>紧接着，第二天，第三天，每天都能赚个两三万，第五天的时候，模拟资金已高达110多万。这要是真钱，该多好啊。那我岂不是白白赚了10万块钱。所以你想想，那些有钱的人，真的是越来越有钱。随便弄一下，几百万就来了。</p>

<p>与此同时，其他炒股的同事都在赚，投一万多，赚一千多。看起来还真不错。看到大家都赚钱了，我这个股票小白，模拟都能赚10万块。是不是很想入市啊。</p>

<p>事情并没有想象的那么简单。随后的两三周，股票大跌，各种跌停。有的股票都快跌一半了。包括我前同事买的那个股票从60多又跌回到30多了。不过幸好，他已经抛了。</p>

<p>并不是每个人都那么幸运。有的人都快损失过半了。这种过山车的股市，真让人受不了。炒股不仅有风险，还严重影响生活。与其这样，还不如好好思考如何提高自己的技术。</p>

<p>再看看我的模拟炒股战绩：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/monichaogu.png" alt="gu" /></p>

<h2>股市大跌之后</h2>

<p>经过前面的大跌，股市下一步走向如何呢？或许会继续跌一些，但是我更愿意相信股市会涨，我也希望能涨，让更多被套牢的朋友赚点。我不是股神，无法给出精准的答案。</p>

<p>也许在中国根本就不存在巴菲特口中的<strong>价值投资理论</strong>。有的只是政策市。</p>

<p>股市大跌之后，我也不再想通过股市走向逆袭之路。作为一名屌丝程序员，还是安心的做个美男子，去实现更多有价值的理想吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton中的三个UIEdgeInsets属性（二）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/04/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-(er-)/"/>
    <updated>2015-07-04T14:14:43+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/04/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-(er-)</id>
    <content type="html"><![CDATA[<p>昨天去公司加班的人请举手，不是只有我一个吧？（😭）我觉得加班的人应该不少吧。今天周日，应该不需要去加班了。心里暗暗自喜，终于可以休息一天啦。（😄）</p>

<p>说到加班，应该是程序猿心里的痛啊。不加班吧，东西做不完；加班吧，身体吃不消。作为程序猿真的不容易，每天从早忙到晚。突然有一天，六点下班，看见太阳还在等我，心里被踢有多高兴。</p>

<p>弱弱的问一下：加班好不好？</p>

<p>要看这个问题问谁了。如果问老板，老板肯定美滋滋的说，加班好啊，说明你有责任心，有上进心，把公司当成自己的&hellip;</p>

<p>如果问我，哈哈，我当然说加班不好啦，不然会被打死的。开个玩笑。说句实话，加班肯定是不好的，尤其是对程序猿来说。每天面对电脑，每天坐着，时间长了，各种问题就凸显出来。</p>

<p>但是，我说加班不好有用吗？如果我要是老板，我就直接让员工在家办公。（😊）所以大家感觉支持我吧，说不定哪天我真的&hellip;</p>

<p>接着昨天的<a href="http://www.superqq.com/blog/2015/07/03/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-%28%5B%3F%5D-%29/">UIButton中的三个UIEdgeInsets属性</a>，今天我们具体谈谈UIButton的contentEdgeInsets、titleEdgeInsets、imageEdgeInsets属性。</p>

<h2>创建UIButton</h2>

<pre><code>UIButton *button = [[UIButton alloc] init];
button.frame = CGRectMake(50, 200, 200, 50);
[button setTitle:@"我是UIButton" forState:UIControlStateNormal];
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
[button setBackgroundColor:[UIColor orangeColor]];
button.titleLabel.textAlignment = NSTextAlignmentLeft;
button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;
[self.view addSubview:button];
</code></pre>

<p>创建一个button，让button的title居左，以便观察：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button1.png" alt="1" /></p>

<h2>UIButton的contentEdgeInsets属性</h2>

<pre><code>@property(nonatomic)          UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR; // default is UIEdgeInsetsZero
</code></pre>

<p>contentEdgeInsets里有一个content应该指的就是UIButton的title。</p>

<h3>参数含义</h3>

<p>上一篇文章我们讲了UIEdgeInsets是个结构体类型。里面有四个参数，分别是：top, left, bottom, right。这四个参数表示距离上边界、左边界、下边界、右边界的距离。</p>

<p>这四个参数的值可以为正值，也可以为负值。拿left举例：</p>

<pre><code>left = 10; //代表以当前位置为基准，向右移动10个像素
left = -10; //代表以当前位置为基准，向左移动10个像素
</code></pre>

<h3>向右移动20个像素</h3>

<pre><code>button.contentEdgeInsets = UIEdgeInsetsMake(0, 20, 0, 0);
</code></pre>

<p>向右移动20个像素，left = 20，就可以了。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button2.png" alt="2" /></p>

<h3>向左移动20个像素</h3>

<pre><code>button.contentEdgeInsets = UIEdgeInsetsMake(0, -20, 0, 0);
</code></pre>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button3.png" alt="2" /></p>

<h2>UIButton的titleEdgeInsets属性</h2>

<p>titleEdgeInsets和contentEdgeInsets的作用差不多。我们及设置contentEdgeInsets，又设置titleEdgeInsets，会怎样呢？</p>

<pre><code>button.titleEdgeInsets = UIEdgeInsetsMake(0, 20, 0, 0);
button.contentEdgeInsets = UIEdgeInsetsMake(0, 20 , 0, 0);
</code></pre>

<p>看一下效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button4.png" alt="3" /></p>

<h2>UIButton的titleEdgeInsets属性</h2>

<h3>创建一个带照片的button</h3>

<pre><code>UIButton *button = [[UIButton alloc] init];
button.frame = CGRectMake(50, 200, 200, 200);
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
[button setBackgroundColor:[UIColor orangeColor]];
[button setImage:[UIImage imageNamed:@"test"] forState:UIControlStateNormal];
[self.view addSubview:button];
</code></pre>

<p>运行一下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button5.png" alt="5" /></p>

<h3>向右移动50个像素</h3>

<pre><code>button.imageEdgeInsets = UIEdgeInsetsMake(0, 50, 0, 0);
</code></pre>

<p>看看效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button6.png" alt="6" /></p>

<h3>向左移动50个像素</h3>

<pre><code>button.imageEdgeInsets = UIEdgeInsetsMake(0, -50, 0, 0);
</code></pre>

<p>看看效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/button7.png" alt="7" /></p>

<p>大家可以自行设置其他三个参数看看效果是怎样的，自己动手便于理解。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="ios" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton中的三个UIEdgeInsets属性（一）]]></title>
    <link href="http://www.superqq.com/blog/2015/07/03/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-(%5B%3F%5D-)/"/>
    <updated>2015-07-03T23:29:55+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/03/uibuttonzhong-de-san-ge-uiedgeinsetsshu-xing-([?]-)</id>
    <content type="html"><![CDATA[<p>随着时间的推移，随着我的坚持，公众号的订阅用户已经越来越多了。非常感谢大家的信任，我会再接再厉，努力为大家提供更多优秀的文章。</p>

<p>当初创建<a href="http://www.superqq.com/">iOS开发</a>（ <strong>iOSDevTip</strong> ），只是自己的兴趣。刚开始还不怎么会用微信公众号的后台，连发图文消息都不会。不知道怎么去编辑，当初的微信公众号后台也没有现在这么强大。我还以为就是个一对多的聊天工具呢。（😊）</p>

<p>慢慢的我学会了编辑文章，成为一个真正意义上的小编。每天负责为大家推送一些iOS相关的技术文章。每天到各大论坛、网站、大神的博客找一些好的文章。这个过程是漫长的，但是是值得的。</p>

<p>找文章的过程中，对自己来说，也是学习的好机会。如果没有这个公众号，我可能就看不到那么多的技术文章，也不能为大家推荐文章，自己也不会建立博客。</p>

<p>现在微信团队已经邀请我开通原创功能，以后，我就会多发一些原创内容。一个人的力量比较是有限的，订阅的用户如果有喜欢写技术文章的，欢迎头投稿给我，我的邮箱：<strong>worldligang@163.com</strong></p>

<p><strong>相信我，你的付出也会有回报的。</strong></p>

<p>今天是周六，不知道正在看文章的你有没有在加班。没有加班的，就好好休息一下吧；加班的，我只能同情一下啦。今天我们来看看UIButton中的三个UIEdgeInsets属性。</p>

<h2>UIEdgeInsets是什么</h2>

<p>UIEdgeInsets是什么？我们点进去看一下：</p>

<pre><code>typedef struct UIEdgeInsets {
    CGFloat top, left, bottom, right;  // specify amount to inset (positive) for each of the edges. values can be negative to 'outset'
} UIEdgeInsets;
</code></pre>

<p>UIEdgeInsets是个结构体类型。里面有四个参数，分别是：top, left, bottom, right。这四个参数表示距离上边界、左边界、下边界、右边界的距离。</p>

<h2>哪三个UIEdgeInsets属性</h2>

<p>不知道大家发现没有，UIButton里面有三个UIEdgeInsets属性，分别是：</p>

<pre><code>@property(nonatomic)          UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR; // default is UIEdgeInsetsZero

@property(nonatomic)          UIEdgeInsets titleEdgeInsets;                // default is UIEdgeInsetsZero

@property(nonatomic)          UIEdgeInsets imageEdgeInsets;                // default is UIEdgeInsetsZero
</code></pre>

<p>contentEdgeInsets后面有个UI_APPEARANCE_SELECTOR是什么意思呢？</p>

<pre><code>提示：UI_APPEARANCE_SELECTOR标记的属性都支持通过外观代理来定制。
</code></pre>

<p>举例，设置UIButton的contentEdgeInsets属性，可以直接调用：</p>

<pre><code>[[UIButton appearance] setTitleEdgeInsets:UIEdgeInsetsMake(0, 0, 0, 0)];
</code></pre>

<p>关于UIButton三个UIEdgeInsets属性的作用，下一篇文章介绍。</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="ios" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton文字居左显示]]></title>
    <link href="http://www.superqq.com/blog/2015/07/02/uibuttonwen-zi-ju-zuo-xian-shi/"/>
    <updated>2015-07-02T22:18:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/02/uibuttonwen-zi-ju-zuo-xian-shi</id>
    <content type="html"><![CDATA[<p>题外话：时间依旧过的很快，不知不觉2015年就过去一半了。感觉自己好像没有大的改变，只能感叹时间飞逝，却不能有所收获。</p>

<p>我从来都不是一个安于现状的人，改变自己的想法从未停止过。我想大多数人都跟我有类似的想法。但是为什么很难有所成就呢？我觉得最重要的原因就是，<strong>只是想一下，而没有去行动</strong>。</p>

<p>这是一个全民创业的时代，不把握机会，只能错过。错过的机会，越多遗憾就越多。有句话说：<strong>老了之后，回想人生，不会因为自己做过什么而后悔，而会因为自己没有做过什么而遗憾。</strong>不想给人生留下遗憾，所以努力去尝试是唯一的选择。</p>

<p>随便感慨一下。每天上班太舒服了，淡忘了自己的理想，借此提醒一下自己。</p>

<p>来来，收回思路，今天我们来讲如何让UIButton文字居左显示？我们都应该写过让UILabel的text居左显示。代码也非常简单。</p>

<h2>UILabel文字居左显示</h2>

<p>实现文字居左显示代码如下：</p>

<pre><code>UILabel *label = [[UILabel alloc] init];
label.frame = CGRectMake(50, 100, 200, 50);
label.text = @"我是label";
label.textAlignment = NSTextAlignmentLeft;
label.backgroundColor = [UIColor orangeColor];
[self.view addSubview:label];
</code></pre>

<p>运行起来看一下效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/labelleft.png" alt="1" /></p>

<p>label.backgroundColor = [UIColor orangeColor];设置label的背景颜色方便我们参考。你是不是这样做的。依次类推UIButton也很简单，你肯定能想到。我们来看看。</p>

<h2>UIButton文字居左显示</h2>

<h3>创建UIButton</h3>

<pre><code>UIButton *button = [[UIButton alloc] init];
//设置坐标
button.frame = CGRectMake(100, 100, 100, 50);
//设置标题
[button setTitle:@"我是UIButton" forState:UIControlStateNormal];
//设置标题颜色
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
//设置背景颜色    
[button setBackgroundColor:[UIColor orangeColor]];
[self.view addSubview:button];
</code></pre>

<p>以上代码是创建一个button，设置坐标、标题、和标题颜色。</p>

<h3>让文字居左</h3>

<p>按照UILabel文字居左的写法，UIButton应该这么写：</p>

<pre><code> button.titleLabel.textAlignment = NSTextAlignmentLeft;
</code></pre>

<p>运行一下看一下效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/buttonnoleft.png" alt="2" /></p>

<p>我们发现UIButton的文字还是居中显示。竟然没有居左显示，怎么办呢？进UIButton看看，还有哪些属性。很快发现：</p>

<pre><code>@property(nonatomic) UIControlContentHorizontalAlignment contentHorizontalAlignment; // how to position content hozontally inside control. default is center

typedef NS_ENUM(NSInteger, UIControlContentHorizontalAlignment) {
    UIControlContentHorizontalAlignmentCenter = 0,
    UIControlContentHorizontalAlignmentLeft   = 1,
    UIControlContentHorizontalAlignmentRight  = 2,
    UIControlContentHorizontalAlignmentFill   = 3,
};
</code></pre>

<h3>设置contentHorizontalAlignment</h3>

<pre><code>button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;
</code></pre>

<p>再次运行起来看效果：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/buttonleft.png" alt="3" /></p>

<p>果然可以，是不是看着居左显示很难看，太靠边了。很简单，设置UIButton的titleEdgeInsets属性：</p>

<pre><code>button.titleEdgeInsets = UIEdgeInsetsMake(0, 10, 0, 0);
</code></pre>

<p>这样button的title就距左边10个像素的距离。</p>

<p>居右显示就很简单了：</p>

<pre><code>button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentRight;
</code></pre>

<p>ok，UIButton文字居左显示完成了。更多iOS技术请点击<a href="www.superqq.com">刚刚在线</a> : <strong>www.superqq.com</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EGOCache如何检测缓存时间过期]]></title>
    <link href="http://www.superqq.com/blog/2015/07/02/egocacheru-he-jian-ce-huan-cun-shi-jian-guo-qi/"/>
    <updated>2015-07-02T00:38:14+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/02/egocacheru-he-jian-ce-huan-cun-shi-jian-guo-qi</id>
    <content type="html"><![CDATA[<blockquote><p>子曰:学而不思则罔,思而不学则殆。</p></blockquote>

<p>在上一篇文章中：<a href="http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie/">EGOCache缓存框架详细讲解</a> 提到<strong>EGOCache</strong>可以设定缓存过期时间，默认是1天。查看了一下EGOCache源码，设置默认时间：</p>

<pre><code>    [self setDefaultTimeoutInterval:86400];

    //86400 = 24 * 60 * 60 刚好是一天时间。
</code></pre>

<p>EGOCache为什么要提供设定缓存过期时间呢？或者说设定缓存过期时间有什么好处呢？我觉得最大的好处就是可以定时清除缓存。可以设置某一项的缓存时间，很方便管理缓存。</p>

<p>那么问题来了：</p>

<ol>
<li>EGOCache是怎么检测缓存过期时间的呢？</li>
<li>检测到时间过期之后，什么时候触发删除缓存项的？</li>
</ol>


<p>带着这两个问题，我们来继续分析。</p>

<h2>你会怎么实现</h2>

<p>记得在公司里，老板经常会举这样的例子：</p>

<pre><code>某某同志，刚来我们公司的时候，遇到问题就知道抱怨。从来不知道去思考怎么解决，只知道把问题抛给领导。工作半年下来，成长了很多。现在碰到问题，不仅把问题抛出来，而且还提供了自己的解决方案...
</code></pre>

<p>类似的例子，相信大家都听过。同样，既然前面我们提出这两个问题，我们也先来思考一下，如果我们来做该怎么解决？</p>

<p>如果让我来写的话，我脑海里初步实现方法有几个：</p>

<ol>
<li>通过定时器来轮询，每隔一段时间检测一次。</li>
<li>写一个while循环来检测。</li>
<li>每次去读取缓存项的时候，判断缓存时间有没有过期。没过期，就返回读取的缓存项；否则，返回nil。</li>
</ol>


<p>当然，还有一些方法，不一一例举了。仔细想想，这些方法弊端很容易显露出来。</p>

<ol>
<li>为了小小的缓存时间，就用定时器轮询，显然是资源浪费</li>
<li>跟方法1差不多。</li>
<li>每次读取的时候判断是否过期，如果一直不读取，app的缓存会越来越大，也不可取。</li>
</ol>


<p>这些方法都被排除了，还有好的方法吗？继续往下看：</p>

<h2>EGOCache是怎么实现的？</h2>

<p>仔细查看EGOCache源码，发现在initWithCacheDirectory:方法里，每次初始化EGOCache实例对象的时，会遍历一遍plist文件中所有已存在的缓存项，拿每个缓存项的时间和当前时间作比较，缓存项过期时间早于当前时间，则删除对应缓存文件，并删除 plist 文件中对应 key 的记录。</p>

<p>具体实现代码如下：</p>

<h3>读取缓存项信息</h3>

<pre><code>_cacheInfo = [[NSDictionary dictionaryWithContentsOfFile:cachePathForKey(_directory, @"EGOCache.plist")] mutableCopy];

if(!_cacheInfo) {
    _cacheInfo = [[NSMutableDictionary alloc] init];
}
</code></pre>

<h3>获取当前时间的NSTimeInterval</h3>

<pre><code>NSTimeInterval now = [[NSDate date] timeIntervalSinceReferenceDate];
</code></pre>

<h3>声明removedKeys保存过期的缓存项对应的key</h3>

<pre><code>NSMutableArray* removedKeys = [[NSMutableArray alloc] init];
</code></pre>

<h3>遍历缓存项信息并判断缓存时间</h3>

<pre><code>for(NSString* key in _cacheInfo) {
    //判断缓存项过期时间是否早于当前时间
    if([_cacheInfo[key] timeIntervalSinceReferenceDate] &lt;= now) {
        //如果缓存项过期时间早于当前时间，移除缓存项
        [[NSFileManager defaultManager] removeItemAtPath:cachePathForKey(_directory, key) error:NULL];
        //把过期的缓存项对于的key保存到removedKeys里面
        [removedKeys addObject:key];
    }
}
</code></pre>

<h3>删除过期缓存项对于的key</h3>

<pre><code>[_cacheInfo removeObjectsForKeys:removedKeys];
</code></pre>

<p>看到这些，是不是觉得人家思路特牛叉，反正，我是觉得这个作者不简单。到这一步就解决了吗？</p>

<h2>EGOCache还做了什么？</h2>

<p>细心的童鞋会发现：<strong>EGOCache是个<a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">单列类</a></strong>，也就是说整个程序应用周期只初始化一次。</p>

<pre><code>+ (instancetype)globalCache {
    static id instance;

    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        instance = [[[self class] alloc] init];
    });

    return instance;
}
</code></pre>

<p>每次初始化的时候去判断了缓存项是否过期，这样做非常正确。思考一个场景：</p>

<ol>
<li>用户打开app，EGOCache被初始化，并判断了缓存项是否过期。</li>
<li>如果刚好有一些缓存项在EGOCache被初始化之后过期。这个时候我们依然可以读到这个缓存项。这就不对了。</li>
</ol>


<p>继续分析EGOCache源码发现，EGOCache在读取一个缓存项的时候，先判断缓存项是否存在，然后读取缓存项（注意：是读取EGOCache初始化的时候没有过期的缓存项，并没有说现在没有过期），最后去判断读取到的缓存项跟当前时间相比是否过期.</p>

<p>具体实现如下：</p>

<pre><code>- (BOOL)hasCacheForKey:(NSString*)key {
    //读取EGOCache初始化的时候没有过期的缓存项
    NSDate* date = [self dateForKey:key];
    if(date == nil) return NO;
    //判断读取到的缓存项当前是否过期
    if([date timeIntervalSinceReferenceDate] &lt; CFAbsoluteTimeGetCurrent()) return NO;

    return [[NSFileManager defaultManager] fileExistsAtPath:cachePathForKey(_directory, key)];
}

- (NSDate*)dateForKey:(NSString*)key {
    __block NSDate* date = nil;

    dispatch_sync(_frozenCacheInfoQueue, ^{
        date = (self.frozenCacheInfo)[key];
    });

    return date;
}
</code></pre>

<p>EGOCache检测缓存时间过期的思路值得学习，以后遇到类似场景，完全可以借鉴。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EGOCache缓存框架详细讲解]]></title>
    <link href="http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie/"/>
    <updated>2015-07-01T00:10:18+08:00</updated>
    <id>http://www.superqq.com/blog/2015/07/01/egocachehuan-cun-kuang-jia-xiang-xi-jiang-jie</id>
    <content type="html"><![CDATA[<p><strong>EGOCache</strong>是一个轻量级的缓存框架。用法简单方便，在现在的项目中，我就用到EGOCache来缓存下载过的照片和字符串。</p>

<p>有人可能会问到，缓存照片还需要用EGOCache吗？<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">AFNetworking</a>和<a href="http://www.superqq.com/blog/2015/06/09/sdwebimagejia-zai-tu-pian-huan-cun-tu-pian/">SDWebImage</a>不是已经有这些功能了吗？</p>

<p>是的，不过AFNetworking和SDWebImage是http。我的项目用的是socket，所以我选择EGOCache来做缓存。用下来觉得EGOCache还是挺强大的。</p>

<h2>EGOCache简介</h2>

<pre><code>EGOCache is a simple, thread-safe key value cache store. It has native support for NSString, UI/NSImage, and NSData, but can store anything that implements &lt;NSCoding&gt;. All cached items expire after the timeout, which by default, is one day.
</code></pre>

<p>翻译过来就是：EGOCache一个简单、线程安全的基于 key-value 的缓存框架，原生支持NSString、UI/NSImage、和NSData，也支持储存任何实现<NSCoding>协议的类，可以设定缓存过期时间，默认是1天。</p>

<p>EGOCache只有一个类，EGOCache.h和EGOCache.m两个文件。用法也比较容易掌握，仔细研究一下EGOCache.h的方法，很快就可以上手。</p>

<p>EGOCache只提供了磁盘缓存，没有提供内存缓存。同时，也提供了清理缓存的方法：</p>

<pre><code>- (void)clearCache;
</code></pre>

<p>EGOCache还提供了判断缓存是否存在的方法：</p>

<pre><code>- (BOOL)hasCacheForKey:(NSString* __nonnull)key;
</code></pre>

<h2>通过Cocoapods直接加入项目</h2>

<p>直接在你的项目的Podfile加入下面一行：</p>

<pre><code>pod 'EGOCache'
</code></pre>

<p>然后执行：</p>

<pre><code>$ pod update
</code></pre>

<h2>EGOCache用法</h2>

<h3>用EGOCache缓存NSString</h3>

<p>存储：</p>

<pre><code>NSString *saveString = @"把我保存起来吧";
[[EGOCache globalCache] setString:saveString forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[saveString hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>NSString *getSaveString = [[EGOCache globalCache] stringForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveString" hash]]];
</code></pre>

<p>是不是感觉跟NSDictionary很相似，确实，前面我们说了EGOCache是基于key-value 的缓存框架。</p>

<h3>用EGOCache缓存UIImage</h3>

<p>存储：</p>

<pre><code> UIImage *saveImage = [UIImage imageNamed:@"iOSDevTip"];
[[EGOCache globalCache] setImage:saveImage forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveImage" hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>UIImage *getSaveImage = [[EGOCache globalCache] imageForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveImage" hash]]];
</code></pre>

<h3>用EGOCache缓存NSData</h3>

<p>存储：</p>

<pre><code>NSData *saveData = [NSData data];
[[EGOCache globalCache] setData:saveData forKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveData" hash]] withTimeoutInterval:24*60*60];
</code></pre>

<p>读取：</p>

<pre><code>UIImage *getSaveData = [[EGOCache globalCache] dataForKey:[NSString stringWithFormat:@"EGOImageLoader-%lu", (unsigned long)[@"SaveData" hash]]];
</code></pre>

<h2>EGOCache源码下载</h2>

<p><a href="https://github.com/enormego/EGOCache">EGOCache</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[唯有坚持方能成功]]></title>
    <link href="http://www.superqq.com/blog/2015/06/30/wei-you-jian-chi-fang-neng-cheng-gong/"/>
    <updated>2015-06-30T00:44:54+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/30/wei-you-jian-chi-fang-neng-cheng-gong</id>
    <content type="html"><![CDATA[<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/jianchi.jpg" alt="2" /></p>

<p>或许这不是一篇心灵鸡汤，因为心灵鸡汤不是我的擅长;或许这就是一篇心灵鸡汤，希望能点燃你的斗志。</p>

<h2>坚持才有希望</h2>

<p>我常说一句话：不是因为有了希望才坚持，而是坚持了才有希望。我也一直用这句话来告诫自己。只要持续努力，才有成功的可能。</p>

<p>以前，我认为如果谁能给我机会，我将会怎样怎样。我就一直等啊等，等啊等，两年三年后，好像发现没人会给我机会，反而错过很多本应该能抓住的机会。</p>

<p>现在，我改变了这种想法。我要用自己的努力，自己的坚持，来获取更多的机会，更多的可能。</p>

<h2>iOS开发开通原创功能</h2>

<p>就在昨天20:11微信团队邀请我开通微信原创功能。对于我来说，这是一个值得纪念的时刻，这也是对我的努力的一种肯定。特给大家分享一下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/yuanchuang.png" alt="2" /></p>

<p>随着iOS开发微信微信公众号订阅的用户越来越多，让我觉得责任越来越重。</p>

<p>正在看文章的你，可能是一位技术大牛，有时候我发的文章很基础，你会觉得文章水平太低，你想阅读到更多先进的技术；也可能你是一位iOS新人，渴望阅读一些iOS进阶的文章；还可能你是一位大学生，或者是你已经上班，想转行做iOS开发，你想阅读一些如何入门的文章。</p>

<p>这些我都知道。我也在努力去改变，去写一些真正能够帮助到大家的文章。我甚至发说说，问我的朋友，如何提高写作水平？</p>

<p>后来，我发现我错了。iOS开发分享的是技术文章，不是华丽的文字。</p>

<p>我希望能从我的手里写出更多优秀的文章。这对于我来说，真的是一个很大的挑战。我相信，只要我坚持，我就能为大家提供更多优质的文章。</p>

<h2>iOS入门：坚持做一个项目</h2>

<p>有人在微信里问我，iOS开发如何入门。我给大家讲一个，我身边的真实案例。</p>

<p>我有一个朋友，我们叫他A吧。A刚来上海工作，是做Java的，在一家房地产公司。工作相对来说比较稳定，偶尔也加加班，这对程序员来说是常态。</p>

<p>后来，A想学iOS开发。A是一个行动力很强的人，立马花了一万多买了一个MacBook。开始iOS学习之旅。</p>

<p>A的学习方法很简单，网上下载了一些iOS入门视频。他就跟着视频里讲的，做一个新浪微博客户端。</p>

<p>连续写了一个多月，终于，把新浪微博做出来。做到过程中，他遇到一些开发上的问题。就问问身边的朋友，或者百度一下，google一下。</p>

<p>在解决问题的过程中，很熟练地掌握了iOS开发。过完年来了，立马换了一家公司做iOS开发的。薪资比他做Java工作要高一些。</p>

<p>所以，如果你在问iOS开发如何入门，请你认认真真的写一个项目。遇到问题，一定要想办法解决它，解决问题就是学习最好的方法。</p>

<h2>欢迎投稿</h2>

<p>订阅iOS开发的用户不乏有一些大牛，希望你们能把自己的技术分享出来。分享既是快乐，分享既是成长。</p>

<p>投稿邮箱：<strong>worldligang@163.com</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CGContextRef使用简要教程]]></title>
    <link href="http://www.superqq.com/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng/"/>
    <updated>2015-06-29T10:55:01+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng</id>
    <content type="html"><![CDATA[<p>Graphics Context是图形上下文,也可以理解为一块画布,我们可以在上面进行绘画操作,绘制完成后,将画布放到我们的view中显示即可,view看作是一个画框.</p>

<p>CGContextRef功能强大，我们借助它可以画各种图形。开发过程中灵活运用这些技巧，可以帮助我们提供代码水平。</p>

<p>说到画图，我就立马想到：我的数学公式都快忘完了。</p>

<h2>高中数学你还记得多少？</h2>

<p>我记得我上学的时候，数学一直都很好。以至于在班里都不敢和别人吵吵闹闹。一吵吵闹闹，别人就会来一句：以为你数学好，就可以怎么样怎么样了是吧？说的我好无奈啊。</p>

<p>这么多年过去了，说句实话，高中时学的数学公式什么的，都忘记的差不多了。现在要去做高三的考题，估计比写代码还难。</p>

<p>作为一名程序员，数学好，一定是优势。就拿画图来说吧，如果你还清楚的记得那些公式，那么你就可以很随意地画出一些好看的图形出来。</p>

<p>接下来，我们来看看CGContextRef到底能实现些什么？</p>

<h2>写文字</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //开始写字
    [@"我是文字" drawInRect:CGRectMake(10, 10, 100, 30) withFont:font];  
    [super drawRect:rect];
}
</code></pre>

<p>这段代码就可以很漂亮的写出四个大字：我是文字。很容易理解，每句话都有注释。</p>

<h2>画直线</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //顶部横线
    CGContextMoveToPoint(ctx, 0, 10);
    CGContextAddLineToPoint(ctx, self.bounds.size.width, 10);
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<h2>画圆</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //void CGContextAddArc(CGContextRef c,CGFloat x, CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle, int clockwise)1弧度＝180°/π （≈57.3°） 度＝弧度×180°/π 360°＝360×π/180 ＝2π 弧度
    // x,y为圆点坐标，radius半径，startAngle为开始的弧度，endAngle为 结束的弧度，clockwise 0为顺时针，1为逆时针。
    CGContextAddArc(ctx, 100, 20, 20, 0, 2*M_PI, 0); //添加一个圆
    CGContextDrawPath(ctx, kCGPathStroke); //绘制路径
    [super drawRect:rect];
}
</code></pre>

<p>这个画圆的公式你还记得吗？你还知道M_PI是什么吗？等于多少吗？赶紧脑补一下吧！</p>

<h2>画矩形</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    CGContextAddRect(ctx, CGRectMake(2, 2, 30, 30));
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<p>图形千千万，万变不离其宗。更多画图方法，期待你的探索。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用正则表达式验证邮箱和手机号]]></title>
    <link href="http://www.superqq.com/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao/"/>
    <updated>2015-06-27T07:35:42+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao</id>
    <content type="html"><![CDATA[<blockquote><p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></blockquote>

<p>做iOS开发的童鞋，应该都用过正则表达式吧。正则表达式很好地，帮助我们判断一个字符串是否合法。比如：</p>

<ol>
<li><p>在做app注册页面的时候，需要判断手机号是否格式正确，是否够11位。</p></li>
<li><p>在做意见反馈的时候，需要判断邮箱格式是否正确。</p></li>
</ol>


<p>判断手机号和判断邮箱，应该是iOS开发者们最常用的。具体如何判断，简单整理如下：</p>

<h2>验证邮箱</h2>

<pre><code>+ (BOOL)validateEmail:(NSString *)email
{
    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}";
    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex];
    return [emailTest evaluateWithObject:email];
}
</code></pre>

<p>NSPredicate是一个Foundation类，是用来查询的，原理和用法都类似于SQL中的where。</p>

<h2>验证手机号</h2>

<h3>简单的判断方法</h3>

<pre><code>+ (BOOL)validatePhone:(NSString *)phone
{
    NSString *phoneRegex = @"1[3|5|7|8|][0-9]{9}";
    NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", phoneRegex];
    return [phoneTest evaluateWithObject:phone];
}
</code></pre>

<p>这只是简单地判断手机号格式。其实手机的格式还是有一点复杂的。</p>

<h3>详细的判断方法</h3>

<pre><code>//正则判断手机号码格式
+ (BOOL)validatePhone:(NSString *)phone
{
       /**
        * 手机号码
        * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        * 联通：130,131,132,152,155,156,185,186
        * 电信：133,1349,153,180,189
        */
       NSString * MOBILE = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";
       /**
        10         * 中国移动：China Mobile
        11         * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        12         */
       NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d{7}$";
       /**
        15         * 中国联通：China Unicom
        16         * 130,131,132,152,155,156,185,186
        17         */
       NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d{8}$";
       /**
        20         * 中国电信：China Telecom
        21         * 133,1349,153,180,189
        22         */
       NSString * CT = @"^1((33|53|8[09])[0-9]|349)\\d{7}$";
       /**
        25         * 大陆地区固话及小灵通
        26         * 区号：010,020,021,022,023,024,025,027,028,029
        27         * 号码：七位或八位
        28         */
      // NSString * PHS = @"^0(10|2[0-5789]|\\d{3})\\d{7,8}$";

     NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBILE];
     NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM];
     NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU];
     NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT];

    if (([regextestmobile evaluateWithObject:phone] == YES)
    || ([regextestcm evaluateWithObject:phone] == YES)
    || ([regextestct evaluateWithObject:phone] == YES)
    || ([regextestcu evaluateWithObject:phone] == YES))
    {
        if([regextestcm evaluateWithObject:phone] == YES) {
          NSLog(@"China Mobile");
        } else if([regextestct evaluateWithObject:phone] == YES) {
          NSLog(@"China Telecom");
        } else if ([regextestcu evaluateWithObject:phone] == YES) {
          NSLog(@"China Unicom");
        } else {
          NSLog(@"Unknow");
        }

        return YES;
    }
    else 
    {
        return NO;
    }
}
</code></pre>

<p>以上这段（来自网络）是手机号判断的详细方法。基本上这个判断就够用了，如果三大运营商，再出其他段的手机号。直接子啊上面做简单修改即可。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode真机调试报错：The Application Could Not Be Verified.]]></title>
    <link href="http://www.superqq.com/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified/"/>
    <updated>2015-06-26T15:33:34+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified</id>
    <content type="html"><![CDATA[<p> 今天真机调试的时候遇到这个错误：</p>

<pre><code>The application could not be verified.
</code></pre>

<p> 这还是第一次遇到，应该是手机上的app的证书跟现在的证书不一致导致。</p>

<p> 解决方法有两个</p>

<p> ###xcode中切换证书：</p>

<pre><code>你手机上的app用的是哪个证书，你现在还用那个证书运行。
</code></pre>

<p> ###删除手机上的app</p>

<pre><code>直接删除手机上的app，再运行就可以啦！
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSDate和NSString相互转换]]></title>
    <link href="http://www.superqq.com/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan/"/>
    <updated>2015-06-26T07:34:32+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan</id>
    <content type="html"><![CDATA[<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/2NSDate.jpg" alt="1" /></p>

<p>不积小流无以成江海，不及硅步无以至千里。做<a href="http://www.superqq.com/blog/2015/01/14/ioskai-fa-zhi-shou-shi-shi-bie-hui-zong/">iOS开发</a>也是这样，平时写代码要多收集一些有用的代码，以免每次都从新来一遍，不仅浪费时间，也影响开发效率。</p>

<p>有人把做app形容成盖房子，码农就是搬砖的，真的是形象无比。随着时间的推移，手里积累的优秀代码就越来越多。这样，盖起房子来，效率肯定是杠杠的。</p>

<p>我也会收集一些有用的代码，有的会写在博客里，有的会写成demo放在<a href="http://www.superqq.com/blog/2014/11/19/ioskai-fa-zhong-gitfen-zhi-chuang-jian-he-guan-li/">github</a>上面，有的就很安静的躺在我的电脑里。每次我用到的时候，我都会顺手复制过来。</p>

<p>今天给大家分享一些关于NSDate和NSString相互转换。百度一下，有一大推相关的方法。每次都百度，不如自己收集起来方便。</p>

<h2>NSDate转NSString</h2>

<p>日期转成字符串。这个虽然简单，但是我相信很多朋友初次遇到肯定束手无策。脑子里蹦出四个字：这怎么转？直接上代码：</p>

<pre><code>//获取系统当前时间
NSDate *currentDate = [NSDate date];
//用于格式化NSDate对象
NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
//设置格式：zzz表示时区
[dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
//NSDate转NSString
NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
//输出currentDateString
NSLog(@"%@",currentDateString);
</code></pre>

<p>NSDate对象包含两个部分，日期（Date）和时间（Time）。格式化的时间字符串主要也是针对日期和时间的。NSDateFormatter是一个很常用的类，用于格式化NSDate对象，支持本地化的信息。</p>

<p>NSDateFormatter常用的格式有：</p>

<pre><code>yyyy-MM-dd HH:mm:ss.SSS 
yyyy-MM-dd HH:mm:ss
yyyy-MM-dd
MM dd yyyy
</code></pre>

<p>NSDateFormatter格式化参数如下：</p>

<pre><code>G: 公元时代，例如AD公元
yy: 年的后2位
yyyy: 完整年
MM: 月，显示为1-12
MMM: 月，显示为英文月份简写,如 Jan
MMMM: 月，显示为英文月份全称，如 Janualy
dd: 日，2位数表示，如02
d: 日，1-2位显示，如 2
EEE: 简写星期几，如Sun
EEEE: 全写星期几，如Sunday
aa: 上下午，AM/PM
H: 时，24小时制，0-23
K：时，12小时制，0-11
m: 分，1-2位
mm: 分，2位
s: 秒，1-2位
ss: 秒，2位
S: 毫秒
</code></pre>

<h2>NSString转NSDate</h2>

<p>既然NSDate可以转成NSString，毫无疑问NSString也可以转成NSDate。代码如下：</p>

<pre><code>//需要转换的字符串
NSString *dateString = @"2015-06-26 08:08:08";
 //设置转换格式
NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
[formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
//NSString转NSDate
NSDate *date=[formatter dateFromString:dateString];
</code></pre>

<p>NSDate和NSString相互转换就是这么简单。</p>

<h2>转换工具类</h2>

<p>在项目中，我们需要用到转换的地方可能不止一处，所以建议我们定义一个工具类。在工具类里实现如下两个方法：</p>

<pre><code>//NSDate转NSString
+ (NSString *)stringFromDate:(NSDate *)date
{
    //获取系统当前时间
    NSDate *currentDate = [NSDate date];
    //用于格式化NSDate对象
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //设置格式：zzz表示时区
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
    //NSDate转NSString
    NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
    //输出currentDateString
    NSLog(@"%@",currentDateString);
    return currentDateString;
}

//NSString转NSDate
+ (NSDate *)dateFromString:(NSString *)string
{
    //需要转换的字符串
    NSString *dateString = @"2015-06-26 08:08:08";
    //设置转换格式
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    //NSString转NSDate
    NSDate *date=[formatter dateFromString:dateString];
    return date;
}
</code></pre>

<p>有了这个工具类，妈妈再也不用担心我的转换能力啦！</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何成为一名优秀的iOS开发工程师]]></title>
    <link href="http://www.superqq.com/blog/2015/06/25/ru-he-cheng-wei-%5B%3F%5D-ming-you-xiu-de-ioskai-fa-gong-cheng-shi/"/>
    <updated>2015-06-25T07:49:07+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/25/ru-he-cheng-wei-[?]-ming-you-xiu-de-ioskai-fa-gong-cheng-shi</id>
    <content type="html"><![CDATA[<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/1iOSkaifa.jpg" alt="1" /></p>

<p>如果你是一位专业的<strong>iOS开发工程师</strong>，你应该为自己感到自豪。因为你能在强大的iOS系统下，一展身手实现自己和他人的想法，这是一件令人无比激动的事情。</p>

<p>作为一名iOS开发工程师，你一定想成为行业的佼佼者。那么，如何成为一名优秀的iOS开发工程师呢？我觉得做到以下几点，你就离优秀越来越近了。</p>

<h3>提高英语水平</h3>

<p>作为码农，英语水平虽然不是一个硬指标，但是，如果你的英语水平足够好，那真是如虎添翼。在公司里面，糟糕的英语表达能力也掩盖了你在软件开发技术上的优势。</p>

<p>很多优秀的技术文章都是英文版本的，就像苹果官方文档一样，你看不懂你就比别人落后了一步。当这些文档被汉化，被翻译成中文，那是需要一段时间的。少则几天，多则几个月。所以与其被动等待，不如先把英语水平提上去。</p>

<p>英语的重要性，不言而喻，不仅仅有助于写代码。如果万一哪一天你成为公众人物了，你是想向刘强东一样讲英语，还是想向雷布斯一样讲英语呢？我觉得你应该更想像马云一样。</p>

<p>至于，如何提高英语水平，请问度娘。</p>

<h3>控制代码质量</h3>

<p>想成为优秀的iOS开发工程师，代码质量是很重要的一关。关于如何提高代码质量，推荐大家看一篇文章：<a href="http://www.90159.com/2015/06/17/Objective-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%9A26%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%A7%A3%E5%86%B3iOS%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/">Objective-C编码规范：26个方面解决iOS开发问题</a>，这篇文章详细的讲述了iOS开发方面的编码规范，建议大家多看一看。</p>

<p>如果你能按着上面的编码规范来规范自己，我觉得最起码你代码看起来就比较整洁。这样的话，哪怕你一个月回头再来看自己的代码，应该很快就可以理解。而且，当你离开现在的公司，不至于后来的人骂你。</p>

<p>没听人常说嘛：良好的习惯是成功的第一步，iOS开发者也不例外。</p>

<h3>写博客分享技术</h3>

<p>在csdn上看到有人问：不写博客的程序员是好程序员吗？这个问题问的其实挺好。不写博客的人也有进BAT的，BAT里面的程序员并不一定都写博客；写博客的人大部分都没有进BAT，比如像我这样的屌丝。</p>

<p>但是这并不能说明什么。且看，写博客的好处在哪里？</p>

<p><strong>写博客你可以交到一群志同道合的朋友</strong>。即使你们现实中从来没见过面，但是你们在互联网上有过思想的碰撞，这就已经足够了。</p>

<p><strong>书写就是很好的思考</strong>。当你想熟练掌握一项技能，请将你的技术分享出来吧。</p>

<p><strong>写的过程中也是学习</strong>。当你能把一项技术讲清楚，说明你已经完全理解了。</p>

<p><strong>你的博客将比简历更有价值</strong>。你在各大招聘网站写简历不如你有一个有价值的博客。</p>

<p>把技术分享出来，不仅帮助新人，更是提高自己，这是一种双赢。如果你写了技术文章没有好的地方可以发布，可以投稿给我：<a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x77;&#111;&#x72;&#x6c;&#x64;&#108;&#x69;&#x67;&#x61;&#110;&#103;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;">&#119;&#111;&#x72;&#x6c;&#100;&#108;&#105;&#103;&#97;&#110;&#103;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;</a> 我将发布在我的公众号iOS开发（<strong>iOSDevTip</strong>）上，直接分享给上万名iOS开发者。</p>

<h3>看github开源项目</h3>

<p>github对于程序员来说，可谓是一个金库。很多优秀的人才，都在上面开源自己的项目。这些人都是伟大的。</p>

<p>当你想实现一个功能，很有可能有一些大牛已经实现了。与其我们写出蹩脚代码来实现，不如去阅读大牛们在github上的开源项目。去看大牛是怎么实现的？思路是什么？如果是你你会怎么写？经过这样的思考之后，比你自己去实现重要的多。</p>

<p>如果你自己就是大牛，那就另说了。你可以实现之后，把代码分享到github，帮助更多人。</p>

<h3>实现自己的想法</h3>

<p>一个不想当老板的程序员不是好程序员。谁不想成为马云呢，谁不想改变世界呢。所以，你要敢想，然后通过自己的技术去实现它。</p>

<p>有些人可能以为：在公司里上班，去想做个什么东西，就是对老板不忠。这是一个很严重的错误想法。</p>

<p>在大公司，都是支持内部创业的。如果你有好的想法，尽管去干吧。说不定第一个天使投资人就是你的老板。屌丝逆袭说不定从此开始。</p>

<p>行了，醒醒，有想法更要有行动。</p>

<p>按照我们老师的话说：成为一名优秀的iOS开发工程师任重而道远！这句话也送给你。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Command – 命令模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/"/>
    <updated>2015-06-21T23:39:03+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi</id>
    <content type="html"><![CDATA[<p><strong>命令模式</strong>封装一个请求或行为作为一个对象。封装的请求比原的更加灵活，可以在对象之间传递，储存，动态修改，或放入一个队列。苹果的Target-Action调用机制已经实现了命令模式。</p>

<p>你可以查看跟多关于<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html">Target-Action</a>的苹果官方文档，
NSInvocation包含一个target对象，一个方法和一些参数。这个对象可以按需要动态修改。这是一个非常好的命令模式的列子。减少发送对象和接受对象之间的操作，直接写成一个请求或请求链。</p>

<h3>如何用命令模式</h3>

<p>调用之前，你需要设置取消动作的框架。所以你需要定义一个UIToolBar和NSMutableArray保存需要撤销的堆栈。</p>

<p>添加代码到ViewController.m 文件：</p>

<pre><code>    UIToolbar *toolbar;
// We will use this array as a stack to push and pop operation for the undo option
    NSMutableArray *undoStack;
</code></pre>

<p>创建一个toolbar将显示新的动作按钮，以及一个数组作为命令队列。</p>

<p>将下面的代码添加到viewDidLoad：</p>

<pre><code>  toolbar = [[UIToolbar alloc] init];
UIBarButtonItem *undoItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemUndo target:self action:@selector(undoAction)];
undoItem.enabled = NO;
UIBarButtonItem *space = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];
UIBarButtonItem *delete = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemTrash target:self action:@selector(deleteAlbum)];
[toolbar setItems:@[undoItem,space,delete]];
[self.view addSubview:toolbar];
undoStack = [[NSMutableArray alloc] init];
</code></pre>

<p>上面的代码创建了一个toolbar和两个按钮，它还创建一个空的撤消堆栈。这里的撤销按钮被禁用因为撤销栈为空。</p>

<p>将下面代码添加到ViewController.m：</p>

<pre><code>- (void)viewWillLayoutSubviews
{
    toolbar.frame = CGRectMake(0, self.view.frame.size.height-44, self.view.frame.size.width, 44);
    dataTable.frame = CGRectMake(0, 130, self.view.frame.size.width, self.view.frame.size.height - 200);
}
</code></pre>

<p>在ViewController.m增加三个方法：增加、删除、撤销。</p>

<p>增加一个新专辑代码如下：</p>

<pre><code>- (void)addAlbum:(Album*)album atIndex:(int)index
{
    [[LibraryAPI sharedInstance] addAlbum:album atIndex:index];
    currentAlbumIndex = index;
    [self reloadScroller];
}
</code></pre>

<p>在这里你添加相册，将其设置为当前专辑索引，并重新加载。</p>

<p>接下来就是删除方法：</p>

<pre><code>- (void)deleteAlbum
{
    // 1
    Album *deletedAlbum = allAlbums[currentAlbumIndex];

    // 2
    NSMethodSignature *sig = [self methodSignatureForSelector:@selector(addAlbum:atIndex:)];
    NSInvocation *undoAction = [NSInvocation invocationWithMethodSignature:sig];
    [undoAction setTarget:self];
    [undoAction setSelector:@selector(addAlbum:atIndex:)];
    [undoAction setArgument:&amp;deletedAlbum atIndex:2];
    [undoAction setArgument:&amp;currentAlbumIndex atIndex:3];
    [undoAction retainArguments];

    // 3
    [undoStack addObject:undoAction];

    // 4
    [[LibraryAPI sharedInstance] deleteAlbumAtIndex:currentAlbumIndex];
    [self reloadScroller];

    // 5
    [toolbar.items[0] setEnabled:YES];
}
</code></pre>

<p>这是一段新的令人激动的代码，讲解如下：</p>

<ol>
<li>得到要删除的专辑信息</li>
<li>Define an object of type NSMethodSignature to create the NSInvocation, which will be used to reverse the delete action if the user later decides to undo a deletion. The NSInvocation needs to know three things: The selector (what message to send), the target (who to send the message to) and the arguments of the message. In this example the message sent is delete’s opposite since when you undo a deletion, you need to add back the deleted album.</li>
<li>After the undoAction has been created you add it to the undoStack. This action will be added to the end of the array, just as in a normal stack.</li>
<li>Use LibraryAPI to delete the album from the data structure and reload the scroller.</li>
<li><p>Since there’s an action in the undo stack, you need to enable the undo button.</p>

<pre><code> 提示: With NSInvocation, you need to keep the following points in mind:

 The arguments must be passed by pointer.
 The arguments start at index 2; indices 0 and 1 are reserved for the target and the selector.
 If there’s a chance that the arguments will be deallocated, then you should call retainArguments.
</code></pre></li>
</ol>


<p>最后，添加撤销方法：</p>

<pre><code>- (void)undoAction
{
    if (undoStack.count &gt; 0)
    {
        NSInvocation *undoAction = [undoStack lastObject];
        [undoStack removeLastObject];
        [undoAction invoke];
    }

    if (undoStack.count == 0)
    {
        [toolbar.items[0] setEnabled:NO];
    }
}
</code></pre>

<p>这个撤销操作是取消栈里最后一个对象，This object is always of type NSInvocation and can be invoked by calling … invoke. This invokes the command you created earlier when the album was deleted, and adds the deleted album back to the album list. Since you also deleted the last object in the stack when you “popped” it, you now check to see if the stack is empty. If it is, that means there are no more actions to undo. So you disable the Undo button.</p>

<p>运行你的app，测试撤销功能，删除一个专辑（或两个）然后点击撤销按钮看看效果：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage4.png" alt="1" /></p>

<p>这也是一个很好的地方来测试是否你的相册数据保留会变化。现在，如果你删除一个专辑，app退到后台，并终止应用程序，在下次启动应用程序显示的专辑列表不会有删除专辑信息。</p>

<p>这里的源代码完成的项目：<a href="cdn2.raywenderlich.com/wp-content/uploads/2013/08/BlueLibrary-final.zip">最后bluelibrary</a></p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Archiving – 归档模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/"/>
    <updated>2015-06-20T06:54:13+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi</id>
    <content type="html"><![CDATA[<p><strong>备忘录模式</strong>就是苹果中一种归档形式。它能够把对象转化成一种数据流，在不依赖于外部类的私有属性的情况下来存储和取出数据。你可以在 iOS 6 by Tutorials 这本书的第 16 章读到更多的相关信息。或者这里 Apple’s Archives and Serializations Programming Guide。</p>

<h3>如何使用归档 Archiving</h3>

<p>首先，你需要声明 Album，用 NSCoding 协议来归档数据。打开 Album.h 文件，修改 @ interface 行如下：</p>

<pre><code>@interface Album : NSObject &lt;NSCoding&gt;
</code></pre>

<p>在 Album.m 添加下面两个方法：</p>

<pre><code>- (void)encodeWithCode:(NSCode *)aCoder
{
    [aCode encodeObject:self.year forKey:@“year”];
    [aCode encodeObject:self.title forKey:@“album”];
    [aCode encodeObject:self.artist forKey:@“artist”];
    [aCode encodeObject:self.coverUrl forKey:@“cover_url”];     [aCode encodeObject:self.genre forKey:@“genre”];
}

- (id)initWithCode:(NSCode *)aDecoder
{
    self = [super init];
    if (self) {
        _year = [aDecoder decodeObjectForKey:@“year”];
        _title = [aDecoder decodeObjectForKey:@“album”];
        _artist = [aDecoder decodeObjectForKey:@“artist”];
        _coverUrl = [aDecoder decodeObjectForKey:@“cover_url”];
        _genre = [aDecoder decodeObjectForKey:@“genre”];
    }
    return self;
}
</code></pre>

<p>当你存档这个类的实例时调用 encodeWithCoder:。相反，当你通过解档来创建一个 Album 实例时，需要调用 iniWithCode: 。就这么简单，非常强大。</p>

<p>现在 Album 类可以存档了，添加的代码实际上是存储和加载专辑列表的。</p>

<p>在 PersistencyManger.h 里添加下面方法：</p>

<pre><code>- (void)saveAlbums;
</code></pre>

<p>当存储专辑的时候调用些方法。</p>

<p>现在，在 PersistencyManger.m 里添加方法实现：</p>

<pre><code>- (void)saveAlbums
{
    NSString *filename = [NSHomeDirectory() stringByAppendingString:@“/Document/albums.bin”];
    NSData *data = [NSKeyedArchiver archivedDataWithRootObject:albums];
    [data writeToFile:filename atomically:YES];
}
</code></pre>

<p>NSKeyedArchiver 把专辑数组存档进一个叫 album.bin 的文件里。</p>

<p>当你存档的一个对象包含另一个对象的时候，存档自动递归的把子对象、子对象的子对象一并存储。在这个实例里，存储的是一个专辑实例的数组。因为数组和 Album 都支持 NSCopying 的接口，数组里的东西都会被自动存档。</p>

<p>现在用下面代码替换 PersistencyManger.m 里的 init 方法：</p>

<pre><code>- (id)init
{
    self = [super init];
    if (self) {
        NSData *data = [NSData dataWithContentsOfFile:[NSHomeDirectory() stringByAppendString:@“/Document/albums.bin”]];
        albums = [NSKeyedUnarchiver unarchiveObjectWithData:data];
        if (albums == nil) {
            albums = [NSMutableArray arrayWithArray:
                 @[[[Album alloc] initWithTitle:@"Best of Bowie" artist:@"David Bowie" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png" year:@"1992"],
                 [[Album alloc] initWithTitle:@"It's My Life" artist:@"No Doubt" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png" year:@"2003"],
                 [[Album alloc] initWithTitle:@"Nothing Like The Sun" artist:@"Sting" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png" year:@"1999"],
                 [[Album alloc] initWithTitle:@"Staring at the Sun" artist:@"U2" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png" year:@"2000"],
                 [[Album alloc] initWithTitle:@"American Pie" artist:@"Madonna" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png" year:@"2000"]]];
                [self saveAlbums];
        }
    }
    return self;
}
</code></pre>

<p>在新代码里，如果文件存在，NSKeyedUnarchiver 就从文件加载专辑数据。如果不存在，它就创建专辑数据，然后立即存储，为下一次启动 app 使用。</p>

<p>当然你也可以在 app 后台运行的时候再存储专辑数据。现在它看起来不是很有必要，但如果你在稍后添加修改专辑数据呢？你需要确保所有的数据修改都会被存储。</p>

<p>在 LibraryAPI.h 添加下面的方法</p>

<pre><code>- (void)saveAlbums;
</code></pre>

<p>因为程序的所以有服务都需要通过 LibraryAPI 提供，这就是程序为什么需要 PersistenrcyManger 来存储专辑数据。</p>

<p>现在在 LibraryAPI.m 中添加实现方法：</p>

<pre><code>- (void)saveAlbums
{
    [persistencyManger saveAlbums];
}
</code></pre>

<p>这里是从 LibraryAPI 调用 PersistencyManger 来存储专辑。</p>

<p>在 ViewController.m 文件 saveCurrentState 的后面添加下面代码：</p>

<p>[[LibraryAPI sharedInstance] saveAlbums];</p>

<p>上面的代码是每当 ViewController 存储当前状态时，使用 LibraryAPI 来存储专辑数据。</p>

<p>构建你的 app，检查所有的都能正确编译。</p>

<p>不幸的是，没有一种简单的方法来验证数据是否被正确的创建。你可以在 Finder 里检查模拟器下当前 app 的 Documents 文件夹，来看看专辑数据文件是否被创建，但是为了查看其它变化你还需要添加一些数据来改变专辑数据。</p>

<p>但是，为了修改数据，假使为了删除专辑而需要临时添加一个删除选项，但这个选项并不会一直在你的库中存在？此外，由于误操作，错误的删除了一个专辑，但如果给这个操作添加一个撤消选项不是很好吗？</p>

<p>现在是时候讨论最后一个设计模式了：<a href="http://www.superqq.com/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/">命令 Command</a>。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Memento – 备忘录模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/"/>
    <updated>2015-06-19T06:31:19+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi</id>
    <content type="html"><![CDATA[<p><strong>备忘录模式</strong>是捕获和具体化当前对象的内部状态。换句话说，就是在某个地方存储个东西。稍后，在不违反封装的情况下能够恢复这个具体化的状态；就是说，一些私有数据被私下存储下来了。</p>

<h3>如何使用备忘录模式</h3>

<p>添加下面两个方法到 ViewController.m 文件：</p>

<pre><code>- (void)saveCurrentState
{
    // 当用户退出应用之后再重新打开，他想要跟他之前退出时一样的状态
    // 退出应用，这个时候我们需要做的是把当前显示的专辑存储下来
    // 因为只有一小片信息，我们可用 NSUserDefaults 来存储信息
    [[NSUserDefaults standardUserDefaults] setInteger:currentAlbumIndex forKey:@“currentAlbumIndex”];
}

- (void)loadPreviousState
{
    currentAlbumIndex = [[NSUserDefaults standardUserDefaults] integerForKey@“currentAlbumIndex”];
    [self showDataForAlbumAtIndex:currentAlbumIndex];
}
</code></pre>

<p>saveCurrentState 存储当前专辑的索引到 NSUserDefaults ─ NSUserDefaults 是一个标准数据存储，iOS 用来专门存放程序设置和数据。</p>

<p>loadPreviousState 加载这之前存储的专辑索引。这不是备忘录模式的全部，不过你已经达到目的了。</p>

<p>现在，在 ViewController.m 里，滚动视图初始化之前，在 viewDidLoad 里添加下面一行：</p>

<pre><code>[self loadPreviousState];
</code></pre>

<p>当程序启动的时候加载上一次存储的状态。但是你在哪里存储程序的当前状态呢？你需要使用通知来做这样的事情。当程序进入后台时，iOS 会发送一个 UIApplicationDidEnterBackgroundNotification 通知。你可利用这个通知调用 saveCurrentState。就这么方便？</p>

<p>在 viewDidLoad: 最后面添加下面一行</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(saveCurrentState) name:UIApplicationDidEnterBackgroundNotification object:nil];
</code></pre>

<p>现在，当你的 app 进入后台运行后，ViewController 会自动调用 saveCurrentState 存储当前的状态。</p>

<p>现在，添加下面代码：</p>

<pre><code>- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}
</code></pre>

<p>这里是确保当 ViewController 被释放时，移除类的 <a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">Observer</a>。</p>

<p>构建和运行你的 app，点击到一个专辑，用 Command+Shift+H（如果你使用的是模拟器的话） 将程序在后台运行，然后关掉 app。重启 app，检查之前选择的专辑是不是居中显示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/2013-09-02_10-51-27-214x320.png" alt="1" /></p>

<p>专辑数据看起来是对的，但是正确的专辑封面确没有居中，哪出问题了？</p>

<p>这就是可选方法 initialViewIndexForHorizontalScroller 的用处！因为这个方法没有被委托执行，ViewController 在这种情况下总是会显示默认的第一个专辑封面。</p>

<p>修复这个问题，在 ViewController.m 中添加如下代码：</p>

<pre><code>- (NSInteger)initialViewIndexForHorizontalScroller:(HorizontalScroller *)scroller
{
    return currentAlbumIndex;
}
</code></pre>

<p>现在 HorizontalScroller 的第一个视图总是会被设置成 currentAlbumIndex 索引的图片。这种方法能够确保你的 app 有一个非常棒的用户体验，并且它是可恢复的。</p>

<p>重新运行你的 app，滚动专辑封面，关闭 app，然后重启确保问题已经得到解决：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/2013-09-02_10-56-59-214x320.png" alt="2" /></p>

<p>如果你查看 PersistencyManger 的初始化方法，你会注意到专辑的数据是一种硬编码，PersistencyManger 每次创建，数据也会重复创建一次。有没有一种更好的方法当专辑列表被创建的时候就存储它们呢。那么如何把专辑数据存储到文件里呢？</p>

<p>一种选择就是循环访问 Album 的属性，然后把它存储在一个 plist 文件里，当需要它们的时候重新创建一个 Album 的实例。这不是最好的选择，这需要你在每一个类里根据不同的数据或属性写特定的代码。例子，如果稍后你需要一个电影的类，里面有一些不同的属性，存储和加载这些数据你就需要写一些新的代码。</p>

<p>此外，你不能在每一个类的实例里存储私有变量，因为他们是不可访问的外部类。这就是为什么苹果要创建归档 (Archiving) 机制。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式系列：Observer – 观察者模式]]></title>
    <link href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/"/>
    <updated>2015-06-18T10:14:51+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>在<strong>观察者模式</strong>中，当状态发生改变的时候，一个对象会通知另一个对象。这个对象不需要知道另一个对象发生了什么改变─因此非常鼓励这种分离式的设计。这种模式经常用于，当一个属性发生改变时通知跟它相关的对象。</p>

<p>它通常需要一个观察者(observer)注册跟踪另外一个对象的状态。当状态发生改变的时候，所有的观察对象都会被通知改变。苹果的推送通知服务就是一个这样的例子。</p>

<p>如果你想要一直使用 <a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">MVC 模式</a>（你确实需要），你如果想在模型和视图之间，不直接相互引用的情况下还要有通信。这时候就要用到观察者模式了。</p>

<p>Cocoa 有两个常用的方法来执行观察者模式：Notifications 和 Key-Value Observing (KVO)。</p>

<h3>通知 Notifications</h3>

<p>不要把它和推送、本地通知弄混淆了，通知是基于一个对象（信息发布者）发信息给另一个对象（订阅/监听）的订阅-发布模式的。信息发布者不需要知道任何关于订阅者的信息。</p>

<p>苹果大量的使用了通知。例子，当键盘打开/关闭的时候，系统会分别发送一个 UIKeyboardWillShowNotification/UIKeyboardWillHideNotification。当你的程序要退出的时候，系统会发送一个 UIApplicationDidEnterBackgroundNotification 通知。</p>

<pre><code>提示：打开 UIApplication.h，在文件最后你会看见系统能发送的通知列表有 20 个之多。
</code></pre>

<h3>如何使用通知 Notifications</h3>

<p>打开 AlbumView.m 文件，在 initWithFrame:albumCover: 里面的 [self addSubview:indicator] 后面插入下面代码：</p>

<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:@“BLDownloadImageNotification” object:self userInfo:@{@“imageView”:coverImage, @“coverUrl”:albumCover}];
</code></pre>

<p>这行代码是通过 NSNotificationCenter 单例来发送一个通知。通知内容包括 coverImage 图片视图 和下载封面图片的 URL。这是执行下载专辑封面所需的所有信息。</p>

<p>在 LibraryAPI.m 的 init 方法里，isOnline = NO; 后面添加下面代码：</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downImage:) name:@“BLDownloadImageNotification” object:nil];
</code></pre>

<p>这是等式另一边的观察者对象。任何时候只要 AlbumView 类发送一个 BLDownloadImageNotification 通知，系统就会通知 LibraryAPI，因为 LibraryAPI 已经注册了一个相同的观察者通知。qLibraryAPI 执行 downloadImage:。</p>

<p>不管任何时候，在你执行 downloadImage: 之前，一定要记住在你释放这个类的时候一定要取消这个通知的订阅。如果你不正确的取消一个通知的订阅，这个通知可能发送一个已经释放的实例。这会造成你的程序崩溃。</p>

<p>在 LibraryAPI.m 里添加下面代码：</p>

<pre><code>- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removerObserver:self];
}
</code></pre>

<p>当这个类释放后，移除一个观察者自己已经注册的所有通知。</p>

<p>这里还有一件事情要做。它可以把下载过的封面图片存在本地，这样 app 就不用一次又一次的下载同一个图片了。</p>

<p>打开 PersistencyManger.h 添加下面两个方法：</p>

<pre><code>- (void)saveImage:(UIImage*)image filename:(NSString*)filename;
- (UIImage*)getImage:(NSString*)filename;
</code></pre>

<p>在 PersistencyManger.m 中实现：</p>

<pre><code>- (void)saveImage:(UIImage*)image filename:(NSString*)filename
{
    filename = [NSHomeDirectory() stringByAppendingFormat:@“/Documents/%@”, filename];
    NSData *data = UIImagePNGRepresentation(image);
    [data writeToFile:filename atomically:YES];
}

- (UIImage*)getImage:(NSString*)filename 
{
    filename = [NSHomeDirectory() stringByAppendingFormat:@“/Documents/%@“, filename];
    NSData *data = [NSData dataWithContentsOfFile:filename];
    return [UIImage imageWithData:data];
}
</code></pre>

<p>这里的代码很简单。下载完成的图片会被存储进 Documents 文件夹中，如果没有跟 filename 相匹配的文件，getImage: 会返回 nil。</p>

<p>现在在 LibraryAPI.m 里面添加下面方法：</p>

<pre><code>- (void)downImage:(NSNotification*)notification
{
    // 1 
    UIImageView *imageView = notification.userInfo[@“imageView”];
    NSString *coverUrl   = notification.userInfo[@“coverUrl”];

    // 2
    imageView.image = [persistencyManger getImage:[coverUrl lastPathComponent];

    if (imageView.image == nil) {
        // 3 
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            UIImage *image = [httpClient downloadImage:coverUrl];
            dispatch_sync(dispatch_get_main_queue(), ^{
                imageView.image = image;
                [persistencyManger saveImage:image filename:[coverUrl lastPathComponent];
            });
        });
    }
}
</code></pre>

<p>现在来分析上面的代码：</p>

<ol>
<li>通知执行 downloadImage 方法，方法接受这个这个通知对象，就像它是一个变量一样。通知里会传递 UIImageView 和图片的 URL。</li>
<li>如果以前已经下载过，就从 PersistencyManger 里取出图片。</li>
<li>如果图片没有下载过，使用 HTTPClient 开始下载图片。</li>
<li>当下载完成的时候，在图片视图中显示图片，用 PersistencyManger 存储它到本地。</li>
</ol>


<p>此外，你用外观模式(Facade pattern)隐藏了另外一个下载图片的复杂类。通知发送者不关心图片的来源，不管是从网上下载的还是本地存储的。</p>

<p>构建和运行你的 app，可以看到漂亮的封面已经出现在 HorizontalScroller 里面了：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-4-297x320.png" alt="1" /></p>

<p>停止你的 app，然后再运行它。注意这里显示封面已经没有延时了，因为它们已经下载到本地了。你可断开网络试试，你的 app 同样可以完美的运行。虽然已经很完美了，但是仍然有一个小问题：就是下载提示的小菊花仍然一直在转动，从来没有停止过！哪里出问题了？</p>

<p>当你开始下载图片的时候，你运行了下载提示符，但当图片下载完成的时候，你没有停止下载提示符的方法。你也可以当每个图片下载完成的时候再发送一个通知，当然另一个代替方案，你可以使用另一种观察者模式，KVO。</p>

<h3>键 – 值 观察 (Key-Value Observing KVO)</h3>

<p>在 <a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">KVO</a>  里，一个对象的任何一个特别的属性改变后都可以请求一个通知；不管是它自己的还是其它的对象。如果你感兴趣，你可以在这里读到更多的信息：Apple’s KVO Programming Guide.</p>

<h3>如何使用 KVO 模式</h3>

<p>如上所述，<a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">KVO</a> 的原理是允许一个对象观察一个属性的改变。你所要关心的是，使用 KVO 观察 UIImageView 的 image 属性是否已经改变，就是它是否已经存储了图片。</p>

<p>打开 AlbumView.m，在 initWithFrame:albumCover: 里的 [self addSubview:indicator]; 后面添加下面代码：</p>

<pre><code>[coverImage addObserver:self forKeyPath:@“image” options:0 context:nil];
</code></pre>

<p>不添加在自己上面(self)，在当前的类里，观察 coverImage 的 image 属性。</p>

<p>当你使用过后，你同样需要注销这个观察(observer)。继续在当前文件里面添加下面代码：</p>

<pre><code>- (void)dealloc
{
    [coverImage removerObserver:self forKeyPath:@“image”];
}
</code></pre>

<p>最后，添加下面方法：</p>

<pre><code>- (void)observerValueForKeyPath:(NSString*)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    if ([KeyPath isEqualToString:@“image”])
    {
        [indicator stopAnimating];
    }
}
</code></pre>

<p>你必须在每个类里执行这个方法。如果观察的属性改变了，系统每次都会执行这个方法。上面的代码里，当 image 的属性发生改变时，你停止下载提示符的运行。这种方法，当图片下载完成，下载提示转动的小菊花将会停止转动。</p>

<p>构建个运行你的项目。你会看到小菊花已经不在了：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage3-287x320.png" alt="2" /></p>

<pre><code>提示：永远记住，当你释放内存，你一定要移除这些观察(observers)，或者是当你的程序发送这些不存的观察对象时会造成程序崩溃。
</code></pre>

<p>如果你玩弄一会你的 app，然后关闭它，你程序的当前状态并没有被存储下来。当程序启动的时候你看到的视图并不是上次退出时的样子。</p>

<p>为了更正这些，你需要使用下一项设计模式：备忘录 (Memento)。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[上海iOS开发工资待遇如何？]]></title>
    <link href="http://www.superqq.com/blog/2015/06/17/shang-hai-ioskai-fa-gong-zi-dai-yu-ru-he-%3F/"/>
    <updated>2015-06-17T23:25:30+08:00</updated>
    <id>http://www.superqq.com/blog/2015/06/17/shang-hai-ioskai-fa-gong-zi-dai-yu-ru-he-?</id>
    <content type="html"><![CDATA[<p><strong>上海iOS开发</strong>工资待遇如何呢？一般来说，上海iOS开发的工资还算相对不错的，毕竟是一线城市的魔都，整体来说还算可以。</p>

<p>上海<a href="http://www.superqq.com/blog/2014/12/27/ioskai-fa-zhong-de-gcdduo-xian-cheng-tips/">iOS开发</a>起步薪资大概在5k~8k吧，如果你技术好，在大学里面就是学霸，对计算机也非常精通，超过8k，也不是完全没有可能的。5k~8k只是一个参考值，主要还是靠自己。</p>

<p>对于工作一两年的上海iOS开发者朋友们来说，工资应该在8k~15k。也就是说，上海iOS开发者有一两年工作经验，工资很轻松过五位数。</p>

<p>做一位一名程序员，工作过五位数很正常，尤其是上海iOS开发程序员。</p>

<p>当你在上海做iOS开发三四年以上，而且你的技术确实有牛C，这个时候，工资完全可以突破2万。2万对于程序员来说是一个重要的标志，上海iOS开发程序员也不例外。2万说明你应该是一名很不错的程序员了。</p>

<p>以上是上海iOS开发工资的一个参考，具体可以根据实际<a href="http://www.superqq.com/blog/2015/06/04/mian-shi-guan-wen-xian-zai-gong-zi-shi-duo-shao-gai-zen-yao-hui-da/">面试</a>情况来谈你的工资。</p>

<p>上海iOS开发需求量也很大，所以对于想进入iOS开发行业的人来说，上海iOS开发职位是一个很不错的选择。</p>
]]></content>
  </entry>
  
</feed>
