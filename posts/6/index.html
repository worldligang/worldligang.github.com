
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
      <meta name="baidu-site-verification" content="X93tJz3pCq" />
  <title>刚刚在线</title>
  <meta name="author" content="李刚">
  <meta name="uyan_auth" content="d1112891bb" />
  <meta name="baidu-tc-verification" content="7acda2305fabbf1ddd9f83e385ddd899" />
      
  
  <meta name="description" content="2年iOS开发站长，优秀iOS开发博客之一。关注iOS开发、swift开发、iOSDevTip、移动互联网、自媒体、Cocoapods、Xcode、iOS，刚刚在线博客是一个值得收藏的网站！">
  <meta name="keywords" content="iOS,iOS开发,cocoapods,code,iOS代码, 源代码, 刚刚在线,iOS李刚, pointInside, 刚刚, hitTest, Objective-c,李刚博客">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.superqq.com/posts/6">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="刚刚在线" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->


  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">刚刚在线</a></h1>
  
    <h2>分享iOS开发技术经验的自媒体网站</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://zhannei.superqq.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.superqq.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">全部文章</a></li>
  <li><a href="/blog/categories/ioskai-fa/">iOS开发</a></li>
  <li><a href="/blog/categories/swiftkai-fa">swift开发</a></li>
  <li><a href="/blog/categories/cheng-xu-yuan/">程序员</a></li>
  <li><a href="/blog/categories/yuan-dai-ma/">源代码</a></li>
  <li><a href="/blog/categories/sdkfu-wu/">sdk服务</a></li>
  <li><a href="/blog/categories/tui-jian/">推荐</a></li>
  <li><a href="/about">赞助作者</a></li>
  <li><a href="http://www.90159.com/" target="_blank" title=头条>头条</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/30/wei-you-jian-chi-fang-neng-cheng-gong/">唯有坚持方能成功</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-30T00:44:54+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:44 am</span></time>
        
        
          | <a href="/blog/2015/06/30/wei-you-jian-chi-fang-neng-cheng-gong/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/jianchi.jpg" alt="2" /></p>

<p>或许这不是一篇心灵鸡汤，因为心灵鸡汤不是我的擅长;或许这就是一篇心灵鸡汤，希望能点燃你的斗志。</p>

<h2>坚持才有希望</h2>

<p>我常说一句话：不是因为有了希望才坚持，而是坚持了才有希望。我也一直用这句话来告诫自己。只要持续努力，才有成功的可能。</p>

<p>以前，我认为如果谁能给我机会，我将会怎样怎样。我就一直等啊等，等啊等，两年三年后，好像发现没人会给我机会，反而错过很多本应该能抓住的机会。</p>

<p>现在，我改变了这种想法。我要用自己的努力，自己的坚持，来获取更多的机会，更多的可能。</p>

<h2>iOS开发开通原创功能</h2>

<p>就在昨天20:11微信团队邀请我开通微信原创功能。对于我来说，这是一个值得纪念的时刻，这也是对我的努力的一种肯定。特给大家分享一下：</p>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/yuanchuang.png" alt="2" /></p>

<p>随着iOS开发微信微信公众号订阅的用户越来越多，让我觉得责任越来越重。</p>

<p>正在看文章的你，可能是一位技术大牛，有时候我发的文章很基础，你会觉得文章水平太低，你想阅读到更多先进的技术；也可能你是一位iOS新人，渴望阅读一些iOS进阶的文章；还可能你是一位大学生，或者是你已经上班，想转行做iOS开发，你想阅读一些如何入门的文章。</p>

<p>这些我都知道。我也在努力去改变，去写一些真正能够帮助到大家的文章。我甚至发说说，问我的朋友，如何提高写作水平？</p>

<p>后来，我发现我错了。iOS开发分享的是技术文章，不是华丽的文字。</p>

<p>我希望能从我的手里写出更多优秀的文章。这对于我来说，真的是一个很大的挑战。我相信，只要我坚持，我就能为大家提供更多优质的文章。</p>

<h2>iOS入门：坚持做一个项目</h2>

<p>有人在微信里问我，iOS开发如何入门。我给大家讲一个，我身边的真实案例。</p>

<p>我有一个朋友，我们叫他A吧。A刚来上海工作，是做Java的，在一家房地产公司。工作相对来说比较稳定，偶尔也加加班，这对程序员来说是常态。</p>

<p>后来，A想学iOS开发。A是一个行动力很强的人，立马花了一万多买了一个MacBook。开始iOS学习之旅。</p>

<p>A的学习方法很简单，网上下载了一些iOS入门视频。他就跟着视频里讲的，做一个新浪微博客户端。</p>

<p>连续写了一个多月，终于，把新浪微博做出来。做到过程中，他遇到一些开发上的问题。就问问身边的朋友，或者百度一下，google一下。</p>

<p>在解决问题的过程中，很熟练地掌握了iOS开发。过完年来了，立马换了一家公司做iOS开发的。薪资比他做Java工作要高一些。</p>

<p>所以，如果你在问iOS开发如何入门，请你认认真真的写一个项目。遇到问题，一定要想办法解决它，解决问题就是学习最好的方法。</p>

<h2>欢迎投稿</h2>

<p>订阅iOS开发的用户不乏有一些大牛，希望你们能把自己的技术分享出来。分享既是快乐，分享既是成长。</p>

<p>投稿邮箱：<strong>worldligang@163.com</strong></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng/">CGContextRef使用简要教程</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-29T10:55:01+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:55 am</span></time>
        
        
          | <a href="/blog/2015/06/29/cgcontextrefshi-yong-jian-yao-jiao-cheng/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>Graphics Context是图形上下文,也可以理解为一块画布,我们可以在上面进行绘画操作,绘制完成后,将画布放到我们的view中显示即可,view看作是一个画框.</p>

<p>CGContextRef功能强大，我们借助它可以画各种图形。开发过程中灵活运用这些技巧，可以帮助我们提供代码水平。</p>

<p>说到画图，我就立马想到：我的数学公式都快忘完了。</p>

<h2>高中数学你还记得多少？</h2>

<p>我记得我上学的时候，数学一直都很好。以至于在班里都不敢和别人吵吵闹闹。一吵吵闹闹，别人就会来一句：以为你数学好，就可以怎么样怎么样了是吧？说的我好无奈啊。</p>

<p>这么多年过去了，说句实话，高中时学的数学公式什么的，都忘记的差不多了。现在要去做高三的考题，估计比写代码还难。</p>

<p>作为一名程序员，数学好，一定是优势。就拿画图来说吧，如果你还清楚的记得那些公式，那么你就可以很随意地画出一些好看的图形出来。</p>

<p>接下来，我们来看看CGContextRef到底能实现些什么？</p>

<h2>写文字</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //开始写字
    [@"我是文字" drawInRect:CGRectMake(10, 10, 100, 30) withFont:font];  
    [super drawRect:rect];
}
</code></pre>

<p>这段代码就可以很漂亮的写出四个大字：我是文字。很容易理解，每句话都有注释。</p>

<h2>画直线</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //顶部横线
    CGContextMoveToPoint(ctx, 0, 10);
    CGContextAddLineToPoint(ctx, self.bounds.size.width, 10);
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<h2>画圆</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    //void CGContextAddArc(CGContextRef c,CGFloat x, CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle, int clockwise)1弧度＝180°/π （≈57.3°） 度＝弧度×180°/π 360°＝360×π/180 ＝2π 弧度
    // x,y为圆点坐标，radius半径，startAngle为开始的弧度，endAngle为 结束的弧度，clockwise 0为顺时针，1为逆时针。
    CGContextAddArc(ctx, 100, 20, 20, 0, 2*M_PI, 0); //添加一个圆
    CGContextDrawPath(ctx, kCGPathStroke); //绘制路径
    [super drawRect:rect];
}
</code></pre>

<p>这个画圆的公式你还记得吗？你还知道M_PI是什么吗？等于多少吗？赶紧脑补一下吧！</p>

<h2>画矩形</h2>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //获得当前画板
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    //颜色
    CGContextSetRGBStrokeColor(ctx, 0.2, 0.2, 0.2, 1.0);
    //画线的宽度
    CGContextSetLineWidth(ctx, 0.25);
    CGContextAddRect(ctx, CGRectMake(2, 2, 30, 30));
    CGContextStrokePath(ctx);
    [super drawRect:rect];
}
</code></pre>

<p>图形千千万，万变不离其宗。更多画图方法，期待你的探索。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao/">用正则表达式验证邮箱和手机号</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-27T07:35:42+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:35 am</span></time>
        
        
          | <a href="/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></blockquote>

<p>做iOS开发的童鞋，应该都用过正则表达式吧。正则表达式很好地，帮助我们判断一个字符串是否合法。比如：</p>

<ol>
<li><p>在做app注册页面的时候，需要判断手机号是否格式正确，是否够11位。</p></li>
<li><p>在做意见反馈的时候，需要判断邮箱格式是否正确。</p></li>
</ol>


<p>判断手机号和判断邮箱，应该是iOS开发者们最常用的。具体如何判断，简单整理如下：</p>

<h2>验证邮箱</h2>

<pre><code>+ (BOOL)validateEmail:(NSString *)email
{
    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}";
    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex];
    return [emailTest evaluateWithObject:email];
}
</code></pre>

<p>NSPredicate是一个Foundation类，是用来查询的，原理和用法都类似于SQL中的where。</p>

<h2>验证手机号</h2>

<h3>简单的判断方法</h3>

<pre><code>+ (BOOL)validatePhone:(NSString *)phone
{
    NSString *phoneRegex = @"1[3|5|7|8|][0-9]{9}";
    NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", phoneRegex];
    return [phoneTest evaluateWithObject:phone];
}
</code></pre>

<p>这只是简单地判断手机号格式。其实手机的格式还是有一点复杂的。</p>

<h3>详细的判断方法</h3>

<pre><code>//正则判断手机号码格式
+ (BOOL)validatePhone:(NSString *)phone
{
       /**
        * 手机号码
        * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        * 联通：130,131,132,152,155,156,185,186
        * 电信：133,1349,153,180,189
        */
       NSString * MOBILE = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";
       /**
        10         * 中国移动：China Mobile
        11         * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        12         */
       NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d{7}$";
       /**
        15         * 中国联通：China Unicom
        16         * 130,131,132,152,155,156,185,186
        17         */
       NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d{8}$";
       /**
        20         * 中国电信：China Telecom
        21         * 133,1349,153,180,189
        22         */
       NSString * CT = @"^1((33|53|8[09])[0-9]|349)\\d{7}$";
       /**
        25         * 大陆地区固话及小灵通
        26         * 区号：010,020,021,022,023,024,025,027,028,029
        27         * 号码：七位或八位
        28         */
      // NSString * PHS = @"^0(10|2[0-5789]|\\d{3})\\d{7,8}$";

     NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBILE];
     NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM];
     NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU];
     NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT];

    if (([regextestmobile evaluateWithObject:phone] == YES)
    || ([regextestcm evaluateWithObject:phone] == YES)
    || ([regextestct evaluateWithObject:phone] == YES)
    || ([regextestcu evaluateWithObject:phone] == YES))
    {
        if([regextestcm evaluateWithObject:phone] == YES) {
          NSLog(@"China Mobile");
        } else if([regextestct evaluateWithObject:phone] == YES) {
          NSLog(@"China Telecom");
        } else if ([regextestcu evaluateWithObject:phone] == YES) {
          NSLog(@"China Unicom");
        } else {
          NSLog(@"Unknow");
        }

        return YES;
    }
    else 
    {
        return NO;
    }
}
</code></pre>

<p>以上这段（来自网络）是手机号判断的详细方法。基本上这个判断就够用了，如果三大运营商，再出其他段的手机号。直接子啊上面做简单修改即可。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified/">Xcode真机调试报错：The Application Could Not Be Verified.</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-26T15:33:34+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>3:33 pm</span></time>
        
        
          | <a href="/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p> 今天真机调试的时候遇到这个错误：</p>

<pre><code>The application could not be verified.
</code></pre>

<p> 这还是第一次遇到，应该是手机上的app的证书跟现在的证书不一致导致。</p>

<p> 解决方法有两个</p>

<p> ###xcode中切换证书：</p>

<pre><code>你手机上的app用的是哪个证书，你现在还用那个证书运行。
</code></pre>

<p> ###删除手机上的app</p>

<pre><code>直接删除手机上的app，再运行就可以啦！
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan/">NSDate和NSString相互转换</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-26T07:34:32+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:34 am</span></time>
        
        
          | <a href="/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/2NSDate.jpg" alt="1" /></p>

<p>不积小流无以成江海，不及硅步无以至千里。做<a href="http://www.superqq.com/blog/2015/01/14/ioskai-fa-zhi-shou-shi-shi-bie-hui-zong/">iOS开发</a>也是这样，平时写代码要多收集一些有用的代码，以免每次都从新来一遍，不仅浪费时间，也影响开发效率。</p>

<p>有人把做app形容成盖房子，码农就是搬砖的，真的是形象无比。随着时间的推移，手里积累的优秀代码就越来越多。这样，盖起房子来，效率肯定是杠杠的。</p>

<p>我也会收集一些有用的代码，有的会写在博客里，有的会写成demo放在<a href="http://www.superqq.com/blog/2014/11/19/ioskai-fa-zhong-gitfen-zhi-chuang-jian-he-guan-li/">github</a>上面，有的就很安静的躺在我的电脑里。每次我用到的时候，我都会顺手复制过来。</p>

<p>今天给大家分享一些关于NSDate和NSString相互转换。百度一下，有一大推相关的方法。每次都百度，不如自己收集起来方便。</p>

<h2>NSDate转NSString</h2>

<p>日期转成字符串。这个虽然简单，但是我相信很多朋友初次遇到肯定束手无策。脑子里蹦出四个字：这怎么转？直接上代码：</p>

<pre><code>//获取系统当前时间
NSDate *currentDate = [NSDate date];
//用于格式化NSDate对象
NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
//设置格式：zzz表示时区
[dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
//NSDate转NSString
NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
//输出currentDateString
NSLog(@"%@",currentDateString);
</code></pre>

<p>NSDate对象包含两个部分，日期（Date）和时间（Time）。格式化的时间字符串主要也是针对日期和时间的。NSDateFormatter是一个很常用的类，用于格式化NSDate对象，支持本地化的信息。</p>

<p>NSDateFormatter常用的格式有：</p>

<pre><code>yyyy-MM-dd HH:mm:ss.SSS 
yyyy-MM-dd HH:mm:ss
yyyy-MM-dd
MM dd yyyy
</code></pre>

<p>NSDateFormatter格式化参数如下：</p>

<pre><code>G: 公元时代，例如AD公元
yy: 年的后2位
yyyy: 完整年
MM: 月，显示为1-12
MMM: 月，显示为英文月份简写,如 Jan
MMMM: 月，显示为英文月份全称，如 Janualy
dd: 日，2位数表示，如02
d: 日，1-2位显示，如 2
EEE: 简写星期几，如Sun
EEEE: 全写星期几，如Sunday
aa: 上下午，AM/PM
H: 时，24小时制，0-23
K：时，12小时制，0-11
m: 分，1-2位
mm: 分，2位
s: 秒，1-2位
ss: 秒，2位
S: 毫秒
</code></pre>

<h2>NSString转NSDate</h2>

<p>既然NSDate可以转成NSString，毫无疑问NSString也可以转成NSDate。代码如下：</p>

<pre><code>//需要转换的字符串
NSString *dateString = @"2015-06-26 08:08:08";
 //设置转换格式
NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
[formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
//NSString转NSDate
NSDate *date=[formatter dateFromString:dateString];
</code></pre>

<p>NSDate和NSString相互转换就是这么简单。</p>

<h2>转换工具类</h2>

<p>在项目中，我们需要用到转换的地方可能不止一处，所以建议我们定义一个工具类。在工具类里实现如下两个方法：</p>

<pre><code>//NSDate转NSString
+ (NSString *)stringFromDate:(NSDate *)date
{
    //获取系统当前时间
    NSDate *currentDate = [NSDate date];
    //用于格式化NSDate对象
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //设置格式：zzz表示时区
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
    //NSDate转NSString
    NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
    //输出currentDateString
    NSLog(@"%@",currentDateString);
    return currentDateString;
}

//NSString转NSDate
+ (NSDate *)dateFromString:(NSString *)string
{
    //需要转换的字符串
    NSString *dateString = @"2015-06-26 08:08:08";
    //设置转换格式
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    //NSString转NSDate
    NSDate *date=[formatter dateFromString:dateString];
    return date;
}
</code></pre>

<p>有了这个工具类，妈妈再也不用担心我的转换能力啦！</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/25/ru-he-cheng-wei-%5B%3F%5D-ming-you-xiu-de-ioskai-fa-gong-cheng-shi/">如何成为一名优秀的iOS开发工程师</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-25T07:49:07+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:49 am</span></time>
        
        
          | <a href="/blog/2015/06/25/ru-he-cheng-wei-%5B%3F%5D-ming-you-xiu-de-ioskai-fa-gong-cheng-shi/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/1iOSkaifa.jpg" alt="1" /></p>

<p>如果你是一位专业的<strong>iOS开发工程师</strong>，你应该为自己感到自豪。因为你能在强大的iOS系统下，一展身手实现自己和他人的想法，这是一件令人无比激动的事情。</p>

<p>作为一名iOS开发工程师，你一定想成为行业的佼佼者。那么，如何成为一名优秀的iOS开发工程师呢？我觉得做到以下几点，你就离优秀越来越近了。</p>

<h3>提高英语水平</h3>

<p>作为码农，英语水平虽然不是一个硬指标，但是，如果你的英语水平足够好，那真是如虎添翼。在公司里面，糟糕的英语表达能力也掩盖了你在软件开发技术上的优势。</p>

<p>很多优秀的技术文章都是英文版本的，就像苹果官方文档一样，你看不懂你就比别人落后了一步。当这些文档被汉化，被翻译成中文，那是需要一段时间的。少则几天，多则几个月。所以与其被动等待，不如先把英语水平提上去。</p>

<p>英语的重要性，不言而喻，不仅仅有助于写代码。如果万一哪一天你成为公众人物了，你是想向刘强东一样讲英语，还是想向雷布斯一样讲英语呢？我觉得你应该更想像马云一样。</p>

<p>至于，如何提高英语水平，请问度娘。</p>

<h3>控制代码质量</h3>

<p>想成为优秀的iOS开发工程师，代码质量是很重要的一关。关于如何提高代码质量，推荐大家看一篇文章：<a href="http://www.90159.com/2015/06/17/Objective-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%9A26%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%A7%A3%E5%86%B3iOS%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/">Objective-C编码规范：26个方面解决iOS开发问题</a>，这篇文章详细的讲述了iOS开发方面的编码规范，建议大家多看一看。</p>

<p>如果你能按着上面的编码规范来规范自己，我觉得最起码你代码看起来就比较整洁。这样的话，哪怕你一个月回头再来看自己的代码，应该很快就可以理解。而且，当你离开现在的公司，不至于后来的人骂你。</p>

<p>没听人常说嘛：良好的习惯是成功的第一步，iOS开发者也不例外。</p>

<h3>写博客分享技术</h3>

<p>在csdn上看到有人问：不写博客的程序员是好程序员吗？这个问题问的其实挺好。不写博客的人也有进BAT的，BAT里面的程序员并不一定都写博客；写博客的人大部分都没有进BAT，比如像我这样的屌丝。</p>

<p>但是这并不能说明什么。且看，写博客的好处在哪里？</p>

<p><strong>写博客你可以交到一群志同道合的朋友</strong>。即使你们现实中从来没见过面，但是你们在互联网上有过思想的碰撞，这就已经足够了。</p>

<p><strong>书写就是很好的思考</strong>。当你想熟练掌握一项技能，请将你的技术分享出来吧。</p>

<p><strong>写的过程中也是学习</strong>。当你能把一项技术讲清楚，说明你已经完全理解了。</p>

<p><strong>你的博客将比简历更有价值</strong>。你在各大招聘网站写简历不如你有一个有价值的博客。</p>

<p>把技术分享出来，不仅帮助新人，更是提高自己，这是一种双赢。如果你写了技术文章没有好的地方可以发布，可以投稿给我：<a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x77;&#x6f;&#114;&#x6c;&#x64;&#108;&#x69;&#x67;&#x61;&#x6e;&#x67;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#109;">&#119;&#x6f;&#114;&#x6c;&#x64;&#108;&#105;&#103;&#97;&#x6e;&#103;&#64;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a> 我将发布在我的公众号iOS开发（<strong>iOSDevTip</strong>）上，直接分享给上万名iOS开发者。</p>

<h3>看github开源项目</h3>

<p>github对于程序员来说，可谓是一个金库。很多优秀的人才，都在上面开源自己的项目。这些人都是伟大的。</p>

<p>当你想实现一个功能，很有可能有一些大牛已经实现了。与其我们写出蹩脚代码来实现，不如去阅读大牛们在github上的开源项目。去看大牛是怎么实现的？思路是什么？如果是你你会怎么写？经过这样的思考之后，比你自己去实现重要的多。</p>

<p>如果你自己就是大牛，那就另说了。你可以实现之后，把代码分享到github，帮助更多人。</p>

<h3>实现自己的想法</h3>

<p>一个不想当老板的程序员不是好程序员。谁不想成为马云呢，谁不想改变世界呢。所以，你要敢想，然后通过自己的技术去实现它。</p>

<p>有些人可能以为：在公司里上班，去想做个什么东西，就是对老板不忠。这是一个很严重的错误想法。</p>

<p>在大公司，都是支持内部创业的。如果你有好的想法，尽管去干吧。说不定第一个天使投资人就是你的老板。屌丝逆袭说不定从此开始。</p>

<p>行了，醒醒，有想法更要有行动。</p>

<p>按照我们老师的话说：成为一名优秀的iOS开发工程师任重而道远！这句话也送给你。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/">iOS 设计模式系列：Command – 命令模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-21T23:39:03+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>11:39 pm</span></time>
        
        
          | <a href="/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p><strong>命令模式</strong>封装一个请求或行为作为一个对象。封装的请求比原的更加灵活，可以在对象之间传递，储存，动态修改，或放入一个队列。苹果的Target-Action调用机制已经实现了命令模式。</p>

<p>你可以查看跟多关于<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html">Target-Action</a>的苹果官方文档，
NSInvocation包含一个target对象，一个方法和一些参数。这个对象可以按需要动态修改。这是一个非常好的命令模式的列子。减少发送对象和接受对象之间的操作，直接写成一个请求或请求链。</p>

<h3>如何用命令模式</h3>

<p>调用之前，你需要设置取消动作的框架。所以你需要定义一个UIToolBar和NSMutableArray保存需要撤销的堆栈。</p>

<p>添加代码到ViewController.m 文件：</p>

<pre><code>    UIToolbar *toolbar;
// We will use this array as a stack to push and pop operation for the undo option
    NSMutableArray *undoStack;
</code></pre>

<p>创建一个toolbar将显示新的动作按钮，以及一个数组作为命令队列。</p>

<p>将下面的代码添加到viewDidLoad：</p>

<pre><code>  toolbar = [[UIToolbar alloc] init];
UIBarButtonItem *undoItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemUndo target:self action:@selector(undoAction)];
undoItem.enabled = NO;
UIBarButtonItem *space = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];
UIBarButtonItem *delete = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemTrash target:self action:@selector(deleteAlbum)];
[toolbar setItems:@[undoItem,space,delete]];
[self.view addSubview:toolbar];
undoStack = [[NSMutableArray alloc] init];
</code></pre>

<p>上面的代码创建了一个toolbar和两个按钮，它还创建一个空的撤消堆栈。这里的撤销按钮被禁用因为撤销栈为空。</p>

<p>将下面代码添加到ViewController.m：</p>

<pre><code>- (void)viewWillLayoutSubviews
{
    toolbar.frame = CGRectMake(0, self.view.frame.size.height-44, self.view.frame.size.width, 44);
    dataTable.frame = CGRectMake(0, 130, self.view.frame.size.width, self.view.frame.size.height - 200);
}
</code></pre>

<p>在ViewController.m增加三个方法：增加、删除、撤销。</p>

<p>增加一个新专辑代码如下：</p>

<pre><code>- (void)addAlbum:(Album*)album atIndex:(int)index
{
    [[LibraryAPI sharedInstance] addAlbum:album atIndex:index];
    currentAlbumIndex = index;
    [self reloadScroller];
}
</code></pre>

<p>在这里你添加相册，将其设置为当前专辑索引，并重新加载。</p>

<p>接下来就是删除方法：</p>

<pre><code>- (void)deleteAlbum
{
    // 1
    Album *deletedAlbum = allAlbums[currentAlbumIndex];

    // 2
    NSMethodSignature *sig = [self methodSignatureForSelector:@selector(addAlbum:atIndex:)];
    NSInvocation *undoAction = [NSInvocation invocationWithMethodSignature:sig];
    [undoAction setTarget:self];
    [undoAction setSelector:@selector(addAlbum:atIndex:)];
    [undoAction setArgument:&amp;deletedAlbum atIndex:2];
    [undoAction setArgument:&amp;currentAlbumIndex atIndex:3];
    [undoAction retainArguments];

    // 3
    [undoStack addObject:undoAction];

    // 4
    [[LibraryAPI sharedInstance] deleteAlbumAtIndex:currentAlbumIndex];
    [self reloadScroller];

    // 5
    [toolbar.items[0] setEnabled:YES];
}
</code></pre>

<p>这是一段新的令人激动的代码，讲解如下：</p>

<ol>
<li>得到要删除的专辑信息</li>
<li>Define an object of type NSMethodSignature to create the NSInvocation, which will be used to reverse the delete action if the user later decides to undo a deletion. The NSInvocation needs to know three things: The selector (what message to send), the target (who to send the message to) and the arguments of the message. In this example the message sent is delete’s opposite since when you undo a deletion, you need to add back the deleted album.</li>
<li>After the undoAction has been created you add it to the undoStack. This action will be added to the end of the array, just as in a normal stack.</li>
<li>Use LibraryAPI to delete the album from the data structure and reload the scroller.</li>
<li><p>Since there’s an action in the undo stack, you need to enable the undo button.</p>

<pre><code> 提示: With NSInvocation, you need to keep the following points in mind:

 The arguments must be passed by pointer.
 The arguments start at index 2; indices 0 and 1 are reserved for the target and the selector.
 If there’s a chance that the arguments will be deallocated, then you should call retainArguments.
</code></pre></li>
</ol>


<p>最后，添加撤销方法：</p>

<pre><code>- (void)undoAction
{
    if (undoStack.count &gt; 0)
    {
        NSInvocation *undoAction = [undoStack lastObject];
        [undoStack removeLastObject];
        [undoAction invoke];
    }

    if (undoStack.count == 0)
    {
        [toolbar.items[0] setEnabled:NO];
    }
}
</code></pre>

<p>这个撤销操作是取消栈里最后一个对象，This object is always of type NSInvocation and can be invoked by calling … invoke. This invokes the command you created earlier when the album was deleted, and adds the deleted album back to the album list. Since you also deleted the last object in the stack when you “popped” it, you now check to see if the stack is empty. If it is, that means there are no more actions to undo. So you disable the Undo button.</p>

<p>运行你的app，测试撤销功能，删除一个专辑（或两个）然后点击撤销按钮看看效果：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage4.png" alt="1" /></p>

<p>这也是一个很好的地方来测试是否你的相册数据保留会变化。现在，如果你删除一个专辑，app退到后台，并终止应用程序，在下次启动应用程序显示的专辑列表不会有删除专辑信息。</p>

<p>这里的源代码完成的项目：<a href="cdn2.raywenderlich.com/wp-content/uploads/2013/08/BlueLibrary-final.zip">最后bluelibrary</a></p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-20T06:54:13+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:54 am</span></time>
        
        
          | <a href="/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p><strong>备忘录模式</strong>就是苹果中一种归档形式。它能够把对象转化成一种数据流，在不依赖于外部类的私有属性的情况下来存储和取出数据。你可以在 iOS 6 by Tutorials 这本书的第 16 章读到更多的相关信息。或者这里 Apple’s Archives and Serializations Programming Guide。</p>

<h3>如何使用归档 Archiving</h3>

<p>首先，你需要声明 Album，用 NSCoding 协议来归档数据。打开 Album.h 文件，修改 @ interface 行如下：</p>

<pre><code>@interface Album : NSObject &lt;NSCoding&gt;
</code></pre>

<p>在 Album.m 添加下面两个方法：</p>

<pre><code>- (void)encodeWithCode:(NSCode *)aCoder
{
    [aCode encodeObject:self.year forKey:@“year”];
    [aCode encodeObject:self.title forKey:@“album”];
    [aCode encodeObject:self.artist forKey:@“artist”];
    [aCode encodeObject:self.coverUrl forKey:@“cover_url”];     [aCode encodeObject:self.genre forKey:@“genre”];
}

- (id)initWithCode:(NSCode *)aDecoder
{
    self = [super init];
    if (self) {
        _year = [aDecoder decodeObjectForKey:@“year”];
        _title = [aDecoder decodeObjectForKey:@“album”];
        _artist = [aDecoder decodeObjectForKey:@“artist”];
        _coverUrl = [aDecoder decodeObjectForKey:@“cover_url”];
        _genre = [aDecoder decodeObjectForKey:@“genre”];
    }
    return self;
}
</code></pre>

<p>当你存档这个类的实例时调用 encodeWithCoder:。相反，当你通过解档来创建一个 Album 实例时，需要调用 iniWithCode: 。就这么简单，非常强大。</p>

<p>现在 Album 类可以存档了，添加的代码实际上是存储和加载专辑列表的。</p>

<p>在 PersistencyManger.h 里添加下面方法：</p>

<pre><code>- (void)saveAlbums;
</code></pre>

<p>当存储专辑的时候调用些方法。</p>

<p>现在，在 PersistencyManger.m 里添加方法实现：</p>

<pre><code>- (void)saveAlbums
{
    NSString *filename = [NSHomeDirectory() stringByAppendingString:@“/Document/albums.bin”];
    NSData *data = [NSKeyedArchiver archivedDataWithRootObject:albums];
    [data writeToFile:filename atomically:YES];
}
</code></pre>

<p>NSKeyedArchiver 把专辑数组存档进一个叫 album.bin 的文件里。</p>

<p>当你存档的一个对象包含另一个对象的时候，存档自动递归的把子对象、子对象的子对象一并存储。在这个实例里，存储的是一个专辑实例的数组。因为数组和 Album 都支持 NSCopying 的接口，数组里的东西都会被自动存档。</p>

<p>现在用下面代码替换 PersistencyManger.m 里的 init 方法：</p>

<pre><code>- (id)init
{
    self = [super init];
    if (self) {
        NSData *data = [NSData dataWithContentsOfFile:[NSHomeDirectory() stringByAppendString:@“/Document/albums.bin”]];
        albums = [NSKeyedUnarchiver unarchiveObjectWithData:data];
        if (albums == nil) {
            albums = [NSMutableArray arrayWithArray:
                 @[[[Album alloc] initWithTitle:@"Best of Bowie" artist:@"David Bowie" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png" year:@"1992"],
                 [[Album alloc] initWithTitle:@"It's My Life" artist:@"No Doubt" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png" year:@"2003"],
                 [[Album alloc] initWithTitle:@"Nothing Like The Sun" artist:@"Sting" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png" year:@"1999"],
                 [[Album alloc] initWithTitle:@"Staring at the Sun" artist:@"U2" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png" year:@"2000"],
                 [[Album alloc] initWithTitle:@"American Pie" artist:@"Madonna" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png" year:@"2000"]]];
                [self saveAlbums];
        }
    }
    return self;
}
</code></pre>

<p>在新代码里，如果文件存在，NSKeyedUnarchiver 就从文件加载专辑数据。如果不存在，它就创建专辑数据，然后立即存储，为下一次启动 app 使用。</p>

<p>当然你也可以在 app 后台运行的时候再存储专辑数据。现在它看起来不是很有必要，但如果你在稍后添加修改专辑数据呢？你需要确保所有的数据修改都会被存储。</p>

<p>在 LibraryAPI.h 添加下面的方法</p>

<pre><code>- (void)saveAlbums;
</code></pre>

<p>因为程序的所以有服务都需要通过 LibraryAPI 提供，这就是程序为什么需要 PersistenrcyManger 来存储专辑数据。</p>

<p>现在在 LibraryAPI.m 中添加实现方法：</p>

<pre><code>- (void)saveAlbums
{
    [persistencyManger saveAlbums];
}
</code></pre>

<p>这里是从 LibraryAPI 调用 PersistencyManger 来存储专辑。</p>

<p>在 ViewController.m 文件 saveCurrentState 的后面添加下面代码：</p>

<p>[[LibraryAPI sharedInstance] saveAlbums];</p>

<p>上面的代码是每当 ViewController 存储当前状态时，使用 LibraryAPI 来存储专辑数据。</p>

<p>构建你的 app，检查所有的都能正确编译。</p>

<p>不幸的是，没有一种简单的方法来验证数据是否被正确的创建。你可以在 Finder 里检查模拟器下当前 app 的 Documents 文件夹，来看看专辑数据文件是否被创建，但是为了查看其它变化你还需要添加一些数据来改变专辑数据。</p>

<p>但是，为了修改数据，假使为了删除专辑而需要临时添加一个删除选项，但这个选项并不会一直在你的库中存在？此外，由于误操作，错误的删除了一个专辑，但如果给这个操作添加一个撤消选项不是很好吗？</p>

<p>现在是时候讨论最后一个设计模式了：<a href="http://www.superqq.com/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/">命令 Command</a>。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-19T06:31:19+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:31 am</span></time>
        
        
          | <a href="/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p><strong>备忘录模式</strong>是捕获和具体化当前对象的内部状态。换句话说，就是在某个地方存储个东西。稍后，在不违反封装的情况下能够恢复这个具体化的状态；就是说，一些私有数据被私下存储下来了。</p>

<h3>如何使用备忘录模式</h3>

<p>添加下面两个方法到 ViewController.m 文件：</p>

<pre><code>- (void)saveCurrentState
{
    // 当用户退出应用之后再重新打开，他想要跟他之前退出时一样的状态
    // 退出应用，这个时候我们需要做的是把当前显示的专辑存储下来
    // 因为只有一小片信息，我们可用 NSUserDefaults 来存储信息
    [[NSUserDefaults standardUserDefaults] setInteger:currentAlbumIndex forKey:@“currentAlbumIndex”];
}

- (void)loadPreviousState
{
    currentAlbumIndex = [[NSUserDefaults standardUserDefaults] integerForKey@“currentAlbumIndex”];
    [self showDataForAlbumAtIndex:currentAlbumIndex];
}
</code></pre>

<p>saveCurrentState 存储当前专辑的索引到 NSUserDefaults ─ NSUserDefaults 是一个标准数据存储，iOS 用来专门存放程序设置和数据。</p>

<p>loadPreviousState 加载这之前存储的专辑索引。这不是备忘录模式的全部，不过你已经达到目的了。</p>

<p>现在，在 ViewController.m 里，滚动视图初始化之前，在 viewDidLoad 里添加下面一行：</p>

<pre><code>[self loadPreviousState];
</code></pre>

<p>当程序启动的时候加载上一次存储的状态。但是你在哪里存储程序的当前状态呢？你需要使用通知来做这样的事情。当程序进入后台时，iOS 会发送一个 UIApplicationDidEnterBackgroundNotification 通知。你可利用这个通知调用 saveCurrentState。就这么方便？</p>

<p>在 viewDidLoad: 最后面添加下面一行</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(saveCurrentState) name:UIApplicationDidEnterBackgroundNotification object:nil];
</code></pre>

<p>现在，当你的 app 进入后台运行后，ViewController 会自动调用 saveCurrentState 存储当前的状态。</p>

<p>现在，添加下面代码：</p>

<pre><code>- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}
</code></pre>

<p>这里是确保当 ViewController 被释放时，移除类的 <a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">Observer</a>。</p>

<p>构建和运行你的 app，点击到一个专辑，用 Command+Shift+H（如果你使用的是模拟器的话） 将程序在后台运行，然后关掉 app。重启 app，检查之前选择的专辑是不是居中显示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/2013-09-02_10-51-27-214x320.png" alt="1" /></p>

<p>专辑数据看起来是对的，但是正确的专辑封面确没有居中，哪出问题了？</p>

<p>这就是可选方法 initialViewIndexForHorizontalScroller 的用处！因为这个方法没有被委托执行，ViewController 在这种情况下总是会显示默认的第一个专辑封面。</p>

<p>修复这个问题，在 ViewController.m 中添加如下代码：</p>

<pre><code>- (NSInteger)initialViewIndexForHorizontalScroller:(HorizontalScroller *)scroller
{
    return currentAlbumIndex;
}
</code></pre>

<p>现在 HorizontalScroller 的第一个视图总是会被设置成 currentAlbumIndex 索引的图片。这种方法能够确保你的 app 有一个非常棒的用户体验，并且它是可恢复的。</p>

<p>重新运行你的 app，滚动专辑封面，关闭 app，然后重启确保问题已经得到解决：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/2013-09-02_10-56-59-214x320.png" alt="2" /></p>

<p>如果你查看 PersistencyManger 的初始化方法，你会注意到专辑的数据是一种硬编码，PersistencyManger 每次创建，数据也会重复创建一次。有没有一种更好的方法当专辑列表被创建的时候就存储它们呢。那么如何把专辑数据存储到文件里呢？</p>

<p>一种选择就是循环访问 Album 的属性，然后把它存储在一个 plist 文件里，当需要它们的时候重新创建一个 Album 的实例。这不是最好的选择，这需要你在每一个类里根据不同的数据或属性写特定的代码。例子，如果稍后你需要一个电影的类，里面有一些不同的属性，存储和加载这些数据你就需要写一些新的代码。</p>

<p>此外，你不能在每一个类的实例里存储私有变量，因为他们是不可访问的外部类。这就是为什么苹果要创建归档 (Archiving) 机制。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-18T10:14:51+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:14 am</span></time>
        
        
          | <a href="/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>在<strong>观察者模式</strong>中，当状态发生改变的时候，一个对象会通知另一个对象。这个对象不需要知道另一个对象发生了什么改变─因此非常鼓励这种分离式的设计。这种模式经常用于，当一个属性发生改变时通知跟它相关的对象。</p>

<p>它通常需要一个观察者(observer)注册跟踪另外一个对象的状态。当状态发生改变的时候，所有的观察对象都会被通知改变。苹果的推送通知服务就是一个这样的例子。</p>

<p>如果你想要一直使用 <a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">MVC 模式</a>（你确实需要），你如果想在模型和视图之间，不直接相互引用的情况下还要有通信。这时候就要用到观察者模式了。</p>

<p>Cocoa 有两个常用的方法来执行观察者模式：Notifications 和 Key-Value Observing (KVO)。</p>

<h3>通知 Notifications</h3>

<p>不要把它和推送、本地通知弄混淆了，通知是基于一个对象（信息发布者）发信息给另一个对象（订阅/监听）的订阅-发布模式的。信息发布者不需要知道任何关于订阅者的信息。</p>

<p>苹果大量的使用了通知。例子，当键盘打开/关闭的时候，系统会分别发送一个 UIKeyboardWillShowNotification/UIKeyboardWillHideNotification。当你的程序要退出的时候，系统会发送一个 UIApplicationDidEnterBackgroundNotification 通知。</p>

<pre><code>提示：打开 UIApplication.h，在文件最后你会看见系统能发送的通知列表有 20 个之多。
</code></pre>

<h3>如何使用通知 Notifications</h3>

<p>打开 AlbumView.m 文件，在 initWithFrame:albumCover: 里面的 [self addSubview:indicator] 后面插入下面代码：</p>

<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:@“BLDownloadImageNotification” object:self userInfo:@{@“imageView”:coverImage, @“coverUrl”:albumCover}];
</code></pre>

<p>这行代码是通过 NSNotificationCenter 单例来发送一个通知。通知内容包括 coverImage 图片视图 和下载封面图片的 URL。这是执行下载专辑封面所需的所有信息。</p>

<p>在 LibraryAPI.m 的 init 方法里，isOnline = NO; 后面添加下面代码：</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downImage:) name:@“BLDownloadImageNotification” object:nil];
</code></pre>

<p>这是等式另一边的观察者对象。任何时候只要 AlbumView 类发送一个 BLDownloadImageNotification 通知，系统就会通知 LibraryAPI，因为 LibraryAPI 已经注册了一个相同的观察者通知。qLibraryAPI 执行 downloadImage:。</p>

<p>不管任何时候，在你执行 downloadImage: 之前，一定要记住在你释放这个类的时候一定要取消这个通知的订阅。如果你不正确的取消一个通知的订阅，这个通知可能发送一个已经释放的实例。这会造成你的程序崩溃。</p>

<p>在 LibraryAPI.m 里添加下面代码：</p>

<pre><code>- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removerObserver:self];
}
</code></pre>

<p>当这个类释放后，移除一个观察者自己已经注册的所有通知。</p>

<p>这里还有一件事情要做。它可以把下载过的封面图片存在本地，这样 app 就不用一次又一次的下载同一个图片了。</p>

<p>打开 PersistencyManger.h 添加下面两个方法：</p>

<pre><code>- (void)saveImage:(UIImage*)image filename:(NSString*)filename;
- (UIImage*)getImage:(NSString*)filename;
</code></pre>

<p>在 PersistencyManger.m 中实现：</p>

<pre><code>- (void)saveImage:(UIImage*)image filename:(NSString*)filename
{
    filename = [NSHomeDirectory() stringByAppendingFormat:@“/Documents/%@”, filename];
    NSData *data = UIImagePNGRepresentation(image);
    [data writeToFile:filename atomically:YES];
}

- (UIImage*)getImage:(NSString*)filename 
{
    filename = [NSHomeDirectory() stringByAppendingFormat:@“/Documents/%@“, filename];
    NSData *data = [NSData dataWithContentsOfFile:filename];
    return [UIImage imageWithData:data];
}
</code></pre>

<p>这里的代码很简单。下载完成的图片会被存储进 Documents 文件夹中，如果没有跟 filename 相匹配的文件，getImage: 会返回 nil。</p>

<p>现在在 LibraryAPI.m 里面添加下面方法：</p>

<pre><code>- (void)downImage:(NSNotification*)notification
{
    // 1 
    UIImageView *imageView = notification.userInfo[@“imageView”];
    NSString *coverUrl   = notification.userInfo[@“coverUrl”];

    // 2
    imageView.image = [persistencyManger getImage:[coverUrl lastPathComponent];

    if (imageView.image == nil) {
        // 3 
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            UIImage *image = [httpClient downloadImage:coverUrl];
            dispatch_sync(dispatch_get_main_queue(), ^{
                imageView.image = image;
                [persistencyManger saveImage:image filename:[coverUrl lastPathComponent];
            });
        });
    }
}
</code></pre>

<p>现在来分析上面的代码：</p>

<ol>
<li>通知执行 downloadImage 方法，方法接受这个这个通知对象，就像它是一个变量一样。通知里会传递 UIImageView 和图片的 URL。</li>
<li>如果以前已经下载过，就从 PersistencyManger 里取出图片。</li>
<li>如果图片没有下载过，使用 HTTPClient 开始下载图片。</li>
<li>当下载完成的时候，在图片视图中显示图片，用 PersistencyManger 存储它到本地。</li>
</ol>


<p>此外，你用外观模式(Facade pattern)隐藏了另外一个下载图片的复杂类。通知发送者不关心图片的来源，不管是从网上下载的还是本地存储的。</p>

<p>构建和运行你的 app，可以看到漂亮的封面已经出现在 HorizontalScroller 里面了：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-4-297x320.png" alt="1" /></p>

<p>停止你的 app，然后再运行它。注意这里显示封面已经没有延时了，因为它们已经下载到本地了。你可断开网络试试，你的 app 同样可以完美的运行。虽然已经很完美了，但是仍然有一个小问题：就是下载提示的小菊花仍然一直在转动，从来没有停止过！哪里出问题了？</p>

<p>当你开始下载图片的时候，你运行了下载提示符，但当图片下载完成的时候，你没有停止下载提示符的方法。你也可以当每个图片下载完成的时候再发送一个通知，当然另一个代替方案，你可以使用另一种观察者模式，KVO。</p>

<h3>键 – 值 观察 (Key-Value Observing KVO)</h3>

<p>在 <a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">KVO</a>  里，一个对象的任何一个特别的属性改变后都可以请求一个通知；不管是它自己的还是其它的对象。如果你感兴趣，你可以在这里读到更多的信息：Apple’s KVO Programming Guide.</p>

<h3>如何使用 KVO 模式</h3>

<p>如上所述，<a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">KVO</a> 的原理是允许一个对象观察一个属性的改变。你所要关心的是，使用 KVO 观察 UIImageView 的 image 属性是否已经改变，就是它是否已经存储了图片。</p>

<p>打开 AlbumView.m，在 initWithFrame:albumCover: 里的 [self addSubview:indicator]; 后面添加下面代码：</p>

<pre><code>[coverImage addObserver:self forKeyPath:@“image” options:0 context:nil];
</code></pre>

<p>不添加在自己上面(self)，在当前的类里，观察 coverImage 的 image 属性。</p>

<p>当你使用过后，你同样需要注销这个观察(observer)。继续在当前文件里面添加下面代码：</p>

<pre><code>- (void)dealloc
{
    [coverImage removerObserver:self forKeyPath:@“image”];
}
</code></pre>

<p>最后，添加下面方法：</p>

<pre><code>- (void)observerValueForKeyPath:(NSString*)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    if ([KeyPath isEqualToString:@“image”])
    {
        [indicator stopAnimating];
    }
}
</code></pre>

<p>你必须在每个类里执行这个方法。如果观察的属性改变了，系统每次都会执行这个方法。上面的代码里，当 image 的属性发生改变时，你停止下载提示符的运行。这种方法，当图片下载完成，下载提示转动的小菊花将会停止转动。</p>

<p>构建个运行你的项目。你会看到小菊花已经不在了：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage3-287x320.png" alt="2" /></p>

<pre><code>提示：永远记住，当你释放内存，你一定要移除这些观察(observers)，或者是当你的程序发送这些不存的观察对象时会造成程序崩溃。
</code></pre>

<p>如果你玩弄一会你的 app，然后关闭它，你程序的当前状态并没有被存储下来。当程序启动的时候你看到的视图并不是上次退出时的样子。</p>

<p>为了更正这些，你需要使用下一项设计模式：备忘录 (Memento)。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/7">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/5">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>热门推荐</h1>
  <!--广告位-->
<script type="text/javascript">
    /*250*250 创建于 2015-08-08*/
    var cpro_id = "u2252717";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
  <h1>微信扫一扫，代码写的好</h1>
        <br/>
        <br/><strong>东半球最好的iOS开发公众号</strong> 
        <br/>
        <br/><img width="220px" src="http://images.90159.com/icon/iOSDevTip.jpg" />
        <br/>
        <br/><strong>东半球最好的程序猿公众号</strong>
        <br/>
        <br/><img width="220px" src="http://images.90159.com/icon/codepush.jpg" />
        </p>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/11/color-tabbar-switch-animation/">彩色TabBar切换动画实现</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/10/coremotion-framework-use-accelerometer/">CoreMotion框架中加速度计使用简明教程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/09/performance-optimization-of-mkmapview/">一次对MKMapView的性能优化</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/08/interview-ios-question-answer/">《招聘一个靠谱的iOS》面试题参考答案（上）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/07/implement-uitextview-placeholder/">实现placeholder属性的UITextView</a>
      </li>
    
  </ul>
  <!--广告位-->
<script type="text/javascript">
    /*刚刚在线250*350 创建于 2015-07-31*/
    var cpro_id = "u2238366";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
</section>
</section>
<section>
    <h1>About Me</h1>
    <br/>
    <p> 李刚：百度百家专栏作者，刚刚在线站长，iOS工程师非著名自媒体人，微信公众号iOS开发：iOSDevTip运营者<br/>
    <br/><strong>出师未捷名已落</strong>
    <br/>
    <br/>新浪微博: <a href='http://weibo.com/ligangnc' target='_blank'>李刚移动</a>
    <br/>
    <br/>个人微信: <strong>chinaligang</strong> 欢迎调戏
    <br/>
    <br/>iOS群: <strong>218822587</strong>
  <br/>
</section>

   
 <section>
    <h1>友情链接</h1>
    <ul>
    
       <li>
           <a href="http://www.superqq.com" target="_blank" title=“刚刚在线”>刚刚在线</a>
       </li>
       <li>
           <a href="http://www.90159.com" target="_blank" title=“程序员头条”>程序员头条</a>
       </li>
       <li>
           <a href="http://www.iswifting.com" target="_blank" title=“swift开发”>swift开发</a>
       </li>
       <li>
           <a href="http://www.aswifter.com/" target="_blank" title="APP开发者">APP开发者</a>
       </li>
        <li>
           <a href="http://www.boxingjiaoyu.com/" target="_blank" title="程序员聚合平台">程序员聚合平台</a>
       </li>
      <li>
           <a href="http://www.mobile-open.com/" target="_blank" title="阳和移动开发">阳和移动开发</a>
       </li>
       <li>
           <a href="http://www.jq-school.com/" target="_blank" title="jquery教程">jquery教程</a>
       </li>
        <li>
           <a href="http://www.admin10000.com/" target="_blank" title="WEB开发者">WEB开发者</a>
       </li>
       <li>
           <a href="http://www.aichengxu.com/" target="_blank" title="爱程序网">爱程序网</a>
       </li>
       <li>
           <a href="http://www.lai18.com" target="_blank" title="IT技术文章">IT技术文章</a>
       </li>
       <li>
           <a href="http://www.cftea.com/" target="_blank" title="千一网络">千一网络</a>
       </li>
        <li>
           <a href="http://www.bmob.cn/" target="_blank" title="Bmob">Bmob移动后端云</a>
       </li>
       <li>
           <a href="http://www.leichunfeng.com" target="_blank" title="雷纯锋的技术博客">雷纯锋的技术博客</a>
       </li>
       <li>
           <a href="http://cuiqingcai.com/" target="_blank" title="静觅">静觅</a>
       </li>
       <li>
           <a href="http://letsswift.com/" target="_blank" title="一起Swift">一起Swift</a>
       </li>
       <li>
           <a href="http://www.swiftv.cn/" target="_blank" title="SwiftV课堂">SwiftV课堂</a>
       </li>
        <li>
            <a href="http://blog.csdn.net/iosdevtip" target="_blank" title="刚刚在线">CSDN</a>
        </li>
        <li>
            <a href="http://user.qzone.qq.com/1606535851" target="_blank" title="刚刚在线">QQ空间</a>
        </li>
        <li>
            <br/><strong>交换友链：</strong>欢迎各大程序员站点交换友情链接，如需交换，请添加好本站链接后发送邮件至下方邮箱。
            <br/>
            <br/><strong>格式：</strong>（ 友链文字：“ 刚刚在线 ”，链接：“ http://www.superqq.com/ ” ）
            <br/>
            <br/><strong>邮箱：</strong>worldligang@163.com
            <br/>
        </li>
    </ul>
<br/>
<h1>热门推荐</h1>
<!--广告位-->
<script type="text/javascript">
var cpro_id="u2240614";
(window["cproStyleApi"] = window["cproStyleApi"] || {})[cpro_id]={at:"3",rsi0:"250",rsi1:"350",pat:"6",tn:"baiduCustNativeAD",rss1:"#FFFFFF",conBW:"1",adp:"1",ptt:"0",titFF:"%E5%BE%AE%E8%BD%AF%E9%9B%85%E9%BB%91",titFS:"14",rss2:"#000000",titSU:"0",ptbg:"90",piw:"0",pih:"0",ptp:"0"}
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
Copyright &copy; 2015 - 李刚 
<span class="credit">Powered by <a href="http://octopress.org" target="_blank">Octopress</a></span>
 <span class="credit">, 感谢 <a href="http://gitcafe.com/signup?invited_by=tangqiaoboy" target="_blank">GitCafe</a> 为本站提供存储空间</span>

</p>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/17443209.js"></script>
<noscript><a href="http://www.51.la/?17443209" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/17443209.asp" style="border:none" /></a></noscript>
</footer>
  











</body>
</html>
