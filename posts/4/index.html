
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
      <meta name="baidu-site-verification" content="X93tJz3pCq" />
  <title>刚刚在线</title>
  <meta name="author" content="刚刚">
      <meta name="uyan_auth" content="d1112891bb" />
      <meta name="baidu-tc-verification" content="7acda2305fabbf1ddd9f83e385ddd899" />
      
  
  <meta name="description" content="刚刚在线的博客 | 分享iOS开发经验 | 收集有价值的iOS代码 | iOS开发者 | 源代码 | SDK">
  <meta name="keywords" content="iOS,iOS开发,cocoapods,code,iOS代码, 源代码, 刚刚在线,iOS李刚, iPhone6 Plus, iPhone6, iPhone程序员, Objective-c,李刚博客">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://worldligang.github.io/posts/4">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="刚刚在线" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->


  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">刚刚在线</a></h1>
  
    <h2>游走在互联网岸边的屌丝青年</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://www.baidu.com/" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:worldligang.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">全部文章</a></li>
  <li><a href="/blog/categories/ioskai-fa/">iOS开发</a></li>
  <li><a href="/blog/categories/yuan-dai-ma/">源代码</a></li>
  <li><a href="/blog/categories/sdkfu-wu/">sdk服务</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/18/cocoapodsxiang-jie-zhi-zhi-zuo-pian/">CocoaPods详解之&#8212;-制作篇</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-18T09:33:20+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>9:33 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>学会使用别人的Pods依赖库以后，你一定对创建自己的依赖库跃跃欲试，今天就来揭开Pods依赖库创建过程的神秘面纱。整个创建过程都以我实现的一个名称为WZMarqueeView跑马灯效果的view为例，步骤如下：</p>

<p><div class="entry-content"><h3>一、创建自己的github仓库</h3></p>

<p><a href="http://www.superqq.com/">CocoaPods</a>都托管在github上(官方链接为：<a href="https://github.com/CocoaPods">https://github.com/CocoaPods</a>)，所有的Pods依赖库也都依赖github，因此第一步我们需要创建一个属于自己的github仓库。仓库创建界面如下图：
<img src="http://img.blog.csdn.net/20140304101538437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>上图中标了序号的共6处，对应的说明如下：
1、Repository name
仓库名称，这里写成WZMarqueeView，必填的；
2、Description
仓库的描述信息，可选的；
3、仓库的公开性
这里只能选Public，一个是因为Private是要money的，再一个Private别人看不到还共享个毛；
4、是否创建一个默认的README文件
一个完整地仓库，都需要README说明文档，建议选上。当然不嫌麻烦的话你也可以后面再手动创建一个；
5、是否添加.gitignore文件
.gitignore文件里面记录了若干中文件类型，凡是该文件包含的文件类型，git都不会将其纳入到版本管理中。是否选择看个人需要；
6、license类型
正规的仓库都应该有一个license文件，Pods依赖库对这个文件的要求更严，是必须要有的。因此最好在这里让github创建一个，也可以自己后续再创建。我使用的license类型是MIT。</p>

<p>上面的各项都填写完毕后，点击Create repository按钮即可，创建成功地界面如图：
<img src="http://img.blog.csdn.net/20140304103428187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>到这，仓库创建过程就结束了。</p>

<p><div class="entry-content"><h3>二、clone仓库到本地</h3></p>

<p>为了便于向仓库中删减内容，需要先将仓库clone到本地，操作方式有多种，推荐使用命令行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ git clone https://github.com/wangzz/WZMarqueeView.git  
</code></pre>

<p>操作完成后，github上对应的文件都会拷贝到本地，目录结构为：
<img src="http://img.blog.csdn.net/20140304110718828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>github上仓库中的.gitignore文件是以.开头的隐藏文件，因此这里只能看到两个。
后续我们的所有文件增、删、改都在这个目录下进行。</p>

<p><div class="entry-content"><h3>三、向本地git仓库中添加创建Pods依赖库所需文件</h3></p>

<p>注意：以下描述的文件都要放在步骤二clone到本地的git仓库的根目录下面。
1、后缀为.podspec文件
该文件为Pods依赖库的描述文件，每个Pods依赖库必须有且仅有那么一个描述文件。文件名称要和我们想创建的依赖库名称保持一致，我的WZMarqueeView依赖库对应的文件名为WZMarqueeView.podspec。</p>

<p>1.1 podspec文件内容
WZMarqueeView.podspec的保存内容为：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>Pod::Spec.new do |s|  
  s.name             = "WZMarqueeView"  
  s.version          = "1.0.0"  
  s.summary          = "A marquee view used on iOS."  
  s.description      = &lt;&lt;-DESC  
                       It is a marquee view used on iOS, which implement by Objective-C.  
                       DESC  
  s.homepage         = "https://github.com/wangzz/WZMarqueeView"  
  # s.screenshots      = "www.example.com/screenshots_1", "www.example.com/screenshots_2"  
  s.license          = 'MIT'  
  s.author           = { "王中周" =&gt; "wzzvictory_tjsd@163.com" }  
  s.source           = { :git =&gt; "https://github.com/wangzz/WZMarqueeView.git", :tag =&gt; s.version.to_s }  
  # s.social_media_url = 'https://twitter.com/NAME'  

  s.platform     = :ios, '4.3'  
  # s.ios.deployment_target = '5.0'  
  # s.osx.deployment_target = '10.7'  
  s.requires_arc = true  

  s.source_files = 'WZMarqueeView/*'  
  # s.resources = 'Assets'  

  # s.ios.exclude_files = 'Classes/osx'  
  # s.osx.exclude_files = 'Classes/ios'  
  # s.public_header_files = 'Classes/**/*.h'  
  s.frameworks = 'Foundation', 'CoreGraphics', 'UIKit'  

end  
</code></pre>

<p>该文件是ruby文件，里面的条目都很容易知道含义。
其中需要说明的又几个参数：
①s.license
Pods依赖库使用的license类型，大家填上自己对应的选择即可。
②s.source_files
表示源文件的路径，注意这个路径是相对podspec文件而言的。
③s.frameworks
需要用到的frameworks，不需要加.frameworks后缀。</p>

<p>1.2 如何创建podspec文件
大家创建自己的podspec文件可以有两个途径：
①copy我的podspec文件然后修改对应的参数，推荐使用这种方式。
②执行以下创建命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod spec create WZMarqueeView  
</code></pre>

<p>也会创建名为WZMarqueeView.podspec的文件。但是打开创建完的文件你就会发现里面的东西太多了，很多都是我们不需要的。</p>

<p>2、LICENSE文件
CocoaPods强制要求所有的Pods依赖库都必须有license文件，否则验证不会通过。license的类型有很多种，详情可以参考网站tl;dr Legal。在创建github仓库的时候，我已经选择了MIT类型的license。</p>

<p>3、主类文件
创建Pods依赖库就是为了方便别人使用我们的成果，比如我想共享给大家的WZMarqueeView类，是我想提供给广大用户使用的，这个类自然是必不可少的。我把这个类包含的两个文件放到一个名称为WZMarqueeView的文件夹中，对应的目录结构如图：
<img src="http://img.blog.csdn.net/20140304094406921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>里面包含两个文件：WZMarqueeView.h和WZMarqueeView.m</p>

<p>4、demo工程
为了快速地教会别人使用我们的Pods依赖库，通常需要提供一个demo工程。我创建的demo工程放到了一个名为WZMarqueeViewDemo的文件夹中，该目录包含的文件如下图所示：
<img src="http://img.blog.csdn.net/20140304095547765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>5、README.md
使用github的人应该都熟悉这个文件，它是一个成功github仓库必不可少的一部分，使用的是markdown标记语言，用于对仓库的详细说明。</p>

<p>以上所说的5个是创建Pods依赖库所需最基础的文件，其中1、2、3是必需的，4、5是可选但强烈推荐创建的。
添加完这些文件以后，我的github本地仓库目录就变成了下图所示的样子：
<img src="http://img.blog.csdn.net/20140304120124578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p><div class="entry-content"><h3>四、提交修改文件到github</h3></p>

<p>经过步骤三，向本地的git仓库中添加了不少文件，现在需要将它们提交到github仓库中去。提交过程分以下几步：
1、pod验证
执行以下命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ set the new version to 1.0.0  
$ set the new tag to 1.0.0  
</code></pre>

<p>这两条命令是为pod添加版本号并打上tag。然后执行pod验证命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod lib lint  
</code></pre>

<p>如果一切正常，这条命令执行完后会出现下面的输出：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>-&gt; WZMarqueeView (1.0.0)  

ZMarqueeView passed validation.  
</code></pre>

<p>到此，pod验证就结束了。
需要说明的是，在执行pod验证命令的时候，打印出了任何warning或者error信息，验证都会失败！如果验证出现异常，打印的信息会很详细，大家可以根据对应提示做出修改。</p>

<p>2、本地git仓库修改内容上传到github仓库
依次执行以下命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ git add -A &amp;&amp; git commit -m "Release 1.0.0."  
$ git tag '1.0.0'  
$ git push --tags  
$ git push origin master  
</code></pre>

<p>上述命令均属git的范畴，这里不多述。如果一切正常，github上就应该能看到自己刚添加的内容了。如下图所示：
<img src="http://img.blog.csdn.net/20140304144407281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p><div class="entry-content"><h3>五、上传podspec文件到CocoaPods官方仓库中</h3></p>

<p>经过前边的四步操作，你可能以为已经结束了，不幸的是还早着呢。
要想一个Pods依赖库真正可用，还需要做最后一步操作，将我们刚才生成的podspec文件上传到CocoaPods官方的Specs仓库中，链接为：<a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a>
打开这个链接你就会发现，原来我们能使用的，以及我们使用pod search命令能搜索到的所有Pods依赖库都会把它们的podspec文件上传到这个仓库中，也就是说，只有将我们的podspec文件上传到这个仓库中以后，才能成为一个真正的Pods依赖库，别人才能正常使用！
按照git的规则，要想向别人的仓库中添加文件，必须先fork一份别人的仓库，做完相应地修改后，在push给仓库的原作者，等到作者审核通过，然后合并到原来的仓库中。
流程明白了以后，自然知道该怎么干了：
1、fork一份CocoaPods官方的Specs仓库
进入到刚才的官方仓库链接中，点击屏幕右上角的fork按钮，如下图：
<img src="http://img.blog.csdn.net/20140304150419906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>然后大家会发现自己名下会多一份仓库的分支。比如我的分支为：</p>

<p>2、将fork的仓库clone到本地
执行以下命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ git clone https://github.com/wangzz/Specs.git  
</code></pre>

<p>注意，大家需要将对应的仓库地址换成自己的。
这个仓库有点大，需要有耐心啊。</p>

<p>3、将自己的podspec文件添加到本地Specs仓库中
Specs仓库clone到本地后，会放到一个名为Specs的文件夹中。podspec文件在Specs仓库中的保存原则是：
Pods依赖库同名文件夹&mdash;>版本号同名文件夹&mdash;>podspec文件
照此原则，我需要在Specs文件夹下建立一个名为WZMarqueeView的文件夹，然后进入到WZMarqueeView文件夹下，建立一个名称为1.0.0的文件夹，最后进入到1.0.0这个文件夹下，并且将之前创建好的WZMarqueeView.podspec文件拷贝进来。
不难理解，如果以后有对WZMarqueeView类的升级，就在WZMarqueeView文件夹下建立对应版本名称的文件夹，用于保存对应版本的podspec文件即可。
这些操作完成后，目录层次结构如下所示：
<img src="http://img.blog.csdn.net/20140304151710187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>4、上传本地Specs仓库中的修改到github仓库
执行以下命令：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ git add -A &amp;&amp; git commit -m "Add WZMarqueeView podspec file"  
$ git push origin master  
</code></pre>

<p>成功以后就能在github上自己fork的Specs仓库中看到刚上传的文件了。</p>

<p>5、将在自己fork的Specs上做的修改pull给CocoaPods官方的Specs仓库
进入到自己fork的Specs仓库中，会看到屏幕左上角有一个绿色按钮：
<img src="http://img.blog.csdn.net/20140304152827781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>该按钮点进去以后会有如下图所示的界面：
<img src="http://img.blog.csdn.net/20140304152926843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>点击图中的绿色Create Pull Request按钮，即可将我们fork的Specs上做的修改pull给CocoaPods官方的Specs仓库。</p>

<p>到这一步后，剩下的工作就只有等了，等待CocoaPods的维护人员审核并将我们pull上去的修改合并到官方的Specs仓库中，这个过程通常会有一天左右的等待时间。如果有任何消息，比如审核不通过，或者审核通过了，CocoaPods官方都会发邮件通知的。
等到审核通过的时候，我们就能在官方的Specs仓库中看到自己上传的文件夹了。</p>

<p>6、查看审核进度
当然我们也能查看审核进度，打开这个链接：<a href="https://github.com/CocoaPods/Specs/pulls%EF%BC%8C%E8%BF%99%E9%87%8C%E8%83%BD%E7%9C%8B%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84Specs%E4%BB%93%E5%BA%93pull%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">https://github.com/CocoaPods/Specs/pulls%EF%BC%8C%E8%BF%99%E9%87%8C%E8%83%BD%E7%9C%8B%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84Specs%E4%BB%93%E5%BA%93pull%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A</a>
<img src="http://img.blog.csdn.net/20140304153818828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>红圈标识的就是我刚才pull上来的请求，点进去以后就能看到对应的审核进度。</p>

<p><div class="entry-content"><h3>六、查看我们自己创建的Pods依赖库</h3></p>

<p>如果收到了CocoaPods官方发过来的审核通过邮件以后，你可能很着急的想在自己的电脑上执行pod search命令，看看能不能搜索到自己创建的Pods依赖库。不过你肯定会失望的，因为还需要执行一条命令才能在我们的本地电脑上使用search命令搜索到我们的依赖库：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod setup  
</code></pre>

<p>在我的<a href="http://www.superqq.com/">CocoaPods</a>系列教程中的第一篇：CocoaPods详解之&mdash;-进阶篇中的最后部分介绍过这条命令，它会将所有的Pods依赖库tree跟新到本地。执行完这条命令，再去执行:
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod search WZMarqueeView  
</code></pre>

<p>就能显示出对应的介绍信息了！</p>

<p>说了那么多，到这里整个Pods依赖库创建过程才算真正结束！小伙伴们，你成功了吗？？？遇到问题还请留言。</p>

<p><div class="entry-content"><h3>七、参考文档</h3></p>

<p>1、<a href="http://guides.cocoapods.org">http://guides.cocoapods.org</a></p>

<p>iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p>文章来自： <a href="http://blog.csdn.net/wzzvictory/article/details/20067595"target="_blank"title="CocoaPods详解之----制作篇 ">CocoaPods详解之&mdash;-制作篇 </a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/17/cocoapodsxiang-jie-zhi-jin-jie-pian/">CocoaPods详解之&#8212;-进阶篇</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-17T09:28:14+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>9:28 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><div class="entry-content"><h3>一、Podfile.lock文件</h3></p>

<p>上文讲过，在开始使用<a href="http://www.superqq.com/">CocoaPods</a>，执行完pod install之后，会生成一个Podfile.lock文件。这个文件看起来跟我们关系不大，实际上绝对不应该忽略它。
该文件用于保存已经安装的Pods依赖库的版本，通过<a href="http://www.superqq.com/">CocoaPods</a>安装了SBJson、AFNetworking、Reachability三个POds依赖库以后对应的Podfile.lock文件内容为：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>PODS:  
  - AFNetworking (2.1.0):  
    - AFNetworking/NSURLConnection  
    - AFNetworking/NSURLSession  
    - AFNetworking/Reachability  
    - AFNetworking/Security  
    - AFNetworking/Serialization  
    - AFNetworking/UIKit  
  - AFNetworking/NSURLConnection (2.1.0):  
    - AFNetworking/Reachability  
    - AFNetworking/Security  
    - AFNetworking/Serialization  
  - AFNetworking/NSURLSession (2.1.0):  
    - AFNetworking/NSURLConnection  
  - AFNetworking/Reachability (2.1.0)  
  - AFNetworking/Security (2.1.0)  
  - AFNetworking/Serialization (2.1.0)  
  - AFNetworking/UIKit (2.1.0):  
    - AFNetworking/NSURLConnection  
  - Reachability (3.0.0)  
  - SBJson (4.0.0)  

DEPENDENCIES:  
  - AFNetworking (~&gt; 2.0)  
  - Reachability (~&gt; 3.0.0)  
  - SBJson (~&gt; 4.0.0)  

SPEC CHECKSUMS:  
  AFNetworking: c7d7901a83f631414c7eda1737261f696101a5cd  
  Reachability: 500bd76bf6cd8ff2c6fb715fc5f44ef6e4c024f2  
  SBJson: f3c686806e8e36ab89e020189ac582ba26ec4220  

COCOAPODS: 0.29.0  
</code></pre>

<p>Podfile.lock文件最大得用处在于多人开发。对于没有在Podfile中指定Pods依赖库版本的写法，如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>pod 'SBJson'  
</code></pre>

<p>该句话用于获取当前SBJson这个Pods依赖库的最新版本。
当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的SBJson，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！
在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案：</p>

<pre><code>更改Podfile，使其指向最新版本的SBJson依赖库；
执行pod update命令；
</code></pre>

<p>鉴于Podfile.lock文件对团队协作如此重要，我们需要将它添加到版本管理中。</p>

<p><div class="entry-content"><h3>二、Podfile文件</h3></p>

<p>对于普通用户来说，使用CocoaPods我们打交道最多的就是Podfile文件。CocoaPods是用ruby实现的，因此Podfile文件的语法就是ruby的语法。接着从以下几个方面来介绍Podfile:
1、Podfile文件存放位置</p>

<p>这是在上篇文章中，遗留的一个问题。通常情况下我们都推荐Podfile文件都放在工程根目录，如下图所示：
事实上Podfile文件可以放在任意一个目录下，需要做的是在Podfile中指定工程的路径，和原来相比，Podfile文件就在最开始的位置增加了一行，具体内容如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>xcodeproj "/Users/wangzz/Desktop/CocoaPodsTest/CocoaPodsTest.xcodeproj"  

platform :ios    
pod 'Reachability',  '~&gt; 3.0.0'    
pod 'SBJson', '~&gt; 4.0.0'    

platform :ios, '7.0'    
pod 'AFNetworking', '~&gt; 2.0'   
</code></pre>

<p>指定路径使用的是xcodeproj关键字。
此后，进入Podfile文件所在路径，执行pod install命令就会和之前一样下载这些Pods依赖库，而且生成的相关文件都放在了Podfile所在目录下面，如下图：
和之前一样，我们仍然需要使用这里生成的workspace文件打开工程。</p>

<p>2、Podfile和target
Podfile本质上是用来描述Xcode工程中的targets用的。如果我们不显式指定Podfile对应的target，CocoaPods会创建一个名称为default的隐式target，会和我们工程中的第一个target相对应。换句话说，如果在Podfile中没有指定target，那么只有工程里的第一个target能够使用Podfile中描述的Pods依赖库。
如果想在一个Podfile中同时描述project中的多个target，根据需求的不同，可以有不同的实现方式。为了说明问题，在原来的工程中再创建一个名称为Second的target，现在的project中包含的target有：
①多个target中使用相同的Pods依赖库
比如，名称为CocoaPodsTest的target和Second的target都需要使用Reachability、SBJson、AFNetworking三个Pods依赖库，可以使用link_with关键字来实现，将Podfile写成如下方式：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>link_with 'CocoaPodsTest', 'Second'  
platform :ios    
pod 'Reachability',  '~&gt; 3.0.0'    
pod 'SBJson', '~&gt; 4.0.0'    

platform :ios, '7.0'    
pod 'AFNetworking', '~&gt; 2.0'   
</code></pre>

<p>这种写法就实现了CocoaPodsTest和Second两个target共用相同的Pods依赖库。
②不同的target使用完全不同的Pods依赖库
CocoaPodsTest这个target使用的是Reachability、SBJson、AFNetworking三个依赖库，但Second这个target只需要使用OpenUDID这一个依赖库，这时可以使用target关键字，Podfile的描述方式如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>target :'CocoaPodsTest' do  
platform :ios    
pod 'Reachability',  '~&gt; 3.0.0'    
pod 'SBJson', '~&gt; 4.0.0'    

platform :ios, '7.0'    
pod 'AFNetworking', '~&gt; 2.0'  
end  

target :'Second' do  
pod 'OpenUDID', '~&gt; 1.0.0'  
end  
</code></pre>

<p>其中，do/end作为开始和结束标识符。
3、使用Podfile管理Pods依赖库版本
再引入依赖库时，需要显示或隐式注明引用的依赖库版本，具体写法和表示含义如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>pod 'AFNetworking'      //不显式指定依赖库版本，表示每次都获取最新版本  
pod 'AFNetworking', '2.0'     //只使用2.0版本  
pod 'AFNetworking', '&gt; 2.0'     //使用高于2.0的版本  
pod 'AFNetworking', '&gt;= 2.0'     //使用大于或等于2.0的版本  
pod 'AFNetworking', '&lt; 2.0'     //使用小于2.0的版本  
pod 'AFNetworking', '&lt;= 2.0'     //使用小于或等于2.0的版本  
pod 'AFNetworking', '~&gt; 0.1.2'     //使用大于等于0.1.2但小于0.2的版本  
pod 'AFNetworking', '~&gt;0.1'     //使用大于等于0.1但小于1.0的版本  
pod 'AFNetworking', '~&gt;0'     //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本  
</code></pre>

<p><div class="entry-content"><h3>三、CocoaPods常用命令</h3></p>

<p>1、pod install</p>

<p>根据Podfile文件指定的内容，安装依赖库，如果有Podfile.lock文件而且对应的Podfile文件未被修改，则会根据Podfile.lock文件指定的版本安装。
每次更新了Podfile文件时，都需要重新执行该命令，以便重新安装Pods依赖库。</p>

<p>2、pod update</p>

<p>若果Podfile中指定的依赖库版本不是写死的，当对应的依赖库有了更新，无论有没有Podfile.lock文件都会去获取Podfile文件描述的允许获取到的最新依赖库版本。</p>

<p>3、pod search</p>

<p>命令格式为：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod search OpenUDID  
</code></pre>

<p>后面的OpenUDID为参数。
从命令的名称不难看出，该命令是用来按名称搜索可用的Pods依赖库，执行结果如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>-&gt; OpenUDID (1.0.0)  
   Open source initiative for a universal and persistent UDID solution for iOS.  
   pod 'OpenUDID', '~&gt; 1.0.0'  
   - Homepage: http://OpenUDID.org  
   - Source:   https://github.com/ylechelle/OpenUDID.git  
   - Versions: 1.0.0 [master repo]  
</code></pre>

<p>这里我们搜到了一条可用数据，里面描述了OpenUDID库的简要信息。其实我们真正需要的是上述结果中的第三行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>pod 'OpenUDID', '~&gt; 1.0.0'  
</code></pre>

<p>不难看出，这是我们需要添加到Podfile文件中的。
有了这条命令，就可以方便、迅速地找到需要的Pods依赖库。</p>

<p>4、pod setup</p>

<p>命令格式为：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod setup  
</code></pre>

<p>执行完了以后会打印：
[ruby] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>Setting up CocoaPods master repo  
Updating 7cd4668..f3d3ced  

Fast-forward  
</code></pre>

<p>接下来还会打印很多更新信息。
这条命令用于跟新本地电脑上的保存的Pods依赖库tree。由于每天有很多人会创建或者更新Pods依赖库，这条命令执行的时候会相当慢，还请耐心等待。我们需要经常执行这条命令，否则有新的Pods依赖库的时候执行pod search命令是搜不出来的。</p>

<p><div class="entry-content"><h3>四、参考文档</h3></p>

<p><a href="http://guides.cocoapods.org/using/index.html"target="_blank"title="刚刚在线"><a href="http://guides.cocoapods.org/using/index.html">http://guides.cocoapods.org/using/index.html</a></a></p>

<p></br></p>

<p>iOS开发微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p></br></p>

<p>文章来自： <a href="http://blog.csdn.net/wzzvictory/article/details/19178709"target="_blank"title="CocoaPods详解之----进阶篇">CocoaPods详解之&mdash;-进阶篇</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/15/cocoapodsxiang-jie-zhi-shi-yong-pian/">CocoaPods详解之&#8212;-使用篇</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-15T13:40:53+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>1:40 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p></br></p>

<p><div class="entry-content"><h3>一、什么是CocoaPods</h3></p>

<p><div class="entry-content"><h5>1、为什么需要CocoaPods</h5></p>

<p>在进行iOS开发的时候，总免不了使用第三方的开源库，比如SBJson、AFNetworking、Reachability等等。使用这些库的时候通常需要：</p>

<p>下载开源库的源代码并引入工程</p>

<p>向工程中添加开源库使用到的framework</p>

<p>解决开源库和开源库以及开源库和工程之间的依赖关系、检查重复添加的framework等问题</p>

<p>如果开源库有更新的时候，还需要将工程中使用的开源库删除，重新执行前面的三个步骤，顿时头都大了。。。</p>

<p>自从有了<a href="http://www.superqq.com/">CocoaPods</a>以后，这些繁杂的工作就不再需要我们亲力亲为了，只需要我们做好少量的配置工作，CocoaPods会为我们做好一切！</p>

<p><div class="entry-content"><h5>2、什么是CocoaPods</h5></p>

<p>CocoaPods是一个用来帮助我们管理第三方依赖库的工具。它可以解决库与库之间的依赖关系，下载库的源代码，同时通过创建一个Xcode的workspace来将这些第三方库和我们的工程连接起来，供我们开发使用。</p>

<p>使用CocoaPods的目的是让我们能自动化的、集中的、直观的管理第三方开源库。</p>

<p><div class="entry-content"><h3>二、安装CocoaPods</h3></p>

<p><div class="entry-content"><h5>1、安装CocoaPods</h5></p>

<p>CocoaPods是用Ruby实现的，要想使用它首先需要有Ruby的环境。幸运的是OS X系统默认的已经可以运行Ruby了，因此我们只需要执行以下命令：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ sudo gem install cocoapods  
</code></pre>

<p>CocoaPods是以Ruby gem包的形式被安装的。在安装执行的过程中，可能会问我们是不是更新rake，输入y即可。这是因为rake gem包会在安装的过程中检查更细，如果有可用的新版本就会出现刚才的选项。</p>

<p>在安装进程结束的时候，执行命令：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ pod setup  
</code></pre>

<p>如果没有报错，就说明一切安装就成功了！</p>

<p><div class="entry-content"><h5>2、安装过程中可能遇到的问题</h5></p>

<p>①执行完install命令半天没反应</p>

<p>这有可能是因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ gem sources --remove https://rubygems.org/  
//等有反应之后再敲入以下命令  
$ gem sources -a http://ruby.taobao.org/  
</code></pre>

<p>要想验证是否替换成功了，可以执行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ gem sources -l  
</code></pre>

<p>正常的输出是：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>*** CURRENT SOURCES ***  

http://ruby.taobao.org/  
</code></pre>

<p>②gem版本过老</p>

<p>gem是管理Ruby库和程序的标准包，如果它的版本过低也可能导致安装失败，解决方案自然是升级gem，执行下述命令即可：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ sudo gem update --system  
</code></pre>

<p>③安装完成后，执行pod setup命令时报错：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>/Users/wangzz/.rvm/rubies/ruby-1.9.3-p448/lib/ruby/site_ruby/1.9.1/rubygems/dependency.rb:298:in `to_specs': Could not find 'cocoapods' (&gt;= 0) among 6 total gem(s) (Gem::LoadError)  
    from /Users/wangzz/.rvm/rubies/ruby-1.9.3-p448/lib/ruby/site_ruby/1.9.1/rubygems/dependency.rb:309:in `to_spec'  
    from /Users/wangzz/.rvm/rubies/ruby-1.9.3-p448/lib/ruby/site_ruby/1.9.1/rubygems/core_ext/kernel_gem.rb:53:in `gem'  
    from /Users/wangzz/.rvm/rubies/ruby-1.9.3-p448/bin/pod:22:in `&lt;main&gt;'  
</code></pre>

<p>这就是路径设置的问题，可以通过执行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ rvm use ruby-1.9.3-p448  
</code></pre>

<p>解决该问题。</p>

<p><div class="entry-content"><h5>3、升级CocoaPods</h5></p>

<p>升级很简单，再次执行安装命令即可：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ sudo gem install cocoapods  
</code></pre>

<p>需要注意的是，如果安装的时候使用了sudo，升级的时候一样需要使用该关键字，不然升级完了以后又会出现路径不匹配问题。</p>

<p><div class="entry-content"><h3>三、使用CocoaPods</h3></p>

<p>如果之前做的一切顺利，接下来就可以体验体验<a href="http://www.superqq.com/">CocoaPods</a>的神奇之处了，需要经过以下几步：</p>

<p>为了演示这个过程，我创建了一个名为CocoaPodsTest的工程。
<div class="entry-content"><h5>1、创建Podfile</h5></p>

<p>CocoaPods的一切都是从一个名为Podfile的文件开始的，我们需要先创建这个文件。个人习惯使用命令行，我会这样做：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ cd /Users/wangzz/Desktop/CocoaPodsTest  
$ touch Podfile  
</code></pre>

<p>首先进入到工程的根目录下，创建空白的Podfile文件，创建完毕的目录结构如下图：</p>

<p><img src="http://img.blog.csdn.net/20140126162345078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>（PS：Podfile文件也可以不放在工程的根目录下，只是会稍微麻烦点，在下一篇文章中会有介绍，敬请关注。）
<div class="entry-content"><h5>2、编辑Podfile</h5></p>

<p>根据需要，我们可以在Podfile文件中写入需要用到的第三方库，以SBJson、AFNetworking、Reachability三个库为例，我的Podfile内容如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>platform :ios  
pod 'Reachability',  '~&gt; 3.0.0'  
pod 'SBJson', '~&gt; 4.0.0'  

platform :ios, '7.0'  
pod 'AFNetworking', '~&gt; 2.0'  
</code></pre>

<p><div class="entry-content"><h5>3、执行导入命令</h5></p>

<p>准备工作都完成后，开始导入第三方库：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>$ cd /Users/wangzz/Desktop/CocoaPodsTest  
$ pod install  
</code></pre>

<p>首先进入工程根目录，然后执行pod install命令，CocoaPods就开始为我们做下载源码、配置依赖关系、引入需要的framework等一些列工作，命令的执行结果打印出来如下：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>Analyzing dependencies  
Downloading dependencies  
Installing AFNetworking (2.1.0)  
Installing JSONKit (1.5pre)  
Installing Reachability (3.0.0)  
Generating Pods project  
Integrating client project  

[!] From now on use `CocoaPodsTest.xcworkspace`.  
</code></pre>

<p>这就说明pod install命令执行成功了。再来看看工程根目录发生的变化，如下图：</p>

<p><img src="http://img.blog.csdn.net/20140126163651109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>可以看到，工程的根目录下多了三个东西：CocoaPodsTest.xcworkspace、Podfile.lock文件和Pods目录。</p>

<p><div class="entry-content"><h5>（PS：篇幅有限，Podfile.lock文件会放到系列文章的下一篇介绍，敬请关注。）</h5></p>

<p>再看看刚才执行完pod install命令打印出来的内容的最后一行：
[objc] view plaincopy在CODE上查看代码片派生到我的代码片</p>

<pre><code>[!] From now on use `CocoaPodsTest.xcworkspace`.  
</code></pre>

<p>提示我们从现在起，我们需要使用CocoaPodsTest.xcworkspace文件来开发。</p>

<p>对于工程发生的变化，有几点需要说明：</p>

<pre><code>第三方库会被编译成静态库供我们正真的工程使用
</code></pre>

<p>CocoaPods会将所有的第三方库以target的方式组成一个名为Pods的工程，该工程就放在刚才新生成的Pods目录下。整个第三方库工程会生成一个名称为libPods.a的静态库提供给我们自己的CocoaPodsTest工程使用。</p>

<pre><code>我们的工程和第三方库所在的工程会由一个新生成的workspace管理
</code></pre>

<p>为了方便我们直观的管理工程和第三方库，CocoaPodsTest工程和Pods工程会被以workspace的形式组织和管理，也就是我们刚才看到的CocoaPodsTest.xcworkspace文件。</p>

<p>原来的工程设置已经被更改了，这时候我们直接打开原来的工程文件去编译就会报错，只能使用新生成的workspace来进行项目管理。</p>

<p>打开CocoaPodsTest.xcworkspace，界面如下：</p>

<p><img src="http://img.blog.csdn.net/20140126171045546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p6dmljdG9yeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>

<p>工程的目录结构还是非常明显的。</p>

<p>在项目中引用刚才添加的第三方库的头文件，执行编译操作，果断成功！</p>

<p>至此，CocoaPods使用篇告一段落，接下来打算再用一个篇幅介绍CocoaPods稍微深层次的东西，敬请关注。</p>

<p><div class="entry-content"><h3>四、参考资料</h3></p>

<p><a href="http://code4app.com/article/cocoapods-install-usage"target="_blank"title="刚刚在线">1、<a href="http://code4app.com/article/cocoapods-install-usage">http://code4app.com/article/cocoapods-install-usage</a></a></p>

<p><a href="http://cocoapods.org/"target="_blank"title="刚刚在线">2、<a href="http://cocoapods.org/">http://cocoapods.org/</a></a></p>

<p></br></p>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p></br></p>

<p>文章来自： <a href="http://blog.csdn.net/wzzvictory/article/details/18737437"target="_blank"title="CocoaPods详解之----使用篇">CocoaPods详解之&mdash;-使用篇</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/14/maczhong-duan-guan-ji-ming-ling/">Mac终端关机命令</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-14T14:00:26+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>2:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>立即关机</p>

<pre><code>sudo halt
</code></pre>

<p>或者</p>

<pre><code>sudo shutdown -h now
</code></pre>

<p>10分钟后关机</p>

<pre><code>sudo shutdown -h +10
</code></pre>

<p>晚上8点关机</p>

<pre><code>sudo shutdown -h 20:00
</code></pre>

<p>立即重启</p>

<pre><code>sudo reboot
</code></pre>

<p>或者</p>

<pre><code>sudo shutdown -r now
</code></pre>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/13/zhong-wen-ios-slash-mac-kai-fa-bo-ke-lie-biao/">中文 iOS/Mac 开发博客列表</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-13T09:16:45+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>9:16 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p></br>
本博客列表会不断更新维护，如果有推荐的博客，请直接在本文下面评论。(排名不分先后)</p>

<h2></br></h2>

<p><a href="http://onevcat.com"target="_blank"title="OneV's Den">OneV&rsquo;s Den</a></p>

<p>嗨，我是王巍 (@onevcat)，一名来自中国的 iOS / Unity 开发者。现居日本，就职于 LINE。正在修行，探求创意之源。
<a href="http://swifter.tips/"target="_blank"title="Swifter.tips">Swifter.tips</a> - 我维护的 Swift 使用技巧分享网站，每周三更新，欢迎访问</p>

<h2></br></h2>

<p><a href="http://www.superqq.com"target="_blank"title="刚刚在线">刚刚在线</a></p>

<p>Blogger, iOS开发, 创业者, 屌丝青年。iOS开发工程师，曾开发今日·天下通，二维码商城等项目。iOS学习交流群：303868520 我的微信公众账号: iOSDevTip</p>

<h2></br></h2>

<p><a href="http://beyondvincent.com"target="_blank"title="破船之家">破船之家</a></p>

<p>程序猿砌墙于云南昆明!长期扎根移动软件开发!爱跑步爱打篮球爱运动!命中无大富大贵之面相!愿健康与平淡相随一生!</p>

<h2></br></h2>

<p><a href="http://nshipster.cn"target="_blank"title="NSHipster">NSHipster</a></p>

<p>NSHipster 关注被忽略的 Objective-C、Swift 和 Cocoa 特性。每周更新。</p>

<h2></br></h2>

<p><a href="http://blog.devtang.com"target="_blank"title="唐巧的技术博客">唐巧的技术博客</a></p>

<p>Blogger, InfoQ编辑, iOS开发, 创业者。Java开发工程师，曾开发网易微博后台。iOS开发工程师，曾开发有道云笔记、粉笔网、猿题库。</p>

<h2></br></h2>

<p><a href="http://blog.xcodev.com"target="_blank"title="Xcode Dev">Xcode Dev</a></p>

<p>谌启亮，资深iOS开发工程师，参与过20多个项目的研发，从苹果还未开放官方SDK(非官方Toolchain)开发做起，6年iOS应用开发经验, 精通界面开发及iOS设备用户体验。喜欢学习一些新的知识并分享自己所学。就职于腾讯。</p>

<h2></br></h2>

<p><a href="http://blog.t-xx.me/blog/archives"target="_blank"title="txx's blog">txx&rsquo;s blog</a></p>

<h2></br></h2>

<p><a href="http://xiangwangfeng.com"target="_blank"title="阿毛的蛋疼地">阿毛的蛋疼地</a></p>

<p>阿毛，杭州猪场全职iOS开发一枚，早年学C#,C++未成，与2011年改投OC怀抱。</p>

<h2></br></h2>

<p><a href="http://nonomori.farbox.com"target="_blank"title="Nonomori">Nonomori</a></p>

<h2></br></h2>

<p><a href="http://adad184.com"target="_blank"title="里脊串的开发随笔">里脊串的开发随笔</a></p>

<p>86年生于长沙, 曾于深圳工作, 现已回长沙.</p>

<h2></br></h2>

<p><a href="http://ivoryxiong.org"target="_blank"title="煲仔饭">煲仔饭</a></p>

<p>byr土著，码农一枚，朋友们都习惯叫&#8221;雕&#8221;【不要问为什么:(】，爱好不多，仅有的兴趣现在也成为了职业&hellip;在网易有道打过杂，也在人人网写过代码，目前在深圳折腾无觅阅读。</p>

<h2></br></h2>

<p><a href="http://www.hotobear.com"target="_blank"title="不掏蜂窝的熊">不掏蜂窝的熊</a></p>

<p>我是不掏蜂窝的熊iOS开发，接触过越狱开发，对iOS程序逆向工程有一定了解。其实我只是一只普通的程序猿而已。一直以为自己是巨蟹座，结果某天发现自己是狮子时，已经没有当狮子的潜质了</p>

<h2></br></h2>

<p>参考唐巧的github：<a href="https://github.com/tangqiaoboy/iOSBlogCN"target="_blank"title="中文 iOS/Mac 开发博客列表">中文 iOS/Mac 开发博客列表</a><br/>
</br>
<a href="http://www.superqq.com/blog/2014/11/13/zhong-wen-ios-slash-mac-kai-fa-bo-ke-lie-biao/"target="_blank"title="刚刚在线">转载请注明来自：刚刚在线</a></p>

<h2></br></h2>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/11/jie-du-afnetworkingzhong-demode-mvc/">解读AFNetworking中Demo的MVC</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-11T11:00:21+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Demo的下载地址：<a href=""></a><a href="https://github.com/AFNetworking/AFNetworking.git"target="_blank"title="AFNetworking下载">AFNetworking下载</a></p>

<p>打开Demo：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylDJt3FABXaQmFVO4Hqm1zNzeQGY2kKVSJ9CtQR7HWcsKelE6nuLauFQMdWtO2L90ccabibh5v1yeg/640"></p>

<p>现实的功能，就是一个简易的微博timeline界面：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylDJt3FABXaQmFVO4Hqm1zNW4svNoeQPlAsBHJ40YJeiaUib7ia5Hdgo9Yf5YBee5zZ1lDbXphGCHibCQ/640"></p>

<p>项目预览：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylDJt3FABXaQmFVO4Hqm1zNFUp9X2kpra3gqd98Qh4Yn1RhnHsIKcI46TP97BVKbvJicpvYoUd5tuA/640"></p>

<p>用到的第三方：AFNetworking 和 UIKit+AFNetworking</p>

<p>功能：用户图像（先显示默认图，在加载图片），用户发的内容，下拉刷新。</p>

<p><div class="entry-content"><h3>C层：</h3></p>

<p>发一个请求：（告诉M 要做什么）</p>

<pre><code>- (void)reload:(__unusedid)sender {
    self.navigationItem.rightBarButtonItem.enabled = NO;

    NSURLSessionTask *task = [PostglobalTimelinePostsWithBlock:^(NSArray *posts, NSError *error) {
        if (!error) {

             self.posts = posts;
            [self.tableViewreloadData];
        }
    }];

    [UIAlertViewshowAlertViewForTaskWithErrorOnCompletion:task delegate:nil];
    [self.refreshControlsetRefreshingWithStateOfTask:task];
}
</code></pre>

<p>M 做完之手，产生多个post对象，放到self.post数组里面。C拿到M给的post对象，去更新V</p>

<pre><code>cell.post = [self.postsobjectAtIndex:(NSUInteger)indexPath.row];
</code></pre>

<p><div class="entry-content"><h3>M层：</h3></p>

<p>M 收到C的请求：去请求数据，解析，转换成post对象，然后通过block返回给C</p>

<pre><code>+ (NSURLSessionDataTask *)globalTimelinePostsWithBlock:(void (^)(NSArray *posts, NSError *error))block {
    return [[AFAppDotNetAPIClientsharedClient] GET:@"stream/0/posts/stream/global"parameters:nilsuccess:^(NSURLSessionDataTask * __unused task, id JSON) {
        NSArray *postsFromResponse = [JSON valueForKeyPath:@"data"];
        NSMutableArray *mutablePosts = [NSMutableArrayarrayWithCapacity:[postsFromResponse count]];
        for (NSDictionary *attributes in postsFromResponse) {
            Post *post = [[Postalloc] initWithAttributes:attributes];
            [mutablePosts addObject:post];
        }

        if (block) {
            block([NSArrayarrayWithArray:mutablePosts], nil);
        }
    } failure:^(NSURLSessionDataTask *__unused task, NSError *error) {
        if (block) {
            block([NSArrayarray], error);
        }
    }];
}
</code></pre>

<p><div class="entry-content"><h3>V层：</h3></p>

<p>V：拿到C给的数据，来展示出来，这一步就是更新UI</p>

<pre><code>- (void)setPost:(Post *)post {
    _post = post;

    self.textLabel.text = _post.user.username;
    self.detailTextLabel.text = _post.text;
    [self.imageViewsetImageWithURL:_post.user.avatarImageURLplaceholderImage:[UIImageimageNamed:@"profile-image-placeholder"]];

    [selfsetNeedsLayout];
}
</code></pre>

<p>其中 ：</p>

<pre><code>    [self.imageViewsetImageWithURL:_post.user.avatarImageURLplaceholderImage:[UIImageimageNamed:@"profile-image-placeholder"]];
</code></pre>

<p>这句代码是对UIImageView的扩展，在UIKit+AFNetworking可以直接使用，非常方便。</p>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/10/qian-xi-mvche-shuo-mei-de-guo-cheng/">浅析MVC和说媒的过程</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-10T09:09:18+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>9:09 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>什么是MVC？</p>

<p>MVC 全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面 显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p>

<p>图解MVC（斯坦福公开课的课件）</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlyntSNHaU7eaCHkcL3pjib2pNyjgWU7BF1D1YgmicwMFpFuefvttAe7fEwCu8TTmkmfkRtAO0Hvt1HfA/640"></p>

<p>看了上面的MVC定义和图解，对MVC有了初步的了解，特别是斯坦福这个课件，讲的非常到位。但是在实际开发过程中，却感觉离MVC的标准越来越远。</p>

<p>我也看过一些朋友写的iOS项目，看之前问MVC，都讲的头头是道，但是在项目中却体现的不是那么好。我自己写项目也是，理论上是理解了MVC的模式，但是真去写代码，还是觉得，有些地方不到位。</p>

<p>特别是C（我们就把UIViewController当做C来看，网上有对C的其他解释）显得别急臃肿。有时候C里面代码几千行（并不是说代码过千就是不符合MVC），C干了很多M干的事，同时也干了很多V要干的事。</p>

<p>这几天我看了一个项目（AFNetworking的作者写的DEMO，大家可以到github上下载），觉得MVC用的非常到位。每一步都是很周到，M和C的对接，V和C的对接，做到非常到位。</p>

<p>对于MVC，我说说我的理解，俗一点讲：媒婆说没得过程。M -> 男人 ， V -> 女人 ， C -> 媒婆。</p>

<p>C（媒婆） 要给 M（男人） 介绍个女朋友 V （女人），C 是一个桥梁起着对接的作用， M 和 V 本是不认识的两个人，不能直接沟通。</p>

<p>说媒过程是这样的：C 给 M 说，第一次见女孩子，你要给女孩子准备什么礼物吧？</p>

<p>这个时候，M 肯定不会说，这点小事，你还来麻烦我，自己去买吧，那估计媒婆气都气死了，这事肯定成不了。（写代码的时候，不要让C干M得事）</p>

<p>这事必须 M 自己去做，M 买东西就是处理数据得过程。买东西怎么去买？多少钱？怎么讲价？这都是 M 自己要去干的事。最终结果是 M 买来礼物，礼物就是我们编程过程中 Model所产生的对象。</p>

<p>礼物买来了，M 也不认识 V ，肯定也不知道怎么送给 V，所以这个时候 C 的作用就体现出来了，M 要把 买来的礼物（Object）交给C，让C帮忙送给 V。</p>

<p>就这样，V 拿到礼物，觉得不错，就自己用了。</p>

<p>回想一下这个过程：C 发起一个请求，买礼物。M 知道之后，就去执行这件事，最终买来礼物。M 脱 C 把礼物送给V。一个完整的请求数据，展示数据的过程。</p>

<p>虽然有点俗，但是还是有一定道理的。</p>

<p>后面时间允许的话，我会详解一下AFNetworking的作者写的DEMO。看看MVC在项目的体现到底是什么样的。</p>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/08/xcode6wei-shi-yao-gan-diao-pch(precompile-prefix-header)-and-ru-he-tian-jia-pchwen-jian/">Xcode6为什么干掉pch（Precompile Prefix Header）&amp;如何添加pch文件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-08T10:11:23+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>10:11 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一直在用xcode6开发，但项目都是在xcode5上创建的，所以一直没注意到，xcode6竟然干掉pch文件了。</p>

<p><div class="entry-content"><h3>为什么xcode6没有自动创建pch文件呢？</h3></p>

<p>简单地看：我们在写项目的时候，大部分宏定义，头文件导入都在这里，Xcode6去掉Precompile Prefix Header的主要原因可能在于Prefix Header大大的增加了Build的时间。没有了Prefix Header之后就要通过手动@import来手动导入头文件了，在失去了编程便利性的同时也降低了Build的时间。
具体原因</p>

<p>StackOverFlow上讨论的已经比较清晰了</p>

<p><a href="http://stackoverflow.com/questions/24158648/why-isnt-projectname-prefix-pch-created-automatically-in-xcode-6"target="_blank"title="StackOverFlow:为什么xcode6没有自动创建pch文件呢？">StackOverFlow:为什么xcode6没有自动创建pch文件呢？</a></p>

<p><div class="entry-content"><h3>如何在Xcode6中添加pch（Precompile Prefix Header）？</h3></p>

<p>1，Command+N，打开新建文件窗口：ios->other->PCH file，创建一个pch文件：“工程名-Prefix.pch”：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlynoFBbyWveMYy6wticicsiasX3njmTFhaLX2E5bcJ6nCw3eqnuhNokuWGOpnj2VfFebls5132y2cDI6g/0"></p>

<p>2，将building setting中的precompile header选项的路径添加“$(SRCROOT)/项目名称/pch文件名”（例如：$(SRCROOT)/LotteryFive/LotteryFive-Prefix.pch）</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlynoFBbyWveMYy6wticicsiasX38btBBs0AT3s6kGic99kpGDMk9bJ4ctI8bQRL7ahnavlDqm21QDTfWBA/0"></p>

<p>可以了，编译一下程序，如果有错误检查一下添加的路径是否正确。</p>

<p>3，将Precompile Prefix Header为YES，预编译后的pch文件会被缓存起来，可以提高编译速度</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlynoFBbyWveMYy6wticicsiasX35f55EbKxXYqghNKeE4o3YLYTvRyQzdMMcVaQmmkNE68hZypyI24lQQ/0"></p>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>

<p>✎最新iOS、iPhone资讯，iOS开发者、swift开发、果粉聚集，参与技术讨论，整理开发技巧，分享创业经验！享受生活、热爱编程！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">iOS网络编程之AFNetworking使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-07T11:07:32+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:07 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">iOS网络编程之AFNetworking使用</a></p>

<p>现在大家都喜欢用AFNetworking，因为有人维护。看来一下官方文档，把使用的代码简单罗列一下：</p>

<p>首先通过<a href="http://www.superqq.com/blog/2014/10/16/cocoapodsan-zhuang-he-shi-yong-jiao-cheng/">CocoaPods</a>(没用过的看这篇文章)把AFNetworking拉下来</p>

<p>Podfile</p>

<pre><code>platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0"
</code></pre>

<p>方法一：GET 请求</p>

<pre><code>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager GET:@"http://example.com/resources.json" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<p>方法二：POST 请求</p>

<pre><code>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
NSDictionary *parameters = @{@"foo": @"bar"};
[manager POST:@"http://example.com/resources.json" parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<p>方法三：POST Multi-Part Request</p>

<pre><code>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
NSDictionary *parameters = @{@"foo": @"bar"};
NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];
[manager POST:@"http://example.com/resources.json" parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
    [formData appendPartWithFileURL:filePath name:@"image" error:nil];
} success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"Success: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<p>方法四：创建一个下载文件任务</p>

<pre><code>NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

NSURL *URL = [NSURL URLWithString:@"http://example.com/download.zip"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];

NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) {
    NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
    return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];
} completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) {
    NSLog(@"File downloaded to: %@", filePath);
}];
[downloadTask resume];
</code></pre>

<p>方法五：创建一个上传文件任务</p>

<pre><code>NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];

NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];
NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:nil completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@"Error: %@", error);
    } else {
        NSLog(@"Success: %@ %@", response, responseObject);
    }
}];
[uploadTask resume];
</code></pre>

<p>方法六：创建一个上传文件任务并显示进度</p>

<pre><code>NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:@"http://example.com/upload" parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
        [formData appendPartWithFileURL:[NSURL fileURLWithPath:@"file://path/to/image.jpg"] name:@"file" fileName:@"filename.jpg" mimeType:@"image/jpeg" error:nil];
    } error:nil];

AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
NSProgress *progress = nil;

NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&amp;progress completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@"Error: %@", error);
    } else {
        NSLog(@"%@ %@", response, responseObject);
    }
}];
[uploadTask resume];
</code></pre>

<p>方法七：创建一个上传数据data任务</p>

<pre><code>NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];

NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@"Error: %@", error);
    } else {
        NSLog(@"%@ %@", response, responseObject);
    }
}];
[dataTask resume];
</code></pre>

<p>方法八：获取网络状态</p>

<pre><code>[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    NSLog(@"Reachability: %@", AFStringFromNetworkReachabilityStatus(status));
}]; 
</code></pre>

<p>方法九： HTTP Manager Reachability</p>

<pre><code>NSURL *baseURL = [NSURL URLWithString:@"http://example.com/"];
AFHTTPRequestOperationManager *manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:baseURL];

NSOperationQueue *operationQueue = manager.operationQueue;
[manager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    switch (status) {
        case AFNetworkReachabilityStatusReachableViaWWAN:
        case AFNetworkReachabilityStatusReachableViaWiFi:
            [operationQueue setSuspended:NO];
            break;
        case AFNetworkReachabilityStatusNotReachable:
        default:
            [operationQueue setSuspended:YES];
            break;
    }
}];

[manager.reachabilityManager startMonitoring];
</code></pre>

<p>方法十：AFHTTPRequestOperation的GET请求</p>

<pre><code>NSURL *URL = [NSURL URLWithString:@"http://example.com/resources/123.json"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[[NSOperationQueue mainQueue] addOperation:op];  
</code></pre>

<p>方法十一：Batch of Operations</p>

<pre><code>NSMutableArray *mutableOperations = [NSMutableArray array];
for (NSURL *fileURL in filesToUpload) {
    NSURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:@"http://example.com/upload" parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
        [formData appendPartWithFileURL:fileURL name:@"images[]" error:nil];
    }];

    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];

    [mutableOperations addObject:operation];
}

NSArray *operations = [AFURLConnectionOperation batchOfRequestOperations:@[...] progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {
    NSLog(@"%lu of %lu complete", numberOfFinishedOperations, totalNumberOfOperations);
} completionBlock:^(NSArray *operations) {
    NSLog(@"All operations in batch complete");
}];
[[NSOperationQueue mainQueue] addOperations:operations waitUntilFinished:NO];
</code></pre>

<p>方法十二：获取请求的一些信息(我也没有用过，不太常用)</p>

<p>Request Serialization</p>

<p>Request serializers create requests from URL strings, encoding parameters as either a query string or HTTP body.</p>

<pre><code>NSString *URLString = @"http://example.com";
NSDictionary *parameters = @{@"foo": @"bar", @"baz": @[@1, @2, @3]};
</code></pre>

<p>Query String Parameter Encoding</p>

<pre><code>[[AFHTTPRequestSerializer serializer] requestWithMethod:@"GET" URLString:URLString parameters:parameters error:nil];

GET http://example.com?foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3
</code></pre>

<p>URL Form Parameter Encoding</p>

<pre><code>[[AFHTTPRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters];

POST http://example.com/
Content-Type: application/x-www-form-urlencoded

foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3
</code></pre>

<p>JSON Parameter Encoding</p>

<pre><code>[[AFJSONRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters];

POST http://example.com/
Content-Type: application/json

{"foo": "bar", "baz": [1,2,3]}
</code></pre>

<p>我的微信公众号 iOS开发 ：</p>

<pre><code>iOSDevTip
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/07/xcode6-dot-1diao-shi-de-shi-hou-you-shi-can-shu-du-wei-nilzen-yao-jie-jue/">xcode6.1调试的时候有时参数都为nil怎么解决?</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-07T09:18:04+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>9:18 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.superqq.com/blog/2014/11/07/xcode6-dot-1diao-shi-de-shi-hou-you-shi-can-shu-du-wei-nilzen-yao-jie-jue/">xcode6.1调试的时候有时参数都为nil怎么解决?</a></p>

<p>昨天我在写代码的时候，发现xcode6.1调试的时候有时参数都为nil？曾经有朋友遇到过这个问题，我一直没当回事，昨天我也碰到了：</p>

<p>看下图：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylSosnUuLhV6wTjsFzyRRxoxIUFMqUwfUBic9qDUm8IY9gJQibL0oNeGUMCKN1oVJBwnv6l5OAezkicg/640" ></p>

<p>刚创建的vc 和 nav 都为nil，这给断点调试增加了很多麻烦，难道是xcode的bug吗？</p>

<p>群里问问大牛，不得姐，网上有查，最终找到解决方法：</p>

<p>在Project的Build Settings中把Optimization Level 设置成 None 即可。</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylSosnUuLhV6wTjsFzyRRxo44fXntXf13uoSlnLOsdTkbhHFsHXeDljz69g3JR4sEJnr5SRSLO8icQ/640" ></p>

<p>在运行看一下结果：</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz/8RTSPr4mlylSosnUuLhV6wTjsFzyRRxoHE3BZhvRDgzxlCG8ibiceSGl81ykIM58AejX3nYW5YO5aSTwTsick82Sw/640" ></p>

<p>果然，有值了。小问题的解决方法，分享给大家。</p>

<p>喜欢我们的内容，可以点击右上角「分享到朋友圈」</p>

<p>以后大家有什么问题，可以登录<a href="http://www.iswifting.com">swift社区</a> 里面设置有问答区，会有大牛帮大家解答问题的。</p>

<p>微信公众账号：iOS开发</p>

<pre><code>iOSDevTip
</code></pre>

<p>QQ群：iOS学习交流群</p>

<pre><code>303868520
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/5">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/3">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/01/29/ioskai-fa-xia-zai-wen-jian-su-du-ji-suan/">iOS开发下载文件速度计算</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/22/jie-jue-mwphotobrowserzhong-de-sdwebimagejia-zai-da-tu-dao-zhi-de-nei-cun-jing-gao-wen-ti/">解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/19/ioskai-fa-zhi-uisearchbarchu-tan/">iOS开发之UISearchBar初探</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/15/objective-cxiang-guan-categoryde-shou-ji/">Objective-C相关Category的收集</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/14/ioskai-fa-zhi-shou-shi-shi-bie-hui-zong/">iOS开发之手势识别汇总</a>
      </li>
    
  </ul>
</section>
</section>
<section>
    <h1>About Me</h1>
    <br/>
    <p> Blogger, iOS开发, 创业者, 屌丝青年。<br/>
    <br/>iOS开发工程师，曾开发今日·天下通，二维码商城等项目。
    <br/>
    <br/>
    <br/>新浪微博: <a href='http://weibo.com/ligangnc' target='_blank'>李刚移动</a>
        <span id="wb_follow_btn"></span>
        <br/>
        <br />我的<strong>&#8220;iOSDevTip&#8221;</strong>微信公众账号:
        <br/>
        <br/><img width="220px" src="http://www.superqq.com/images/getqrcode.jpg" />
        </p>
        </section>
        
    <br/>iOS群：
    
    <br/>iOS开发经验交流：218822587
    <br/>个人微信：chinaligang 欢迎调戏<section>
    <h1>友情链接</h1>
    <ul>
        <li>
            <a href="http://www.iswifting.com/forum.php" target="_blank" title="swift社区">swift社区</a>
        </li>
        <li>
            <a href="http://blog.csdn.net/iosdevtip" target="_blank" title="刚刚在线">CSDN</a>
        </li>
        <li>
        <a href="http://user.qzone.qq.com/1606535851" target="_blank" title="刚刚在线">QQ空间</a>
        </li>
        
    </ul>
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
Copyright &copy; 2015 - 刚刚 
<span class="credit">Powered by <a href="http://octopress.org" target="_blank">Octopress</a></span>
 <span class="credit">, 感谢 <a href="http://gitcafe.com/signup?invited_by=tangqiaoboy" target="_blank">GitCafe</a> 为本站提供存储空间</span>

</p>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/17443209.js"></script>
<noscript><a href="http://www.51.la/?17443209" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/17443209.asp" style="border:none" /></a></noscript>
</footer>
  











</body>
</html>
