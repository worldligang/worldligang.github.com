
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
      <meta name="baidu-site-verification" content="X93tJz3pCq" />
  <title>刚刚在线</title>
  <meta name="author" content="李刚">
  <meta name="uyan_auth" content="d1112891bb" />
  <meta name="baidu-tc-verification" content="7acda2305fabbf1ddd9f83e385ddd899" />
      
  
  <meta name="description" content="2年iOS开发站长，优秀iOS开发博客之一。关注iOS开发、swift开发、iOSDevTip、移动互联网、自媒体、Cocoapods、Xcode、iOS，刚刚在线博客是一个值得收藏的网站！">
  <meta name="keywords" content="iOS,iOS开发,cocoapods,code,iOS代码, 源代码, 刚刚在线,iOS李刚, pointInside, 刚刚, hitTest, Objective-c,李刚博客">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.superqq.com/posts/5">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="刚刚在线" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->


  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">刚刚在线</a></h1>
  
    <h2>关注iOS开发和移动互联网的自媒体博客</h2>
  
</hgroup>

<!--广告位-->
<dic class="flashnews">
    <script type="text/javascript">
        /*960*60 创建于 2015-06-13*/
        var cpro_id = "u2154036";
        </script>
    <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
    </div>
<!--广告链接结束--></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://zhannei.superqq.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.superqq.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">全部文章</a></li>
  <li><a href="/blog/categories/ioskai-fa/">iOS开发</a></li>
  <li><a href="/blog/categories/swiftkai-fa">swift开发</a></li>
  <li><a href="/blog/categories/cheng-xu-yuan/">程序员</a></li>
  <li><a href="/blog/categories/yuan-dai-ma/">源代码</a></li>
  <li><a href="/blog/categories/sdkfu-wu/">sdk服务</a></li>
  <li><a href="/blog/categories/tui-jian/">推荐</a></li>
  <li><a href="/about">赞助作者</a></li>
  <li><a href="http://www.90159.com/" target="_blank" title=头条>头条</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao/">用正则表达式验证邮箱和手机号</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-27T07:35:42+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:35 am</span></time>
        
          | <a href="/blog/2015/06/27/yong-zheng-ze-biao-da-shi-yan-zheng-you-xiang-he-shou-ji-hao/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><blockquote><p>正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></blockquote>

<p>做iOS开发的童鞋，应该都用过正则表达式吧。正则表达式很好地，帮助我们判断一个字符串是否合法。比如：</p>

<ol>
<li><p>在做app注册页面的时候，需要判断手机号是否格式正确，是否够11位。</p></li>
<li><p>在做意见反馈的时候，需要判断邮箱格式是否正确。</p></li>
</ol>


<p>判断手机号和判断邮箱，应该是iOS开发者们最常用的。具体如何判断，简单整理如下：</p>

<h2>验证邮箱</h2>

<pre><code>+ (BOOL)validateEmail:(NSString *)email
{
    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}";
    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex];
    return [emailTest evaluateWithObject:email];
}
</code></pre>

<p>NSPredicate是一个Foundation类，是用来查询的，原理和用法都类似于SQL中的where。</p>

<h2>验证手机号</h2>

<h3>简单的判断方法</h3>

<pre><code>+ (BOOL)validatePhone:(NSString *)phone
{
    NSString *phoneRegex = @"1[3|5|7|8|][0-9]{9}";
    NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", phoneRegex];
    return [phoneTest evaluateWithObject:phone];
}
</code></pre>

<p>这只是简单地判断手机号格式。其实手机的格式还是有一点复杂的。</p>

<h3>详细的判断方法</h3>

<pre><code>//正则判断手机号码格式
+ (BOOL)validatePhone:(NSString *)phone
{
       /**
        * 手机号码
        * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        * 联通：130,131,132,152,155,156,185,186
        * 电信：133,1349,153,180,189
        */
       NSString * MOBILE = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";
       /**
        10         * 中国移动：China Mobile
        11         * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188
        12         */
       NSString * CM = @"^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d{7}$";
       /**
        15         * 中国联通：China Unicom
        16         * 130,131,132,152,155,156,185,186
        17         */
       NSString * CU = @"^1(3[0-2]|5[256]|8[56])\\d{8}$";
       /**
        20         * 中国电信：China Telecom
        21         * 133,1349,153,180,189
        22         */
       NSString * CT = @"^1((33|53|8[09])[0-9]|349)\\d{7}$";
       /**
        25         * 大陆地区固话及小灵通
        26         * 区号：010,020,021,022,023,024,025,027,028,029
        27         * 号码：七位或八位
        28         */
      // NSString * PHS = @"^0(10|2[0-5789]|\\d{3})\\d{7,8}$";

     NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", MOBILE];
     NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM];
     NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU];
     NSPredicate *regextestct = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT];

    if (([regextestmobile evaluateWithObject:phone] == YES)
    || ([regextestcm evaluateWithObject:phone] == YES)
    || ([regextestct evaluateWithObject:phone] == YES)
    || ([regextestcu evaluateWithObject:phone] == YES))
    {
        if([regextestcm evaluateWithObject:phone] == YES) {
          NSLog(@"China Mobile");
        } else if([regextestct evaluateWithObject:phone] == YES) {
          NSLog(@"China Telecom");
        } else if ([regextestcu evaluateWithObject:phone] == YES) {
          NSLog(@"China Unicom");
        } else {
          NSLog(@"Unknow");
        }

        return YES;
    }
    else 
    {
        return NO;
    }
}
</code></pre>

<p>以上这段（来自网络）是手机号判断的详细方法。基本上这个判断就够用了，如果三大运营商，再出其他段的手机号。直接子啊上面做简单修改即可。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified/">Xcode真机调试报错：The Application Could Not Be Verified.</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-26T15:33:34+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>3:33 pm</span></time>
        
          | <a href="/blog/2015/06/26/xcodezhen-ji-diao-shi-bao-cuo-:the-application-could-not-be-verified/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><p> 今天真机调试的时候遇到这个错误：</p>

<pre><code>The application could not be verified.
</code></pre>

<p> 这还是第一次遇到，应该是手机上的app的证书跟现在的证书不一致导致。</p>

<p> 解决方法有两个</p>

<p> ###xcode中切换证书：</p>

<pre><code>你手机上的app用的是哪个证书，你现在还用那个证书运行。
</code></pre>

<p> ###删除手机上的app</p>

<pre><code>直接删除手机上的app，再运行就可以啦！
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan/">NSDate和NSString相互转换</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-26T07:34:32+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:34 am</span></time>
        
          | <a href="/blog/2015/06/26/nsdatehe-nsstringxiang-hu-zhuan-huan/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/2NSDate.jpg" alt="1" /></p>

<p>不积小流无以成江海，不及硅步无以至千里。做<a href="http://www.superqq.com/blog/2015/01/14/ioskai-fa-zhi-shou-shi-shi-bie-hui-zong/">iOS开发</a>也是这样，平时写代码要多收集一些有用的代码，以免每次都从新来一遍，不仅浪费时间，也影响开发效率。</p>

<p>有人把做app形容成盖房子，码农就是搬砖的，真的是形象无比。随着时间的推移，手里积累的优秀代码就越来越多。这样，盖起房子来，效率肯定是杠杠的。</p>

<p>我也会收集一些有用的代码，有的会写在博客里，有的会写成demo放在<a href="http://www.superqq.com/blog/2014/11/19/ioskai-fa-zhong-gitfen-zhi-chuang-jian-he-guan-li/">github</a>上面，有的就很安静的躺在我的电脑里。每次我用到的时候，我都会顺手复制过来。</p>

<p>今天给大家分享一些关于NSDate和NSString相互转换。百度一下，有一大推相关的方法。每次都百度，不如自己收集起来方便。</p>

<h2>NSDate转NSString</h2>

<p>日期转成字符串。这个虽然简单，但是我相信很多朋友初次遇到肯定束手无策。脑子里蹦出四个字：这怎么转？直接上代码：</p>

<pre><code>//获取系统当前时间
NSDate *currentDate = [NSDate date];
//用于格式化NSDate对象
NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
//设置格式：zzz表示时区
[dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
//NSDate转NSString
NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
//输出currentDateString
NSLog(@"%@",currentDateString);
</code></pre>

<p>NSDate对象包含两个部分，日期（Date）和时间（Time）。格式化的时间字符串主要也是针对日期和时间的。NSDateFormatter是一个很常用的类，用于格式化NSDate对象，支持本地化的信息。</p>

<p>NSDateFormatter常用的格式有：</p>

<pre><code>yyyy-MM-dd HH:mm:ss.SSS 
yyyy-MM-dd HH:mm:ss
yyyy-MM-dd
MM dd yyyy
</code></pre>

<p>NSDateFormatter格式化参数如下：</p>

<pre><code>G: 公元时代，例如AD公元
yy: 年的后2位
yyyy: 完整年
MM: 月，显示为1-12
MMM: 月，显示为英文月份简写,如 Jan
MMMM: 月，显示为英文月份全称，如 Janualy
dd: 日，2位数表示，如02
d: 日，1-2位显示，如 2
EEE: 简写星期几，如Sun
EEEE: 全写星期几，如Sunday
aa: 上下午，AM/PM
H: 时，24小时制，0-23
K：时，12小时制，0-11
m: 分，1-2位
mm: 分，2位
s: 秒，1-2位
ss: 秒，2位
S: 毫秒
</code></pre>

<h2>NSString转NSDate</h2>

<p>既然NSDate可以转成NSString，毫无疑问NSString也可以转成NSDate。代码如下：</p>

<pre><code>//需要转换的字符串
NSString *dateString = @"2015-06-26 08:08:08";
 //设置转换格式
NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
[formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
//NSString转NSDate
NSDate *date=[formatter dateFromString:dateString];
</code></pre>

<p>NSDate和NSString相互转换就是这么简单。</p>

<h2>转换工具类</h2>

<p>在项目中，我们需要用到转换的地方可能不止一处，所以建议我们定义一个工具类。在工具类里实现如下两个方法：</p>

<pre><code>//NSDate转NSString
+ (NSString *)stringFromDate:(NSDate *)date
{
    //获取系统当前时间
    NSDate *currentDate = [NSDate date];
    //用于格式化NSDate对象
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //设置格式：zzz表示时区
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss zzz"];
    //NSDate转NSString
    NSString *currentDateString = [dateFormatter stringFromDate:currentDate];
    //输出currentDateString
    NSLog(@"%@",currentDateString);
    return currentDateString;
}

//NSString转NSDate
+ (NSDate *)dateFromString:(NSString *)string
{
    //需要转换的字符串
    NSString *dateString = @"2015-06-26 08:08:08";
    //设置转换格式
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init] ;
    [formatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    //NSString转NSDate
    NSDate *date=[formatter dateFromString:dateString];
    return date;
}
</code></pre>

<p>有了这个工具类，妈妈再也不用担心我的转换能力啦！</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/25/ru-he-cheng-wei-%5B%3F%5D-ming-you-xiu-de-ioskai-fa-gong-cheng-shi/">如何成为一名优秀的iOS开发工程师</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-25T07:49:07+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:49 am</span></time>
        
          | <a href="/blog/2015/06/25/ru-he-cheng-wei-%5B%3F%5D-ming-you-xiu-de-ioskai-fa-gong-cheng-shi/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/1iOSkaifa.jpg" alt="1" /></p>

<p>如果你是一位专业的<strong>iOS开发工程师</strong>，你应该为自己感到自豪。因为你能在强大的iOS系统下，一展身手实现自己和他人的想法，这是一件令人无比激动的事情。</p>

<p>作为一名iOS开发工程师，你一定想成为行业的佼佼者。那么，如何成为一名优秀的iOS开发工程师呢？我觉得做到以下几点，你就离优秀越来越近了。</p>

<h3>提高英语水平</h3>

<p>作为码农，英语水平虽然不是一个硬指标，但是，如果你的英语水平足够好，那真是如虎添翼。在公司里面，糟糕的英语表达能力也掩盖了你在软件开发技术上的优势。</p>

<p>很多优秀的技术文章都是英文版本的，就像苹果官方文档一样，你看不懂你就比别人落后了一步。当这些文档被汉化，被翻译成中文，那是需要一段时间的。少则几天，多则几个月。所以与其被动等待，不如先把英语水平提上去。</p>

<p>英语的重要性，不言而喻，不仅仅有助于写代码。如果万一哪一天你成为公众人物了，你是想向刘强东一样讲英语，还是想向雷布斯一样讲英语呢？我觉得你应该更想像马云一样。</p>

<p>至于，如何提高英语水平，请问度娘。</p>

<h3>控制代码质量</h3>

<p>想成为优秀的iOS开发工程师，代码质量是很重要的一关。关于如何提高代码质量，推荐大家看一篇文章：<a href="http://www.90159.com/2015/06/17/Objective-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%9A26%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%A7%A3%E5%86%B3iOS%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/">Objective-C编码规范：26个方面解决iOS开发问题</a>，这篇文章详细的讲述了iOS开发方面的编码规范，建议大家多看一看。</p>

<p>如果你能按着上面的编码规范来规范自己，我觉得最起码你代码看起来就比较整洁。这样的话，哪怕你一个月回头再来看自己的代码，应该很快就可以理解。而且，当你离开现在的公司，不至于后来的人骂你。</p>

<p>没听人常说嘛：良好的习惯是成功的第一步，iOS开发者也不例外。</p>

<h3>写博客分享技术</h3>

<p>在csdn上看到有人问：不写博客的程序员是好程序员吗？这个问题问的其实挺好。不写博客的人也有进BAT的，BAT里面的程序员并不一定都写博客；写博客的人大部分都没有进BAT，比如像我这样的屌丝。</p>

<p>但是这并不能说明什么。且看，写博客的好处在哪里？</p>

<p><strong>写博客你可以交到一群志同道合的朋友</strong>。即使你们现实中从来没见过面，但是你们在互联网上有过思想的碰撞，这就已经足够了。</p>

<p><strong>书写就是很好的思考</strong>。当你想熟练掌握一项技能，请将你的技术分享出来吧。</p>

<p><strong>写的过程中也是学习</strong>。当你能把一项技术讲清楚，说明你已经完全理解了。</p>

<p><strong>你的博客将比简历更有价值</strong>。你在各大招聘网站写简历不如你有一个有价值的博客。</p>

<p>把技术分享出来，不仅帮助新人，更是提高自己，这是一种双赢。如果你写了技术文章没有好的地方可以发布，可以投稿给我：<a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x77;&#x6f;&#x72;&#x6c;&#x64;&#108;&#105;&#x67;&#x61;&#x6e;&#x67;&#x40;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109;">&#x77;&#x6f;&#114;&#x6c;&#x64;&#108;&#x69;&#x67;&#x61;&#110;&#x67;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d;</a> 我将发布在我的公众号iOS开发（<strong>iOSDevTip</strong>）上，直接分享给上万名iOS开发者。</p>

<h3>看github开源项目</h3>

<p>github对于程序员来说，可谓是一个金库。很多优秀的人才，都在上面开源自己的项目。这些人都是伟大的。</p>

<p>当你想实现一个功能，很有可能有一些大牛已经实现了。与其我们写出蹩脚代码来实现，不如去阅读大牛们在github上的开源项目。去看大牛是怎么实现的？思路是什么？如果是你你会怎么写？经过这样的思考之后，比你自己去实现重要的多。</p>

<p>如果你自己就是大牛，那就另说了。你可以实现之后，把代码分享到github，帮助更多人。</p>

<h3>实现自己的想法</h3>

<p>一个不想当老板的程序员不是好程序员。谁不想成为马云呢，谁不想改变世界呢。所以，你要敢想，然后通过自己的技术去实现它。</p>

<p>有些人可能以为：在公司里上班，去想做个什么东西，就是对老板不忠。这是一个很严重的错误想法。</p>

<p>在大公司，都是支持内部创业的。如果你有好的想法，尽管去干吧。说不定第一个天使投资人就是你的老板。屌丝逆袭说不定从此开始。</p>

<p>行了，醒醒，有想法更要有行动。</p>

<p>按照我们老师的话说：成为一名优秀的iOS开发工程师任重而道远！这句话也送给你。</p>

<blockquote><p>作者李刚是刚刚在线（<a href="www.superqq.com">www.superqq.com</a>）站长，百度百家专栏作者
iOS工程师非著名自媒体，微信公众号iOS开发：iOSDevTip运营者</p></blockquote>

<p><img src="http://7xjrlb.com1.z0.glb.clouddn.com/ios.png" alt="2" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/">iOS 设计模式系列：Command – 命令模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-21T23:39:03+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>11:39 pm</span></time>
        
          | <a href="/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><p><strong>命令模式</strong>封装一个请求或行为作为一个对象。封装的请求比原的更加灵活，可以在对象之间传递，储存，动态修改，或放入一个队列。苹果的Target-Action调用机制已经实现了命令模式。</p>

<p>你可以查看跟多关于<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html">Target-Action</a>的苹果官方文档，
NSInvocation包含一个target对象，一个方法和一些参数。这个对象可以按需要动态修改。这是一个非常好的命令模式的列子。减少发送对象和接受对象之间的操作，直接写成一个请求或请求链。</p>

<h3>如何用命令模式</h3>

<p>调用之前，你需要设置取消动作的框架。所以你需要定义一个UIToolBar和NSMutableArray保存需要撤销的堆栈。</p>

<p>添加代码到ViewController.m 文件：</p>

<pre><code>    UIToolbar *toolbar;
// We will use this array as a stack to push and pop operation for the undo option
    NSMutableArray *undoStack;
</code></pre>

<p>创建一个toolbar将显示新的动作按钮，以及一个数组作为命令队列。</p>

<p>将下面的代码添加到viewDidLoad：</p>

<pre><code>  toolbar = [[UIToolbar alloc] init];
UIBarButtonItem *undoItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemUndo target:self action:@selector(undoAction)];
undoItem.enabled = NO;
UIBarButtonItem *space = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];
UIBarButtonItem *delete = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemTrash target:self action:@selector(deleteAlbum)];
[toolbar setItems:@[undoItem,space,delete]];
[self.view addSubview:toolbar];
undoStack = [[NSMutableArray alloc] init];
</code></pre>

<p>上面的代码创建了一个toolbar和两个按钮，它还创建一个空的撤消堆栈。这里的撤销按钮被禁用因为撤销栈为空。</p>

<p>将下面代码添加到ViewController.m：</p>

<pre><code>- (void)viewWillLayoutSubviews
{
    toolbar.frame = CGRectMake(0, self.view.frame.size.height-44, self.view.frame.size.width, 44);
    dataTable.frame = CGRectMake(0, 130, self.view.frame.size.width, self.view.frame.size.height - 200);
}
</code></pre>

<p>在ViewController.m增加三个方法：增加、删除、撤销。</p>

<p>增加一个新专辑代码如下：</p>

<pre><code>- (void)addAlbum:(Album*)album atIndex:(int)index
{
    [[LibraryAPI sharedInstance] addAlbum:album atIndex:index];
    currentAlbumIndex = index;
    [self reloadScroller];
}
</code></pre>

<p>在这里你添加相册，将其设置为当前专辑索引，并重新加载。</p>

<p>接下来就是删除方法：</p>

<pre><code>- (void)deleteAlbum
{
    // 1
    Album *deletedAlbum = allAlbums[currentAlbumIndex];

    // 2
    NSMethodSignature *sig = [self methodSignatureForSelector:@selector(addAlbum:atIndex:)];
    NSInvocation *undoAction = [NSInvocation invocationWithMethodSignature:sig];
    [undoAction setTarget:self];
    [undoAction setSelector:@selector(addAlbum:atIndex:)];
    [undoAction setArgument:&amp;deletedAlbum atIndex:2];
    [undoAction setArgument:&amp;currentAlbumIndex atIndex:3];
    [undoAction retainArguments];

    // 3
    [undoStack addObject:undoAction];

    // 4
    [[LibraryAPI sharedInstance] deleteAlbumAtIndex:currentAlbumIndex];
    [self reloadScroller];

    // 5
    [toolbar.items[0] setEnabled:YES];
}
</code></pre>

<p>这是一段新的令人激动的代码，讲解如下：</p>

<ol>
<li>得到要删除的专辑信息</li>
<li>Define an object of type NSMethodSignature to create the NSInvocation, which will be used to reverse the delete action if the user later decides to undo a deletion. The NSInvocation needs to know three things: The selector (what message to send), the target (who to send the message to) and the arguments of the message. In this example the message sent is delete’s opposite since when you undo a deletion, you need to add back the deleted album.</li>
<li>After the undoAction has been created you add it to the undoStack. This action will be added to the end of the array, just as in a normal stack.</li>
<li>Use LibraryAPI to delete the album from the data structure and reload the scroller.</li>
<li><p>Since there’s an action in the undo stack, you need to enable the undo button.</p>

<pre><code> 提示: With NSInvocation, you need to keep the following points in mind:

 The arguments must be passed by pointer.
 The arguments start at index 2; indices 0 and 1 are reserved for the target and the selector.
 If there’s a chance that the arguments will be deallocated, then you should call retainArguments.
</code></pre></li>
</ol>


<p>最后，添加撤销方法：</p>

<pre><code>- (void)undoAction
{
    if (undoStack.count &gt; 0)
    {
        NSInvocation *undoAction = [undoStack lastObject];
        [undoStack removeLastObject];
        [undoAction invoke];
    }

    if (undoStack.count == 0)
    {
        [toolbar.items[0] setEnabled:NO];
    }
}
</code></pre>

<p>这个撤销操作是取消栈里最后一个对象，This object is always of type NSInvocation and can be invoked by calling … invoke. This invokes the command you created earlier when the album was deleted, and adds the deleted album back to the album list. Since you also deleted the last object in the stack when you “popped” it, you now check to see if the stack is empty. If it is, that means there are no more actions to undo. So you disable the Undo button.</p>

<p>运行你的app，测试撤销功能，删除一个专辑（或两个）然后点击撤销按钮看看效果：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage4.png" alt="1" /></p>

<p>这也是一个很好的地方来测试是否你的相册数据保留会变化。现在，如果你删除一个专辑，app退到后台，并终止应用程序，在下次启动应用程序显示的专辑列表不会有删除专辑信息。</p>

<p>这里的源代码完成的项目：<a href="cdn2.raywenderlich.com/wp-content/uploads/2013/08/BlueLibrary-final.zip">最后bluelibrary</a></p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-20T06:54:13+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:54 am</span></time>
        
          | <a href="/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><p><strong>备忘录模式</strong>就是苹果中一种归档形式。它能够把对象转化成一种数据流，在不依赖于外部类的私有属性的情况下来存储和取出数据。你可以在 iOS 6 by Tutorials 这本书的第 16 章读到更多的相关信息。或者这里 Apple’s Archives and Serializations Programming Guide。</p>

<h3>如何使用归档 Archiving</h3>

<p>首先，你需要声明 Album，用 NSCoding 协议来归档数据。打开 Album.h 文件，修改 @ interface 行如下：</p>

<pre><code>@interface Album : NSObject &lt;NSCoding&gt;
</code></pre>

<p>在 Album.m 添加下面两个方法：</p>

<pre><code>- (void)encodeWithCode:(NSCode *)aCoder
{
    [aCode encodeObject:self.year forKey:@“year”];
    [aCode encodeObject:self.title forKey:@“album”];
    [aCode encodeObject:self.artist forKey:@“artist”];
    [aCode encodeObject:self.coverUrl forKey:@“cover_url”];     [aCode encodeObject:self.genre forKey:@“genre”];
}

- (id)initWithCode:(NSCode *)aDecoder
{
    self = [super init];
    if (self) {
        _year = [aDecoder decodeObjectForKey:@“year”];
        _title = [aDecoder decodeObjectForKey:@“album”];
        _artist = [aDecoder decodeObjectForKey:@“artist”];
        _coverUrl = [aDecoder decodeObjectForKey:@“cover_url”];
        _genre = [aDecoder decodeObjectForKey:@“genre”];
    }
    return self;
}
</code></pre>

<p>当你存档这个类的实例时调用 encodeWithCoder:。相反，当你通过解档来创建一个 Album 实例时，需要调用 iniWithCode: 。就这么简单，非常强大。</p>

<p>现在 Album 类可以存档了，添加的代码实际上是存储和加载专辑列表的。</p>

<p>在 PersistencyManger.h 里添加下面方法：</p>

<pre><code>- (void)saveAlbums;
</code></pre>

<p>当存储专辑的时候调用些方法。</p>

<p>现在，在 PersistencyManger.m 里添加方法实现：</p>

<pre><code>- (void)saveAlbums
{
    NSString *filename = [NSHomeDirectory() stringByAppendingString:@“/Document/albums.bin”];
    NSData *data = [NSKeyedArchiver archivedDataWithRootObject:albums];
    [data writeToFile:filename atomically:YES];
}
</code></pre>

<p>NSKeyedArchiver 把专辑数组存档进一个叫 album.bin 的文件里。</p>

<p>当你存档的一个对象包含另一个对象的时候，存档自动递归的把子对象、子对象的子对象一并存储。在这个实例里，存储的是一个专辑实例的数组。因为数组和 Album 都支持 NSCopying 的接口，数组里的东西都会被自动存档。</p>

<p>现在用下面代码替换 PersistencyManger.m 里的 init 方法：</p>

<pre><code>- (id)init
{
    self = [super init];
    if (self) {
        NSData *data = [NSData dataWithContentsOfFile:[NSHomeDirectory() stringByAppendString:@“/Document/albums.bin”]];
        albums = [NSKeyedUnarchiver unarchiveObjectWithData:data];
        if (albums == nil) {
            albums = [NSMutableArray arrayWithArray:
                 @[[[Album alloc] initWithTitle:@"Best of Bowie" artist:@"David Bowie" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png" year:@"1992"],
                 [[Album alloc] initWithTitle:@"It's My Life" artist:@"No Doubt" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png" year:@"2003"],
                 [[Album alloc] initWithTitle:@"Nothing Like The Sun" artist:@"Sting" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png" year:@"1999"],
                 [[Album alloc] initWithTitle:@"Staring at the Sun" artist:@"U2" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png" year:@"2000"],
                 [[Album alloc] initWithTitle:@"American Pie" artist:@"Madonna" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png" year:@"2000"]]];
                [self saveAlbums];
        }
    }
    return self;
}
</code></pre>

<p>在新代码里，如果文件存在，NSKeyedUnarchiver 就从文件加载专辑数据。如果不存在，它就创建专辑数据，然后立即存储，为下一次启动 app 使用。</p>

<p>当然你也可以在 app 后台运行的时候再存储专辑数据。现在它看起来不是很有必要，但如果你在稍后添加修改专辑数据呢？你需要确保所有的数据修改都会被存储。</p>

<p>在 LibraryAPI.h 添加下面的方法</p>

<pre><code>- (void)saveAlbums;
</code></pre>

<p>因为程序的所以有服务都需要通过 LibraryAPI 提供，这就是程序为什么需要 PersistenrcyManger 来存储专辑数据。</p>

<p>现在在 LibraryAPI.m 中添加实现方法：</p>

<pre><code>- (void)saveAlbums
{
    [persistencyManger saveAlbums];
}
</code></pre>

<p>这里是从 LibraryAPI 调用 PersistencyManger 来存储专辑。</p>

<p>在 ViewController.m 文件 saveCurrentState 的后面添加下面代码：</p>

<p>[[LibraryAPI sharedInstance] saveAlbums];</p>

<p>上面的代码是每当 ViewController 存储当前状态时，使用 LibraryAPI 来存储专辑数据。</p>

<p>构建你的 app，检查所有的都能正确编译。</p>

<p>不幸的是，没有一种简单的方法来验证数据是否被正确的创建。你可以在 Finder 里检查模拟器下当前 app 的 Documents 文件夹，来看看专辑数据文件是否被创建，但是为了查看其它变化你还需要添加一些数据来改变专辑数据。</p>

<p>但是，为了修改数据，假使为了删除专辑而需要临时添加一个删除选项，但这个选项并不会一直在你的库中存在？此外，由于误操作，错误的删除了一个专辑，但如果给这个操作添加一个撤消选项不是很好吗？</p>

<p>现在是时候讨论最后一个设计模式了：<a href="http://www.superqq.com/blog/2015/06/21/ios-she-ji-mo-shi-xi-lie-:command-ming-ling-mo-shi/">命令 Command</a>。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-19T06:31:19+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:31 am</span></time>
        
          | <a href="/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><p><strong>备忘录模式</strong>是捕获和具体化当前对象的内部状态。换句话说，就是在某个地方存储个东西。稍后，在不违反封装的情况下能够恢复这个具体化的状态；就是说，一些私有数据被私下存储下来了。</p>

<h3>如何使用备忘录模式</h3>

<p>添加下面两个方法到 ViewController.m 文件：</p>

<pre><code>- (void)saveCurrentState
{
    // 当用户退出应用之后再重新打开，他想要跟他之前退出时一样的状态
    // 退出应用，这个时候我们需要做的是把当前显示的专辑存储下来
    // 因为只有一小片信息，我们可用 NSUserDefaults 来存储信息
    [[NSUserDefaults standardUserDefaults] setInteger:currentAlbumIndex forKey:@“currentAlbumIndex”];
}

- (void)loadPreviousState
{
    currentAlbumIndex = [[NSUserDefaults standardUserDefaults] integerForKey@“currentAlbumIndex”];
    [self showDataForAlbumAtIndex:currentAlbumIndex];
}
</code></pre>

<p>saveCurrentState 存储当前专辑的索引到 NSUserDefaults ─ NSUserDefaults 是一个标准数据存储，iOS 用来专门存放程序设置和数据。</p>

<p>loadPreviousState 加载这之前存储的专辑索引。这不是备忘录模式的全部，不过你已经达到目的了。</p>

<p>现在，在 ViewController.m 里，滚动视图初始化之前，在 viewDidLoad 里添加下面一行：</p>

<pre><code>[self loadPreviousState];
</code></pre>

<p>当程序启动的时候加载上一次存储的状态。但是你在哪里存储程序的当前状态呢？你需要使用通知来做这样的事情。当程序进入后台时，iOS 会发送一个 UIApplicationDidEnterBackgroundNotification 通知。你可利用这个通知调用 saveCurrentState。就这么方便？</p>

<p>在 viewDidLoad: 最后面添加下面一行</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(saveCurrentState) name:UIApplicationDidEnterBackgroundNotification object:nil];
</code></pre>

<p>现在，当你的 app 进入后台运行后，ViewController 会自动调用 saveCurrentState 存储当前的状态。</p>

<p>现在，添加下面代码：</p>

<pre><code>- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}
</code></pre>

<p>这里是确保当 ViewController 被释放时，移除类的 <a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">Observer</a>。</p>

<p>构建和运行你的 app，点击到一个专辑，用 Command+Shift+H（如果你使用的是模拟器的话） 将程序在后台运行，然后关掉 app。重启 app，检查之前选择的专辑是不是居中显示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/2013-09-02_10-51-27-214x320.png" alt="1" /></p>

<p>专辑数据看起来是对的，但是正确的专辑封面确没有居中，哪出问题了？</p>

<p>这就是可选方法 initialViewIndexForHorizontalScroller 的用处！因为这个方法没有被委托执行，ViewController 在这种情况下总是会显示默认的第一个专辑封面。</p>

<p>修复这个问题，在 ViewController.m 中添加如下代码：</p>

<pre><code>- (NSInteger)initialViewIndexForHorizontalScroller:(HorizontalScroller *)scroller
{
    return currentAlbumIndex;
}
</code></pre>

<p>现在 HorizontalScroller 的第一个视图总是会被设置成 currentAlbumIndex 索引的图片。这种方法能够确保你的 app 有一个非常棒的用户体验，并且它是可恢复的。</p>

<p>重新运行你的 app，滚动专辑封面，关闭 app，然后重启确保问题已经得到解决：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/2013-09-02_10-56-59-214x320.png" alt="2" /></p>

<p>如果你查看 PersistencyManger 的初始化方法，你会注意到专辑的数据是一种硬编码，PersistencyManger 每次创建，数据也会重复创建一次。有没有一种更好的方法当专辑列表被创建的时候就存储它们呢。那么如何把专辑数据存储到文件里呢？</p>

<p>一种选择就是循环访问 Album 的属性，然后把它存储在一个 plist 文件里，当需要它们的时候重新创建一个 Album 的实例。这不是最好的选择，这需要你在每一个类里根据不同的数据或属性写特定的代码。例子，如果稍后你需要一个电影的类，里面有一些不同的属性，存储和加载这些数据你就需要写一些新的代码。</p>

<p>此外，你不能在每一个类的实例里存储私有变量，因为他们是不可访问的外部类。这就是为什么苹果要创建归档 (Archiving) 机制。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-18T10:14:51+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:14 am</span></time>
        
          | <a href="/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><p>在<strong>观察者模式</strong>中，当状态发生改变的时候，一个对象会通知另一个对象。这个对象不需要知道另一个对象发生了什么改变─因此非常鼓励这种分离式的设计。这种模式经常用于，当一个属性发生改变时通知跟它相关的对象。</p>

<p>它通常需要一个观察者(observer)注册跟踪另外一个对象的状态。当状态发生改变的时候，所有的观察对象都会被通知改变。苹果的推送通知服务就是一个这样的例子。</p>

<p>如果你想要一直使用 <a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">MVC 模式</a>（你确实需要），你如果想在模型和视图之间，不直接相互引用的情况下还要有通信。这时候就要用到观察者模式了。</p>

<p>Cocoa 有两个常用的方法来执行观察者模式：Notifications 和 Key-Value Observing (KVO)。</p>

<h3>通知 Notifications</h3>

<p>不要把它和推送、本地通知弄混淆了，通知是基于一个对象（信息发布者）发信息给另一个对象（订阅/监听）的订阅-发布模式的。信息发布者不需要知道任何关于订阅者的信息。</p>

<p>苹果大量的使用了通知。例子，当键盘打开/关闭的时候，系统会分别发送一个 UIKeyboardWillShowNotification/UIKeyboardWillHideNotification。当你的程序要退出的时候，系统会发送一个 UIApplicationDidEnterBackgroundNotification 通知。</p>

<pre><code>提示：打开 UIApplication.h，在文件最后你会看见系统能发送的通知列表有 20 个之多。
</code></pre>

<h3>如何使用通知 Notifications</h3>

<p>打开 AlbumView.m 文件，在 initWithFrame:albumCover: 里面的 [self addSubview:indicator] 后面插入下面代码：</p>

<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:@“BLDownloadImageNotification” object:self userInfo:@{@“imageView”:coverImage, @“coverUrl”:albumCover}];
</code></pre>

<p>这行代码是通过 NSNotificationCenter 单例来发送一个通知。通知内容包括 coverImage 图片视图 和下载封面图片的 URL。这是执行下载专辑封面所需的所有信息。</p>

<p>在 LibraryAPI.m 的 init 方法里，isOnline = NO; 后面添加下面代码：</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downImage:) name:@“BLDownloadImageNotification” object:nil];
</code></pre>

<p>这是等式另一边的观察者对象。任何时候只要 AlbumView 类发送一个 BLDownloadImageNotification 通知，系统就会通知 LibraryAPI，因为 LibraryAPI 已经注册了一个相同的观察者通知。qLibraryAPI 执行 downloadImage:。</p>

<p>不管任何时候，在你执行 downloadImage: 之前，一定要记住在你释放这个类的时候一定要取消这个通知的订阅。如果你不正确的取消一个通知的订阅，这个通知可能发送一个已经释放的实例。这会造成你的程序崩溃。</p>

<p>在 LibraryAPI.m 里添加下面代码：</p>

<pre><code>- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removerObserver:self];
}
</code></pre>

<p>当这个类释放后，移除一个观察者自己已经注册的所有通知。</p>

<p>这里还有一件事情要做。它可以把下载过的封面图片存在本地，这样 app 就不用一次又一次的下载同一个图片了。</p>

<p>打开 PersistencyManger.h 添加下面两个方法：</p>

<pre><code>- (void)saveImage:(UIImage*)image filename:(NSString*)filename;
- (UIImage*)getImage:(NSString*)filename;
</code></pre>

<p>在 PersistencyManger.m 中实现：</p>

<pre><code>- (void)saveImage:(UIImage*)image filename:(NSString*)filename
{
    filename = [NSHomeDirectory() stringByAppendingFormat:@“/Documents/%@”, filename];
    NSData *data = UIImagePNGRepresentation(image);
    [data writeToFile:filename atomically:YES];
}

- (UIImage*)getImage:(NSString*)filename 
{
    filename = [NSHomeDirectory() stringByAppendingFormat:@“/Documents/%@“, filename];
    NSData *data = [NSData dataWithContentsOfFile:filename];
    return [UIImage imageWithData:data];
}
</code></pre>

<p>这里的代码很简单。下载完成的图片会被存储进 Documents 文件夹中，如果没有跟 filename 相匹配的文件，getImage: 会返回 nil。</p>

<p>现在在 LibraryAPI.m 里面添加下面方法：</p>

<pre><code>- (void)downImage:(NSNotification*)notification
{
    // 1 
    UIImageView *imageView = notification.userInfo[@“imageView”];
    NSString *coverUrl   = notification.userInfo[@“coverUrl”];

    // 2
    imageView.image = [persistencyManger getImage:[coverUrl lastPathComponent];

    if (imageView.image == nil) {
        // 3 
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            UIImage *image = [httpClient downloadImage:coverUrl];
            dispatch_sync(dispatch_get_main_queue(), ^{
                imageView.image = image;
                [persistencyManger saveImage:image filename:[coverUrl lastPathComponent];
            });
        });
    }
}
</code></pre>

<p>现在来分析上面的代码：</p>

<ol>
<li>通知执行 downloadImage 方法，方法接受这个这个通知对象，就像它是一个变量一样。通知里会传递 UIImageView 和图片的 URL。</li>
<li>如果以前已经下载过，就从 PersistencyManger 里取出图片。</li>
<li>如果图片没有下载过，使用 HTTPClient 开始下载图片。</li>
<li>当下载完成的时候，在图片视图中显示图片，用 PersistencyManger 存储它到本地。</li>
</ol>


<p>此外，你用外观模式(Facade pattern)隐藏了另外一个下载图片的复杂类。通知发送者不关心图片的来源，不管是从网上下载的还是本地存储的。</p>

<p>构建和运行你的 app，可以看到漂亮的封面已经出现在 HorizontalScroller 里面了：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-4-297x320.png" alt="1" /></p>

<p>停止你的 app，然后再运行它。注意这里显示封面已经没有延时了，因为它们已经下载到本地了。你可断开网络试试，你的 app 同样可以完美的运行。虽然已经很完美了，但是仍然有一个小问题：就是下载提示的小菊花仍然一直在转动，从来没有停止过！哪里出问题了？</p>

<p>当你开始下载图片的时候，你运行了下载提示符，但当图片下载完成的时候，你没有停止下载提示符的方法。你也可以当每个图片下载完成的时候再发送一个通知，当然另一个代替方案，你可以使用另一种观察者模式，KVO。</p>

<h3>键 – 值 观察 (Key-Value Observing KVO)</h3>

<p>在 <a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">KVO</a>  里，一个对象的任何一个特别的属性改变后都可以请求一个通知；不管是它自己的还是其它的对象。如果你感兴趣，你可以在这里读到更多的信息：Apple’s KVO Programming Guide.</p>

<h3>如何使用 KVO 模式</h3>

<p>如上所述，<a href="http://www.superqq.com/blog/2015/06/05/ios-kvogai-shu-yu-shi-jian/">KVO</a> 的原理是允许一个对象观察一个属性的改变。你所要关心的是，使用 KVO 观察 UIImageView 的 image 属性是否已经改变，就是它是否已经存储了图片。</p>

<p>打开 AlbumView.m，在 initWithFrame:albumCover: 里的 [self addSubview:indicator]; 后面添加下面代码：</p>

<pre><code>[coverImage addObserver:self forKeyPath:@“image” options:0 context:nil];
</code></pre>

<p>不添加在自己上面(self)，在当前的类里，观察 coverImage 的 image 属性。</p>

<p>当你使用过后，你同样需要注销这个观察(observer)。继续在当前文件里面添加下面代码：</p>

<pre><code>- (void)dealloc
{
    [coverImage removerObserver:self forKeyPath:@“image”];
}
</code></pre>

<p>最后，添加下面方法：</p>

<pre><code>- (void)observerValueForKeyPath:(NSString*)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    if ([KeyPath isEqualToString:@“image”])
    {
        [indicator stopAnimating];
    }
}
</code></pre>

<p>你必须在每个类里执行这个方法。如果观察的属性改变了，系统每次都会执行这个方法。上面的代码里，当 image 的属性发生改变时，你停止下载提示符的运行。这种方法，当图片下载完成，下载提示转动的小菊花将会停止转动。</p>

<p>构建个运行你的项目。你会看到小菊花已经不在了：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/08/design-pattern-stage3-287x320.png" alt="2" /></p>

<pre><code>提示：永远记住，当你释放内存，你一定要移除这些观察(observers)，或者是当你的程序发送这些不存的观察对象时会造成程序崩溃。
</code></pre>

<p>如果你玩弄一会你的 app，然后关闭它，你程序的当前状态并没有被存储下来。当程序启动的时候你看到的视图并不是上次退出时的样子。</p>

<p>为了更正这些，你需要使用下一项设计模式：备忘录 (Memento)。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/17/shang-hai-ioskai-fa-gong-zi-dai-yu-ru-he-%3F/">上海iOS开发工资待遇如何？</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-17T23:25:30+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:25 pm</span></time>
        
          | <a href="/blog/2015/06/17/shang-hai-ioskai-fa-gong-zi-dai-yu-ru-he-%3F/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><p><strong>上海iOS开发</strong>工资待遇如何呢？一般来说，上海iOS开发的工资还算相对不错的，毕竟是一线城市的魔都，整体来说还算可以。</p>

<p>上海<a href="http://www.superqq.com/blog/2014/12/27/ioskai-fa-zhong-de-gcdduo-xian-cheng-tips/">iOS开发</a>起步薪资大概在5k~8k吧，如果你技术好，在大学里面就是学霸，对计算机也非常精通，超过8k，也不是完全没有可能的。5k~8k只是一个参考值，主要还是靠自己。</p>

<p>对于工作一两年的上海iOS开发者朋友们来说，工资应该在8k~15k。也就是说，上海iOS开发者有一两年工作经验，工资很轻松过五位数。</p>

<p>做一位一名程序员，工作过五位数很正常，尤其是上海iOS开发程序员。</p>

<p>当你在上海做iOS开发三四年以上，而且你的技术确实有牛C，这个时候，工资完全可以突破2万。2万对于程序员来说是一个重要的标志，上海iOS开发程序员也不例外。2万说明你应该是一名很不错的程序员了。</p>

<p>以上是上海iOS开发工资的一个参考，具体可以根据实际<a href="http://www.superqq.com/blog/2015/06/04/mian-shi-guan-wen-xian-zai-gong-zi-shi-duo-shao-gai-zen-yao-hui-da/">面试</a>情况来谈你的工资。</p>

<p>上海iOS开发需求量也很大，所以对于想进入iOS开发行业的人来说，上海iOS开发职位是一个很不错的选择。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-17T14:24:04+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:24 pm</span></time>
        
          | <a href="/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/#comments">Comments</a>
         
        
      </p>
    
  </header>


<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul  class="ds-top-threads" data-range="weekly" data-num-items="5"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
  <div class="entry-content"><p>注：本节有点长，并且有些难度，希望大家有毅力看下去。</p>

<p>一个适配器允许接口不兼容的类在一起工作。它把它自己包裹成一个对象，公开一个与这个对象相互作用的标准接口。</p>

<p>如果你熟习<strong>适配器模式</strong>，你会注意到苹果实施它的时候有一点不同的习惯─苹果使用协议 (protocols)。你可能熟习像 UITableViewDelegate, UIScrollViewDelegate, NSCoding 和 NSCopying 这样的协议。例子，NSCopying 的协议 (protocol)，任何类都可以提供这样一个标准的复制方法。</p>

<h3>如何使用适配器模式</h3>

<p>我们提到的滚动区域是这样的：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/protocol1.png" alt="1" /></p>

<p>现在开始，在项目导航的 View 文件夹上右击鼠标，选择 New File…，用 iOS\Cocoa Touch\Object-C class 模板创建一个新类。新类的名字叫 HorizontalScroller，选择它的子类为 UIView。</p>

<p>打开 HorizontalScroller.h 文件在 @end 后面插入如下代码：</p>

<pre><code>@protocol HorizontalScrollerDelegate &lt;NSObject&gt;
// methods declaration goes in here
@end
</code></pre>

<p>这里定义一个 HorizontalScrollerDelegate 名字的协议，它继承于 NSObject 协议，同样的这是继承它父类的一个 Objective-C 类。符合 NSObject 协议，这是一个很好的做法─或者遵照 NSObject 协议。这能使你从定义的 NSObject 发送消息到 HorizontalScroller 的代理。你将会看到为什么这很重要。</p>

<p>定义个代理执行的方法，要在 @protocol 和 @end 之间，它们分为必要方法和可选方法。添加下面协议方法：</p>

<pre><code>@required
// 询问 delegate 在滚动区域里有多少个视图要被显示
- (NSInteger)numberOfViewsForHorizontalScroller:    (HorizontalScroller*)scroller;

// 返回索引是 index 的视图
- (UIView*)horizontalScroller:(HorizontalScroller*)scroller viewAtIndex:(int)index;

// 当索引是 index 的视图被点击了，通知 delegate 
- (void)horizontalScroller:(HorizontalScroller*)scroller clickedViewAtIndex:(int)index;

@optional
// 通知 delegate，显示初始化时索引是 Index 的视图。这个方法是可选的
// ask the delegate for the index of the initial view to display. this method is optional
// 如果没有被 delegate 执行，默认值是 0
- (NSInteger)initialViewIndexForHorizontalScroller:(HorizontalScroller*)scroller;
</code></pre>

<p>这里我们必选的和可选的方法我们都定义了。必选方法一定要被代理执行，它通常包含一些类必须要执行的数据。这里，必选方法是获取视图的数量，当前显示视图的索引和当视图被点击的时候执行的操作。可选方法这里是初始化视图；如果没有执行 HorizontalScroller 将会显示第一个索引的视图。</p>

<p>接下来，你需要在 HorizontalScroller 内部定义你的新代理。但是协议的定义在类的定义下面，因此在这点上它是不可见的。你该怎么办？</p>

<p>解决办法就是在前面声明协议以便于编译器（和Xcode）知道这个协议是可用的。好了，在 @interface 上面加入下面代码：</p>

<pre><code>@protocol HorizontalScrollerDelegate;
</code></pre>

<p>还是 HorizontalScroller.h，在 @interface 和 @end 之间加入下面代码：</p>

<pre><code>@property (weak) id&lt;HorizontalScrollerDelegate&gt; delegate;
- (void)reload;
</code></pre>

<p>这个属性被定义成为一个 weak。这是为了防止循环 retain。如果一个类保持一个强指针(strong pointer)指向它的委托(delegate)，同时委托也保持一个强指针指向这个类，在释放类所占用的内存时会造成 app 内存泄漏。</p>

<p>id 的意思是把这个代理指定给一个类，它遵照 HorizontalScrollerDelegate，给你一些类型安全。</p>

<p>reload 方法是模仿 UITableView 类的 relaodData；它重新加载所有数据用来创建一个水平移动视图。</p>

<p>用下面代码替换 HorizontalScroller.m 的内容：</p>

<pre><code>#import “HorizontalScroller.m”

#define VIEW_PADDING 10
#define VIEW_DIMENSIONS 100
#define VIEW_OFFSET 100

@interface HorizontalScroller () &lt;UIScrollViewDelegate&gt;
@end

@implementation HorizontalScroller
{
    UIScrollView *scroller;
}
@end
</code></pre>

<p>来解释下每块代码：</p>

<ol>
<li>常量定义，在设计时间可以方便修改布局。在滚动视图内，每个图片的大小在一个 100×100 内边距为 10 点(point) 的矩形内。</li>
<li>HorizontalScroller 遵照 UIScrollViewDelegate 协议。因为 HorizontalScroller 使用一个 UIScrollView 来滚动专辑封面，它需要知道用户什么时候停止滚动。</li>
<li>创建一个包含图片的滚动视图。</li>
</ol>


<p>接下来你需要执行初始化。添加下面的方法：</p>

<pre><code>- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        scroller = [[UIScrollerView alloc] initWithFrame:CGRectMake(0, 0, frame.size.width, frame.size.height)];
        scroller.delegate = self;
        UITapGestureRecognizer *tapRecognizer = [[UITapGestureRecognizer alloc] initWithTarger:self action:@select(scrollerTapped:)];
        [scroller addGestureRecognizer:tapRecognizer];
    }
    return self;
}
</code></pre>

<p>HorizontalScroller 将被滚动视图整个填充。如果一个专辑封面被点击，UITapGestureRecognizer 将会监听它上面的事件。如果有，它会通知 HorizontalScroller 的代理。</p>

<p>现在添加下面方法：</p>

<pre><code>- (void)scrollerTapped:(UITapGestureRecognizer*)gesture
{
    CGPoint location = [gesture locationInView:gesture.view];
    // we can’t use an enumerator here, because we don’t want to enumerate over ALL of the UIScrollView subviews.
    // we want to enumerate only the subview that we added
    for (int index=0; index&lt;[self.delegate numberOfViewForHorizontalScroller:self]; index++) {
        UIView *view = scroller.subviews[index];
        if (CGRectContainsPoint(view.frame, location)) {
            [self.delegate horizontalScroller:self clickedViewAtIndex:index];
            [scroller setContentOffset:CGPointMake(view.frame.origin.x - self.frame.size.width/2 + view.frame.size.width/2, 0) animated:YES];
            break;
        }
    }
}
</code></pre>

<p>手势操作就如同传入的一个参数，可以从 locationInView: 获取定位信息。</p>

<p>接下来，调用委托的 numberOfViewForHorizontalScroller: 方法。它必须遵照 HorizontalScrollerDelegate 的协议安全发送消息，否则 HorizontalScroller 实例的代理是没法使用这些信息。</p>

<p>滚动视图里的每个视图，用 CGRectContainsPoint 执行一个点击测试，找到那个被点击的视图。当视图被找到，发送给委托一个消息 horizontalScroller:clickedViewAtIndex:。当你跳出这个循环后，设置被点击的视图滚动到视图中间。</p>

<p>现在添加下面的代码，用来刷新滚动视图(scroller):</p>

<pre><code>- (void)reload
{
    // 1 - nothing to load if there’s no delegate
    if (self.delegate == nil) return;

    // 2 - remover all subviews
    [scroller.subviews enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        [obj removeFromSuperview];
    }

    // 3 - xValue is the starting point of the views inside the scroller
    CGFloat xValue = VIEWS_OFFSET;
    for (int i=0; i&lt;[self.delegate numberOfViewsForHorizontalScroller:self]; i++) {
        // 4 - add a view at the right position
        xValue += VIEW_PADDING;
        UIView *view = [self.delegate horizontalScroller:self viewAtIndex:i]
        view.frame = CGRectMake(xValue, VIEW_PADDING, VIEW_DIMENSIONS, VIEW_DIMENSIONS);
        xValue += VIEW_DIMENSIONS + VIEW_PADDING;
    }

    // 5
    [scroller setContentSize:CGSizeMake(xValue+VIEWS_OFFSET, self.frame.size.height)];

    // 6 - if an initial view is defined, center the scroller on it
    if (self.delegate respondsToSelector:@select(initialViewIndexForHorizontalScroller:)]) {
        int initialView = [self.delegate initialViewIndexForHorizontalScroller:self];
        [scroller setContentOffset:CGPointMake(initialView*(VIEW_DIMENSIONS+(2*VIEW_PADDING)), 0) animated:YES];
    }
}
</code></pre>

<p>能过代码一步步来讨论：</p>

<ol>
<li>如果没有代理，这里什么事情也不做。</li>
<li>移除之前添加的所有的子视图。</li>
<li>给所有视图设置一个偏移(offset)位置。现在的是 100，但是通过顶部的 #define，它很容易修改。</li>
<li>HorizontalScroller 通过它的委托一次请求一个视图，用之前定义的 padding 值把它们依次的一个个放置下来。</li>
<li>当所有的视图都生成好，通过设置滚动视图内容的偏移量以达到用户能过滚动可以看到所有专辑封面的目的。</li>
<li>HorizontalScroller 的委托需要验证是否响应了 initialViewIndexForHorizontalScroller: 方法。这个验证是必需的，因为这个特别的协议方法是可选性的。如果代理没有执行这个方法，它的默认值会是 0。最终，通过委托，这块代码会在滚动视图中间设置一个初始化好的视图。</li>
</ol>


<p>当数据发生改变的时候执行 reload 方法。当添加 HorizontalScroller 到别个一个视图时，你同样可以执行这个方法。在 HorizontalScroller.m 添加下面的代码替换后面的方案：</p>

<pre><code>- (void)didMoveToSuperview
{
    [self reload];
} 
</code></pre>

<p>当它要添加一个子视图的时候，didMoveToSuperview 会发送消息给视图。这时正好可以更新滚动视图的内容。</p>

<p>HorizontalScroller 的最后一个难题就是，如何设置你看到的专辑总是在滚动视图的中间。为了这些，当用户通过他们的手指拖动滚动视图的时候你就需要做一些计算了。</p>

<p>添加下面方法（同样在 HorizontalScroller.m）：</p>

<pre><code>- (void)centerCurrentView {
    int xFinal = scroller.contentOffset.x + (VIEWS_OFFSET/2) + VIEW_PADDING;
    int viewIndex = xFinal / (VIEW_DIMENSIONS + (2*VIEW_PADDING));
    xFinal = viewIndex * (VIEW_DIMENSIONS+(2*VIEW_PADDING));
    [scroller setContentOffset:CGPointMake(xFinal, 0) animated:YES];
    [self.delegate horizontalScroller:self clickedViewAtIndex:viewIndex];
}
</code></pre>

<p>上面的代码通过滚动视图的当前偏移量，外观尺寸，内边距来计算当前视图离中心的距离。最后一行非常重要：当一个视图居中后，你需要通知委托你选择的视图改变了。</p>

<p>为了侦测用户在滚动视图内完成拖拽的动作，你需要添加 UIScrollViewDelegate 方法：</p>

<pre><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate
{
    if (!decelerate)
    {
        [self centerCurrentView];
    }
}

- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView
{
    [self centerCurrentView];
}
</code></pre>

<p>当用户完成拖拽的时候 scrollViewDidEndDragging:willDecelerate: 通知委托。如果滚动视图没有停止滚动， decelerate 参数会返回 true。当滚动结束，系统将会调用 scrollViewDidEndDecelerating。当用户拖动滚动当前视图后，两种情况，我们都需要调用一个新方法来使当前视图居中。</p>

<p>HorizontalScroller 现在可以使用了。浏览你刚刚写的代码；这里没有一处提到 Album 和 AlbumView 类。这非常棒，说明这个新的滚动视图是真正的完全独立的和可重用的。</p>

<p>Build 项目，确保所有的代码编译正确。</p>

<p>现在 HorizontalScroller 完成了，是时候在你的 APP 中使用了。打开 ViewController.m 添加如下引用：</p>

<pre><code>#import “HorizontalScroller.h”
#import “AlbumView.h”
</code></pre>

<p>给 ViewController 添加 HorizontalScrollerDelegate：</p>

<p>@interf<!---->ace ViewController () &lt;UITableViewDataSource, UITableViewDelegate, HorizontalScroller></p>

<p>在类的扩展里为水平滚动视图添加如下实例变量：</p>

<p>Horizonta<!---->lScroller *scroller;</p>

<p>现在你可以执行代理方法了；你会惊奇的发现只需要几行代码你就能实现很多功能。</p>

<p>在 ViewController.m 添加如下代码：</p>

<pre><code>#pragma mark - HorizontalScrollerDelegate methods
- (void)horizontalScroller:(HorizontalScroller *)scroller clickedViewAtIndex:(int)index
{
    currentAlbumIndex = index;
    [self showDataForAlbumAtIndex:index];
}
</code></pre>

<p>这里设置一个变量用来存储当前的专辑，然后调用 showDataForAlbumAtIndex: 显示一个新专辑的数据。</p>

<p>提示：一般在方法代码的前面放置 #pragma mark 指示符。编译器会忽略这一行，当你在使用 Xcode 的跳转工具栏(Xcode’s jump bar)查看你的方法列表时，你会看到一个分隔符和个加粗的指示标题。在 Xcode 里，这可以帮助你很容易的组织代码。</p>

<p>下面，添加如下代码：</p>

<pre><code>- (NSInteger)numberOfViewsForHorizontalScroller:(HorizontalScroller *)scroller
{
    return allAlbums.count;
}
</code></pre>

<p>这里，协议方法返回滚动视图里的视图数量。因为滚动视图需要显示所有的专辑封面，这个 count 是所有专辑的数目。</p>

<p>现在，添加这些代码：</p>

<pre><code>- (UIView *)horizontalScroller:(HorizontalScroller *)scroller viewAtIndex:(ini)index
{
    Album *album = allAlbums[index];
    return [[Album alloc] initWithFrame:CGRectMake(0, 0, 100, 100) albumCover:album.coverUrl];
}
</code></pre>

<p>这里你创建了一个新 AlbumView，然后交给 HorizontalScroller 使用。</p>

<p>就是这样，通过三个这么短的方法就可以显示一个漂亮的滚动视图。</p>

<p>实际上，你仍需要创建一个真正的滚动视图，然后添加到你的主视图上，但是在这之前，先添加下面的方法：</p>

<pre><code>- (void)reloadScroller
{
    allAlbums = [[LibraryAPI sharedInstance] getAlbums];
    if (currentAlbumIndex &lt; 0) currentAlbumIndex = 0;
    else if (currentAlbumIndex &gt;=allAlbum.count) currentAlbumIndex = allAlbum.count - 1;
    [scroller reload];

    [self showDataFroAlbumAtIndex:currentAlbumIndex;
}
</code></pre>

<p>这个方法从 LibraryAPI 加载专辑数据，然后以当前视图的索引值为基础设置显示当前的图片。 如果当前视图的索引小于零，意味着当前没有选择视图，显示列表里的第一张专辑。否则显示最后一张专辑。</p>

<p>现在，在 viewDidLoad 里 [self showDataForAlbumIndex:0] 前面添加下面代码来初始化滚动视图：</p>

<pre><code>scroller  = [[HorizontalScroller alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 120)];
scroller.backgroundColor = [UIColor colorWithRed:0.24f greed:0.35f blue:0.49f alpha:1];
scroller.delegate = self;
[self.view addSubview:scroller];

[self reloadScroller];
</code></pre>

<p>上面的代码创建了一个 HorizontalScroller 的实例，设置了它的背景颜色和委托，添加滚动视图到主视图上，在滚动视图的子视图上加载专辑数据。</p>

<pre><code>提示：如果一个协议变得很大，里面有很多方法，你应该考虑把它们分散到几个小的协议里去。UITableViewDelegate 和 UITableViewDataSource 就是一个很好的例子，因为它们都是 UITablveView 的协议。设计协议的时候，最好一个名称引导一个功能。
</code></pre>

<p>构建和运行你的项目，你会看到一个新的很了不起的水平滚动视图：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/08/design-patterns-3-298x320.png" alt="2" /></p>

<p>啊嗯，等等。水平滚动的视图已经有了，可是专辑封面在哪里？</p>

<p>对了，你还没有代码来执行下载图片的功能。你需要添加一个下载图片的方法。查检 LibraryAPI 服务的所有接口，这里需要添加一个新的方法。不管怎样，现在还有几件事情需要考虑：</p>

<ol>
<li>AlbumView 并没没有通过 LibraryAPI 立即工作。你没有给视图添加通信逻辑。</li>
<li>相同的原因，LibraryAPI 并不认识 AlbumView。</li>
<li>LibraryAPI 需要通知 AlbumView，一旦封面下载完成，AlbumView 就会显示它。</li>
</ol>


<p>听起来这是一个难题？不用害怕，你将要学习如何使用观察者模式 (Observer pattern)。</p>

<p><strong>设计模式系列文章</strong>：</p>

<p><a href="http://www.superqq.com/blog/2015/06/10/ios-she-ji-mo-shi-xi-lie-:kai-pian/">iOS 设计模式系列：开篇</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/11/ios-she-ji-mo-shi-xi-lie-:mvc-she-ji-mo-shi-zhong-de-guo-wang/">iOS 设计模式系列：MVC – 设计模式中的国王</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/13/ios-she-ji-mo-shi-xi-lie-:singleton-dan-li-mo-shi/">iOS 设计模式系列：Singleton – 单例模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/15/ios-she-ji-mo-shi-xi-lie-:facade-wai-guan-mo-shi/">iOS 设计模式系列：Facade – 外观模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/">iOS 设计模式系列：Decorator – 装饰器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/17/ios-she-ji-mo-shi-xi-lie-:adapter-gua-pei-qi-mo-shi/">iOS 设计模式系列：Adapter – 适配器模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/18/ios-she-ji-mo-shi-xi-lie-:observer-guan-cha-zhe-mo-shi/">iOS 设计模式系列：Observer – 观察者模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/19/ios-she-ji-mo-shi-xi-lie-:memento-bei-wang-lu-mo-shi/">iOS 设计模式系列：Memento – 备忘录模式</a></p>

<p><a href="http://www.superqq.com/blog/2015/06/20/ios-she-ji-mo-shi-xi-lie-:archiving-gui-dang-mo-shi/">iOS 设计模式系列：Archiving – 归档模式</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/6">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/4">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>微信扫一扫，代码写的好</h1>
        <br/>
        <br/><strong>东半球最好的iOS开发公众号</strong> 
        <br/>
        <br/><img width="220px" src="http://www.superqq.com/images/getqrcode.jpg" />
        <br/>
        <br/><strong>东半球最好的程序猿公众号</strong>
        <br/>
        <br/><img width="220px" src="http://www.superqq.com/images/CodePush.jpg" />
        </p>
<!--广告位-->
<script type="text/javascript">
    /*刚刚在线250*350 创建于 2015-07-31*/
    var cpro_id = "u2238366";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/07/31/aktabbarcontroller-similar-to-wechat-library/">AKTabBarController：类似微信的第三方库</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/30/six-tips-on-navigation-bar/">关于导航栏的六个小技巧</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/29/uiimage-geometric-zoom/">iOS开发之UIImage等比缩放</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/28/swift-alamofire/">著名的AFNetworking网络基础库Swift版Alamofire</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/28/four-create-uiimage-method/">五种创建UIImage的类方法</a>
      </li>
    
  </ul>
</section>
</section>
<section>
    <h1>About Me</h1>
    <br/>
    <p> 李刚：百度百家专栏作者，刚刚在线站长，iOS工程师非著名自媒体人，微信公众号iOS开发：iOSDevTip运营者<br/>
    <br/><strong>出师未捷名已落</strong>
    <br/>
    <br/>新浪微博: <a href='http://weibo.com/ligangnc' target='_blank'>李刚移动</a>
    <br/>
    <br/>个人微信: <strong>chinaligang</strong> 欢迎调戏
    <br/>
    <br/>iOS群: <strong>218822587</strong>
  <br/>
</section>

   
 <section>
    <h1>友情链接</h1>
    <ul>
    
       <li>
           <a href="http://www.superqq.com" target="_blank" title=“刚刚在线”>刚刚在线</a>
       </li>
       <li>
           <a href="http://www.90159.com" target="_blank" title=“程序员头条”>程序员头条</a>
       </li>
       <li>
           <a href="http://www.iswifting.com" target="_blank" title=“swift开发”>swift开发</a>
       </li>
       <li>
           <a href="http://www.aswifter.com/" target="_blank" title="APP开发者">APP开发者</a>
       </li>
        <li>
           <a href="http://www.boxingjiaoyu.com/" target="_blank" title="程序员聚合平台">程序员聚合平台</a>
       </li>
       <li>
           <a href="http://www.jq-school.com/" target="_blank" title="jquery教程">jquery教程</a>
       </li>
        <li>
           <a href="http://www.admin10000.com/" target="_blank" title="WEB开发者">WEB开发者</a>
       </li>
       <li>
           <a href="http://www.aichengxu.com/" target="_blank" title="爱程序网">爱程序网</a>
       </li>
       <li>
           <a href="http://www.lai18.com" target="_blank" title="IT技术文章">IT技术文章</a>
       </li>
       <li>
           <a href="http://www.cftea.com/" target="_blank" title="千一网络">千一网络</a>
       </li>
        <li>
           <a href="http://www.bmob.cn/" target="_blank" title="Bmob">Bmob移动后端云</a>
       </li>
       <li>
           <a href="http://www.leichunfeng.com" target="_blank" title="雷纯锋的技术博客">雷纯锋的技术博客</a>
       </li>
       <li>
           <a href="http://cuiqingcai.com/" target="_blank" title="静觅">静觅</a>
       </li>
       <li>
           <a href="http://letsswift.com/" target="_blank" title="一起Swift">一起Swift</a>
       </li>
       <li>
           <a href="http://www.swiftv.cn/" target="_blank" title="SwiftV课堂">SwiftV课堂</a>
       </li>
        <li>
            <a href="http://blog.csdn.net/iosdevtip" target="_blank" title="刚刚在线">CSDN</a>
        </li>
        <li>
            <a href="http://user.qzone.qq.com/1606535851" target="_blank" title="刚刚在线">QQ空间</a>
        </li>
        <li>
            <br/><strong>交换友链：</strong>欢迎各大程序员站点交换友情链接，如需交换，请添加好本站链接后发送邮件至下方邮箱。
            <br/>
            <br/><strong>格式：</strong>（ 友链文字：“ 刚刚在线 ”，链接：“ http://www.superqq.com/ ” ）
            <br/>
            <br/><strong>邮箱：</strong>worldligang@163.com
            <br/>
        </li>
    </ul>
</section>
<!--广告位-->
<script type="text/javascript">
    /*刚刚在线侧部250*600 创建于 2015-07-31*/
    var cpro_id = "u2237889";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
<!--广告链接结束-->
<ul class="ds-recent-visitors"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"您的多说二级域名"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
Copyright &copy; 2015 - 李刚 
<span class="credit">Powered by <a href="http://octopress.org" target="_blank">Octopress</a></span>
 <span class="credit">, 感谢 <a href="http://gitcafe.com/signup?invited_by=tangqiaoboy" target="_blank">GitCafe</a> 为本站提供存储空间</span>

</p>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/17443209.js"></script>
<noscript><a href="http://www.51.la/?17443209" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/17443209.asp" style="border:none" /></a></noscript>
<!--广告位-->
<dic class="flashnews">
    <script type="text/javascript">
        /*960*60 创建于 2015-06-05*/
        var cpro_id = "u2140429";
        </script>
    <script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
    </div>
<!--广告链接结束--></footer>
  











</body>
</html>
